["class Solution def trap(self, height): result, left, right, level = 0, 0, len(height)-1, 0 while left < right: if height[left] < height[right]: lower = height[left] left += 1 else: lower = height[right] right -= 1 level = max(level, lower) result += level-lower return result ", "class Solution def trap(self, A): result = 0 top = 0 for i in xrange(len(A)): if A[top] < A[i]: top = i second_top = 0 for i in xrange(top): if A[second_top] < A[i]: second_top = i result += A[second_top] - A[i] second_top = len(A) - 1 for i in reversed(xrange(top, len(A))): if A[second_top] < A[i]: second_top = i result += A[second_top] - A[i] return result ", "class Solution def trap(self, height): right = [0]*len(height) mx = 0 for i in reversed(xrange(len(height))): right[i] = mx mx = max(mx, height[i]) result = left = 0 for i in xrange(len(height)): left = max(left, height[i]) result += max(min(left, right[i])-height[i], 0) return result ", "class Solution def trap(self, height): result = 0 stk = [] for i in xrange(len(height)): prev = 0 while stk and height[stk[-1]] <= height[i]: j = stk.pop() result += (height[j] - prev) * (i - j - 1) prev = height[j] if stk: result += (height[i] - prev) * (i - stk[-1] - 1) stk.append(i) return result ", "class Solution def uniqueMorseRepresentations(self, words): MORSE = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"] lookup = {\"\".join(MORSE[ord(c) - ord('a')] for c in word) for word in words} return len(lookup) ", "class Solution def numberOfWays(self, corridor): MOD = 10**9+7 result, cnt, j = 1, 0, -1 for i, x in enumerate(corridor): if x != 'S': continue cnt += 1 if cnt >= 3 and cnt%2: result = result*(i-j)%MOD j = i return result if cnt and cnt%2 == 0 else 0 ", "class Solution def beautifulPartitions(self, s, k, minLength): MOD = 10**9+7 PRIMES = {'2', '3', '5', '7'} dp = [0]*len(s) for i in xrange(minLength-1, len(s)): if s[0] in PRIMES and s[i] not in PRIMES: dp[i] = 1 for j in xrange(2, k+1): new_dp = [0]*len(s) curr = int(j == 1) for i in xrange(j*minLength-1, len(s)): if s[i-minLength+1] in PRIMES: curr = (curr+dp[i-minLength])%MOD if s[i] not in PRIMES: new_dp[i] = curr dp = new_dp return dp[-1] ", "class Solution def findRedundantDirectedConnection(self, edges): cand1, cand2 = [], [] parent = {} for edge in edges: if edge[1] not in parent: parent[edge[1]] = edge[0] else: cand1 = [parent[edge[1]], edge[1]] cand2 = edge union_find = UnionFind(len(edges)+1) for edge in edges: if edge == cand2: continue if not union_find.union_set(*edge): return cand1 if cand2 else edge return cand2 ", "class Solution def slowestKey(self, releaseTimes, keysPressed): result, lookup = 'a', collections.Counter() for i, c in enumerate(keysPressed): lookup[c] = max(lookup[c], releaseTimes[i]-(releaseTimes[i-1] if i > 0 else 0)) if lookup[c] > lookup[result] or lookup[c] == lookup[result] and c > result: result = c return result ", "class Solution def read(self, buf, n): read_bytes = 0 buffer = [''] * 4 for i in xrange((n+4-1)//4): size = min(read4(buffer), n-read_bytes) buf[read_bytes:read_bytes+size] = buffer[:size] read_bytes += size return read_bytes ", "class Solution def removeOccurrences(self, s, part): def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j != -1 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix prefix = getPrefix(part) result, lookup = [], [] i = -1 for c in s: while i != -1 and part[i+1] != c: i = prefix[i] if part[i+1] == c: i += 1 result.append(c) lookup.append(i) if i == len(part)-1: result[len(result)-len(part):] = [] lookup[len(lookup)-len(part):] = [] i = lookup[-1] if lookup else -1 return \"\".join(result) ", "class Solution def validSubarraySplit(self, nums): def gcd(a, b): while b: a, b = b, a%b return a dp = [float(\"inf\")]*(len(nums)+1) dp[0] = 0 for i in xrange(1, len(nums)+1): for j in xrange(i): if gcd(nums[j], nums[i-1]) != 1: dp[i] = min(dp[i], dp[j]+1) return dp[-1] if dp[-1] != float(\"inf\") else -1 ", "class Solution def sumOfDigits(self, A): total = sum([int(c) for c in str(min(A))]) return 1 if total % 2 == 0 else 0 ", "class Solution def pancakeSort(self, arr): bit = BIT(len(arr)) result = [] for i in xrange(len(arr)): n = bit.query((arr[i]-1)-1) bit.add(arr[i]-1, 1) if n == i: continue if n == 0: if i > 1: result.append(i) result.append(i+1) else: if n > 1: result.append(n) result.append(i) result.append(i+1) result.append(n+1) return result ", "class Solution def pancakeSort(self, arr): def smallerMergeSort(idxs, start, end, counts): if end - start <= 0: return 0 mid = start + (end - start) // 2 smallerMergeSort(idxs, start, mid, counts) smallerMergeSort(idxs, mid + 1, end, counts) r = start tmp = [] for i in xrange(mid+1, end + 1): while r <= mid and idxs[r][0] < idxs[i][0]: tmp.append(idxs[r]) r += 1 if r <= mid: tmp.append(idxs[i]) counts[idxs[i][1]] += r - start while r <= mid: tmp.append(idxs[r]) r += 1 idxs[start:start+len(tmp)] = tmp idxs = [] smaller_counts = [0]*len(arr) for i, x in enumerate(arr): idxs.append((x, i)) smallerMergeSort(idxs, 0, len(idxs)-1, smaller_counts) result = [] for i, n in enumerate(smaller_counts): if n == i: continue if n == 0: if i > 1: result.append(i) result.append(i+1) else: if n > 1: result.append(n) result.append(i) result.append(i+1) result.append(n+1) return result ", "class Solution def pancakeSort(self, A): def reverse(l, begin, end): for i in xrange((end-begin) // 2): l[begin+i], l[end-1-i] = l[end-1-i], l[begin+i] result = [] for n in reversed(xrange(1, len(A)+1)): i = A.index(n) reverse(A, 0, i+1) result.append(i+1) reverse(A, 0, n) result.append(n) return result ", "class Solution def sumOfMultiples(self, n): def f(d): return d*((1+(n//d))*(n//d)//2) return (f(3)+f(5)+f(7))-(f(3*5)+f(5*7)+f(7*3))+f(3*5*7) ", "class Solution def maxEqualFreq(self, nums): result = 0 count = collections.Counter() freq = [0 for _ in xrange(len(nums)+1)] for i, n in enumerate(nums, 1): freq[count[n]] -= 1 freq[count[n]+1] += 1 count[n] += 1 c = count[n] if freq[c]*c == i and i < len(nums): result = i+1 remain = i-freq[c]*c if freq[remain] == 1 and remain in [1, c+1]: result = i return result ", "class Solution def reverseEvenLengthGroups(self, head): prev, l = head, 2 while prev.next: curr, cnt = prev, 0 for _ in xrange(l): if not curr.next: break cnt += 1 curr = curr.next l += 1 if cnt%2: prev = curr continue curr, last = prev.next, None for _ in xrange(cnt): curr.next, curr, last = last, curr.next, curr prev.next.next, prev.next, prev = curr, last, prev.next return head ", "class Solution def diagonalPrime(self, nums): result = 0 for i in xrange(len(nums)): if nums[i][i] in PRIMES_SET: result = max(result, nums[i][i]) if nums[i][~i] in PRIMES_SET: result = max(result, nums[i][~i]) return result ", "class Solution def nextBeautifulNumber(self, n): candidates = [ 1, 22, 122, 212, 221, 333 , 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555, 122333, 123233, 123323, 123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233, 213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444, 244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444] return candidates[bisect.bisect_right(candidates, n)] ", "class Solution def nextBeautifulNumber(self, n): def next_permutation(nums, begin, end): def reverse(nums, begin, end): left, right = begin, end-1 while left < right: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1 k, l = begin-1, begin for i in reversed(xrange(begin, end-1)): if nums[i] < nums[i+1]: k = i break else: reverse(nums, begin, end) return False for i in reversed(xrange(k+1, end)): if nums[i] > nums[k]: l = i break nums[k], nums[l] = nums[l], nums[k] reverse(nums, k+1, end) return True balanced = [1, 22, 122, 333, 1333, 4444, 14444, 22333, 55555, 122333, 155555, 224444, 666666] s = list(str(n)) result = 1224444 for x in balanced: x = list(str(x)) if len(x) < len(s): continue if len(x) > len(s): result = min(result, int(\"\".join(x))) continue while True: if x > s: result = min(result, int(\"\".join(x))) if not next_permutation(x, 0, len(x)): break return result import itertools ", "class Solution def nextBeautifulNumber(self, n): balanced = [1, 22, 122, 333, 1333, 4444, 14444, 22333, 55555, 122333, 155555, 224444, 666666] s = tuple(str(n)) result = 1224444 for x in balanced: x = tuple(str(x)) if len(x) < len(s): continue if len(x) > len(s): result = min(result, int(\"\".join(x))) continue for perm in itertools.permutations(x): if perm > s: result = min(result, int(\"\".join(perm))) return result ", "class Solution def countSubstrings(self, s): def manacher(s): s = '^#' + '#'.join(s) + '#$' P = [0] * len(s) C, R = 0, 0 for i in xrange(1, len(s) - 1): i_mirror = 2*C-i if R > i: P[i] = min(R-i, P[i_mirror]) while s[i+1+P[i]] == s[i-1-P[i]]: P[i] += 1 if i+P[i] > R: C, R = i, i+P[i] return P return sum((max_len+1)//2 for max_len in manacher(s)) ", "class Solution def minimumDeleteSum(self, s1, s2): dp = [[0] * (len(s2)+1) for _ in xrange(2)] for j in xrange(len(s2)): dp[0][j+1] = dp[0][j] + ord(s2[j]) for i in xrange(len(s1)): dp[(i+1)%2][0] = dp[i%2][0] + ord(s1[i]) for j in xrange(len(s2)): if s1[i] == s2[j]: dp[(i+1)%2][j+1] = dp[i%2][j] else: dp[(i+1)%2][j+1] = min(dp[i%2][j+1] + ord(s1[i]), dp[(i+1)%2][j] + ord(s2[j])) return dp[len(s1)%2][-1] ", "class Solution def minimumDeleteSum(self, s1, s2): dp = [[0] * (len(s2)+1) for _ in xrange(len(s1)+1)] for i in xrange(len(s1)): dp[i+1][0] = dp[i][0] + ord(s1[i]) for j in xrange(len(s2)): dp[0][j+1] = dp[0][j] + ord(s2[j]) for i in xrange(len(s1)): for j in xrange(len(s2)): if s1[i] == s2[j]: dp[i+1][j+1] = dp[i][j] else: dp[i+1][j+1] = min(dp[i][j+1] + ord(s1[i]), dp[i+1][j] + ord(s2[j])) return dp[-1][-1] ", "class Solution def minimumSemesters(self, N, relations): g = collections.defaultdict(list) in_degree = [0]*N for x, y in relations: g[x-1].append(y-1) in_degree[y-1] += 1 q = collections.deque([(1, i) for i in xrange(N) if not in_degree[i]]) result = 0 count = N while q: level, u = q.popleft() count -= 1 result = level for v in g[u]: in_degree[v] -= 1 if not in_degree[v]: q.append((level+1, v)) return result if count == 0 else -1 ", "class Solution def rotate(self, nums, k): def reverse(nums, start, end): while start < end: nums[start], nums[end - 1] = nums[end - 1], nums[start] start += 1 end -= 1 k %= len(nums) reverse(nums, 0, len(nums)) reverse(nums, 0, k) reverse(nums, k, len(nums)) from fractions import gcd ", "class Solution def rotate(self, nums, k): def apply_cycle_permutation(k, offset, cycle_len, nums): tmp = nums[offset] for i in xrange(1, cycle_len): nums[(offset + i * k) % len(nums)], tmp = tmp, nums[(offset + i * k) % len(nums)] nums[offset] = tmp k %= len(nums) num_cycles = gcd(len(nums), k) cycle_len = len(nums) / num_cycles for i in xrange(num_cycles): apply_cycle_permutation(k, i, cycle_len, nums) ", "class Solution def rotate(self, nums, k): count = 0 start = 0 while count < len(nums): curr = start prev = nums[curr] while True: idx = (curr + k) % len(nums) nums[idx], prev = prev, nums[idx] curr = idx count += 1 if start == curr: break start += 1 ", "class Solution def rotate(self, nums, k): nums[:] = nums[len(nums) - k:] + nums[:len(nums) - k] ", "class Solution def rotate(self, nums, k): while k > 0: nums.insert(0, nums.pop()) k -= 1 ", "class Solution def minimumScore(self, nums, edges): def is_ancestor(a, b): return left[a] <= left[b] and right[b] <= right[a] def iter_dfs(): cnt = 0 left = [0]*len(nums) right = [0]*len(nums) stk = [(1, (0, -1))] while stk: step, args = stk.pop() if step == 1: u, p = args left[u] = cnt cnt += 1 stk.append((2, (u, p))) for v in adj[u]: if v == p: continue stk.append((1, (v, u))) elif step == 2: u, p = args for v in adj[u]: if v == p: continue nums[u] ^= nums[v] right[u] = cnt return left, right adj = [[] for _ in xrange(len(nums))] for u, v in edges: adj[u].append(v) adj[v].append(u) left, right = iter_dfs() result = float(\"inf\") for i in xrange(1, len(nums)): for j in xrange(i+1, len(nums)): if is_ancestor(i, j): a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j] elif is_ancestor(j, i): a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i] else: a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j] result = min(result, max(a, b, c)-min(a, b, c)) return result ", "class Solution def minimumScore(self, nums, edges): def is_ancestor(a, b): return left[a] <= left[b] and right[b] <= right[a] def dfs(u, p): left[u] = cnt[0] cnt[0] += 1 for v in adj[u]: if v == p: continue dfs(v, u) nums[u] ^= nums[v] right[u] = cnt[0] adj = [[] for _ in xrange(len(nums))] for u, v in edges: adj[u].append(v) adj[v].append(u) cnt = [0] left = [0]*len(nums) right = [0]*len(nums) dfs(0, -1) result = float(\"inf\") for i in xrange(1, len(nums)): for j in xrange(i+1, len(nums)): if is_ancestor(i, j): a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j] elif is_ancestor(j, i): a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i] else: a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j] result = min(result, max(a, b, c)-min(a, b, c)) return result ", "class Solution def minimumScore(self, nums, edges): def dfs(u, p, result): total = nums[u] for v in adj[u]: if v == p: continue total ^= dfs(v, u, result) result.append(total) return total adj = [[] for _ in xrange(len(nums))] for u, v in edges: adj[u].append(v) adj[v].append(u) total = reduce(lambda x, y: x^y, nums) result = float(\"inf\") for u, v in edges: left = [] dfs(u, v, left) right = [] dfs(v, u, right) for candidates in (left, right): total2 = candidates.pop() for x in candidates: a, b, c = total^total2, x, total2^x result = min(result, max(a, b, c)-min(a, b, c)) return result ", "class Solution def minimumScore(self, nums, edges): def iter_dfs(nums, adj, u, p): result = [] stk = [(1, (u, p, [0]))] while stk: step, args = stk.pop() if step == 1: u, p, ret = args new_rets = [] stk.append((2, (u, new_rets, ret))) for v in adj[u]: if v == p: continue new_rets.append([0]) stk.append((1, (v, u, new_rets[-1]))) elif step == 2: u, new_rets, ret = args ret[0] = nums[u] for x in new_rets: ret[0] ^= x[0] result.append(ret[0]) return result adj = [[] for _ in xrange(len(nums))] for u, v in edges: adj[u].append(v) adj[v].append(u) total = reduce(lambda x, y: x^y, nums) result = float(\"inf\") for u, v in edges: for candidates in (iter_dfs(nums, adj, u, v), iter_dfs(nums, adj, v, u)): total2 = candidates.pop() for x in candidates: a, b, c = total^total2, x, total2^x result = min(result, max(a, b, c)-min(a, b, c)) return result ", "class Solution def relativeSortArray(self, arr1, arr2): lookup = {v: i for i, v in enumerate(arr2)} return sorted(arr1, key=lambda i: lookup.get(i, len(arr2)+i)) ", "class Solution def minimumSum(self, num): def inplace_counting_sort(nums, reverse=False): count = [0]*(max(nums)+1) for num in nums: count[num] += 1 for i in xrange(1, len(count)): count[i] += count[i-1] for i in reversed(xrange(len(nums))): while nums[i] >= 0: count[nums[i]] -= 1 j = count[nums[i]] nums[i], nums[j] = nums[j], ~nums[i] for i in xrange(len(nums)): nums[i] = ~nums[i] if reverse: nums.reverse() nums = map(int, list(str(num))) inplace_counting_sort(nums) a = b = 0 for x in nums: a = a*10+x a, b = b, a return a+b ", "class Solution def minimumSum(self, num): nums = sorted(map(int, list(str(num)))) a = b = 0 for x in nums: a = a*10+x a, b = b, a return a+b ", "class Solution def maxDepth(self, s): result = curr = 0 for c in s: if c == '(': curr += 1 result = max(result, curr) elif c == ')': curr -= 1 return result ", "class Solution def areSentencesSimilarTwo(self, words1, words2, pairs): if len(words1) != len(words2): return False lookup = {} union_find = UnionFind(2 * len(pairs)) for pair in pairs: for p in pair: if p not in lookup: lookup[p] = len(lookup) union_find.union_set(lookup[pair[0]], lookup[pair[1]]) return all(w1 == w2 or w1 in lookup and w2 in lookup and union_find.find_set(lookup[w1]) == union_find.find_set(lookup[w2]) for w1, w2 in itertools.izip(words1, words2)) ", "class Solution def maxScore(self, cardPoints, k): result, total, curr, left = float(\"inf\"), 0, 0, 0 for right, point in enumerate(cardPoints): total += point curr += point if right-left+1 > len(cardPoints)-k: curr -= cardPoints[left] left += 1 if right-left+1 == len(cardPoints)-k: result = min(result, curr) return total-result ", "class Solution def reverseBits(self, n): n = (n >> 16) | (n << 16) n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8) n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4) n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2) n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1) return n ", "class Solution def reverseBits(self, n): result = 0 for i in xrange(32): result <<= 1 result |= n & 1 n >>= 1 return result ", "class Solution def maxIncreasingGroups(self, usageLimits): def inplace_counting_sort(nums, reverse=False): if not nums: return count = [0]*(max(nums)+1) for num in nums: count[num] += 1 for i in xrange(1, len(count)): count[i] += count[i-1] for i in reversed(xrange(len(nums))): while nums[i] >= 0: count[nums[i]] -= 1 j = count[nums[i]] nums[i], nums[j] = nums[j], ~nums[i] for i in xrange(len(nums)): nums[i] = ~nums[i] if reverse: nums.reverse() usageLimits = [min(x, len(usageLimits)) for x in usageLimits] inplace_counting_sort(usageLimits) result = curr = 0 for x in usageLimits: curr += x if curr >= result+1: curr -= result+1 result += 1 return result ", "class Solution def maxIncreasingGroups(self, usageLimits): usageLimits.sort() result = curr = 0 for x in usageLimits: curr += x if curr >= result+1: curr -= result+1 result += 1 return result ", "class Solution def maxIncreasingGroups(self, usageLimits): def check(l): curr = 0 for i in xrange(l): curr += usageLimits[~i]-(l-i) curr = min(curr, 0) for i in xrange(len(usageLimits)-l): curr += usageLimits[i] return curr >= 0 usageLimits.sort() left, right = 1, len(usageLimits) while left <= right: mid = left + (right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right ", "class Solution def maxIncreasingGroups(self, usageLimits): def check(l): return all((i+1)*i//2 <= prefix[len(usageLimits)-(l-i)] for i in xrange(1, l+1)) usageLimits.sort() prefix = [0]*(len(usageLimits)+1) for i in xrange(len(usageLimits)): prefix[i+1] = prefix[i]+usageLimits[i] left, right = 1, len(usageLimits) while left <= right: mid = left + (right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right ", "class Solution def getLengthOfOptimalCompression(self, s, k): def length(cnt): l = 2 if cnt >= 2 else 1 while cnt >= 10: l += 1 cnt //= 10 return l dp = [[len(s)]*(k+1) for _ in xrange(len(s)+1)] dp[0][0] = 0 for i in xrange(1, len(s)+1): for j in xrange(k+1): if i-1 >= 0 and j-1 >= 0: dp[i][j] = min(dp[i][j], dp[i-1][j-1]) keep = delete = 0 for m in xrange(i, len(s)+1): if s[i-1] == s[m-1]: keep += 1 else: delete += 1 if j+delete <= k: dp[m][j+delete] = min(dp[m][j+delete], dp[i-1][j]+length(keep)); return dp[len(s)][k] ", "class Solution def minOperations(self, nums, k): def popcount(x): return bin(x).count('1') return popcount(reduce(lambda x, y: x^y, nums, k)) ", "class Solution def reverseString(self, s): i, j = 0, len(s) - 1 while i < j: s[i], s[j] = s[j], s[i] i += 1 j -= 1 ", "class Solution def equalizeWater(self, buckets, loss): def check(buckets, rate, x): return sum(b-x for b in buckets if b-x > 0)*rate >= sum(x-b for b in buckets if x-b > 0) EPS = 1e-5 rate = (100-loss)/100.0 left, right = float(min(buckets)), float(sum(buckets))/len(buckets) while right-left > EPS: mid = left + (right-left)/2 if not check(buckets, rate, mid): right = mid else: left = mid return left ", "class Solution def sortJumbled(self, mapping, nums): def transform(mapping, x): if not x: return mapping[x] result, base = 0, 1 while x: result += mapping[x%10]*base x //= 10 base *= 10 return result return [nums[i] for _, i in sorted((transform(mapping, nums[i]), i) for i in xrange(len(nums)))] ", "class Solution def canMakePalindromeQueries(self, s, queries): def check(left1, right1, left2, right2): def same(left, right): return all(prefixs1[right+1][i]-prefixs1[left][i] == prefixs2[right+1][i]-prefixs2[left][i] for i in xrange(d)) min_left, max_left = min(left1, left2), max(left1, left2) min_right, max_right = min(right1, right2), max(right1, right2) if not (prefix[min_left]-prefix[0] == prefix[-1]-prefix[max_right+1] == 0): return False if min_right < max_left: return prefix[max_left]-prefix[min_right+1] == 0 and same(min_left, min_right) and same(max_left, max_right) if (left1 == min_left) == (right1 == max_right): return same(min_left, max_right) p1, p2 = (prefixs1, prefixs2) if min_left == left1 else (prefixs2, prefixs1) diff1 = [(p1[min_right+1][i]-p1[min_left][i])-(p2[max_left][i]-p2[min_left][i]) for i in xrange(d)] diff2 = [(p2[max_right+1][i]-p2[max_left][i])-(p1[max_right+1][i]-p1[min_right+1][i]) for i in xrange(d)] return diff1 == diff2 and all(x >= 0 for x in diff1) lookup = [-1]*26 d = 0 for x in s: if lookup[ord(x)-ord('a')] != -1: continue lookup[ord(x)-ord('a')] = d d += 1 prefix = [0]*(len(s)//2+1) prefixs1 = [[0]*d for _ in xrange(len(s)//2+1)] prefixs2 = [[0]*d for _ in xrange(len(s)//2+1)] for i in xrange(len(s)//2): x, y = lookup[ord(s[i])-ord('a')], lookup[ord(s[~i])-ord('a')] prefix[i+1] = prefix[i]+int(x != y) for j in xrange(d): prefixs1[i+1][j] = prefixs1[i][j]+int(j == x) prefixs2[i+1][j] = prefixs2[i][j]+int(j == y) return [check(q[0], q[1], (len(s)-1)-q[3], (len(s)-1)-q[2]) for q in queries] ", "class Solution def canMakePalindromeQueries(self, s, queries): def check(left1, right1, left2, right2): def same(left, right): return all(prefixs1[right+1][i]-prefixs1[left][i] == prefixs2[right+1][i]-prefixs2[left][i] for i in xrange(26)) min_left, max_left = min(left1, left2), max(left1, left2) min_right, max_right = min(right1, right2), max(right1, right2) if not (prefix[min_left]-prefix[0] == prefix[-1]-prefix[max_right+1] == 0): return False if min_right < max_left: return prefix[max_left]-prefix[min_right+1] == 0 and same(min_left, min_right) and same(max_left, max_right) if (left1 == min_left) == (right1 == max_right): return same(min_left, max_right) p1, p2 = (prefixs1, prefixs2) if min_left == left1 else (prefixs2, prefixs1) diff1 = [(p1[min_right+1][i]-p1[min_left][i])-(p2[max_left][i]-p2[min_left][i]) for i in xrange(26)] diff2 = [(p2[max_right+1][i]-p2[max_left][i])-(p1[max_right+1][i]-p1[min_right+1][i]) for i in xrange(26)] return diff1 == diff2 and all(x >= 0 for x in diff1) prefix = [0]*(len(s)//2+1) prefixs1 = [[0]*26 for _ in xrange(len(s)//2+1)] prefixs2 = [[0]*26 for _ in xrange(len(s)//2+1)] for i in xrange(len(s)//2): x, y = ord(s[i])-ord('a'), ord(s[~i])-ord('a') prefix[i+1] = prefix[i]+int(x != y) for j in xrange(26): prefixs1[i+1][j] = prefixs1[i][j]+int(j == x) prefixs2[i+1][j] = prefixs2[i][j]+int(j == y) return [check(q[0], q[1], (len(s)-1)-q[3], (len(s)-1)-q[2]) for q in queries] ", "class Solution def wordSquares(self, words): result = [] trie = TrieNode() for i in xrange(len(words)): trie.insert(words, i) curr = [] for s in words: curr.append(s) self.wordSquaresHelper(words, trie, curr, result) curr.pop() return result def wordSquaresHelper(self, words, trie, curr, result): if len(curr) >= len(words[0]): return result.append(list(curr)) node = trie for s in curr: node = node.children[ord(s[len(curr)]) - ord('a')] if not node: return for i in node.indices: curr.append(words[i]) self.wordSquaresHelper(words, trie, curr, result) curr.pop() ", "class Solution def minMaxGame(self, nums): n = len(nums) while n != 1: new_q = [] for i in xrange(n//2): nums[i] = min(nums[2*i], nums[2*i+1]) if i%2 == 0 else max(nums[2*i], nums[2*i+1]) n //= 2 return nums[0] ", "class Solution def minMaxGame(self, nums): q = nums[:] while len(q) != 1: new_q = [] for i in xrange(len(q)//2): new_q.append(min(q[2*i], q[2*i+1]) if i%2 == 0 else max(q[2*i], q[2*i+1])) q = new_q return q[0] ", "class Solution def maxHammingDistances(self, nums, m): dp = [float(\"-inf\")]*(1<<m) for x in nums: dp[x] = 0 for i in xrange(m): new_dp = dp[:] for mask in xrange(1<<m): new_dp[mask] = max(new_dp[mask], dp[mask^(1<<i)]+1) dp = new_dp return [dp[x] for x in nums] ", "class Solution def maxHammingDistances(self, nums, m): q = [] dist = [-1]*(1<<m) for x in nums: if dist[x] != -1: continue dist[x] = 0 q.append(x) d = 0 while q: d += 1 new_q = [] for u in q: for i in xrange(m): if dist[u^(1<<i)] != -1: continue dist[u^(1<<i)] = d new_q.append(u^(1<<i)) q = new_q return [m-dist[((1<<m)-1)^x] for x in nums] ", "class Solution def maxSubarraySumCircular(self, A): total, max_sum, cur_max, min_sum, cur_min = 0, -float(\"inf\"), 0, float(\"inf\"), 0 for a in A: cur_max = max(cur_max+a, a) max_sum = max(max_sum, cur_max) cur_min = min(cur_min+a, a) min_sum = min(min_sum, cur_min) total += a return max(max_sum, total-min_sum) if max_sum >= 0 else max_sum ", "class Solution def partitionString(self, s): result, left = 1, 0 lookup = {} for i, x in enumerate(s): if x in lookup and lookup[x] >= left: left = i result += 1 lookup[x] = i return result ", "class Solution def minimumLevels(self, possible): prefix = [0]*(len(possible)+1) for i in xrange(len(possible)): prefix[i+1] = prefix[i]+(+1 if possible[i] else -1) return next((i+1 for i in xrange(len(possible)-1) if prefix[i+1] > prefix[-1]-prefix[i+1]), -1) ", "class Solution def leastInterval(self, tasks, n): counter = Counter(tasks) _, max_count = counter.most_common(1)[0] return max((max_count-1) * (n+1) + counter.values().count(max_count), len(tasks)) ", "class Solution def isRectangleCover(self, rectangles): left = min(rec[0] for rec in rectangles) bottom = min(rec[1] for rec in rectangles) right = max(rec[2] for rec in rectangles) top = max(rec[3] for rec in rectangles) points = defaultdict(int) for l, b, r, t in rectangles: for p, q in zip(((l, b), (r, b), (l, t), (r, t)), (1, 2, 4, 8)): if points[p] & q: return False points[p] |= q for px, py in points: if left < px < right or bottom < py < top: if points[(px, py)] not in (3, 5, 10, 12, 15): return False return True ", "class Solution def palindromePartition(self, s, k): dp1 = [[0]*len(s) for _ in xrange(len(s))] for l in xrange(1, len(s)+1): for i in xrange(len(s)-l+1): j = i+l-1 if i == j-1: dp1[i][j] = 0 if s[i] == s[j] else 1 elif i != j: dp1[i][j] = dp1[i+1][j-1] if s[i] == s[j] else dp1[i+1][j-1]+1 dp2 = [[float(\"inf\")]*len(s) for _ in xrange(2)] dp2[1] = dp1[0][:] for d in xrange(2, k+1): dp2[d%2] = [float(\"inf\")]*len(s) for i in xrange(d-1, len(s)): for j in xrange(d-2, i): dp2[d%2][i] = min(dp2[d%2][i], dp2[(d-1)%2][j]+dp1[j+1][i]) return dp2[k%2][len(s)-1] ", "class Solution def searchMatrix(self, matrix, target): m = len(matrix) if m == 0: return False n = len(matrix[0]) if n == 0: return False i, j = 0, n - 1 while i < m and j >= 0: if matrix[i][j] == target: return True elif matrix[i][j] > target: j -= 1 else: i += 1 return False ", "class Solution def minimumMoves(self, s): result = i = 0 while i < len(s): if s[i] == 'X': result += 1 i += 3 else: i += 1 return result ", "class Solution def maximumSumScore(self, nums): prefix = suffix = 0 result = float(\"-inf\") right = len(nums)-1 for left in xrange(len(nums)): prefix += nums[left] suffix += nums[right] right -= 1 result = max(result, prefix, suffix) return result ", "class Solution def maximumSumScore(self, nums): total = sum(nums) prefix = 0 result = float(\"-inf\") for x in nums: prefix += x result = max(result, prefix, total-prefix+x) return result ", "class Solution def cleanRoom(self, robot): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def goBack(robot): robot.turnLeft() robot.turnLeft() robot.move() robot.turnRight() robot.turnRight() def dfs(pos, robot, d, lookup): robot.clean() for _ in directions: new_pos = (pos[0]+directions[d][0], pos[1]+directions[d][1]) if new_pos not in lookup: lookup.add(new_pos) if robot.move(): dfs(new_pos, robot, d, lookup) goBack(robot) robot.turnRight() d = (d+1) % len(directions) dfs((0, 0), robot, 0, set()) ", "class Solution def fillCups(self, amount): return max(max(amount), (sum(amount)+1)//2) ", "class Solution def fillCups(self, amount): mx, total = max(amount), sum(amount) return mx if sum(amount)-mx <= mx else (total+1)//2 ", "class Solution def findStrobogrammatic(self, n): lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'} result = ['0', '1', '8'] if n%2 else [''] for i in xrange(n%2, n, 2): result = [a + num + b for a, b in lookup.iteritems() if i != n-2 or a != '0' for num in result] return result ", "class Solution def findStrobogrammatic(self, n): lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'} def findStrobogrammaticRecu(n, k): if k == 0: return [''] elif k == 1: return ['0', '1', '8'] result = [] for num in findStrobogrammaticRecu(n, k - 2): for key, val in lookup.iteritems(): if n != k or key != '0': result.append(key + num + val) return result return findStrobogrammaticRecu(n, n) ", "class Solution def maxKelements(self, nums, k): def ceil_divide(a, b): return (a+b-1)//b result = 0 for i, x in enumerate(nums): nums[i] = -x heapq.heapify(nums) for _ in xrange(k): if not nums: break x = -heapq.heappop(nums) result += x nx = ceil_divide(x, 3) if not nx: continue heapq.heappush(nums, -nx) return result import heapq ", "class Solution def maxKelements(self, nums, k): def ceil_divide(a, b): return (a+b-1)//b result = 0 for i, x in enumerate(nums): nums[i] = -x heapq.heapify(nums) for _ in xrange(k): x = -heapq.heappop(nums) result += x heapq.heappush(nums, -ceil_divide(x, 3)) return result ", "class Solution def isPossible(self, nums): pre, cur = float(\"-inf\"), 0 cnt1, cnt2, cnt3 = 0, 0, 0 i = 0 while i < len(nums): cnt = 0 cur = nums[i] while i < len(nums) and cur == nums[i]: cnt += 1 i += 1 if cur != pre + 1: if cnt1 != 0 or cnt2 != 0: return False cnt1, cnt2, cnt3 = cnt, 0, 0 else: if cnt < cnt1 + cnt2: return False cnt1, cnt2, cnt3 = max(0, cnt - (cnt1 + cnt2 + cnt3)), cnt1, cnt2 + min(cnt3, cnt - (cnt1 + cnt2)) pre = cur return cnt1 == 0 and cnt2 == 0 ", "class Solution def slidingPuzzle(self, board): def dot(p1, p2): return p1[0]*p2[0]+p1[1]*p2[1] def heuristic_estimate(board, R, C, expected): result = 0 for i in xrange(R): for j in xrange(C): val = board[C*i + j] if val == 0: continue r, c = expected[val] result += abs(r-i) + abs(c-j) return result R, C = len(board), len(board[0]) begin = tuple(itertools.chain(*board)) end = tuple(range(1, R*C) + [0]) expected = {(C*i+j+1) % (R*C) : (i, j) for i in xrange(R) for j in xrange(C)} min_steps = heuristic_estimate(begin, R, C, expected) closer, detour = [(begin.index(0), begin)], [] lookup = set() while True: if not closer: if not detour: return -1 min_steps += 2 closer, detour = detour, closer zero, board = closer.pop() if board == end: return min_steps if board not in lookup: lookup.add(board) r, c = divmod(zero, C) for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)): i, j = r+direction[0], c+direction[1] if 0 <= i < R and 0 <= j < C: new_zero = i*C+j tmp = list(board) tmp[zero], tmp[new_zero] = tmp[new_zero], tmp[zero] new_board = tuple(tmp) r2, c2 = expected[board[new_zero]] r1, c1 = divmod(zero, C) r0, c0 = divmod(new_zero, C) is_closer = dot((r1-r0, c1-c0), (r2-r0, c2-c0)) > 0 (closer if is_closer else detour).append((new_zero, new_board)) return min_steps ", "class Solution def slidingPuzzle(self, board): def heuristic_estimate(board, R, C, expected): result = 0 for i in xrange(R): for j in xrange(C): val = board[C*i + j] if val == 0: continue r, c = expected[val] result += abs(r-i) + abs(c-j) return result R, C = len(board), len(board[0]) begin = tuple(itertools.chain(*board)) end = tuple(range(1, R*C) + [0]) end_wrong = tuple(range(1, R*C-2) + [R*C-1, R*C-2, 0]) expected = {(C*i+j+1) % (R*C) : (i, j) for i in xrange(R) for j in xrange(C)} min_heap = [(0, 0, begin.index(0), begin)] lookup = {begin: 0} while min_heap: f, g, zero, board = heapq.heappop(min_heap) if board == end: return g if board == end_wrong: return -1 if f > lookup[board]: continue r, c = divmod(zero, C) for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)): i, j = r+direction[0], c+direction[1] if 0 <= i < R and 0 <= j < C: new_zero = C*i+j tmp = list(board) tmp[zero], tmp[new_zero] = tmp[new_zero], tmp[zero] new_board = tuple(tmp) f = g+1+heuristic_estimate(new_board, R, C, expected) if f < lookup.get(new_board, float(\"inf\")): lookup[new_board] = f heapq.heappush(min_heap, (f, g+1, new_zero, new_board)) return -1 ", "class Solution def largestVariance(self, s): def modified_kadane(a, x, y): result = curr = 0 lookup = [0]*2 remain = [a.count(x), a.count(y)] for c in a: if c not in (x, y): continue lookup[c != x] = 1 remain[c != x] -= 1 curr += 1 if c == x else -1 if curr < 0 and remain[0] and remain[1]: curr = lookup[0] = lookup[1] = 0 if lookup[0] and lookup[1]: result = max(result, curr) return result alphabets = set(s) return max(modified_kadane(s, x, y) for x, y in itertools.permutations(alphabets, 2)) if len(alphabets) >= 2 else 0 ", "class Solution def rotate(self, matrix): n = len(matrix) for i in xrange(n): for j in xrange(n - i): matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j] for i in xrange(n / 2): for j in xrange(n): matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j] return matrix ", "class Solution def rotate(self, matrix): return [list(reversed(x)) for x in zip(*matrix)] ", "class Solution def maxProductPath(self, grid): MOD = 10**9+7 max_dp = [[0]*len(grid[0]) for _ in xrange(2)] min_dp = [[0]*len(grid[0]) for _ in xrange(2)] for i in xrange(len(grid)): for j in xrange(len(grid[i])): if i == 0 and j == 0: max_dp[i%2][j] = min_dp[i%2][j] = grid[i][j] continue curr_max = max(max_dp[(i-1)%2][j] if i > 0 else max_dp[i%2][j-1], max_dp[i%2][j-1] if j > 0 else max_dp[(i-1)%2][j]) curr_min = min(min_dp[(i-1)%2][j] if i > 0 else min_dp[i%2][j-1], min_dp[i%2][j-1] if j > 0 else min_dp[(i-1)%2][j]) if grid[i][j] < 0: curr_max, curr_min = curr_min, curr_max max_dp[i%2][j] = curr_max*grid[i][j] min_dp[i%2][j] = curr_min*grid[i][j] return max_dp[(len(grid)-1)%2][-1]%MOD if max_dp[(len(grid)-1)%2][-1] >= 0 else -1 ", "class Solution def verticalTraversal(self, root): def dfs(node, lookup, x, y): if not node: return lookup[x][y].append(node) dfs(node.left, lookup, x-1, y+1) dfs(node.right, lookup, x+1, y+1) lookup = collections.defaultdict(lambda: collections.defaultdict(list)) dfs(root, lookup, 0, 0) result = [] for x in sorted(lookup): report = [] for y in sorted(lookup[x]): report.extend(sorted(node.val for node in lookup[x][y])) result.append(report) return result ", "class Solution def numberOfGoodSubsets(self, nums): def sieve_of_eratosthenes(n): if n < 2: return [] primes = [2] is_prime = [True]*((n+1)//2) for i in xrange(1, len(is_prime)): if not is_prime[i]: continue primes.append(2*i+1) for j in xrange(2*i*(i+1), len(is_prime), (2*i+1)): is_prime[j] = False return primes def to_mask(primes, x): mask, basis = 0, 1 for p in primes: if x%p == 0: mask |= basis basis <<= 1 return mask MOD = 10**9+7 primes = sieve_of_eratosthenes(max(nums)) dp = [0]*(1<<len(primes)) dp[0] = 1 cnts = collections.Counter(nums) for x, cnt in cnts.iteritems(): if x == 1 or any(x%(p*p) == 0 for p in primes if p*p <= x): continue mask = to_mask(primes, x) for i in xrange(len(dp)-1): if i&mask: continue dp[i|mask] = (dp[i|mask]+cnt*dp[i])%MOD return (pow(2, cnts[1], MOD))*(reduce(lambda total, x: (total+x)%MOD, dp, 0)-1)%MOD ", "class Solution def reversePairs(self, nums): def merge(nums, start, mid, end): r = mid + 1 tmp = [] for i in xrange(start, mid + 1): while r <= end and nums[i] > nums[r]: tmp.append(nums[r]) r += 1 tmp.append(nums[i]) nums[start:start+len(tmp)] = tmp def countAndMergeSort(nums, start, end): if end - start <= 0: return 0 mid = start + (end - start) / 2 count = countAndMergeSort(nums, start, mid) + countAndMergeSort(nums, mid + 1, end) r = mid + 1 for i in xrange(start, mid + 1): while r <= end and nums[i] > nums[r] * 2: r += 1 count += r - (mid + 1) merge(nums, start, mid, end) return count return countAndMergeSort(nums, 0, len(nums) - 1) ", "class Solution def missingInteger(self, nums): total = nums[0] for i in xrange(1, len(nums)): if nums[i] != nums[i-1]+1: break total += nums[i] lookup = set(nums) while total in lookup: total += 1 return total ", "class Solution def maximumNumberOfOnes(self, width, height, sideLength, maxOnes): if width < height: width, height = height, width R, r = divmod(height, sideLength) C, c = divmod(width, sideLength) assert(R <= C) area_counts = [(r*c, (R+1)*(C+1)), (r*(sideLength-c), (R+1)*C), ((sideLength-r)*c, R*(C+1)), ((sideLength-r)*(sideLength-c), R*C)] result = 0 for area, count in area_counts: area = min(maxOnes, area) result += count*area maxOnes -= area if not maxOnes: break return result ", "class Solution def shortestSubarray(self, A, K): accumulated_sum = [0]*(len(A)+1) for i in xrange(len(A)): accumulated_sum[i+1] = accumulated_sum[i]+A[i] result = float(\"inf\") mono_increasing_q = collections.deque() for i, curr in enumerate(accumulated_sum): while mono_increasing_q and curr <= accumulated_sum[mono_increasing_q[-1]]: mono_increasing_q.pop() while mono_increasing_q and curr-accumulated_sum[mono_increasing_q[0]] >= K: result = min(result, i-mono_increasing_q.popleft()) mono_increasing_q.append(i) return result if result != float(\"inf\") else -1 ", "class Solution def numEnclaves(self, A): directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] def dfs(A, i, j): if not (0 <= i < len(A) and 0 <= j < len(A[0]) and A[i][j]): return A[i][j] = 0 for d in directions: dfs(A, i+d[0], j+d[1]) for i in xrange(len(A)): dfs(A, i, 0) dfs(A, i, len(A[0])-1) for j in xrange(1, len(A[0])-1): dfs(A, 0, j) dfs(A, len(A)-1, j) return sum(sum(row) for row in A) ", "class Solution def numberGame(self, nums): nums.sort() for i in xrange(0, len(nums), 2): nums[i], nums[i+1] = nums[i+1], nums[i] return nums ", "class Solution def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience): result = 0 for hp, ex in itertools.izip(energy, experience): inc1 = max((hp+1)-initialEnergy, 0) inc2 = max((ex+1)-initialExperience, 0) result += inc1+inc2 initialEnergy += inc1-hp initialExperience += inc2+ex return result ", "class Solution def findLongestChain(self, pairs): pairs.sort(key=lambda x: x[1]) cnt, i = 0, 0 for j in xrange(len(pairs)): if j == 0 or pairs[i][1] < pairs[j][0]: cnt += 1 i = j return cnt ", "class Solution def sumOfNumberAndReverse(self, num): def backtracking(num, chosen): if num == 0: return True if chosen == 1: return False if num <= 18: return (num%2 == 0) or (num == 11 and chosen == 0) if chosen == 2: return False for x in (num%10, 10+num%10): if not (1 <= x <= 18): continue base = 11 if chosen: base = chosen else: while x*((base-1)*10+1) <= num: base = (base-1)*10+1 if num-x*base >= 0 and backtracking((num-x*base)//10, base//100+1): return True return False return backtracking(num, 0) ", "class Solution def sumOfNumberAndReverse(self, num): def reverse(n): result = 0 while n: result = result*10 + n%10 n //= 10 return result return any(x+reverse(x) == num for x in xrange(num//2, num+1)) ", "class Solution def sumOfNumberAndReverse(self, num): return any(x+int(str(x)[::-1]) == num for x in xrange(num//2, num+1)) ", "class Solution def reachingPoints(self, sx, sy, tx, ty): while tx >= sx and ty >= sy: if tx < ty: sx, sy = sy, sx tx, ty = ty, tx if ty > sy: tx %= ty else: return (tx - sx) % ty == 0 return False ", "class Solution def oddString(self, words): for i in xrange(len(words[0])-1): lookup = collections.defaultdict(list) for j, w in enumerate(words): if len(lookup[ord(w[i+1])-ord(w[i])]) < 2: lookup[ord(w[i+1])-ord(w[i])].append(j) if len(lookup) == 2: return next(words[l[0]] for l in lookup.itervalues() if len(l) == 1) import collections ", "class Solution def oddString(self, words): cnt = collections.Counter(tuple(ord(w[i+1])-ord(w[i]) for i in xrange(len(w)-1)) for w in words) target = next(k for k, v in cnt.iteritems() if v == 1) return next(w for w in words if tuple(ord(w[i+1])-ord(w[i]) for i in xrange(len(w)-1)) == target) ", "class Solution def sortArrayByParityII(self, A): j = 1 for i in xrange(0, len(A), 2): if A[i] % 2: while A[j] % 2: j += 2 A[i], A[j] = A[j], A[i] return A ", "class Solution def findLengthOfShortestSubarray(self, arr): j = -1 for j in reversed(xrange(1, len(arr))): if arr[j-1] > arr[j]: break else: return 0 result = j for i in xrange(j): if i and arr[i] < arr[i-1]: break while j < len(arr) and arr[i] > arr[j]: j += 1 result = min(result, (j-i+1)-2) return result ", "class Solution def findLengthOfShortestSubarray(self, arr): result = 0 for i in xrange(1, len(arr)): if arr[i-1] <= arr[i]: continue j = len(arr)-1 while j > i and (j == len(arr)-1 or arr[j] <= arr[j+1]) and arr[i-1] <= arr[j]: j -= 1 result = j-i+1 break for j in reversed(xrange(len(arr)-1)): if arr[j] <= arr[j+1]: continue i = 0 while i < j and (i == 0 or arr[i-1] <= arr[i]) and arr[i] <= arr[j+1]: i += 1 result = min(result, j-i+1) break return result ", "class Solution def minimumNumbers(self, num, k): return next((i for i in xrange(1, (min(num//k, 10) if k else 1)+1) if (num-i*k)%10 == 0), -1) if num else 0 ", "class Solution def mergeTrees(self, t1, t2): if t1 is None: return t2 if t2 is None: return t1 t1.val += t2.val t1.left = self.mergeTrees(t1.left, t2.left) t1.right = self.mergeTrees(t1.right, t2.right) return t1 ", "class Solution def convertTime(self, current, correct): OPS = (60, 15, 5, 1) diff = (int(correct[:2])*60+int(correct[3:]))-(int(current[:2])*60+int(current[3:])) result = 0 for x in OPS: q, diff = divmod(diff, x) result += q return result ", "class Solution def judgeCircle(self, moves): count = collections.Counter(moves) return count['L'] == count['R'] and count['U'] == count['D'] ", "class Solution def judgeCircle(self, moves): v, h = 0, 0 for move in moves: if move == 'U': v += 1 elif move == 'D': v -= 1 elif move == 'R': h += 1 elif move == 'L': h -= 1 return v == 0 and h == 0 ", "class Solution def maximumCandies(self, candies, k): def check(x): return sum(c//x for c in candies) >= k left, right = 1, max(candies) while left <= right: mid = left+(right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right ", "class Solution def widthOfBinaryTree(self, root): def dfs(node, i, depth, leftmosts): if not node: return 0 if depth >= len(leftmosts): leftmosts.append(i) return max(i-leftmosts[depth]+1, dfs(node.left, i*2, depth+1, leftmosts), dfs(node.right, i*2+1, depth+1, leftmosts)) leftmosts = [] return dfs(root, 1, 0, leftmosts) ", "class Solution def nextLargerNodes(self, head): result, stk = [], [] while head: while stk and stk[-1][1] < head.val: result[stk.pop()[0]] = head.val stk.append([len(result), head.val]) result.append(0) head = head.next return result ", "class Solution def validWordAbbreviation(self, word, abbr): i , digit = 0, 0 for c in abbr: if c.isdigit(): if digit == 0 and c == '0': return False digit *= 10 digit += int(c) else: if digit: i += digit digit = 0 if i >= len(word) or word[i] != c: return False i += 1 if digit: i += digit return i == len(word) ", "class Solution def uniqueOccurrences(self, arr): count = collections.Counter(arr) lookup = set() for v in count.itervalues(): if v in lookup: return False lookup.add(v) return True ", "class Solution def uniqueOccurrences(self, arr): count = collections.Counter(arr) return len(count) == len(set(count.itervalues())) ", "class Solution def powerfulIntegers(self, x, y, bound): result = set() log_x = int(math.floor(math.log(bound) / math.log(x)))+1 if x != 1 else 1 log_y = int(math.floor(math.log(bound) / math.log(y)))+1 if y != 1 else 1 pow_x = 1 for i in xrange(log_x): pow_y = 1 for j in xrange(log_y): val = pow_x + pow_y if val <= bound: result.add(val) pow_y *= y pow_x *= x return list(result) ", "class Solution def mostSimilar(self, n, roads, names, targetPath): adj = [[] for _ in xrange(n)] for u, v in roads: adj[u].append(v) adj[v].append(u) dp = [[0]*n for _ in xrange(len(targetPath)+1)] for i in xrange(1, len(targetPath)+1): for v in xrange(n): dp[i][v] = (names[v] != targetPath[i-1]) + min(dp[i-1][u] for u in adj[v]) path = [dp[-1].index(min(dp[-1]))] for i in reversed(xrange(2, len(targetPath)+1)): for u in adj[path[-1]]: if dp[i-1][u]+(names[path[-1]] != targetPath[i-1]) == dp[i][path[-1]]: path.append(u) break return path[::-1] ", "class Solution def minSpeedOnTime(self, dist, hour): def ceil(a, b): return (a+b-1)//b def total_time(dist, x): return sum(ceil(dist[i], x) for i in xrange(len(dist)-1)) + float(dist[-1])/x def check(dist, hour, x): return total_time(dist, x) <= hour MAX_SPEED = 10**7 if not check(dist, hour, MAX_SPEED): return -1 left, right = 1, MAX_SPEED while left <= right: mid = left + (right-left)//2 if check(dist, hour, mid): right = mid-1 else: left = mid+1 return left ", "class Solution def maxAlternatingSum(self, nums): result = nums[0] for i in xrange(len(nums)-1): result += max(nums[i+1]-nums[i], 0) return result ", "class Solution def maxArea(self, h, w, horizontalCuts, verticalCuts): def max_len(l, cuts): cuts.sort() l = max(cuts[0]-0, l-cuts[-1]) for i in xrange(1, len(cuts)): l = max(l, cuts[i]-cuts[i-1]) return l MOD = 10**9+7 return max_len(h, horizontalCuts) * max_len(w, verticalCuts) % MOD ", "class Solution def maxRepOpt1(self, text): K = 1 result = 0 total_count, count = collections.Counter(), collections.Counter() left, max_count = 0, 0 for i in xrange(len(text)): total_count[text[i]] += 1 count[text[i]] += 1 max_count = max(max_count, count[text[i]]) if i-left+1 - max_count > K: count[text[left]] -= 1 left += 1 result = max(result, min(i-left+1, total_count[text[i]])) return result import itertools ", "class Solution def maxRepOpt1(self, text): A = [[c, len(list(group))] for c, group in itertools.groupby(text)] total_count = collections.Counter(text) result = max(min(l+1, total_count[c]) for c, l in A) for i in xrange(1, len(A)-1): if A[i-1][0] == A[i+1][0] and A[i][1] == 1: result = max(result, min(A[i-1][1] + 1 + A[i+1][1], total_count[A[i+1][0]])) return result ", "class Solution def crawl(self, startUrl, htmlParser): SCHEME = \"http://\" def hostname(url): pos = url.find('/', len(SCHEME)) if pos == -1: return url return url[:pos] result = [startUrl] lookup = set(result) for from_url in result: name = hostname(from_url) for to_url in htmlParser.getUrls(from_url): if to_url not in lookup and name == hostname(to_url): result.append(to_url) lookup.add(to_url) return result ", "class Solution def uniquePaths(self, m, n): def nCr(n, r): if n-r < r: r = n-r c = 1 for k in xrange(1, r+1): c *= n-k+1 c //= k return c return nCr((m-1)+(n-1), n-1) ", "class Solution def uniquePaths(self, m, n): if m < n: m, n = n, m dp = [1]*n for i in xrange(1, m): for j in xrange(1, n): dp[j] += dp[j-1] return dp[n-1] ", "class Solution def maximumScore(self, nums, k): result = curr = nums[k] left = right = k while left-1 >= 0 or right+1 < len(nums): if (nums[left-1] if left-1 >= 0 else 0) <= (nums[right+1] if right+1 < len(nums) else 0): right += 1 else: left -= 1 curr = min(curr, nums[left], nums[right]) result = max(result, curr*(right-left+1)) return result import bisect ", "class Solution def maximumScore(self, nums, k): def score(nums, k): prefix = [nums[k]]*(k+1) for i in reversed(xrange(k)): prefix[i] = min(prefix[i+1], nums[i]) result = right = nums[k] for j in xrange(k+1, len(nums)): right = min(right, nums[j]) i = bisect.bisect_left(prefix, right) if i >= 0: result = max(result, right*(j-i+1)) return result return max(score(nums, k), score(nums[::-1], len(nums)-1-k)) ", "class Solution def scoreOfParentheses(self, S): result, depth = 0, 0 for i in xrange(len(S)): if S[i] == '(': depth += 1 else: depth -= 1 if S[i-1] == '(': result += 2**depth return result ", "class Solution def scoreOfParentheses(self, S): stack = [0] for c in S: if c == '(': stack.append(0) else: last = stack.pop() stack[-1] += max(1, 2*last) return stack[0] ", "class Solution def maxTaxiEarnings(self, n, rides): rides.sort() dp = [0]*(n+1) j = 0 for i in xrange(1, n+1): dp[i] = max(dp[i], dp[i-1]) while j < len(rides) and rides[j][0] == i: dp[rides[j][1]] = max(dp[rides[j][1]], dp[i]+rides[j][1]-rides[j][0]+rides[j][2]) j += 1 return dp[-1] ", "class Solution def reverseKGroup(self, head, k): dummy = ListNode(-1) dummy.next = head cur, cur_dummy = head, dummy length = 0 while cur: next_cur = cur.next length = (length + 1) % k if length == 0: next_dummy = cur_dummy.next self.reverse(cur_dummy, cur.next) cur_dummy = next_dummy cur = next_cur return dummy.next def reverse(self, begin, end): first = begin.next cur = first.next while cur != end: first.next = cur.next cur.next = begin.next begin.next = cur cur = first.next ", "class Solution def searchBST(self, root, val): while root and val != root.val: if val < root.val: root = root.left else: root = root.right return root ", "class Solution def secondsToRemoveOccurrences(self, s): result = cnt = 0 for c in s: if c == '0': cnt += 1 continue if cnt: result = max(result+1, cnt) return result ", "class Solution def printVertically(self, s): return [\"\".join(c).rstrip() for c in itertools.izip_longest(*s.split(), fillvalue=' ')] ", "class Solution def shortestCompletingWord(self, licensePlate, words): def contains(counter1, w2): c2 = collections.Counter(w2.lower()) c2.subtract(counter1) return all(map(lambda x: x >= 0, c2.values())) result = None counter = collections.Counter(c.lower() for c in licensePlate if c.isalpha()) for word in words: if (result is None or (len(word) < len(result))) and contains(counter, word): result = word return result ", "class Solution dp = {} def getKth(self, lo, hi, k): def nth_element(nums, n, compare=lambda a, b: a < b): def partition_around_pivot(left, right, pivot_idx, nums, compare): new_pivot_idx = left nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx] for i in xrange(left, right): if compare(nums[i], nums[right]): nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i] new_pivot_idx += 1 nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right] return new_pivot_idx left, right = 0, len(nums) - 1 while left <= right: pivot_idx = random.randint(left, right) new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare) if new_pivot_idx == n: return elif new_pivot_idx > n: right = new_pivot_idx - 1 else: left = new_pivot_idx + 1 def power_value(x): y, result = x, 0 while x > 1 and x not in Solution.dp: result += 1 if x%2: x = 3*x + 1 else: x //= 2 Solution.dp[y] = result + (Solution.dp[x] if x > 1 else 0) return Solution.dp[y], y arr = map(power_value, range(lo, hi+1)) nth_element(arr, k-1) return arr[k-1][1] ", "class Solution dp = {} def getKth(self, lo, hi, k): def power_value(x): y, result = x, 0 while x > 1 and x not in Solution2.dp: result += 1 if x%2: x = 3*x + 1 else: x //= 2 Solution2.dp[y] = result + (Solution2.dp[x] if x > 1 else 0) return Solution2.dp[y], y return sorted(range(lo, hi+1), key=power_value)[k-1] ", "class Solution def maxTastiness(self, price, tastiness, maxAmount, maxCoupons): dp = [[0]*(maxCoupons+1) for _ in xrange(maxAmount+1)] for p, t in itertools.izip(price, tastiness): for i in reversed(xrange(p//2, maxAmount+1)): for j in reversed(xrange(maxCoupons+1)): if i-p >= 0: dp[i][j] = max(dp[i][j], t+dp[i-p][j]) if j-1 >= 0: dp[i][j] = max(dp[i][j], t+dp[i-p//2][j-1]) return dp[maxAmount][maxCoupons] ", "class Solution def findOcurrences(self, text, first, second): result = [] first += ' ' second += ' ' third = [] i, j, k = 0, 0, 0 while k < len(text): c = text[k] k += 1 if i != len(first): if c == first[i]: i += 1 else: i = 0 continue if j != len(second): if c == second[j]: j += 1 else: k -= j+1 i, j = 0, 0 continue if c != ' ': third.append(c) continue k -= len(second) + len(third) + 1 i, j = 0, 0 result.append(\"\".join(third)) third = [] if third: result.append(\"\".join(third)) return result ", "class Solution def maxFrequencyScore(self, nums, k): MOD = 10**9+7 lookup = {} def powmod(n, p): if (n, p) not in lookup: lookup[n, p] = (lookup[n, p-1]*n)%MOD if p >= 2 else n%MOD return lookup[n, p] result = curr = 0 cnt = collections.Counter() for i in xrange(len(nums)): if i >= k: curr = (curr-powmod(nums[i-k], cnt[nums[i-k]]))%MOD cnt[nums[i-k]] -= 1 if cnt[nums[i-k]]: curr = (curr+powmod(nums[i-k], cnt[nums[i-k]]))%MOD if cnt[nums[i]]: curr = (curr-powmod(nums[i], cnt[nums[i]]))%MOD cnt[nums[i]] += 1 curr = (curr+powmod(nums[i], cnt[nums[i]]))%MOD if i >= k-1: result = max(result, curr) return result import collections ", "class Solution def maxFrequencyScore(self, nums, k): MOD = 10**9+7 result = curr = 0 cnt = collections.Counter() for i in xrange(len(nums)): if i >= k: curr = (curr-pow(nums[i-k], cnt[nums[i-k]], MOD))%MOD cnt[nums[i-k]] -= 1 if cnt[nums[i-k]]: curr = (curr+pow(nums[i-k], cnt[nums[i-k]], MOD))%MOD if cnt[nums[i]]: curr = (curr-pow(nums[i], cnt[nums[i]], MOD))%MOD cnt[nums[i]] += 1 curr = (curr+pow(nums[i], cnt[nums[i]], MOD))%MOD if i >= k-1: result = max(result, curr) return result ", "class Solution def getMaxLen(self, nums): result, neg_cnt, last_zero_pos, first_valid_neg_pos = 0, 0, -1, -1 for i in xrange(len(nums)): if nums[i] == 0: neg_cnt = 0 last_zero_pos = i first_valid_neg_pos = -1 continue if nums[i] < 0: if first_valid_neg_pos == -1: first_valid_neg_pos = i neg_cnt += 1 result = max(result, i-(last_zero_pos if neg_cnt%2 == 0 else first_valid_neg_pos)) return result ", "class Solution def shiftGrid(self, grid, k): def rotate(grids, k): def reverse(grid, start, end): while start < end: start_r, start_c = divmod(start, len(grid[0])) end_r, end_c = divmod(end-1, len(grid[0])) grid[start_r][start_c], grid[end_r][end_c] = grid[end_r][end_c], grid[start_r][start_c] start += 1 end -= 1 k %= len(grid)*len(grid[0]) reverse(grid, 0, len(grid)*len(grid[0])) reverse(grid, 0, k) reverse(grid, k, len(grid)*len(grid[0])) rotate(grid, k) return grid ", "class Solution def numberOfDays(self, Y, M): leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0 return (28+leap if (M == 2) else 31-(M-1)%7%2) ", "class Solution def maxMatrixSum(self, matrix): abs_total = sum(abs(x) for row in matrix for x in row) min_abs_val = min(abs(x) for row in matrix for x in row) neg_cnt = sum(x < 0 for row in matrix for x in row) return abs_total if neg_cnt%2 == 0 else abs_total - 2*min_abs_val ", "class Solution def isUgly(self, num): if num == 0: return False for i in [2, 3, 5]: while num % i == 0: num /= i return num == 1 ", "class Solution def shortestPalindrome(self, s): def getPrefix(pattern): prefix = [-1] * len(pattern) j = -1 for i in xrange(1, len(pattern)): while j > -1 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix if not s: return s A = s + '#' + s[::-1] return s[getPrefix(A)[-1]+1:][::-1] + s ", "class Solution def shortestPalindrome(self, s): def getPrefix(pattern): prefix = [-1] * len(pattern) j = -1 for i in xrange(1, len(pattern)): while j > -1 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix if not s: return s A = s + s[::-1] prefix = getPrefix(A) i = prefix[-1] while i >= len(s): i = prefix[i] return s[i+1:][::-1] + s ", "class Solution def shortestPalindrome(self, s): def preProcess(s): if not s: return ['^', '$'] string = ['^'] for c in s: string += ['#', c] string += ['#', '$'] return string string = preProcess(s) palindrome = [0] * len(string) center, right = 0, 0 for i in xrange(1, len(string) - 1): i_mirror = 2 * center - i if right > i: palindrome[i] = min(right - i, palindrome[i_mirror]) else: palindrome[i] = 0 while string[i + 1 + palindrome[i]] == string[i - 1 - palindrome[i]]: palindrome[i] += 1 if i + palindrome[i] > right: center, right = i, i + palindrome[i] max_len = 0 for i in xrange(1, len(string) - 1): if i - palindrome[i] == 1: max_len = palindrome[i] return s[len(s)-1:max_len-1:-1] + s ", "class Solution def findMaxAverage(self, nums, k): result = total = sum(nums[:k]) for i in xrange(k, len(nums)): total += nums[i] - nums[i-k] result = max(result, total) return float(result) / k ", "class Solution def deleteDuplicatesUnsorted(self, head): count = collections.defaultdict(int) curr = head while curr: count[curr.val] += 1 curr = curr.next curr = dummy = ListNode(0, head) while curr.next: if count[curr.next.val] == 1: curr = curr.next else: curr.next = curr.next.next return dummy.next ", "class Solution def passThePillow(self, n, time): return n-abs((n-1)-(time%(2*(n-1)))) ", "class Solution def assignTasks(self, servers, tasks): idle = [(servers[i], i) for i in xrange(len(servers))] working = [] heapq.heapify(idle) result = [] t = 0 for i in xrange(len(tasks)): t = max(t, i) if idle else working[0][0] while working and working[0][0] <= t: _, w, idx = heapq.heappop(working) heapq.heappush(idle, (w, idx)) w, idx = heapq.heappop(idle) heapq.heappush(working, (t+tasks[i], w, idx)) result.append(idx) return result ", "class Solution def minSteps(self, s, t): cnt1, cnt2 = collections.Counter(s), collections.Counter(t) return sum((cnt1-cnt2).itervalues())+sum((cnt2-cnt1).itervalues()) ", "class Solution def findMinStep(self, board, hand): def shrink(s): while True: i = 0 for start in xrange(len(s)): while i < len(s) and s[start] == s[i]: i += 1 if i-start >= 3: s = s[0:start]+s[i:] break else: break return s def findMinStepHelper(board, hand, lookup): if not board: return 0 if not hand: return float(\"inf\") if tuple(hand) in lookup[tuple(board)]: return lookup[tuple(board)][tuple(hand)] result = float(\"inf\") for i in xrange(len(hand)): for j in xrange(len(board)+1): next_board = shrink(board[0:j] + hand[i:i+1] + board[j:]) next_hand = hand[0:i] + hand[i+1:] result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1) lookup[tuple(board)][tuple(hand)] = result return result lookup = collections.defaultdict(dict) board, hand = list(board), list(hand) result = findMinStepHelper(board, hand, lookup) return -1 if result == float(\"inf\") else result import collections class Solution_TLE(object): def findMinStep(self, board, hand): def shrink(s): stack = [] start = 0 for i in xrange(len(s)+1): if i == len(s) or s[i] != s[start]: if stack and stack[-1][0] == s[start]: stack[-1][1] += i - start if stack[-1][1] >= 3: stack.pop() elif s and i - start < 3: stack += [s[start], i - start], start = i result = [] for p in stack: result += [p[0]] * p[1] return result def findMinStepHelper(board, hand, lookup): if not board: return 0 if not hand: return float(\"inf\") if tuple(hand) in lookup[tuple(board)]: return lookup[tuple(board)][tuple(hand)] result = float(\"inf\") for i in xrange(len(hand)): for j in xrange(len(board)+1): next_board = shrink(board[0:j] + hand[i:i+1] + board[j:]) next_hand = hand[0:i] + hand[i+1:] result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1) lookup[tuple(board)][tuple(hand)] = result return result lookup = collections.defaultdict(dict) board, hand = list(board), list(hand) result = findMinStepHelper(board, hand, lookup) return -1 if result == float(\"inf\") else result import collections class Solution_GREEDY_ACCEPT_BUT_NOT_PROVED(object): def findMinStep(self, board, hand): def shrink(s): stack = [] start = 0 for i in xrange(len(s)+1): if i == len(s) or s[i] != s[start]: if stack and stack[-1][0] == s[start]: stack[-1][1] += i - start if stack[-1][1] >= 3: stack.pop() elif s and i - start < 3: stack += [s[start], i - start], start = i result = [] for p in stack: result += [p[0]] * p[1] return result def findMinStepHelper2(board, hand, lookup): result = float(\"inf\") for i in xrange(len(hand)): for j in xrange(len(board)+1): next_board = shrink(board[0:j] + hand[i:i+1] + board[j:]) next_hand = hand[0:i] + hand[i+1:] result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1) return result def find(board, c, j): for i in xrange(j, len(board)): if board[i] == c: return i return -1 def findMinStepHelper(board, hand, lookup): if not board: return 0 if not hand: return float(\"inf\") if tuple(hand) in lookup[tuple(board)]: return lookup[tuple(board)][tuple(hand)] result = float(\"inf\") for i in xrange(len(hand)): j = 0 while j < len(board): k = find(board, hand[i], j) if k == -1: break if k < len(board) - 1 and board[k] == board[k+1]: next_board = shrink(board[0:k] + board[k+2:]) next_hand = hand[0:i] + hand[i+1:] result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1) k += 1 elif i > 0 and hand[i] == hand[i-1]: next_board = shrink(board[0:k] + board[k+1:]) next_hand = hand[0:i-1] + hand[i+1:] result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 2) j = k+1 lookup[tuple(board)][tuple(hand)] = result return result board, hand = list(board), list(hand) hand.sort() result = findMinStepHelper(board, hand, collections.defaultdict(dict)) if result == float(\"inf\"): result = findMinStepHelper2(board, hand, collections.defaultdict(dict)) return -1 if result == float(\"inf\") else result class Solution_WRONG_GREEDY_AND_NOT_ACCEPT_NOW(object): def findMinStep(self, board, hand): def shrink(s): stack = [] start = 0 for i in xrange(len(s)+1): if i == len(s) or s[i] != s[start]: if stack and stack[-1][0] == s[start]: stack[-1][1] += i - start if stack[-1][1] >= 3: stack.pop() elif s and i - start < 3: stack += [s[start], i - start], start = i result = [] for p in stack: result += [p[0]] * p[1] return result def find(board, c, j): for i in xrange(j, len(board)): if board[i] == c: return i return -1 def findMinStepHelper(board, hand, lookup): if not board: return 0 if not hand: return float(\"inf\") if tuple(hand) in lookup[tuple(board)]: return lookup[tuple(board)][tuple(hand)] result = float(\"inf\") for i in xrange(len(hand)): j = 0 while j < len(board): k = find(board, hand[i], j) if k == -1: break if k < len(board) - 1 and board[k] == board[k+1]: next_board = shrink(board[0:k] + board[k+2:]) next_hand = hand[0:i] + hand[i+1:] result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 1) k += 1 elif i > 0 and hand[i] == hand[i-1]: next_board = shrink(board[0:k] + board[k+1:]) next_hand = hand[0:i-1] + hand[i+1:] result = min(result, findMinStepHelper(next_board, next_hand, lookup) + 2) j = k+1 lookup[tuple(board)][tuple(hand)] = result return result lookup = collections.defaultdict(dict) board, hand = list(board), list(hand) hand.sort() result = findMinStepHelper(board, hand, lookup) return -1 if result == float(\"inf\") else result ", "class Solution def minimumDeviation(self, nums): max_heap = [-num*2 if num%2 else -num for num in nums] heapq.heapify(max_heap) min_elem = -max(max_heap) result = float(\"inf\") while len(max_heap) == len(nums): num = -heapq.heappop(max_heap) result = min(result, num-min_elem) if not num%2: min_elem = min(min_elem, num//2) heapq.heappush(max_heap, -num//2) return result ", "class Solution def minimumXORSum(self, nums1, nums2): def hungarian(a): if not a: return 0, [] n, m = len(a)+1, len(a[0])+1 u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1) for i in xrange(1, n): p[0] = i j0 = 0 dist, pre = [float(\"inf\")]*m, [-1]*m done = [False]*(m+1) while True: done[j0] = True i0, j1, delta = p[j0], None, float(\"inf\") for j in xrange(1, m): if done[j]: continue cur = a[i0-1][j-1]-u[i0]-v[j] if cur < dist[j]: dist[j], pre[j] = cur, j0 if dist[j] < delta: delta, j1 = dist[j], j for j in xrange(m): if done[j]: u[p[j]] += delta v[j] -= delta else: dist[j] -= delta j0 = j1 if not p[j0]: break while j0: j1 = pre[j0] p[j0], j0 = p[j1], j1 for j in xrange(1, m): if p[j]: ans[p[j]-1] = j-1 return -v[0], ans adj = [[0]*len(nums2) for _ in xrange(len(nums1))] for i in xrange(len(nums1)): for j in xrange(len(nums2)): adj[i][j] = nums1[i]^nums2[j] return hungarian(adj)[0] ", "class Solution def minimumXORSum(self, nums1, nums2): dp = [(float(\"inf\"), float(\"inf\"))]*(2**len(nums2)) dp[0] = (0, 0) for mask in xrange(len(dp)): bit = 1 for i in xrange(len(nums2)): if (mask&bit) == 0: dp[mask|bit] = min(dp[mask|bit], (dp[mask][0]+(nums1[dp[mask][1]]^nums2[i]), dp[mask][1]+1)) bit <<= 1 return dp[-1][0] ", "class Solution def rotatedDigits(self, N): A = map(int, str(N)) invalid, diff = set([3, 4, 7]), set([2, 5, 6, 9]) def dp(A, i, is_prefix_equal, is_good, lookup): if i == len(A): return int(is_good) if (i, is_prefix_equal, is_good) not in lookup: result = 0 for d in xrange(A[i]+1 if is_prefix_equal else 10): if d in invalid: continue result += dp(A, i+1, is_prefix_equal and d == A[i], is_good or d in diff, lookup) lookup[i, is_prefix_equal, is_good] = result return lookup[i, is_prefix_equal, is_good] lookup = {} return dp(A, 0, True, False, lookup) ", "class Solution def rotatedDigits(self, N): INVALID, SAME, DIFF = 0, 1, 2 same, diff = [0, 1, 8], [2, 5, 6, 9] dp = [0] * (N+1) dp[0] = SAME for i in xrange(N//10+1): if dp[i] != INVALID: for j in same: if i*10+j <= N: dp[i*10+j] = max(SAME, dp[i]) for j in diff: if i*10+j <= N: dp[i*10+j] = DIFF return dp.count(DIFF) ", "class Solution def rotatedDigits(self, N): invalid, diff = set(['3', '4', '7']), set(['2', '5', '6', '9']) result = 0 for i in xrange(N+1): lookup = set(list(str(i))) if invalid & lookup: continue if diff & lookup: result += 1 return result ", "class Solution def minScoreTriangulation(self, A): dp = [[0 for _ in xrange(len(A))] for _ in xrange(len(A))] for p in xrange(3, len(A)+1): for i in xrange(len(A)-p+1): j = i+p-1; dp[i][j] = float(\"inf\") for k in xrange(i+1, j): dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j] + A[i]*A[j]*A[k]) return dp[0][-1] ", "class Solution def minimumRecolors(self, blocks, k): result = k curr = 0 for i, x in enumerate(blocks): curr += int(blocks[i] == 'W') if i+1-k < 0: continue result = min(result, curr) curr -= int(blocks[i+1-k] == 'W') return result ", "class Solution def numberOfRightTriangles(self, grid): def get(i, j): return grid[i][j] if n < m else grid[j][i] n, m = len(grid), len(grid[0]) result = 0 cnt1 = [sum(get(i, j) for j in xrange(max(n, m))) for i in xrange(min(n, m))] for j in xrange(max(n, m)): cnt2 = sum(get(i, j) for i in xrange(min(n, m))) result += sum((cnt1[i]-1)*(cnt2-1) for i in xrange(min(n, m)) if get(i, j)) return result ", "class Solution def numberOfRightTriangles(self, grid): n, m = len(grid), len(grid[0]) cnt1 = [sum(grid[i][j] for j in xrange(m)) for i in xrange(n)] cnt2 = [sum(grid[i][j] for i in xrange(n)) for j in xrange(m)] return sum((cnt1[i]-1)*(cnt2[j]-1) for i in xrange(n) for j in xrange(m) if grid[i][j]) ", "class Solution def numberOfRightTriangles(self, grid): def get(i, j): return grid[i][j] if n < m else grid[j][i] def count(direction): result = 0 cnt = [0]*min(n, m) for j in direction(xrange(max(n, m))): c = sum(get(i, j) for i in xrange(len(cnt))) for i in xrange(len(cnt)): if get(i, j) == 0: continue result += cnt[i] cnt[i] += c-1 return result n, m = len(grid), len(grid[0]) return count(lambda x: x)+count(reversed) ", "class Solution def shortestToChar(self, S, C): result = [len(S)] * len(S) prev = -len(S) for i in itertools.chain(xrange(len(S)), reversed(xrange(len(S)))): if S[i] == C: prev = i result[i] = min(result[i], abs(i-prev)) return result ", "class Solution def twoSum(self, nums, target): lookup = {} for i, num in enumerate(nums): if target - num in lookup: return [lookup[target - num], i] lookup[num] = i def twoSum2(self, nums, target): for i in nums: j = target - i tmp_nums_start_index = nums.index(i) + 1 tmp_nums = nums[tmp_nums_start_index:] if j in tmp_nums: return [nums.index(i), tmp_nums_start_index + tmp_nums.index(j)] ", "class Solution def minOperations(self, nums, queries): nums.sort() prefix = [0]*(len(nums)+1) for i in xrange(len(nums)): prefix[i+1] = prefix[i]+nums[i] result = [0]*len(queries) for i, q in enumerate(queries): j = bisect.bisect_left(nums, q) result[i] = (q*j-prefix[j])+((prefix[-1]-prefix[j])-q*(len(nums)-j)) return result ", "class Solution def __init__(self, nums): self.__nums = nums def reset(self): return self.__nums def shuffle(self): nums = list(self.__nums) for i in xrange(len(nums)): j = random.randint(i, len(nums)-1) nums[i], nums[j] = nums[j], nums[i] return nums ", "class Solution def replaceDigits(self, s): return \"\".join(chr(ord(s[i-1])+int(s[i])) if i%2 else s[i] for i in xrange(len(s))) ", "class Solution def profitableSchemes(self, G, P, group, profit): dp = [[0 for _ in xrange(G+1)] for _ in xrange(P+1)] dp[0][0] = 1 for p, g in itertools.izip(profit, group): for i in reversed(xrange(P+1)): for j in reversed(xrange(G-g+1)): dp[min(i+p, P)][j+g] += dp[i][j] return sum(dp[P]) % (10**9 + 7) ", "class Solution def maximumGain(self, s, x, y): def score(s, a, x): i = result = 0 for j in xrange(len(s)): s[i] = s[j] i += 1 if i >= 2 and s[i-2:i] == a: i -= 2 result += x s[:] = s[:i] return result s, a, b = list(s), list(\"ab\"), list(\"ba\") if x < y: x, y = y, x a, b = b, a return score(s, a, x) + score(s, b, y) ", "class Solution def sumOfLeftLeaves(self, root): def sumOfLeftLeavesHelper(root, is_left): if not root: return 0 if not root.left and not root.right: return root.val if is_left else 0 return sumOfLeftLeavesHelper(root.left, True) + sumOfLeftLeavesHelper(root.right, False) return sumOfLeftLeavesHelper(root, False) ", "class Solution def tourOfKnight(self, m, n, r, c): DIRECTIONS = ((1, 2), (-1, 2), (1, -2), (-1, -2), (2, 1), (-2, 1), (2, -1), (-2, -1)) def backtracking(r, c, i): def degree(x): cnt = 0 r, c = x for dr, dc in DIRECTIONS: nr, nc = r+dr, c+dc if 0 <= nr < m and 0 <= nc < n and result[nr][nc] == -1: cnt += 1 return cnt if i == m*n: return True candidates = [] for dr, dc in DIRECTIONS: nr, nc = r+dr, c+dc if 0 <= nr < m and 0 <= nc < n and result[nr][nc] == -1: candidates.append((nr, nc)) for nr, nc in sorted(candidates, key=degree): result[nr][nc] = i if backtracking(nr, nc, i+1): return True result[nr][nc] = -1 return False result = [[-1]*n for _ in xrange(m)] result[r][c] = 0 backtracking(r, c, 1) return result ", "class Solution def tourOfKnight(self, m, n, r, c): DIRECTIONS = ((1, 2), (-1, 2), (1, -2), (-1, -2), (2, 1), (-2, 1), (2, -1), (-2, -1)) def backtracking(r, c, i): if i == m*n: return True for dr, dc in DIRECTIONS: nr, nc = r+dr, c+dc if not (0 <= nr < m and 0 <= nc < n and result[nr][nc] == -1): continue result[nr][nc] = i if backtracking(nr, nc, i+1): return True result[nr][nc] = -1 return False result = [[-1]*n for _ in xrange(m)] result[r][c] = 0 backtracking(r, c, 1) return result ", "class Solution def maxSubarrayLength(self, nums): stk = [] for i in reversed(xrange(len(nums))): if not stk or nums[stk[-1]] > nums[i]: stk.append(i) result = 0 for left in xrange(len(nums)): while stk and nums[stk[-1]] < nums[left]: result = max(result, stk.pop()-left+1) return result ", "class Solution def maxSubarrayLength(self, nums): idxs = range(len(nums)) idxs.sort(key=lambda x: nums[x], reverse=True) result = 0 for left in xrange(len(nums)): while idxs and nums[idxs[-1]] < nums[left]: result = max(result, idxs.pop()-left+1) return result ", "class Solution def minOperations(self, nums, x, y): def ceil_divide(a, b): return (a+b-1)//b def check(total): return sum(ceil_divide(max(v-min(ceil_divide(v, y), total)*y, 0), x-y) for v in nums) <= total left, right = 1, ceil_divide(max(nums), y) while left <= right: mid = left+(right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left ", "class Solution def maximumBooks(self, books): def count(right, l): left = max(right-l+1, 0) return (left+right)*(right-left+1)//2 result = curr = 0 stk = [-1] for i in xrange(len(books)): while stk[-1] != -1 and books[stk[-1]] >= books[i]-(i-stk[-1]): j = stk.pop() curr -= count(books[j], j-stk[-1]) curr += count(books[i], i-stk[-1]) stk.append(i) result = max(result, curr) return result ", "class Solution def minMeetingRooms(self, intervals): result, curr = 0, 0 line = [x for i, j in intervals for x in [[i, 1], [j, -1]]] line.sort() for _, num in line: curr += num result = max(result, curr) return result ", "class Solution def minMeetingRooms(self, intervals): starts, ends = [], [] for start, end in intervals: starts.append(start) ends.append(end) starts.sort() ends.sort() s, e = 0, 0 min_rooms, cnt_rooms = 0, 0 while s < len(starts): if starts[s] < ends[e]: cnt_rooms += 1 min_rooms = max(min_rooms, cnt_rooms) s += 1 else: cnt_rooms -= 1 e += 1 return min_rooms from heapq import heappush, heappop ", "class Solution def minMeetingRooms(self, intervals): if not intervals: return 0 intervals.sort(key=lambda x: x[0]) free_rooms = [] heappush(free_rooms, intervals[0][1]) for interval in intervals[1:]: if free_rooms[0] <= interval[0]: heappop(free_rooms) heappush(free_rooms, interval[1]) return len(free_rooms) ", "class Solution def stoneGameVIII(self, stones): for i in xrange(len(stones)-1): stones[i+1] += stones[i] return reduce(lambda curr, i: max(curr, stones[i]-curr), reversed(xrange(1, len(stones)-1)), stones[-1]) ", "class Solution def maxWidthOfVerticalArea(self, points): sorted_x = sorted({x for x, y in points}) return max([b-a for a, b in itertools.izip(sorted_x, sorted_x[1:])] + [0]) ", "class Solution def peakIndexInMountainArray(self, arr): left, right = 0, len(arr)-1 while left <= right: mid = left + (right-left)//2 if arr[mid] > arr[mid+1]: right = mid-1 else: left = mid+1 return left ", "class Solution def maxProduct(self, s): def palindromic_subsequence_length(s, mask): result = 0 left, right = 0, len(s)-1 left_bit, right_bit = 1<<left, 1<<right while left <= right: if mask&left_bit == 0: left, left_bit = left+1, left_bit<<1 elif mask&right_bit == 0: right, right_bit = right-1, right_bit>>1 elif s[left] == s[right]: result += 1 if left == right else 2 left, left_bit = left+1, left_bit<<1 right, right_bit = right-1, right_bit>>1 else: return 0 return result dp = [palindromic_subsequence_length(s, mask) for mask in xrange(1<<len(s))] result = 0 for mask in xrange(len(dp)): if dp[mask]*(len(s)-dp[mask]) <= result: continue submask = inverse_mask = (len(dp)-1)^mask while submask: result = max(result, dp[mask]*dp[submask]) submask = (submask-1)&inverse_mask return result ", "class Solution def isValidPalindrome(self, s, k): if s == s[::-1]: return True dp = [[1] * len(s) for _ in xrange(2)] for i in reversed(xrange(len(s))): for j in xrange(i+1, len(s)): if s[i] == s[j]: dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2 else: dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1]) return len(s) <= k + dp[0][-1] ", "class Solution def stoneGameII(self, piles): def dp(piles, lookup, i, m): if i+2*m >= len(piles): return piles[i] if (i, m) not in lookup: lookup[i, m] = piles[i] - min(dp(piles, lookup, i+x, max(m, x)) for x in xrange(1, 2*m+1)) return lookup[i, m] for i in reversed(xrange(len(piles)-1)): piles[i] += piles[i+1] return dp(piles, {}, 0, 1) ", "class Solution def maxProbability(self, n, edges, succProb, start, end): adj = collections.defaultdict(list) for (u, v), p in itertools.izip(edges, succProb): adj[u].append((v, p)) adj[v].append((u, p)) max_heap = [(-1.0, start)] result, lookup = collections.defaultdict(float), set() result[start] = 1.0 while max_heap and len(lookup) != len(adj): curr, u = heapq.heappop(max_heap) if u in lookup: continue lookup.add(u) for v, w in adj[u]: if v in lookup: continue if v in result and result[v] >= -curr*w: continue result[v] = -curr*w heapq.heappush(max_heap, (-result[v], v)) return result[end] ", "class Solution def minimizeMax(self, nums, p): def check(x): i = cnt = 0 while i+1 < len(nums) and cnt < p: if nums[i+1]-nums[i] <= x: i += 1 cnt += 1 i += 1 return cnt == p nums.sort() left, right = 0, nums[-1]-nums[0] while left <= right: mid = left + (right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left ", "class Solution def __init__(self, N, blacklist): self.__n = N-len(blacklist) self.__lookup = {} white = iter(set(range(self.__n, N))-set(blacklist)) for black in blacklist: if black < self.__n: self.__lookup[black] = next(white) def pick(self): index = random.randint(0, self.__n-1) return self.__lookup[index] if index in self.__lookup else index import random ", "class Solution def __init__(self, N, blacklist): self.__n = N-len(blacklist) blacklist.sort() self.__blacklist = blacklist def pick(self): index = random.randint(0, self.__n-1) left, right = 0, len(self.__blacklist)-1 while left <= right: mid = left+(right-left)//2 if index+mid < self.__blacklist[mid]: right = mid-1 else: left = mid+1 return index+left ", "class Solution def maximumScore(self, a, b, c): return min((a+b+c)//2, a+b+c - max(a, b, c)) ", "class Solution def minDays(self, n): def memoization(lookup, i): if i <= 1: return i if i not in lookup: lookup[i] = 1+min(i%2+memoization(lookup, i//2), i%3+memoization(lookup, i//3)) return lookup[i] lookup = {} return memoization(lookup, n) ", "class Solution def minDays(self, n): result = 0 q, lookup = [n], set([n]) while q: new_q = [] for i in q: if not i: return result if i-1 not in lookup: lookup.add(i-1) new_q.append(i-1) if i%2 == 0 and i//2 not in lookup: lookup.add(i//2) new_q.append(i//2) if i%3 == 0 and i//3 not in lookup: lookup.add(i//3) new_q.append(i//3) result += 1 q = new_q return result ", "class Solution def pickGifts(self, gifts, k): for i, x in enumerate(gifts): gifts[i] = -x heapq.heapify(gifts) for _ in xrange(k): x = heapq.heappop(gifts) heapq.heappush(gifts, -int((-x)**0.5)) return -sum(gifts) ", "class Solution def maxBottlesDrunk(self, numBottles, numExchange): result = numBottles while numBottles >= numExchange: numBottles -= numExchange numExchange += 1 result += 1 numBottles += 1 return result ", "class Solution def pathSum(self, root, sum): return self.pathSumRecu([], [], root, sum) def pathSumRecu(self, result, cur, root, sum): if root is None: return result if root.left is None and root.right is None and root.val == sum: result.append(cur + [root.val]) return result cur.append(root.val) self.pathSumRecu(result, cur, root.left, sum - root.val) self.pathSumRecu(result, cur,root.right, sum - root.val) cur.pop() return result ", "class Solution def twoOutOfThree(self, nums1, nums2, nums3): K = 2 cnt = collections.Counter() for nums in nums1, nums2, nums3: cnt.update(set(nums)) return [x for x, c in cnt.iteritems() if c >= K] import collections ", "class Solution def twoOutOfThree(self, nums1, nums2, nums3): K = 2 cnt = collections.Counter() result = [] for nums in nums1, nums2, nums3: for x in set(nums): cnt[x] += 1 if cnt[x] == K: result.append(x) return result ", "class Solution def numMusicPlaylists(self, N, L, K): M = 10**9+7 dp = [[0 for _ in xrange(1+L)] for _ in xrange(2)] dp[0][0] = dp[1][1] = 1 for n in xrange(1, N+1): dp[n % 2][n] = (dp[(n-1) % 2][n-1] * n) % M for l in xrange(n+1, L+1): dp[n % 2][l] = ((dp[n % 2][l-1] * max(n-K, 0)) % M + (dp[(n-1) % 2][l-1] * n) % M) % M return dp[N % 2][L] ", "class Solution def removeElement(self, A, elem): i, last = 0, len(A) - 1 while i <= last: if A[i] == elem: A[i], A[last] = A[last], A[i] last -= 1 else: i += 1 return last + 1 ", "class Solution def removeKdigits(self, num, k): result = [] for d in num: while k and result and result[-1] > d: result.pop() k -= 1 result.append(d) return ''.join(result).lstrip('0')[:-k or None] or '0' ", "class Solution def search(self, reader, target): left, right = 0, 19999 while left <= right: mid = left + (right-left)//2 response = reader.get(mid) if response > target: right = mid-1 elif response < target: left = mid+1 else: return mid return -1 ", "class Solution def swapPairs(self, head): dummy = ListNode(0) dummy.next = head current = dummy while current.next and current.next.next: next_one, next_two, next_three = current.next, current.next.next, current.next.next.next current.next = next_two next_two.next = next_one next_one.next = next_three current = next_one return dummy.next ", "class Solution def similarRGB(self, color): def rounding(color): q, r = divmod(int(color, 16), 17) if r > 8: q += 1 return '{:02x}'.format(17*q) return '#' + rounding(color[1:3]) + rounding(color[3:5]) + rounding(color[5:7]) ", "class Solution def minRectanglesToCoverPoints(self, points, w): points.sort(key=lambda x: x[0]) result = 0 left = -(w+1) for right, _ in points: if right-left <= w: continue left = right result += 1 return result ", "class Solution def countSeniors(self, details): return sum(x[-4:-2] > \"60\" for x in details) ", "class Solution def minimumBuckets(self, street): result = 0 street = list(street) for i, c in enumerate(street): if c != 'H' or (i and street[i-1] == 'B'): continue if i+1 < len(street) and street[i+1] == '.': street[i+1] = 'B' result += 1 elif i and street[i-1] == '.': street[i-1] = 'B' result += 1 else: return -1 return result ", "class Solution def singleDivisorTriplet(self, nums): def check(a, b, c): return sum((a+b+c)%x == 0 for x in (a, b, c)) == 1 cnt = collections.Counter(nums) return 6*(sum(cnt[a]*cnt[b]*cnt[c] for a, b, c in itertools.combinations(cnt.keys(), 3) if check(a, b, c)) + sum(cnt[a]*(cnt[a]-1)//2*cnt[b] for a, b in itertools.permutations(cnt.keys(), 2) if check(a, a, b))) ", "class Solution def minEnd(self, n, x): n -= 1 base_n = base_x = 1 while base_n <= n: if (x&base_x) == 0: if n&base_n: x |= base_x base_n <<= 1 base_x <<= 1 return x ", "class Solution def countSegments(self, s): result = int(len(s) and s[-1] != ' ') for i in xrange(1, len(s)): if s[i] == ' ' and s[i-1] != ' ': result += 1 return result def countSegments2(self, s): return len([i for i in s.strip().split(' ') if i]) ", "class Solution def successfulPairs(self, spells, potions, success): def ceil_divide(a, b): return (a+(b-1))//b potions.sort() return [len(potions)-bisect.bisect_left(potions, ceil_divide(success, s)) for s in spells] ", "class Solution def recoverFromPreorder(self, S): i = 0 stack = [] while i < len(S): level = 0 while i < len(S) and S[i] == '-': level += 1 i += 1 while len(stack) > level: stack.pop() val = [] while i < len(S) and S[i] != '-': val.append(S[i]) i += 1 node = TreeNode(int(\"\".join(val))) if stack: if stack[-1].left is None: stack[-1].left = node else: stack[-1].right = node stack.append(node) return stack[0] ", "class Solution def recoverFromPreorder(self, S): def recoverFromPreorderHelper(S, level, i): j = i[0] while j < len(S) and S[j] == '-': j += 1 if level != j - i[0]: return None i[0] = j while j < len(S) and S[j] != '-': j += 1 node = TreeNode(int(S[i[0]:j])) i[0] = j node.left = recoverFromPreorderHelper(S, level+1, i) node.right = recoverFromPreorderHelper(S, level+1, i) return node return recoverFromPreorderHelper(S, 0, [0]) ", "class Solution def minOperations(self, nums): result = prev = 0 for curr in nums: if prev < curr: prev = curr continue prev += 1 result += prev-curr return result ", "class Solution def maxLevelSum(self, root): def dfs(node, i, level_sums): if not node: return if i == len(level_sums): level_sums.append(0) level_sums[i] += node.val dfs(node.left, i+1, level_sums) dfs(node.right, i+1, level_sums) level_sums = [] dfs(root, 0, level_sums) return level_sums.index(max(level_sums))+1 ", "class Solution def maxLevelSum(self, root): result, level, max_total = 0, 1, float(\"-inf\") q = collections.deque([root]) while q: total = 0 for _ in xrange(len(q)): node = q.popleft() total += node.val if node.left: q.append(node.left) if node.right: q.append(node.right) if total > max_total: result, max_total = level, total level += 1 return result ", "class Solution def removeInterval(self, intervals, toBeRemoved): A, B = toBeRemoved return [[x, y] for a, b in intervals for x, y in ((a, min(A, b)), (max(a, B), b)) if x < y] ", "class Solution def findErrorNums(self, nums): x_xor_y = 0 for i in xrange(len(nums)): x_xor_y ^= nums[i] ^ (i+1) bit = x_xor_y & ~(x_xor_y-1) result = [0] * 2 for i, num in enumerate(nums): result[bool(num & bit)] ^= num result[bool((i+1) & bit)] ^= i+1 if result[0] not in nums: result[0], result[1] = result[1], result[0] return result ", "class Solution def findErrorNums(self, nums): result = [0] * 2 for i in nums: if nums[abs(i)-1] < 0: result[0] = abs(i) else: nums[abs(i)-1] *= -1 for i in xrange(len(nums)): if nums[i] > 0: result[1] = i+1 else: nums[i] *= -1 return result ", "class Solution def findErrorNums(self, nums): N = len(nums) x_minus_y = sum(nums) - N*(N+1)//2 x_plus_y = (sum(x*x for x in nums) - N*(N+1)*(2*N+1)/6) // x_minus_y return (x_plus_y+x_minus_y) // 2, (x_plus_y-x_minus_y) // 2 ", "class Solution def distinctNames(self, ideas): lookup = [set() for _ in xrange(26)] for x in ideas: lookup[ord(x[0])-ord('a')].add(x[1:]) result = 0 for i in xrange(len(lookup)): for j in xrange(i+1, len(lookup)): common = len(lookup[i]&lookup[j]) result += (len(lookup[i])-common)*(len(lookup[j])-common) return result*2 ", "class Solution def minScore(self, grid): idxs = [(i, j) for i in xrange(len(grid)) for j in xrange(len(grid[0]))] idxs.sort(key=lambda x: grid[x[0]][x[1]]) row_max, col_max = [0]*len(grid), [0]*len(grid[0]) for i, j in idxs: grid[i][j] = row_max[i] = col_max[j] = max(row_max[i], col_max[j])+1 return grid ", "class Solution def getDescentPeriods(self, prices): result = l = 0 for i in xrange(len(prices)): l += 1 if i+1 == len(prices) or prices[i]-1 != prices[i+1]: result += l*(l+1)//2 l = 0 return result ", "class Solution def minimumCost(self, source, target, original, changed, cost): INF = float(\"inf\") def dijkstra(start): best = {start:0} min_heap = [(0, start)] while min_heap: curr, u = heapq.heappop(min_heap) if curr > best[u]: continue if u not in dist: continue for v, w in dist[u].iteritems(): if v in best and best[v] <= curr+w: continue best[v] = curr+w heapq.heappush(min_heap, (best[v], v)) return best memo = {} def memoization(u, v): if u not in memo: memo[u] = dijkstra(u) return memo[u][v] if v in memo[u] else INF dist = {} for i in xrange(len(original)): u, v = ord(original[i])-ord('a'), ord(changed[i])-ord('a') if u not in dist: dist[u] = {v:INF} if v not in dist[u]: dist[u][v] = INF dist[u][v] = min(dist[u][v], cost[i]) result = sum(memoization(ord(source[i])-ord('a'), ord(target[i])-ord('a')) for i in xrange(len(source))) return result if result != INF else -1 ", "class Solution def minimumCost(self, source, target, original, changed, cost): INF = float(\"inf\") def floydWarshall(dist): for k in xrange(len(dist)): for i in xrange(len(dist)): if dist[i][k] == INF: continue for j in xrange(len(dist[i])): if dist[k][j] == INF: continue dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) dist = [[0 if u == v else INF for v in xrange(26)] for u in xrange(26)] for i in xrange(len(original)): u, v = ord(original[i])-ord('a'), ord(changed[i])-ord('a') dist[u][v] = min(dist[u][v], cost[i]) floydWarshall(dist) result = sum(dist[ord(source[i])-ord('a')][ord(target[i])-ord('a')] for i in xrange(len(source))) return result if result != INF else -1 ", "class Solution def balancedString(self, s): count = collections.Counter(s) result = len(s) left = 0 for right in xrange(len(s)): count[s[right]] -= 1 while left < len(s) and all(v <= len(s)//4 for v in count.itervalues()): result = min(result, right-left+1) count[s[left]] += 1 left += 1 return result ", "class Solution def findMaximumNumber(self, k, x): def floor_log2(x): return x.bit_length()-1 def binary_search_right(left, right, check): while left <= right: mid = left+(right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right def count(l): return (prefix_cnt<<(x*l))+lookup[l] result = prefix_cnt = 0 lookup = [0] i = 0 while (lookup[-1]<<x)+(1<<(i+x-1)) <= k: lookup.append((lookup[-1]<<x)+(1<<(i+x-1))) i += x while k >= prefix_cnt: l = binary_search_right(1, len(lookup)-1, lambda l: count(l) <= k) cnt, i = count(l), x*l c = min(floor_log2(k//cnt) if cnt else float(\"inf\"), x-1) cnt <<= c i += c k -= cnt result += 1<<i prefix_cnt += int((i+1)%x == 0) return result-1 ", "class Solution def findMaximumNumber(self, k, x): def floor_log2(x): return x.bit_length()-1 result = prefix_cnt = 0 while k >= prefix_cnt: cnt, i = prefix_cnt, 0 while (cnt<<x)+(1<<(i+x-1)) <= k: cnt = (cnt<<x)+(1<<(i+x-1)) i += x c = min(floor_log2(k//cnt) if cnt else float(\"inf\"), x-1) cnt <<= c i += c k -= cnt result += 1<<i prefix_cnt += int((i+1)%x == 0) return result-1 ", "class Solution def findMaximumNumber(self, k, x): def floor_log2(x): return x.bit_length()-1 result = prefix_cnt = 0 while k >= prefix_cnt: cnt, i = prefix_cnt, 0 while (cnt<<1)+(1<<i if (i+1)%x == 0 else 0) <= k: cnt = (cnt<<1)+(1<<i if (i+1)%x == 0 else 0) i += 1 k -= cnt result += 1<<i prefix_cnt += int((i+1)%x == 0) return result-1 ", "class Solution def findMaximumNumber(self, k, x): def binary_search_right(left, right, check): while left <= right: mid = left+(right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right def count(v): cnt = i = 0 while 1<<(i+x-1) <= v: q, r = divmod(v+1, 1<<((i+x-1)+1)) cnt += q*1*(1<<(i+x-1))+max(r-1*(1<<(i+x-1)), 0) i += x return cnt return binary_search_right(1, max(k<<2, 1<<x), lambda v: count(v) <= k) ", "class Solution def countDigitOne(self, n): DIGIT = 1 is_zero = int(DIGIT == 0) result = is_zero base = 1 while n >= base: result += (n//(10*base)-is_zero)*base + min(base, max(n%(10*base) - DIGIT*base + 1, 0)) base *= 10 return result ", "class Solution def secondHighest(self, s): first = second = -1 for c in s: if not c.isdigit(): continue d = int(c) if d > first: first, second = d, first elif first > d > second: second = d return second ", "class Solution def minimumDeletions(self, word, k): def counting_sort(arr, key=lambda x:x, reverse=False): count = [0]*(max(arr, key=key)+1) for x in arr: count[key(x)] += 1 for i in xrange(1, len(count)): count[i] += count[i-1] result = [0]*len(arr) if not reverse: for x in reversed(arr): count[key(x)] -= 1 result[count[key(x)]] = x else: for x in arr: count[key(x)] -= 1 result[count[key(x)]] = x result.reverse() return result cnt = [0]*26 for x in word: cnt[ord(x)-ord('a')] += 1 arr = counting_sort([x for x in cnt if x]) result = float(\"inf\") right = prefix = 0 suffix = len(word) prev = -1 for left in xrange(len(arr)): if left+1 < len(arr) and arr[left+1] == arr[left]: continue while right < len(arr) and arr[right] <= arr[left]+k: suffix -= arr[right] right += 1 result = min(result, prefix+(suffix-(arr[left]+k)*(len(arr)-right))) prefix += arr[left]*(left-prev) prev = left return result ", "class Solution def minimumDeletions(self, word, k): cnt = [0]*26 for x in word: cnt[ord(x)-ord('a')] += 1 arr = sorted(x for x in cnt if x) result = float(\"inf\") right = prefix = 0 suffix = len(word) prev = -1 for left in xrange(len(arr)): if left+1 < len(arr) and arr[left+1] == arr[left]: continue while right < len(arr) and arr[right] <= arr[left]+k: suffix -= arr[right] right += 1 result = min(result, prefix+(suffix-(arr[left]+k)*(len(arr)-right))) prefix += arr[left]*(left-prev) prev = left return result ", "class Solution def minimumDeletions(self, word, k): cnt = [0]*26 for x in word: cnt[ord(x)-ord('a')] += 1 return min(sum(y if y < x else max(y-(x+k), 0) for y in cnt if y) for x in cnt if x) ", "class Solution def removeDuplicates(self, s, k): stk = [['^', 0]] for c in s: if stk[-1][0] == c: stk[-1][1] += 1 if stk[-1][1] == k: stk.pop() else: stk.append([c, 1]) return \"\".join(c*k for c, k in stk) ", "class Solution def waysToPartition(self, nums, k): total = sum(nums) right = collections.Counter() prefix = 0 for i in xrange(len(nums)-1): prefix += nums[i] right[prefix-(total-prefix)] += 1 result = right[0] left = collections.Counter() prefix = 0 for x in nums: result = max(result, left[k-x]+right[-(k-x)]) prefix += x left[prefix-(total-prefix)] += 1 right[prefix-(total-prefix)] -= 1 return result ", "class Solution def moveZeroes(self, nums): pos = 0 for i in xrange(len(nums)): if nums[i]: nums[i], nums[pos] = nums[pos], nums[i] pos += 1 def moveZeroes2(self, nums): nums.sort(cmp=lambda a, b: 0 if b else -1) ", "class Solution def moveZeroes(self, nums): pos = 0 for i in xrange(len(nums)): if nums[i]: nums[pos] = nums[i] pos += 1 for i in xrange(pos, len(nums)): nums[i] = 0 ", "class Solution def rotateString(self, A, B): def check(index): return all(A[(i+index) % len(A)] == c for i, c in enumerate(B)) if len(A) != len(B): return False M, p = 10**9+7, 113 p_inv = pow(p, M-2, M) b_hash, power = 0, 1 for c in B: b_hash += power * ord(c) b_hash %= M power = (power*p) % M a_hash, power = 0, 1 for i in xrange(len(B)): a_hash += power * ord(A[i%len(A)]) a_hash %= M power = (power*p) % M if a_hash == b_hash and check(0): return True power = (power*p_inv) % M for i in xrange(len(B), 2*len(A)): a_hash = (a_hash-ord(A[(i-len(B))%len(A)])) * p_inv a_hash += power * ord(A[i%len(A)]) a_hash %= M if a_hash == b_hash and check(i-len(B)+1): return True return False ", "class Solution def rotateString(self, A, B): def strStr(haystack, needle): def KMP(text, pattern): prefix = getPrefix(pattern) j = -1 for i in xrange(len(text)): while j > -1 and pattern[j + 1] != text[i]: j = prefix[j] if pattern[j + 1] == text[i]: j += 1 if j == len(pattern) - 1: return i - j return -1 def getPrefix(pattern): prefix = [-1] * len(pattern) j = -1 for i in xrange(1, len(pattern)): while j > -1 and pattern[j + 1] != pattern[i]: j = prefix[j] if pattern[j + 1] == pattern[i]: j += 1 prefix[i] = j return prefix if not needle: return 0 return KMP(haystack, needle) if len(A) != len(B): return False return strStr(A*2, B) != -1 ", "class Solution def rotateString(self, A, B): return len(A) == len(B) and B in A*2 ", "class Solution def maxProduct(self, words): def counting_sort(words): k = 1000 buckets = [[] for _ in xrange(k)] for word in words: buckets[len(word)].append(word) res = [] for i in reversed(xrange(k)): if buckets[i]: res += buckets[i] return res words = counting_sort(words) bits = [0] * len(words) for i, word in enumerate(words): for c in word: bits[i] |= (1 << (ord(c) - ord('a'))) max_product = 0 for i in xrange(len(words) - 1): if len(words[i]) ** 2 <= max_product: break for j in xrange(i + 1, len(words)): if len(words[i]) * len(words[j]) <= max_product: break if not (bits[i] & bits[j]): max_product = len(words[i]) * len(words[j]) return max_product ", "class Solution def maxProduct(self, words): words.sort(key=lambda x: len(x), reverse=True) bits = [0] * len(words) for i, word in enumerate(words): for c in word: bits[i] |= (1 << (ord(c) - ord('a'))) max_product = 0 for i in xrange(len(words) - 1): if len(words[i]) ** 2 <= max_product: break for j in xrange(i + 1, len(words)): if len(words[i]) * len(words[j]) <= max_product: break if not (bits[i] & bits[j]): max_product = len(words[i]) * len(words[j]) return max_product ", "class Solution def minInteger(self, num, k): lookup = collections.defaultdict(list) bit = BIT(len(num)+1) for i in reversed(xrange(len(num))): bit.add(i+1, 1) lookup[int(num[i])].append(i+1) result = [] for _ in xrange(len(num)): for d in xrange(10): if lookup[d] and bit.sum(lookup[d][-1]-1) <= k: k -= bit.sum(lookup[d][-1]-1) bit.add(lookup[d].pop(), -1) result.append(d) break return \"\".join(map(str, result)) ", "class Solution def reformatDate(self, date): lookup = {\"Jan\":1, \"Feb\":2, \"Mar\":3, \"Apr\":4, \"May\":5, \"Jun\":6, \"Jul\":7, \"Aug\":8, \"Sep\":9, \"Oct\":10, \"Nov\":11, \"Dec\":12} return \"{:04d}-{:02d}-{:02d}\".format(int(date[-4:]), lookup[date[-8:-5]], int(date[:date.index(' ')-2])) ", "class Solution def evaluate(self, expression): def getval(lookup, x): return lookup.get(x, x) def evaluate(tokens, lookup): if tokens[0] in ('add', 'mult'): a, b = map(int, map(lambda x: getval(lookup, x), tokens[1:])) return str(a+b if tokens[0] == 'add' else a*b) for i in xrange(1, len(tokens)-1, 2): if tokens[i+1]: lookup[tokens[i]] = getval(lookup, tokens[i+1]) return getval(lookup, tokens[-1]) tokens, lookup, stk = [''], {}, [] for c in expression: if c == '(': if tokens[0] == 'let': evaluate(tokens, lookup) stk.append((tokens, dict(lookup))) tokens = [''] elif c == ' ': tokens.append('') elif c == ')': val = evaluate(tokens, lookup) tokens, lookup = stk.pop() tokens[-1] += val else: tokens[-1] += c return int(tokens[0]) ", "class Solution def minimumArrayLength(self, nums): mn = min(nums) return (nums.count(mn)+1)//2 if all(x%mn == 0 for x in nums) else 1 ", "class Solution def maxBuilding(self, n, restrictions): restrictions.extend([[1, 0], [n, n-1]]) restrictions.sort() for i in reversed(xrange(len(restrictions)-1)): restrictions[i][1] = min(restrictions[i][1], restrictions[i+1][1]+(restrictions[i+1][0]-restrictions[i][0])) result = 0 for i in xrange(1, len(restrictions)): restrictions[i][1] = min(restrictions[i][1], restrictions[i-1][1]+(restrictions[i][0]-restrictions[i-1][0])) left, h1 = restrictions[i-1] right, h2 = restrictions[i] result = max(result, max(h1, h2)+((right-left)-abs(h1-h2))//2) return result ", "class Solution def houseOfCards(self, n): dp = [0]*(n+1) dp[0] = 1 for t in xrange(1, (n+1)//3+1): for i in reversed(xrange(3*t-1, n+1)): dp[i] += dp[i-(3*t-1)] return dp[n] class Solution_TLE(object): def houseOfCards(self, n): dp = [[0]*(n+1) for _ in xrange((n+1)//3+1)] dp[0][0] = 1 for t in xrange(1, (n+1)//3+1): for i in xrange(3*t-1, n+1): dp[t][i] = sum(dp[j][i-(3*t-1)] for j in xrange(t)) return sum(dp[t][n] for t in xrange((n+1)//3+1)) ", "class Solution def __init__(self, nums): self.__nums = nums def pick(self, target): reservoir = -1 n = 0 for i in xrange(len(self.__nums)): if self.__nums[i] != target: continue reservoir = i if randint(1, n+1) == 1 else reservoir n += 1 return reservoir ", "class Solution def canBeTypedWords(self, text, brokenLetters): lookup = set(brokenLetters) result, broken = 0, False for c in text: if c == ' ': result += int(broken == False) broken = False elif c in lookup: broken = True return result + int(broken == False) ", "class Solution def minRemoveToMakeValid(self, s): result = list(s) count = 0 for i, v in enumerate(result): if v == '(': count += 1 elif v == ')': if count: count -= 1 else: result[i] = \"\" if count: for i in reversed(xrange(len(result))): if result[i] == '(': result[i] = \"\" count -= 1 if not count: break return \"\".join(result) ", "class Solution def earliestAcq(self, logs, N): logs.sort() union_find = UnionFind(N) for t, a, b in logs: union_find.union_set(a, b) if union_find.count == 1: return t return -1 ", "class Solution def minimizeResult(self, expression): def stoi(s, i, j): result = 0 for k in xrange(i, j): result = result*10+(ord(s[k])-ord('0')) return result best = None min_val = float(\"inf\") pos = expression.index('+') left, right = stoi(expression, 0, pos), stoi(expression, pos+1, len(expression)) base1, base2_init = 10**pos, 10**(len(expression)-(pos+1)-1) for i in xrange(pos): base2 = base2_init for j in xrange(pos+1, len(expression)): a, b = divmod(left, base1) c, d = divmod(right, base2) val = max(a, 1)*(b+c)*max(d, 1) if val < min_val: min_val = val best = (i, j) base2 //= 10 base1 //= 10 return \"\".join(itertools.chain((expression[i] for i in xrange(best[0])), '(', (expression[i] for i in xrange(best[0], best[1]+1)), ')', (expression[i] for i in xrange(best[1]+1, len(expression))))) ", "class Solution def minimizeResult(self, expression): best = None min_val = float(\"inf\") pos = expression.index('+') left, right = int(expression[0:pos]), int(expression[pos+1:]) base1, base2_init = 10**pos, 10**(len(expression)-(pos+1)-1) for i in xrange(pos): base2 = base2_init for j in xrange(pos+1, len(expression)): a, b = divmod(left, base1) c, d = divmod(right, base2) val = max(a, 1)*(b+c)*max(d, 1) if val < min_val: min_val = val best = (i, j) base2 //= 10 base1 //= 10 return \"\".join([expression[:best[0]], '(', expression[best[0]:best[1]+1], ')', expression[best[1]+1:]]) ", "class Solution def minimizeResult(self, expression): best = None min_val = float(\"inf\") pos = expression.index('+') for i in xrange(pos): for j in xrange(pos+1, len(expression)): val = (int(expression[:i] or \"1\")* (int(expression[i:pos])+int(expression[pos+1:j+1]))* int(expression[j+1:] or \"1\")) if val < min_val: min_val = val best = (i, j) return \"\".join([expression[:best[0]], '(', expression[best[0]:best[1]+1], ')', expression[best[1]+1:]]) ", "class Solution def miceAndCheese(self, reward1, reward2, k): def nth_element(nums, n, left=0, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right right = len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 for i in xrange(len(reward1)): reward1[i] -= reward2[i] nth_element(reward1, k-1, compare=lambda a, b: a > b) return sum(reward2)+sum(reward1[i] for i in xrange(k)) ", "class Solution def compress(self, chars): anchor, write = 0, 0 for read, c in enumerate(chars): if read+1 == len(chars) or chars[read+1] != c: chars[write] = chars[anchor] write += 1 if read > anchor: n, left = read-anchor+1, write while n > 0: chars[write] = chr(n%10+ord('0')) write += 1 n /= 10 right = write-1 while left < right: chars[left], chars[right] = chars[right], chars[left] left += 1 right -= 1 anchor = read+1 return write ", "class Solution def minBitFlips(self, start, goal): return bin(start^goal).count('1') ", "class Solution lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'} def isStrobogrammatic(self, num): n = len(num) for i in xrange((n+1) / 2): if num[n-1-i] not in self.lookup or num[i] != self.lookup[num[n-1-i]]: return False return True ", "class Solution def findWords(self, board, words): visited = [[False for j in xrange(len(board[0]))] for i in xrange(len(board))] result = {} trie = TrieNode() for word in words: trie.insert(word) for i in xrange(len(board)): for j in xrange(len(board[0])): self.findWordsRecu(board, trie, 0, i, j, visited, [], result) return result.keys() def findWordsRecu(self, board, trie, cur, i, j, visited, cur_word, result): if not trie or i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]: return if board[i][j] not in trie.leaves: return cur_word.append(board[i][j]) next_node = trie.leaves[board[i][j]] if next_node.is_string: result[\"\".join(cur_word)] = True visited[i][j] = True self.findWordsRecu(board, next_node, cur + 1, i + 1, j, visited, cur_word, result) self.findWordsRecu(board, next_node, cur + 1, i - 1, j, visited, cur_word, result) self.findWordsRecu(board, next_node, cur + 1, i, j + 1, visited, cur_word, result) self.findWordsRecu(board, next_node, cur + 1, i, j - 1, visited, cur_word, result) visited[i][j] = False cur_word.pop() ", "class Solution def maximumMinimumPath(self, A): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def check(A, val, r, c, lookup): if r == len(A)-1 and c == len(A[0])-1: return True lookup.add((r, c)) for d in directions: nr, nc = r + d[0], c + d[1] if 0 <= nr < len(A) and 0 <= nc < len(A[0]) and (nr, nc) not in lookup and A[nr][nc] >= val and check(A, val, nr, nc, lookup): return True return False vals, ceil = [], min(A[0][0], A[-1][-1]) for i in xrange(len(A)): for j in xrange(len(A[0])): if A[i][j] <= ceil: vals.append(A[i][j]) vals = list(set(vals)) vals.sort() left, right = 0, len(vals)-1 while left <= right: mid = left + (right-left)//2 if not check(A, vals[mid], 0, 0, set()): right = mid-1 else: left = mid+1 return vals[right] import heapq ", "class Solution def maximumMinimumPath(self, A): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] max_heap = [(-A[0][0], 0, 0)] lookup = set([(0, 0)]) while max_heap: i, r, c = heapq.heappop(max_heap) if r == len(A)-1 and c == len(A[0])-1: return -i for d in directions: nr, nc = r+d[0], c+d[1] if 0 <= nr < len(A) and 0 <= nc < len(A[0]) and (nr, nc) not in lookup: heapq.heappush(max_heap, (-min(-i, A[nr][nc]), nr, nc)) lookup.add((nr, nc)) return -1 ", "class Solution def numberOfCuts(self, n): return 0 if n == 1 else n if n%2 else n//2 ", "class Solution def maximumScoreAfterOperations(self, edges, values): def iter_dfs(): dp = [0]*len(values) stk = [(1, 0, -1)] while stk: step, u, p = stk.pop() if step == 1: if len(adj[u]) == (1 if u else 0): dp[u] = values[u] continue stk.append((2, u, p)) for v in reversed(adj[u]): if v != p: stk.append((1, v, u)) elif step == 2: dp[u] = min(sum(dp[v] for v in adj[u] if v != p), values[u]) return dp[0] adj = [[] for _ in xrange(len(values))] for u, v in edges: adj[u].append(v) adj[v].append(u) return sum(values)-iter_dfs() ", "class Solution def maximumScoreAfterOperations(self, edges, values): def dfs(u, p): if len(adj[u]) == (1 if u else 0): return values[u] return min(sum(dfs(v, u) for v in adj[u] if v != p), values[u]) adj = [[] for _ in xrange(len(values))] for u, v in edges: adj[u].append(v) adj[v].append(u) return sum(values)-dfs(0, -1) ", "class Solution def parseTernary(self, expression): if not expression: return \"\" stack = [] for c in expression[::-1]: if stack and stack[-1] == '?': stack.pop() first = stack.pop() stack.pop() second = stack.pop() if c == 'T': stack.append(first) else: stack.append(second) else: stack.append(c) return str(stack[-1]) ", "class Solution def minCost(self, nums, cost): def f(x): return sum(abs(y-x)*c for y, c in itertools.izip(nums, cost)) def check(x, t): return sum(c for y, c in itertools.izip(nums, cost) if y <= x) >= t idxs = range(len(nums)) idxs.sort(key=lambda x: nums[x]) left, right = 0, len(idxs)-1 total = sum(cost) median = (total+1)//2 while left <= right: mid = left+(right-left)//2 if check(nums[idxs[mid]], median): right = mid-1 else: left = mid+1 return f(nums[idxs[left]]) import itertools ", "class Solution def minCost(self, nums, cost): def f(x): return sum(abs(y-x)*c for y, c in itertools.izip(nums, cost)) def check(x): return x+1 == len(idxs) or f(nums[idxs[x]]) < f(nums[idxs[x+1]]) idxs = range(len(nums)) idxs.sort(key=lambda x: nums[x]) left, right = 0, len(idxs)-1 while left <= right: mid = left+(right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return f(nums[idxs[left]]) ", "class Solution def minCost(self, nums, cost): idxs = range(len(nums)) idxs.sort(key=lambda x: nums[x]) prefix = [0]*(len(cost)+1) left = 0 for i in xrange(len(cost)): if i-1 >= 0: left += prefix[i]*(nums[idxs[i]]-nums[idxs[i-1]]) prefix[i+1] = prefix[i]+cost[idxs[i]] result = float(\"inf\") suffix = right = 0 for i in reversed(xrange(len(cost))): if i+1 < len(idxs): right += suffix*(nums[idxs[i+1]]-nums[idxs[i]]) result = min(result, left+right) if i-1 >= 0: left -= prefix[i]*(nums[idxs[i]]-nums[idxs[i-1]]) suffix += cost[idxs[i]] return result ", "class Solution def splitString(self, s): def backtracking(s, i, num, cnt): if i == len(s): return cnt >= 2 new_num = 0 for j in xrange(i, len(s)): new_num = new_num*10 + int(s[j]) if new_num >= num >= 0: break if (num == -1 or num-1 == new_num) and backtracking(s, j+1, new_num, cnt+1): return True return False return backtracking(s, 0, -1, 0) ", "class Solution def minimumPushes(self, word): return sum(x*(i//(9-2+1)+1) for i, x in enumerate(sorted(collections.Counter(word).itervalues(), reverse=True))) ", "class Solution def numWays(self, steps, arrLen): MOD = int(1e9+7) l = min(1+steps//2, arrLen) dp = [0]*(l+2) dp[1] = 1 while steps > 0: steps -= 1 new_dp = [0]*(l+2) for i in xrange(1, l+1): new_dp[i] = (dp[i] + dp[i-1] + dp[i+1]) % MOD dp = new_dp return dp[1] ", "class Solution def mostProfitablePath(self, edges, bob, amount): def iter_dfs(): lookup = [[float(\"-inf\"), float(\"inf\")] for _ in xrange(len(adj))] stk = [(1, (0, -1, 0))] while stk: step, (u, p, ah) = stk.pop() if step == 1: stk.append((2, (u, p, ah))) for v in adj[u]: if v == p: continue stk.append((1, (v, u, ah+1))) elif step == 2: if len(adj[u])+(u == 0) == 1: lookup[u][0] = 0 if u == bob: lookup[u][1] = 0 for v in adj[u]: if v == p: continue lookup[u][0] = max(lookup[u][0], lookup[v][0]) lookup[u][1] = min(lookup[u][1], lookup[v][1]) if ah == lookup[u][1]: lookup[u][0] += amount[u]//2 elif ah < lookup[u][1]: lookup[u][0] += amount[u] lookup[u][1] += 1 return lookup[0][0] adj = [[] for _ in xrange(len(edges)+1)] lookup = [False]*len(adj) for u, v in edges: adj[u].append(v) adj[v].append(u) return iter_dfs() ", "class Solution def mostProfitablePath(self, edges, bob, amount): def dfs(u, ah): lookup[u] = True result = 0 if len(adj[u])+(u == 0) == 1 else float(\"-inf\") bh = 0 if u == bob else float(\"inf\") for v in adj[u]: if lookup[v]: continue r, h = dfs(v, ah+1) result = max(result, r) bh = min(bh, h) if ah == bh: result += amount[u]//2 elif ah < bh: result += amount[u] return result, bh+1 adj = [[] for _ in xrange(len(edges)+1)] lookup = [False]*len(adj) for u, v in edges: adj[u].append(v) adj[v].append(u) return dfs(0, 0)[0] ", "class Solution def shortestDistance(self, words, word1, word2): dist = float(\"inf\") i, index1, index2 = 0, None, None while i < len(words): if words[i] == word1: index1 = i elif words[i] == word2: index2 = i if index1 is not None and index2 is not None: dist = min(dist, abs(index1 - index2)) i += 1 return dist ", "class Solution def minimizeTheDifference(self, mat, target): chosen_min = sum(min(row) for row in mat) if chosen_min >= target: return chosen_min-target dp = {0} for row in mat: dp = {total+x for total in dp for x in row if (total+x)-target < target-chosen_min} return min(abs(target-total) for total in dp) ", "class Solution def maximumXOR(self, nums): return reduce(lambda x, y: x|y, nums) ", "class Solution def isValidSudoku(self, board): for i in xrange(9): if not self.isValidList([board[i][j] for j in xrange(9)]) or not self.isValidList([board[j][i] for j in xrange(9)]): return False for i in xrange(3): for j in xrange(3): if not self.isValidList([board[m][n] for n in xrange(3 * j, 3 * j + 3) for m in xrange(3 * i, 3 * i + 3)]): return False return True def isValidList(self, xs): xs = filter(lambda x: x != '.', xs) return len(set(xs)) == len(xs) ", "class Solution def countDistinct(self, s): count = 0 trie = {} for i in xrange(len(s)): curr = trie for j in xrange(i, len(s)): if s[j] not in curr: count += 1 curr[s[j]] = {} curr = curr[s[j]] return count ", "class Solution def reverseParentheses(self, s): stk, lookup = [], {} for i, c in enumerate(s): if c == '(': stk.append(i) elif c == ')': j = stk.pop() lookup[i], lookup[j] = j, i result = [] i, d = 0, 1 while i < len(s): if i in lookup: i = lookup[i] d *= -1 else: result.append(s[i]) i += d return \"\".join(result) ", "class Solution def reverseParentheses(self, s): stk = [[]] for c in s: if c == '(': stk.append([]) elif c == ')': end = stk.pop() end.reverse() stk[-1].extend(end) else: stk[-1].append(c) return \"\".join(stk.pop()) ", "class Solution def minOperations(self, nums, k): return sum(x < k for x in nums) ", "class Solution def connectTwoGroups(self, cost): total = 2**len(cost[0]) dp = [[float(\"inf\")]*total for _ in xrange(2)] dp[0][0] = 0 for i in xrange(len(cost)): dp[(i+1)%2] = [float(\"inf\")]*total for mask in xrange(total): base = 1 for j in xrange(len(cost[0])): dp[i%2][mask|base] = min(dp[i%2][mask|base], cost[i][j]+dp[i%2][mask]) dp[(i+1)%2][mask|base] = min(dp[(i+1)%2][mask|base], cost[i][j]+dp[i%2][mask]) base <<= 1 return dp[len(cost)%2][-1] ", "class Solution def countPrimeSetBits(self, L, R): def bitCount(n): result = 0 while n: n &= n-1 result += 1 return result primes = {2, 3, 5, 7, 11, 13, 17, 19} return sum(bitCount(i) in primes for i in xrange(L, R+1)) ", "class Solution def minSwap(self, A, B): dp_no_swap, dp_swap = [0]*2, [1]*2 for i in xrange(1, len(A)): dp_no_swap[i%2], dp_swap[i%2] = float(\"inf\"), float(\"inf\") if A[i-1] < A[i] and B[i-1] < B[i]: dp_no_swap[i%2] = min(dp_no_swap[i%2], dp_no_swap[(i-1)%2]) dp_swap[i%2] = min(dp_swap[i%2], dp_swap[(i-1)%2]+1) if A[i-1] < B[i] and B[i-1] < A[i]: dp_no_swap[i%2] = min(dp_no_swap[i%2], dp_swap[(i-1)%2]) dp_swap[i%2] = min(dp_swap[i%2], dp_no_swap[(i-1)%2]+1) return min(dp_no_swap[(len(A)-1)%2], dp_swap[(len(A)-1)%2]) ", "class Solution def reconstructMatrix(self, upper, lower, colsum): upper_matrix, lower_matrix = [0]*len(colsum), [0]*len(colsum) for i in xrange(len(colsum)): upper_matrix[i] = int(upper > 0 and colsum[i] != 0) lower_matrix[i] = colsum[i]-upper_matrix[i] upper -= upper_matrix[i] lower -= lower_matrix[i] return [upper_matrix, lower_matrix] if upper == lower == 0 else [] ", "class Solution def findShortestWay(self, maze, ball, hole): ball, hole = tuple(ball), tuple(hole) dirs = {'u' : (-1, 0), 'r' : (0, 1), 'l' : (0, -1), 'd': (1, 0)} def neighbors(maze, node): for dir, vec in dirs.iteritems(): cur_node, dist = list(node), 0 while 0 <= cur_node[0]+vec[0] < len(maze) and 0 <= cur_node[1]+vec[1] < len(maze[0]) and not maze[cur_node[0]+vec[0]][cur_node[1]+vec[1]]: cur_node[0] += vec[0] cur_node[1] += vec[1] dist += 1 if tuple(cur_node) == hole: break yield tuple(cur_node), dir, dist heap = [(0, '', ball)] visited = set() while heap: dist, path, node = heapq.heappop(heap) if node in visited: continue if node == hole: return path visited.add(node) for neighbor, dir, neighbor_dist in neighbors(maze, node): heapq.heappush(heap, (dist+neighbor_dist, path+dir, neighbor)) return \"impossible\" ", "class Solution def distance(self, nums): result = [0]*len(nums) cnt1, left = collections.Counter(), collections.Counter() for i in xrange(len(nums)): result[i] += cnt1[nums[i]]*i-left[nums[i]] cnt1[nums[i]] += 1 left[nums[i]] += i cnt2, right = collections.Counter(), collections.Counter() for i in reversed(xrange(len(nums))): result[i] += right[nums[i]]-cnt2[nums[i]]*i cnt2[nums[i]] += 1 right[nums[i]] += i return result ", "class Solution def checkPalindromeFormation(self, a, b): def is_palindrome(s, i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True def check(a, b): i, j = 0, len(b)-1 while i < j: if a[i] != b[j]: return is_palindrome(a, i, j) or is_palindrome(b, i, j) i += 1 j -= 1 return True return check(a, b) or check(b, a) ", "class Solution def maxNiceDivisors(self, primeFactors): MOD = 10**9 + 7 if primeFactors <= 3: return primeFactors if primeFactors % 3 == 0: return pow(3, primeFactors//3, MOD) if primeFactors % 3 == 1: return (2*2*pow(3, (primeFactors-4)//3, MOD)) % MOD return (2*pow(3, (primeFactors-2)//3, MOD)) % MOD ", "class Solution def minReverseOperations(self, n, p, banned, k): lookup = [False]*n for i in banned: lookup[i] = True d = 0 result = [-1]*n result[p] = d uf = UnionFind(n+2) uf.union_set(p, p+2) q = [p] d += 1 while q: new_q = [] for p in q: left, right = 2*max(p-(k-1), 0)+(k-1)-p, 2*min(p+(k-1), n-1)-(k-1)-p p = uf.right_set(left) while p <= right: if not lookup[p]: result[p] = d new_q.append(p) uf.union_set(p, p+2) p = uf.right_set(p) q = new_q d += 1 return result from sortedcontainers import SortedList ", "class Solution def minReverseOperations(self, n, p, banned, k): lookup = [False]*n for i in banned: lookup[i] = True d = 0 result = [-1]*n result[p] = d sl = [SortedList(i for i in xrange(0, n, 2)), SortedList(i for i in xrange(1, n, 2))] sl[p%2].remove(p) q = [p] d += 1 while q: new_q = [] for p in q: left, right = 2*max(p-(k-1), 0)+(k-1)-p, 2*min(p+(k-1), n-1)-(k-1)-p for p in list(sl[left%2].irange(left, right)): if not lookup[p]: result[p] = d new_q.append(p) sl[left%2].remove(p) q = new_q d += 1 return result ", "class Solution def maxIceCream(self, costs, coins): costs.sort() for i, c in enumerate(costs): coins -= c if coins < 0: return i return len(costs) ", "class Solution def mostCommonWord(self, paragraph, banned): lookup = set(banned) counts = collections.Counter(word.strip(\"!?',.\") for word in paragraph.lower().split()) result = '' for word in counts: if (not result or counts[word] > counts[result]) and word not in lookup: result = word return result ", "class Solution def minimumTime(self, n, relations, time): adj = [[] for _ in xrange(n)] in_degree = [0]*n for prev, nxt in relations: adj[prev-1].append(nxt-1) in_degree[nxt-1] += 1 q = [u for u in xrange(n) if not in_degree[u]] dist = [time[u] if not in_degree[u] else 0 for u in xrange(n)] while q: new_q = [] for u in q: for v in adj[u]: dist[v] = max(dist[v], dist[u]+time[v]) in_degree[v] -= 1 if not in_degree[v]: new_q.append(v) q = new_q return max(dist) ", "class Solution def __init__(self, n_rows, n_cols): self.__n_rows = n_rows self.__n_cols = n_cols self.__n = n_rows*n_cols self.__lookup = {} def flip(self): self.__n -= 1 target = random.randint(0, self.__n) x = self.__lookup.get(target, target) self.__lookup[target] = self.__lookup.get(self.__n, self.__n) return divmod(x, self.__n_cols) def reset(self): self.__n = self.__n_rows*self.__n_cols self.__lookup = {} ", "class Solution def repairCars(self, ranks, cars): def check(x): return sum(int((x//k)**0.5)*v for k, v in cnt.iteritems()) >= cars cnt = collections.Counter(ranks) left, right = 1, min(cnt.iterkeys())*cars**2 while left <= right: mid = left+(right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left import collections import heapq ", "class Solution def repairCars(self, ranks, cars): cnt = collections.Counter(ranks) min_heap = [(r*1**2, 1) for r in cnt.iterkeys()] heapq.heapify(min_heap) while cars > 0: t, k = heapq.heappop(min_heap) r = t//k**2 cars -= cnt[r] k += 1 heapq.heappush(min_heap, (r*k**2, k)) return t ", "class Solution def matrixReshape(self, nums, r, c): if not nums or r*c != len(nums) * len(nums[0]): return nums result = [[0 for _ in xrange(c)] for _ in xrange(r)] count = 0 for i in xrange(len(nums)): for j in xrange(len(nums[0])): result[count/c][count%c] = nums[i][j] count += 1 return result ", "class Solution def partition(self, head, x): dummySmaller, dummyGreater = ListNode(-1), ListNode(-1) smaller, greater = dummySmaller, dummyGreater while head: if head.val < x: smaller.next = head smaller = smaller.next else: greater.next = head greater = greater.next head = head.next smaller.next = dummyGreater.next greater.next = None return dummySmaller.next ", "class Solution def recoverArray(self, nums): def check(k, cnt, result): for x in nums: if cnt[x] == 0: continue if cnt[x+2*k] == 0: return False cnt[x] -= 1 cnt[x+2*k] -= 1 result.append(x+k) return True nums.sort() cnt = collections.Counter(nums) for i in xrange(1, len(nums)//2+1): k = nums[i]-nums[0] if k == 0 or k%2: continue k //= 2 result = [] if check(k, collections.Counter(cnt), result): return result return [] ", "class Solution def survivedRobotsHealths(self, positions, healths, directions): stk = [] for i in sorted(xrange(len(positions)), key=lambda x:positions[x]): if directions[i] == 'R': stk.append(i) continue while stk: if healths[stk[-1]] == healths[i]: healths[stk.pop()] = healths[i] = 0 break if healths[stk[-1]] > healths[i]: healths[i] = 0 healths[stk[-1]] -= 1 break healths[stk.pop()] = 0 healths[i] -= 1 return [x for x in healths if x] ", "class Solution def validateBinaryTreeNodes(self, n, leftChild, rightChild): roots = set(range(n)) - set(leftChild) - set(rightChild) if len(roots) != 1: return False root, = roots stk = [root] lookup = set([root]) while stk: node = stk.pop() for c in (leftChild[node], rightChild[node]): if c < 0: continue if c in lookup: return False lookup.add(c) stk.append(c) return len(lookup) == n ", "class Solution def maxHappyGroups(self, batchSize, groups): def memoization(batchSize, count, mask, remain, lookup): if lookup[mask] == 0: a_remain = 0 if remain in count: curr, basis = mask, 1 for i, c in count.iteritems(): if i == remain: break basis *= c+1 curr //= c+1 a_remain = curr%(count[remain]+1) result = 0 if a_remain: result = max(result, int(remain == 0) + memoization(batchSize, count, mask-basis, 0, lookup)) else: curr, basis = mask, 1 for i, c in count.iteritems(): if curr%(c+1): result = max(result, int(remain == 0) + memoization(batchSize, count, mask-basis, (remain-i)%batchSize, lookup)) basis *= c+1 curr //= c+1 lookup[mask] = result return lookup[mask] count = [0]*batchSize for i in groups: count[i%len(count)] += 1 result = count[0] count[0] = 0 for i in xrange(1, len(count)//2+1): pair_count = min(count[i], count[len(count)-i]) if 2*i != len(count) else count[i]//2 result += pair_count count[i] -= pair_count count[len(count)-i] -= pair_count new_count = {i:c for i, c in enumerate(count) if c} max_mask = reduce(lambda total, c: total*(c+1), new_count.itervalues(), 1) lookup = [0]*max_mask return result+memoization(batchSize, new_count, max_mask-1, 0, lookup) ", "class Solution def maxHappyGroups(self, batchSize, groups): count = [0]*batchSize for i in groups: count[i%len(count)] += 1 result = count[0] count[0] = 0 for i in xrange(1, len(count)//2+1): pair_count = min(count[i], count[len(count)-i]) if 2*i != len(count) else count[i]//2 result += pair_count count[i] -= pair_count count[len(count)-i] -= pair_count new_count = {i:c for i, c in enumerate(count) if c} max_mask = reduce(lambda total, c: total*(c+1), new_count.itervalues(), 1) dp = [0]*max_mask for mask in xrange(len(dp)): remain = 0 curr, basis = mask, 1 for i, c in new_count.iteritems(): ai = curr%(c+1) if ai: dp[mask] = max(dp[mask], dp[mask-basis]) remain = (remain+ai*i)%batchSize basis *= c+1 curr //= c+1 if mask != len(dp)-1 and remain == 0: dp[mask] += 1 return result+dp[-1] ", "class Solution def validIPAddress(self, IP): blocks = IP.split('.') if len(blocks) == 4: for i in xrange(len(blocks)): if not blocks[i].isdigit() or not 0 <= int(blocks[i]) < 256 or (blocks[i][0] == '0' and len(blocks[i]) > 1): return \"Neither\" return \"IPv4\" blocks = IP.split(':') if len(blocks) == 8: for i in xrange(len(blocks)): if not (1 <= len(blocks[i]) <= 4) or not all(c in string.hexdigits for c in blocks[i]): return \"Neither\" return \"IPv6\" return \"Neither\" ", "class Solution def specialArray(self, nums): MAX_NUM = 1000 count = [0]*(MAX_NUM+1) for num in nums: count[num] += 1 n = len(nums) for i in xrange(len(count)): if i == n: return i n -= count[i] return -1 ", "class Solution def specialArray(self, nums): MAX_NUM = 1000 def inplace_counting_sort(nums, reverse=False): count = [0]*(MAX_NUM+1) for num in nums: count[num] += 1 for i in xrange(1, len(count)): count[i] += count[i-1] for i in reversed(xrange(len(nums))): while nums[i] >= 0: count[nums[i]] -= 1 j = count[nums[i]] nums[i], nums[j] = nums[j], ~nums[i] for i in xrange(len(nums)): nums[i] = ~nums[i] if reverse: nums.reverse() inplace_counting_sort(nums, reverse=True) left, right = 0, len(nums)-1 while left <= right: mid = left + (right-left)//2 if nums[mid] <= mid: right = mid-1 else: left = mid+1 return -1 if left < len(nums) and nums[left] == left else left ", "class Solution def specialArray(self, nums): MAX_NUM = 1000 def counting_sort(nums, reverse=False): count = [0]*(MAX_NUM+1) for num in nums: count[num] += 1 for i in xrange(1, len(count)): count[i] += count[i-1] result = [0]*len(nums) if not reverse: for num in reversed(nums): count[num] -= 1 result[count[num]] = num else: for num in nums: count[num] -= 1 result[count[num]] = num result.reverse() return result nums = counting_sort(nums, reverse=True) left, right = 0, len(nums)-1 while left <= right: mid = left + (right-left)//2 if nums[mid] <= mid: right = mid-1 else: left = mid+1 return -1 if left < len(nums) and nums[left] == left else left ", "class Solution def specialArray(self, nums): nums.sort(reverse=True) for i in xrange(len(nums)): if nums[i] <= i: break else: i += 1 return -1 if i < len(nums) and nums[i] == i else i ", "class Solution def maximumUniqueSubarray(self, nums): lookup = {} prefix = [0]*(len(nums)+1) result, left = 0, 0 for right, num in enumerate(nums): prefix[right+1] = prefix[right]+num if num in lookup: left = max(left, lookup[num]+1) lookup[num] = right result = max(result, prefix[right+1]-prefix[left]) return result ", "class Solution def numberOfWeeks(self, milestones): total, max_num = sum(milestones), max(milestones) other_total = (total-max_num) return other_total+min(other_total+1, max_num) ", "class Solution def maximumSegmentSum(self, nums, removeQueries): result = [0]*len(removeQueries) lookup = [0]*len(nums) uf = UnionFind(nums) for i in reversed(xrange(1, len(removeQueries))): q = removeQueries[i] lookup[q] = 1 if q-1 >= 0 and lookup[q-1]: uf.union_set(q-1, q) if q+1 < len(nums) and lookup[q+1]: uf.union_set(q, q+1) result[i-1] = max(result[i], uf.total(q)) return result from sortedcontainers import SortedList ", "class Solution def maximumSegmentSum(self, nums, removeQueries): removed_idxs = SortedList([-1, len(nums)]) prefix = [0]*(len(nums)+1) for i in xrange(len(nums)): prefix[i+1] = prefix[i]+nums[i] segments = SortedList([prefix[-1]]) result = [] for q in removeQueries: removed_idxs.add(q) i = removed_idxs.bisect_left(q) left, right = removed_idxs[i-1], removed_idxs[i+1] segments.remove(prefix[right]-prefix[left+1]) segments.add(prefix[q]-prefix[left+1]) segments.add(prefix[right]-prefix[q+1]) result.append(segments[-1]) return result ", "class Solution def minPushBox(self, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dot(a, b): return a[0]*b[0]+a[1]*b[1] def can_reach(grid, b, p, t): closer, detour = [p], [] lookup = set([b]) while closer or detour: if not closer: closer, detour = detour, closer p = closer.pop() if p == t: return True if p in lookup: continue lookup.add(p) for dx, dy in directions: np = (p[0]+dx, p[1]+dy) if not (0 <= np[0] < len(grid) and 0 <= np[1] < len(grid[0]) and grid[np[0]][np[1]] != '#' and np not in lookup): continue (closer if dot((dx, dy), (t[0]-p[0], t[1]-p[1])) > 0 else detour).append(np) return False def g(a, b): return abs(a[0]-b[0])+abs(a[1]-b[1]) def a_star(grid, b, p, t): f, dh = g(b, t), 2 closer, detour = [(b, p)], [] lookup = set() while closer or detour: if not closer: f += dh closer, detour = detour, closer b, p = closer.pop() if b == t: return f if (b, p) in lookup: continue lookup.add((b, p)) for dx, dy in directions: nb, np = (b[0]+dx, b[1]+dy), (b[0]-dx, b[1]-dy) if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and 0 <= np[0] < len(grid) and 0 <= np[1] < len(grid[0]) and grid[nb[0]][nb[1]] != '#' and grid[np[0]][np[1]] != '#' and (nb, b) not in lookup and can_reach(grid, b, p, np)): continue (closer if dot((dx, dy), (t[0]-b[0], t[1]-b[1])) > 0 else detour).append((nb, b)) return -1 b, p, t = None, None, None for i in xrange(len(grid)): for j in xrange(len(grid[0])): if grid[i][j] == 'B': b = (i, j) elif grid[i][j] == 'S': p = (i, j) elif grid[i][j] == 'T': t = (i, j) return a_star(grid, b, p, t) ", "class Solution def maxSlidingWindow(self, nums, k): result, dq = [], deque() for i in xrange(len(nums)): if dq and i-dq[0] == k: dq.popleft() while dq and nums[dq[-1]] <= nums[i]: dq.pop() dq.append(i) if i >= k-1: result.append(nums[dq[0]]) return result ", "class Solution def numberOfPairs(self, nums1, nums2, diff): sl = SortedList() result = 0 for x, y in itertools.izip(nums1, nums2): result += sl.bisect_right((x-y)+diff) sl.add(x-y) return result import itertools import bisect class BIT(object): def __init__(self, n): self.__bit = [0]*(n+1) def add(self, i, val): i += 1 while i < len(self.__bit): self.__bit[i] += val i += (i & -i) def query(self, i): i += 1 ret = 0 while i > 0: ret += self.__bit[i] i -= (i & -i) return ret ", "class Solution def numberOfPairs(self, nums1, nums2, diff): sorted_nums = sorted(set(x-y for x, y in itertools.izip(nums1, nums2))) num_to_idx = {x:i for i, x in enumerate(sorted_nums)} result = 0 bit = BIT(len(num_to_idx)) for x, y in itertools.izip(nums1, nums2): result += bit.query(bisect.bisect_right(sorted_nums, (x-y)+diff)-1) bit.add(num_to_idx[x-y], 1) return result import itertools ", "class Solution def numberOfPairs(self, nums1, nums2, diff): def merge_sort(nums, left, right, result): if left == right: return mid = left+(right-left)//2 merge_sort(nums, left, mid, result) merge_sort(nums, mid+1, right, result) r = mid+1 for l in xrange(left, mid+1): while r < right+1 and nums[l]-nums[r] > diff: r += 1 result[0] += right-r+1 tmp = [] l, r = left, mid+1 while l < mid+1 or r < right+1: if r >= right+1 or (l < mid+1 and nums[l] <= nums[r]): tmp.append(nums[l]) l += 1 else: tmp.append(nums[r]) r += 1 nums[left:right+1] = tmp nums = [x-y for x, y in itertools.izip(nums1, nums2)] result = [0] merge_sort(nums, 0, len(nums)-1, result) return result[0] ", "class Solution def minOperations(self, boxes): result = [0]*len(boxes) for direction in (lambda x:x, reversed): cnt = accu = 0 for i in direction(xrange(len(boxes))): result[i] += accu if boxes[i] == '1': cnt += 1 accu += cnt return result ", "class Solution def findPoisonedDuration(self, timeSeries, duration): result = duration * len(timeSeries) for i in xrange(1, len(timeSeries)): result -= max(0, duration - (timeSeries[i] - timeSeries[i-1])) return result ", "class Solution def peopleIndexes(self, favoriteCompanies): lookup, comps = {}, [] for cs in favoriteCompanies: comps.append(set()) for c in cs: if c not in lookup: lookup[c] = len(lookup) comps[-1].add(lookup[c]) return [i for i, c1 in enumerate(comps) if not any(i != j and len(c1) < len(c2) and c1 < c2 for j, c2 in enumerate(comps))] class UnionFind(object): def __init__(self, data): self.data = [set(d) for d in data] self.set = range(len(data)) def find_set(self, x): if self.set[x] != x: self.set[x] = self.find_set(self.set[x]) return self.set[x] def union_set(self, x, y): x_root, y_root = map(self.find_set, (x, y)) if x_root == y_root: return if len(self.data[x_root]) > len(self.data[y_root]) and self.data[x_root] > self.data[y_root]: self.set[y_root] = x_root elif len(self.data[x_root]) < len(self.data[y_root]) and self.data[x_root] < self.data[y_root]: self.set[x_root] = y_root ", "class Solution def peopleIndexes(self, favoriteCompanies): lookup, comps = {}, [] for cs in favoriteCompanies: comps.append(set()) for c in cs: if c not in lookup: lookup[c] = len(lookup) comps[-1].add(lookup[c]) union_find = UnionFind(comps) for i in xrange(len(comps)): for j in xrange(len(comps)): if j == i: continue union_find.union_set(i, j) return [x for i, x in enumerate(union_find.set) if x == i] ", "class Solution def minimizeStringValue(self, s): def counting_sort(cnt): for i in xrange(len(cnt)): for _ in xrange(cnt[i]): yield i def fill(cnt): result = [0]*26 a = [(x, i) for i, x in enumerate(cnt)] a.sort() total = s.count('?') curr = 0 for i in xrange(len(a)-1): if curr+(a[i+1][0]-a[i][0])*(i+1) > total: break curr += (a[i+1][0]-a[i][0])*(i+1) else: i = len(a)-1 q, r = divmod(total-curr, i+1) for j in xrange(i+1): result[a[j][1]] = (a[i][0]-a[j][0])+q cnt2 = [0]*26 for j in xrange(i+1): cnt2[a[j][1]] += 1 it = counting_sort(cnt2) for _ in xrange(r): result[next(it)] += 1 return result cnt = [0]*26 for x in s: if x == '?': continue cnt[ord(x)-ord('a')] += 1 it = counting_sort(fill(cnt)) result = list(s) for i in xrange(len(result)): if result[i] != '?': continue result[i] = chr(ord('a')+next(it)) return \"\".join(result) import heapq ", "class Solution def minimizeStringValue(self, s): def counting_sort(cnt): for i in xrange(len(cnt)): for _ in xrange(cnt[i]): yield i cnt = [0]*26 for x in s: if x == '?': continue cnt[ord(x)-ord('a')] += 1 min_heap = [(x, i) for i, x in enumerate(cnt)] heapq.heapify(min_heap) cnt2 = [0]*26 for _ in xrange(s.count('?')): c, i = heapq.heappop(min_heap) heapq.heappush(min_heap, (c+1, i)) cnt2[i] += 1 it = counting_sort(cnt2) result = list(s) for i in xrange(len(result)): if result[i] != '?': continue result[i] = chr(ord('a')+next(it)) return \"\".join(result) ", "class Solution def minimizeStringValue(self, s): def counting_sort(cnt): for i in xrange(len(cnt)): for _ in xrange(cnt[i]): yield i cnt = [0]*26 for x in s: if x == '?': continue cnt[ord(x)-ord('a')] += 1 cnt2 = [0]*26 for _ in xrange(s.count('?')): i = min(xrange(len(cnt)), key=lambda x: cnt[x]+cnt2[x]) cnt2[i] += 1 it = counting_sort(cnt2) result = list(s) for i in xrange(len(result)): if result[i] != '?': continue result[i] = chr(ord('a')+next(it)) return \"\".join(result) ", "class Solution def sumCounts(self, nums): MOD = 10**9+7 class BIT(object): def __init__(self, n): self.__bit = [0]*(n+1) def add(self, i, val): i += 1 while i < len(self.__bit): self.__bit[i] = (self.__bit[i]+val) % MOD i += (i & -i) def query(self, i): i += 1 ret = 0 while i > 0: ret = (ret+self.__bit[i]) % MOD i -= (i & -i) return ret def update(accu, d): i = sl.bisect_left(idxs[x][-1]) accu = (accu + d*(len(nums)*(2*len(sl)-1) - (2*i+1)*idxs[x][-1] - 2*(bit.query(len(nums)-1)-bit.query(idxs[x][-1])))) % MOD bit.add(idxs[x][-1], d*idxs[x][-1]) return accu idxs = collections.defaultdict(list) for i in reversed(xrange(len(nums))): idxs[nums[i]].append(i) result = 0 sl = SortedList(idxs[x][-1] for x in idxs) accu = (len(nums)*len(sl)**2) % MOD for i, x in enumerate(sl): accu = (accu-(2*i+1)*x) % MOD bit = BIT(len(nums)) for x in sl: bit.add(x, x) for x in nums: result = (result+accu) % MOD accu = update(accu, -1) del sl[0] idxs[x].pop() if not idxs[x]: continue sl.add(idxs[x][-1]) accu = update(accu, +1) assert(accu == 0) return result ", "class Solution def sumCounts(self, nums): MOD = 10**9+7 class SegmentTree(object): def __init__(self, N, build_fn=None, query_fn=lambda x, y: y if x is None else x if y is None else (x+y)%MOD, update_fn=lambda x, y: y if x is None else (x+y)%MOD): self.tree = [None]*(1<<((N-1).bit_length()+1)) self.base = len(self.tree)>>1 self.lazy = [None]*self.base self.query_fn = query_fn self.update_fn = update_fn if build_fn is not None: for i in xrange(self.base, self.base+N): self.tree[i] = build_fn(i-self.base) for i in reversed(xrange(1, self.base)): self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1]) self.count = [1]*len(self.tree) for i in reversed(xrange(1, self.base)): self.count[i] = self.count[i<<1] + self.count[(i<<1)+1] def __apply(self, x, val): self.tree[x] = self.update_fn(self.tree[x], val*self.count[x]) if x < self.base: self.lazy[x] = self.update_fn(self.lazy[x], val) def __push(self, x): for h in reversed(xrange(1, x.bit_length())): y = x>>h if self.lazy[y] is not None: self.__apply(y<<1, self.lazy[y]) self.__apply((y<<1)+1, self.lazy[y]) self.lazy[y] = None def update(self, L, R, h): def pull(x): while x > 1: x >>= 1 self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1]) if self.lazy[x] is not None: self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x]) L += self.base R += self.base L0, R0 = L, R while L <= R: if L & 1: self.__apply(L, h) L += 1 if R & 1 == 0: self.__apply(R, h) R -= 1 L >>= 1 R >>= 1 pull(L0) pull(R0) def query(self, L, R): if L > R: return None L += self.base R += self.base self.__push(L) self.__push(R) left = right = None while L <= R: if L & 1: left = self.query_fn(left, self.tree[L]) L += 1 if R & 1 == 0: right = self.query_fn(self.tree[R], right) R -= 1 L >>= 1 R >>= 1 return self.query_fn(left, right) result = accu = 0 sl = {} st = SegmentTree(len(nums)) for i in xrange(len(nums)): j = sl[nums[i]] if nums[i] in sl else -1 accu = (accu+((i-j)+2*max(st.query(j+1, i), 0)))%MOD result = (result+accu)%MOD st.update(j+1, i, 1) sl[nums[i]] = i return result ", "class Solution def peopleAwareOfSecret(self, n, delay, forget): MOD = 10**9+7 dp = [0]*forget dp[0] = 1 for i in xrange(1, n): dp[i%forget] = ((dp[(i-1)%forget] if i-1 else 0)-dp[i%forget]+dp[(i-delay)%forget]) % MOD return sum(dp)%MOD ", "class Solution def minimumOperations(self, nums): even_top = collections.Counter(nums[i] for i in xrange(0, len(nums), 2)).most_common(2) odd_top = collections.Counter(nums[i] for i in xrange(1, len(nums), 2)).most_common(2) if not odd_top or even_top[0][0] != odd_top[0][0]: return len(nums)-even_top[0][1]-(odd_top[0][1] if odd_top else 0) return min(len(nums)-even_top[0][1]-(odd_top[1][1] if len(odd_top) == 2 else 0), len(nums)-odd_top[0][1]-(even_top[1][1] if len(even_top) == 2 else 0)) ", "class Solution def maxVowels(self, s, k): VOWELS = set(\"aeiou\") result = curr = 0 for i, c in enumerate(s): curr += c in VOWELS if i >= k: curr -= s[i-k] in VOWELS result = max(result, curr) return result ", "class Solution def maximumOddBinaryNumber(self, s): a = list(s) left = 0 for i in xrange(len(a)): if a[i] != '1': continue a[i], a[left] = a[left], a[i] left += 1 if a[-1] != '1': a[-1], a[left-1] = a[left-1], a[-1] return \"\".join(a) ", "class Solution def maximumOddBinaryNumber(self, s): n = s.count('1') return \"\".join(['1']*(n-1)+['0']*(len(s)-n)+['1']) ", "class Solution def mostPopularCreator(self, creators, ids, views): cnt = collections.Counter() lookup = collections.defaultdict(lambda: (float(\"inf\"), float(\"inf\"))) for c, i, v in itertools.izip(creators, ids, views): cnt[c] += v lookup[c] = min(lookup[c], (-v, i)) mx = max(cnt.itervalues()) return [[k, lookup[k][1]] for k, v in cnt.iteritems() if v == mx] ", "class Solution def minStoneSum(self, piles, k): for i, x in enumerate(piles): piles[i] = -x heapq.heapify(piles) for i in xrange(k): heapq.heappush(piles, heapq.heappop(piles)//2) return -sum(piles) ", "class Solution def maxPalindromesAfterOperations(self, words): cnt = [0]*26 for w in words: for c in w: cnt[ord(c)-ord('a')] += 1 curr = sum(x//2 for x in cnt) for i, l in enumerate(sorted(map(len, words))): curr -= l//2 if curr < 0: return i return len(words) ", "class Solution def maximumDifference(self, nums): result, prefix = 0, float(\"inf\") for x in nums: result = max(result, x-prefix) prefix = min(prefix, x) return result if result else -1 ", "class Solution def minimumSwaps(self, nums): min_idx = min(xrange(len(nums)), key=nums.__getitem__) max_idx = max(reversed(xrange(len(nums))), key=nums.__getitem__) return ((len(nums)-1)-max_idx)+min_idx-int(max_idx < min_idx) ", "class Solution def findBall(self, grid): result = [] for c in xrange(len(grid[0])): for r in xrange(len(grid)): nc = c+grid[r][c] if not (0 <= nc < len(grid[0]) and grid[r][nc] == grid[r][c]): c = -1 break c = nc result.append(c) return result ", "class Solution def sumImbalanceNumbers(self, nums): right = [len(nums)]*len(nums) lookup = [len(nums)]*((len(nums)+1)+1) for i in reversed(xrange(len(nums))): right[i] = min(lookup[nums[i]], lookup[nums[i]+1]) lookup[nums[i]] = i result = left = 0 lookup = [-1]*((len(nums)+1)+1) for i in xrange(len(nums)): left = lookup[nums[i]+1] lookup[nums[i]] = i result += (i-left)*(right[i]-i) return result - (len(nums)+1)*len(nums)//2 ", "class Solution def sumImbalanceNumbers(self, nums): result = 0 for right in xrange(len(nums)): lookup = {nums[right]} curr = 0 for left in reversed(xrange(right)): if nums[left] not in lookup: lookup.add(nums[left]) curr += 1-(nums[left]-1 in lookup)-(nums[left]+1 in lookup) result += curr return result ", "class Solution def __init__(self): self.__max_log3 = int(math.log(0x7fffffff) / math.log(3)) self.__max_pow3 = 3 ** self.__max_log3 def isPowerOfThree(self, n): return n > 0 and self.__max_pow3 % n == 0 ", "class Solution def isPowerOfThree(self, n): return n > 0 and (math.log10(n)/math.log10(3)).is_integer() ", "class Solution def removeAlmostEqualCharacters(self, word): result = 0 for i in xrange(len(word)-1): if (i+1)+result >= len(word): break if abs(ord(word[(i+1)+result])-ord(word[i+result])) <= 1: result += 1 return result ", "class Solution def reductionOperations(self, nums): nums.sort() result = curr = 0 for i in xrange(1, len(nums)): if nums[i-1] < nums[i]: curr += 1 result += curr return result ", "class Solution def maxDepthAfterSplit(self, seq): return [(i & 1) ^ (seq[i] == '(') for i, c in enumerate(seq)] ", "class Solution def maxDepthAfterSplit(self, seq): A, B = 0, 0 result = [0]*len(seq) for i, c in enumerate(seq): point = 1 if c == '(' else -1 if (point == 1 and A <= B) or (point == -1 and A >= B): A += point else: B += point result[i] = 1 return result ", "class Solution def balancedStringSplit(self, s): result, count = 0, 0 for c in s: count += 1 if c == 'L' else -1 if count == 0: result += 1 return result ", "class Solution def orangesRotting(self, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] count = 0 q = collections.deque() for r, row in enumerate(grid): for c, val in enumerate(row): if val == 2: q.append((r, c, 0)) elif val == 1: count += 1 result = 0 while q: r, c, result = q.popleft() for d in directions: nr, nc = r+d[0], c+d[1] if not (0 <= nr < len(grid) and 0 <= nc < len(grid[r])): continue if grid[nr][nc] == 1: count -= 1 grid[nr][nc] = 2 q.append((nr, nc, result+1)) return result if count == 0 else -1 ", "class Solution def isSelfCrossing(self, x): if len(x) >= 5 and x[3] == x[1] and x[4] + x[0] >= x[2]: return True for i in xrange(3, len(x)): if x[i] >= x[i - 2] and x[i - 3] >= x[i - 1]: return True elif i >= 5 and x[i - 4] <= x[i - 2] and x[i] + x[i - 4] >= x[i - 2] and x[i - 1] <= x[i - 3] and x[i - 5] + x[i - 1] >= x[i - 3]: return True return False ", "class Solution def arrayRankTransform(self, arr): return map({x: i+1 for i, x in enumerate(sorted(set(arr)))}.get, arr) ", "class Solution def postorder(self, root): if not root: return [] result, stack = [], [root] while stack: node = stack.pop() result.append(node.val) for child in node.children: if child: stack.append(child) return result[::-1] ", "class Solution def postorder(self, root): def dfs(root, result): for child in root.children: if child: dfs(child, result) result.append(root.val) result = [] if root: dfs(root, result) return result ", "class Solution def getHappyString(self, n, k): base = 2**(n-1) if k > 3*base: return \"\" result = [chr(ord('a')+(k-1)//base)] while base > 1: k -= (k-1)//base*base base //= 2 result.append(('a' if result[-1] != 'a' else 'b') if (k-1)//base == 0 else ('c' if result[-1] != 'c' else 'b')) return \"\".join(result) ", "class Solution def maximumBeauty(self, items, queries): items.sort() for i in xrange(len(items)-1): items[i+1][1] = max(items[i+1][1], items[i][1]) result = [] for q in queries: i = bisect.bisect_left(items, [q+1]) result.append(items[i-1][1] if i else 0) return result ", "class Solution def minimumSum(self, nums): INF = float(\"inf\") right = [INF]*len(nums) curr = INF for i in reversed(xrange(len(nums))): right[i] = curr curr = min(curr, nums[i]) result = curr = INF for i in xrange(len(nums)): if curr < nums[i] > right[i]: result = min(result, curr+nums[i]+right[i]) curr = min(curr, nums[i]) return result if result != INF else -1 ", "class Solution def minimumSum(self, nums): INF = float(\"inf\") left = [INF]*len(nums) curr = INF for i in xrange(len(nums)): left[i] = curr curr = min(curr, nums[i]) right = [INF]*len(nums) curr = INF for i in reversed(xrange(len(nums))): right[i] = curr curr = min(curr, nums[i]) result = INF for i in xrange(len(nums)): if left[i] < nums[i] > right[i]: result = min(result, left[i]+nums[i]+right[i]) return result if result != INF else -1 ", "class Solution def deserialize(self, s): if not s: return NestedInteger() if s[0] != '[': return NestedInteger(int(s)) stk = [] i = 0 for j in xrange(len(s)): if s[j] == '[': stk += NestedInteger(), i = j+1 elif s[j] in ',]': if s[j-1].isdigit(): stk[-1].add(NestedInteger(int(s[i:j]))) if s[j] == ']' and len(stk) > 1: cur = stk[-1] stk.pop() stk[-1].add(cur) i = j+1 return stk[-1] ", "class Solution def smallestRangeII(self, A, K): A.sort() result = A[-1]-A[0] for i in xrange(len(A)-1): result = min(result, max(A[-1]-K, A[i]+K) - min(A[0]+K, A[i+1]-K)) return result ", "class Solution def maxBoxesInWarehouse(self, boxes, warehouse): boxes.sort(reverse=True) result = 0 for h in boxes: if h > warehouse[result]: continue result += 1 if result == len(warehouse): break return result ", "class Solution def maxBoxesInWarehouse(self, boxes, warehouse): boxes.sort() for i in xrange(1, len(warehouse)): warehouse[i] = min(warehouse[i], warehouse[i-1]) result, curr = 0, 0 for h in reversed(warehouse): if boxes[curr] > h: continue result += 1 curr += 1 if curr == len(boxes): break return result ", "class Solution def minAnagramLength(self, s): def factors(n): for i in xrange(1, n+1): if i*i > n: break if n%i: continue yield i if n//i != i: yield n//i def check(l): def count(i): cnt = [0]*26 for j in xrange(i, i+l): cnt[ord(s[j])-ord('a')] += 1 return cnt cnt = count(0) return all(count(i) == cnt for i in xrange(l, len(s), l)) return min(l for l in factors(len(s)) if check(l)) ", "class Solution def pourWater(self, heights, V, K): for _ in xrange(V): best = K for d in (-1, 1): i = K while 0 <= i+d < len(heights) and heights[i+d] <= heights[i]: if heights[i+d] < heights[i]: best = i+d i += d if best != K: break heights[best] += 1 return heights ", "class Solution def maxCount(self, banned, n, maxSum): k = min(int((-1+(1+8*maxSum))**0.5/2), n) total = (k+1)*k//2 result = k lookup = set(banned) for x in lookup: if x <= k: total -= x result -= 1 for i in xrange(k+1, n+1): if i in lookup: continue if total+i > maxSum: break total += i result += 1 return result import bisect ", "class Solution def maxCount(self, banned, n, maxSum): def check(x): return (x+1)*x//2-prefix[bisect.bisect_right(sorted_banned, x)] <= maxSum sorted_banned = sorted(set(banned)) prefix = [0]*(len(sorted_banned)+1) for i in xrange(len(sorted_banned)): prefix[i+1] = prefix[i]+sorted_banned[i] left, right = 1, n while left <= right: mid = left + (right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right-bisect.bisect_right(sorted_banned, right) ", "class Solution def maxCount(self, banned, n, maxSum): lookup = set(banned) result = total = 0 for i in xrange(1, n+1): if i in lookup: continue if total+i > maxSum: break total += i result += 1 return result ", "class Solution def sortedSquares(self, A): right = bisect.bisect_left(A, 0) left = right-1 result = [] while 0 <= left or right < len(A): if right == len(A) or (0 <= left and A[left]**2 < A[right]**2): result.append(A[left]**2) left -= 1 else: result.append(A[right]**2) right += 1 return result ", "class Solution def removeBoxes(self, boxes): def dfs(boxes, l, r, k, lookup): if l > r: return 0 if lookup[l][r][k]: return lookup[l][r][k] ll, kk = l, k while l < r and boxes[l+1] == boxes[l]: l += 1 k += 1 result = dfs(boxes, l+1, r, 0, lookup) + (k+1) ** 2 for i in xrange(l+1, r+1): if boxes[i] == boxes[l]: result = max(result, dfs(boxes, l+1, i-1, 0, lookup) + dfs(boxes, i, r, k+1, lookup)) lookup[ll][r][kk] = result return result lookup = [[[0]*len(boxes) for _ in xrange(len(boxes)) ] for _ in xrange(len(boxes)) ] return dfs(boxes, 0, len(boxes)-1, 0, lookup) ", "class Solution def shortestSubstrings(self, arr): class Trie(object): def __init__(self): self.__nodes = [] self.__cnts = [] self.__new_node() def __new_node(self): self.__nodes.append([-1]*26) self.__cnts.append(0) return len(self.__nodes)-1 def add(self, s, d): for i in xrange(len(s)): curr = 0 for j in xrange(i, len(s)): x = ord(s[j])-ord('a') if self.__nodes[curr][x] == -1: self.__nodes[curr][x] = self.__new_node() curr = self.__nodes[curr][x] self.__cnts[curr] += d def query(self, s): result = (float(\"inf\"), \"\") for i in xrange(len(s)): curr = 0 for j in xrange(i, len(s)): curr = self.__nodes[curr][ord(s[j])-ord('a')] if self.__cnts[curr] == 0: result = min(result, (j-i+1, s[i:j+1])) break return result[1] trie = Trie() for x in arr: trie.add(x, +1) result = [] for x in arr: trie.add(x, -1) result.append(trie.query(x)) trie.add(x, +1) return result ", "class Solution def maximumStrongPairXor(self, nums): class Trie(object): def __init__(self, bit_length): self.__nodes = [] self.__cnts = [] self.__new_node() self.__bit_length = bit_length def __new_node(self): self.__nodes.append([-1]*2) self.__cnts.append(0) return len(self.__nodes)-1 def update(self, num, d): curr = 0 for i in reversed(xrange(self.__bit_length)): x = num>>i if self.__nodes[curr][x&1] == -1: self.__nodes[curr][x&1] = self.__new_node() curr = self.__nodes[curr][x&1] self.__cnts[curr] += d def query(self, num): result = curr = 0 for i in reversed(xrange(self.__bit_length)): result <<= 1 x = num>>i if self.__nodes[curr][1^(x&1)] != -1 and self.__cnts[self.__nodes[curr][1^(x&1)]]: curr = self.__nodes[curr][1^(x&1)] result |= 1 else: curr = self.__nodes[curr][x&1] return result nums.sort() trie = Trie(nums[-1].bit_length()) result = j = 0 for i, num in enumerate(nums): trie.update(num, +1) while not (nums[i] <= 2*nums[j]) : trie.update(nums[j], -1) j += 1 result = max(result, trie.query(num)) return result ", "class Solution def maximumStrongPairXor(self, nums): class Trie(object): def __init__(self, bit_length): self.__nodes = [] self.__mins = [] self.__maxs = [] self.__new_node() self.__bit_length = bit_length def __new_node(self): self.__nodes.append([-1]*2) self.__mins.append(float(\"inf\")) self.__maxs.append(float(\"-inf\")) return len(self.__nodes)-1 def insert(self, num): curr = 0 for i in reversed(xrange(self.__bit_length)): x = num>>i if self.__nodes[curr][x&1] == -1: self.__nodes[curr][x&1] = self.__new_node() curr = self.__nodes[curr][x&1] self.__mins[curr] = min(self.__mins[curr], num) self.__maxs[curr] = max(self.__maxs[curr], num) def query(self, num): result = curr = 0 for i in reversed(xrange(self.__bit_length)): result <<= 1 x = num>>i y = (result|1)^x assert(x != y) if (self.__nodes[curr][y&1] != -1 and ((x > y and num <= 2*self.__maxs[self.__nodes[curr][y&1]]) or (x < y and self.__mins[self.__nodes[curr][y&1]] <= 2*num))): result |= 1 curr = self.__nodes[curr][y&1] else: curr = self.__nodes[curr][1^(y&1)] return result trie = Trie(max(nums).bit_length()) result = 0 for num in nums: trie.insert(num) result = max(result, trie.query(num)) return result ", "class Solution def maximumStrongPairXor(self, nums): result = 0 for i in reversed(xrange(max(nums).bit_length())): prefix_min, prefix_max = {}, {} for x in nums: y = x>>i if y not in prefix_min: prefix_min[y] = prefix_max[y] = x prefix_min[y] = min(prefix_min[y], x) prefix_max[y] = max(prefix_max[y], x) result <<= 1 for x in prefix_min.iterkeys(): y = (result|1)^x assert(x != y) if y in prefix_max and prefix_min[max(x, y)] <= 2*prefix_max[min(x, y)]: result |= 1 break return result ", "class Solution def maximumStrongPairXor(self, nums): return max(nums[i]^nums[j] for i in xrange(len(nums)) for j in xrange(i, len(nums)) if abs(nums[i]-nums[j]) <= min(nums[i], nums[j])) ", "class Solution def garbageCollection(self, garbage, travel): result = 0 lookup = {} for i in xrange(len(garbage)): for c in garbage[i]: lookup[c] = i if i+1 < len(travel): travel[i+1] += travel[i] result += len(garbage[i]) result += sum(travel[v-1] for _, v in lookup.iteritems() if v-1 >= 0) return result ", "class Solution def garbageCollection(self, garbage, travel): result = 0 for t in 'MPG': curr = 0 for i in xrange(len(garbage)): cnt = garbage[i].count(t) if cnt: result += curr+cnt curr = 0 if i < len(travel): curr += travel[i] return result ", "class Solution def minSwaps(self, s): result = curr = 0 for c in s: if c == ']': curr += 1 result = max(result, curr) else: curr -= 1 return (result+1)//2 ", "class Solution def maxRotateFunction(self, A): s = sum(A) fi = 0 for i in xrange(len(A)): fi += i * A[i] result = fi for i in xrange(1, len(A)+1): fi += s - len(A) * A[-i] result = max(result, fi) return result ", "class Solution def findCrossingTime(self, n, k, time): left_bridge, right_ware, right_bridge, left_ware = [(-(time[i][0]+time[i][2]), -i) for i in xrange(k)], [], [], [] heapq.heapify(left_bridge) curr = 0 while n: while left_ware and left_ware[0][0] <= curr: _, i = heapq.heappop(left_ware) heapq.heappush(left_bridge, (-(time[i][0]+time[i][2]), -i)) while right_ware and right_ware[0][0] <= curr: _, i = heapq.heappop(right_ware) heapq.heappush(right_bridge, (-(time[i][0]+time[i][2]), -i)) if right_bridge: _, i = heapq.heappop(right_bridge) i = -i curr += time[i][2] heapq.heappush(left_ware, (curr+time[i][3], i)) n -= 1 elif left_bridge and n-len(right_ware): _, i = heapq.heappop(left_bridge) i = -i curr += time[i][0] heapq.heappush(right_ware, (curr+time[i][1], i)) else: curr = min(left_ware[0][0] if left_ware else float(\"inf\"), right_ware[0][0] if right_ware else float(\"inf\")) return curr ", "class Solution def countMatchingSubarrays(self, nums, pattern): def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j+1 > 0 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix def KMP(text, pattern): prefix = getPrefix(pattern) j = -1 for i, x in enumerate(text): while j+1 > 0 and pattern[j+1] != x: j = prefix[j] if pattern[j+1] == x: j += 1 if j+1 == len(pattern): yield i-j j = prefix[j] return sum(1 for _ in KMP((cmp(nums[i+1], nums[i]) for i in xrange(len(nums)-1)), pattern)) ", "class Solution def maximumGap(self, nums): if len(nums) < 2: return 0 max_val, min_val = max(nums), min(nums) gap = max(1, (max_val - min_val) / (len(nums) - 1)) bucket_size = (max_val - min_val) / gap + 1 bucket = [{'min':float(\"inf\"), 'max':float(\"-inf\")} for _ in xrange(bucket_size)] for n in nums: if n in (max_val, min_val): continue i = (n - min_val) / gap bucket[i]['min'] = min(bucket[i]['min'], n) bucket[i]['max'] = max(bucket[i]['max'], n) max_gap, pre_bucket_max = 0, min_val for i in xrange(bucket_size): if bucket[i]['min'] == float(\"inf\") and bucket[i]['max'] == float(\"-inf\"): continue max_gap = max(max_gap, bucket[i]['min'] - pre_bucket_max) pre_bucket_max = bucket[i]['max'] max_gap = max(max_gap, max_val - pre_bucket_max) return max_gap ", "class Solution def maximumGap(self, nums): if len(nums) < 2: return 0 nums.sort() pre = nums[0] max_gap = float(\"-inf\") for i in nums: max_gap = max(max_gap, i - pre) pre = i return max_gap ", "class Solution def selfDividingNumbers(self, left, right): def isDividingNumber(num): n = num while n > 0: n, r = divmod(n, 10) if r == 0 or (num%r) != 0: return False return True return [num for num in xrange(left, right+1) if isDividingNumber(num)] import itertools ", "class Solution def selfDividingNumbers(self, left, right): return [num for num in xrange(left, right+1) if not any(itertools.imap(lambda x: int(x) == 0 or num%int(x) != 0, str(num)))] ", "class Solution def mostFrequentPrime(self, mat): DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)) def numbers(i, j, di, dj): curr = 0 while 0 <= i < len(mat) and 0 <= j < len(mat[0]): curr = curr*10+mat[i][j] yield curr i, j = i+di, j+dj cnt = collections.Counter(x for i in xrange(len(mat)) for j in xrange(len(mat[0])) for di, dj in DIRECTIONS for x in numbers(i, j, di, dj) if x > 10 and SPF[x] == x) cnt[-1] = 0 return max(cnt.iterkeys(), key=lambda x: (cnt[x], x)) import collections def is_prime(n): if n%2 == 0 or n%3 == 0: return False for i in xrange(5, n, 6): if i*i > n: break if n%i == 0 or n%(i+2) == 0: return False return True ", "class Solution def mostFrequentPrime(self, mat): DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)) def numbers(i, j, di, dj): curr = 0 while 0 <= i < len(mat) and 0 <= j < len(mat[0]): curr = curr*10+mat[i][j] yield curr i, j = i+di, j+dj cnt = collections.Counter(x for i in xrange(len(mat)) for j in xrange(len(mat[0])) for di, dj in DIRECTIONS for x in numbers(i, j, di, dj) if x > 10) cnt[-1] = 0 return max((p for p in cnt.iterkeys() if is_prime(p) or p == -1), key=lambda x: (cnt[x], x)) ", "class Solution def stoneGameVII(self, stones): def score(i, j): return prefix[j+1]-prefix[i] prefix = [0] for stone in stones: prefix.append(prefix[-1]+stone) dp = [[0 for _ in xrange(len(stones))] for _ in xrange(2)] for i in reversed(xrange(len(stones))): for j in xrange(i+1, len(stones)): dp[i%2][j] = max(score(i+1, j)-dp[(i+1)%2][j], score(i, j-1)-dp[i%2][j-1]) return dp[0][-1] ", "class Solution def triangleNumber(self, nums): result = 0 nums.sort() for i in reversed(xrange(2, len(nums))): left, right = 0, i-1 while left < right: if nums[left]+nums[right] > nums[i]: result += right-left right -= 1 else: left += 1 return result ", "class Solution def triangleNumber(self, nums): result = 0 nums.sort() for i in xrange(len(nums)-2): if nums[i] == 0: continue k = i+2 for j in xrange(i+1, len(nums)-1): while k < len(nums) and nums[i] + nums[j] > nums[k]: k += 1 result += k-j-1 return result ", "class Solution def getStrongest(self, arr, k): arr.sort() m = arr[(len(arr)-1)//2] result = [] left, right = 0, len(arr)-1 while len(result) < k: if m-arr[left] > arr[right]-m: result.append(arr[left]) left += 1 else: result.append(arr[right]) right -= 1 return result ", "class Solution def getStrongest(self, arr, k): arr.sort() m = arr[(len(arr)-1)//2] arr.sort(key=lambda x: (-abs(x-m), -x)) return arr[:k] import random class Solution_TLE(object): def getStrongest(self, arr, k): def nth_element(nums, n, compare=lambda a, b: a < b): def partition_around_pivot(left, right, pivot_idx, nums, compare): new_pivot_idx = left nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx] for i in xrange(left, right): if compare(nums[i], nums[right]): nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i] new_pivot_idx += 1 nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right] return new_pivot_idx left, right = 0, len(nums) - 1 while left <= right: pivot_idx = random.randint(left, right) new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare) if new_pivot_idx == n: return elif new_pivot_idx > n: right = new_pivot_idx - 1 else: left = new_pivot_idx + 1 nth_element(arr, (len(arr)-1)//2) m = arr[(len(arr)-1)//2] nth_element(arr, k, lambda a, b: abs(a-m) > abs(b-m) if abs(a-m) != abs(b-m) else a > b) return arr[:k] ", "class Solution def maxTotalReward(self, rewardValues): mx = max(rewardValues) dp = 1 mask = (1<<mx)-1 for v in sorted(set(rewardValues)): x = dp&((1<<v)-1) dp |= (x<<v)&mask return mx+(dp.bit_length()-1) ", "class Solution def maxTotalReward(self, rewardValues): dp = 1 for v in sorted(set(rewardValues)): x = dp&((1<<v)-1) dp |= x<<v return dp.bit_length()-1 ", "class Solution def friendRequests(self, n, restrictions, requests): result = [] uf = UnionFind(n) for u, v in requests: pu, pv = uf.find_set(u), uf.find_set(v) ok = True for x, y in restrictions: px, py = uf.find_set(x), uf.find_set(y) if {px, py} == {pu, pv}: ok = False break result.append(ok) if ok: uf.union_set(u, v) return result ", "class Solution def countSteppingNumbers(self, low, high): lit = bisect.bisect_left(result, low); rit = bisect.bisect_right(result, high); return result[lit:rit] ", "class Solution def countSteppingNumbers(self, low, high): result = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] for i in xrange(1, high): if result[-1] >= high: break d1 = result[i]%10 - 1 if d1 >= 0: result.append(result[i]*10 + d1) d2 = result[i]%10 + 1 if d2 <= 9: result.append(result[i]*10 + d2) result.append(float(\"inf\")) lit = bisect.bisect_left(result, low); rit = bisect.bisect_right(result, high); return result[lit:rit] ", "class Solution def nextGreaterElement(self, n): digits = map(int, list(str(n))) k, l = -1, 0 for i in xrange(len(digits) - 1): if digits[i] < digits[i + 1]: k = i if k == -1: digits.reverse() return -1 for i in xrange(k + 1, len(digits)): if digits[i] > digits[k]: l = i digits[k], digits[l] = digits[l], digits[k] digits[k + 1:] = digits[:k:-1] result = int(\"\".join(map(str, digits))) return -1 if result >= 0x7FFFFFFF else result ", "class Solution def numOfWays(self, n): def matrix_expo(A, K): result = [[int(i==j) for j in xrange(len(A))] for i in xrange(len(A))] while K: if K % 2: result = matrix_mult(result, A) A = matrix_mult(A, A) K /= 2 return result def matrix_mult(A, B): ZB = zip(*B) return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A] MOD = 10**9 + 7 T = [[3, 2], [2, 2]] return sum(matrix_mult([[6, 6]], matrix_expo(T, n-1))[0]) % MOD ", "class Solution def numOfWays(self, n): MOD = 10**9 + 7 aba, abc = 6, 6 for _ in xrange(n-1): aba, abc = (3*aba%MOD + 2*abc%MOD)%MOD, (2*abc%MOD + 2*aba%MOD)%MOD return (aba+abc)%MOD ", "class Solution def maximumOr(self, nums, k): right = [0]*(len(nums)+1) for i in reversed(xrange(len(nums))): right[i] = right[i+1]|nums[i] result = left = 0 for i in xrange(len(nums)): result = max(result, left|(nums[i]<<k)|right[i+1]) left |= nums[i] return result ", "class Solution def numMovesStones(self, a, b, c): s = [a, b, c] s.sort() if s[0]+1 == s[1] and s[1]+1 == s[2]: return [0, 0] return [1 if s[0]+2 >= s[1] or s[1]+2 >= s[2] else 2, s[2]-s[0]-2] ", "class Solution def numMovesStones(self, a, b, c): stones = [a, b, c] stones.sort() left, min_moves = 0, float(\"inf\") max_moves = (stones[-1]-stones[0]) - (len(stones)-1) for right in xrange(len(stones)): while stones[right]-stones[left]+1 > len(stones): left += 1 min_moves = min(min_moves, len(stones)-(right-left+1)) return [min_moves, max_moves] ", "class Solution def maximumSubarraySum(self, nums, k): result = left = total = 0 lookup = set() for right in xrange(len(nums)): while nums[right] in lookup or len(lookup) == k: lookup.remove(nums[left]) total -= nums[left] left += 1 lookup.add(nums[right]) total += nums[right] if len(lookup) == k: result = max(result, total) return result ", "class Solution def isValidSerialization(self, preorder): def split_iter(s, tok): start = 0 for i in xrange(len(s)): if s[i] == tok: yield s[start:i] start = i + 1 yield s[start:] if not preorder: return False depth, cnt = 0, preorder.count(',') + 1 for tok in split_iter(preorder, ','): cnt -= 1 if tok == \"#\": depth -= 1 if depth < 0: break else: depth += 1 return cnt == 0 and depth < 0 ", "class Solution def minimumCost(self, cost): cost.sort(reverse=True) return sum(x for i, x in enumerate(cost) if i%3 != 2) ", "class Solution def spiralMatrixIII(self, R, C, r0, c0): r, c = r0, c0 result = [[r, c]] x, y, n, i = 0, 1, 0, 0 while len(result) < R*C: r, c, i = r+x, c+y, i+1 if 0 <= r < R and 0 <= c < C: result.append([r, c]) if i == n//2+1: x, y, n, i = y, -x, n+1, 0 return result ", "class Solution def countBalls(self, lowLimit, highLimit): count = collections.Counter() for i in xrange(lowLimit, highLimit+1): count[sum(itertools.imap(int, str(i)))] += 1 return max(count.itervalues()) ", "class Solution def isOneEditDistance(self, s, t): m, n = len(s), len(t) if m > n: return self.isOneEditDistance(t, s) if n - m > 1: return False i, shift = 0, n - m while i < m and s[i] == t[i]: i += 1 if shift == 0: i += 1 while i < m and s[i] == t[i + shift]: i += 1 return i == m ", "class Solution def hammingWeight(self, n): n = (n & 0x55555555) + ((n >> 1) & 0x55555555) n = (n & 0x33333333) + ((n >> 2) & 0x33333333) n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F) n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF) n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF) return n ", "class Solution def __init__(self): self.__popcount_tab = [ 0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5, 1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6, 1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6, 2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7, 1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6, 2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7, 2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7, 3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8 ] def hammingWeight(self, n): result = 0 while n: result += self.__popcount_tab[n & 0xff] n >>= 8 return result ", "class Solution def hammingWeight(self, n): result = 0 while n: n &= n - 1 result += 1 return result ", "class Solution def possibleBipartition(self, N, dislikes): adj = [[] for _ in xrange(N)] for u, v in dislikes: adj[u-1].append(v-1) adj[v-1].append(u-1) color = [0]*N color[0] = 1 q = collections.deque([0]) while q: cur = q.popleft() for nei in adj[cur]: if color[nei] == color[cur]: return False elif color[nei] == -color[cur]: continue color[nei] = -color[cur] q.append(nei) return True ", "class Solution def minimumDifference(self, nums): left, right = nums[:len(nums)//2], nums[len(nums)//2:] total1, total2 = sum(left), sum(right) result = float(\"inf\") for k in xrange(len(left)+1): sums = sorted(2*sum(comb)-total1 for comb in itertools.combinations(left, k)) for comb in itertools.combinations(right, len(left)-k): diff = 2*sum(comb)-total2 i = bisect.bisect_left(sums, -diff) if i < len(sums): result = min(result, abs(sums[i]+diff)) if i > 0: result = min(result, abs(sums[i-1]+diff)) return result ", "class Solution def wordPattern(self, pattern, str): if len(pattern) != self.wordCount(str): return False w2p, p2w = {}, {} for p, w in izip(pattern, self.wordGenerator(str)): if w not in w2p and p not in p2w: w2p[w] = p p2w[p] = w elif w not in w2p or w2p[w] != p: return False return True def wordCount(self, str): cnt = 1 if str else 0 for c in str: if c == ' ': cnt += 1 return cnt def wordGenerator(self, str): w = \"\" for c in str: if c == ' ': yield w w = \"\" else: w += c yield w ", "class Solution def wordPattern(self, pattern, str): words = str.split() if len(pattern) != len(words): return False w2p, p2w = {}, {} for p, w in izip(pattern, words): if w not in w2p and p not in p2w: w2p[w] = p p2w[p] = w elif w not in w2p or w2p[w] != p: return False return True ", "class Solution def checkPerfectNumber(self, num): if num <= 0: return False sqrt_num = int(num ** 0.5) total = sum(i+num//i for i in xrange(1, sqrt_num+1) if num%i == 0) if sqrt_num ** 2 == num: total -= sqrt_num return total - num == num ", "class Solution def minKnightMoves(self, x, y): x, y = abs(x), abs(y) if x < y: x, y = y, x lookup = {(1, 0):3, (2, 2):4} if (x, y) in lookup: return lookup[(x, y)] k = x-y if y > k: return k - 2*((k-y)//3) return k - 2*((k-y)//4) ", "class Solution def __init__(self): self.__lookup = {(0, 0):0, (1, 1):2, (1, 0):3} def minKnightMoves(self, x, y): def dp(x, y): x, y = abs(x), abs(y) if x < y: x, y = y, x if (x, y) not in self.__lookup: self.__lookup[(x, y)] = min(dp(x-1, y-2), dp(x-2, y-1)) + 1 return self.__lookup[(x, y)] return dp(x, y) ", "class Solution def generatePalindromes(self, s): cnt = collections.Counter(s) mid = ''.join(k for k, v in cnt.iteritems() if v % 2) chars = ''.join(k * (v / 2) for k, v in cnt.iteritems()) return self.permuteUnique(mid, chars) if len(mid) < 2 else [] def permuteUnique(self, mid, nums): result = [] used = [False] * len(nums) self.permuteUniqueRecu(mid, result, used, [], nums) return result def permuteUniqueRecu(self, mid, result, used, cur, nums): if len(cur) == len(nums): half_palindrome = ''.join(cur) result.append(half_palindrome + mid + half_palindrome[::-1]) return for i in xrange(len(nums)): if not used[i] and not (i > 0 and nums[i-1] == nums[i] and used[i-1]): used[i] = True cur.append(nums[i]) self.permuteUniqueRecu(mid, result, used, cur, nums) cur.pop() used[i] = False ", "class Solution def generatePalindromes(self, s): cnt = collections.Counter(s) mid = tuple(k for k, v in cnt.iteritems() if v % 2) chars = ''.join(k * (v / 2) for k, v in cnt.iteritems()) return [''.join(half_palindrome + mid + half_palindrome[::-1]) for half_palindrome in set(itertools.permutations(chars))] if len(mid) < 2 else [] ", "class Solution def maxValue(self, n, x): check = (lambda i: str(x) > n[i]) if n[0] != '-' else (lambda i: str(x) < n[i]) for i in xrange(len(n)): if check(i): break else: i = len(n) return n[:i] + str(x) + n[i:] ", "class Solution def mincostTickets(self, days, costs): durations = [1, 7, 30] W = durations[-1] dp = [float(\"inf\") for i in xrange(W)] dp[0] = 0 last_buy_days = [0, 0, 0] for i in xrange(1,len(days)+1): dp[i%W] = float(\"inf\") for j in xrange(len(durations)): while i-1 < len(days) and days[i-1] > days[last_buy_days[j]]+durations[j]-1: last_buy_days[j] += 1 dp[i%W] = min(dp[i%W], dp[last_buy_days[j]%W]+costs[j]) return dp[len(days)%W] ", "class Solution def isPalindrome(self, x): if x < 0: return False copy, reverse = x, 0 while copy: reverse *= 10 reverse += copy % 10 copy //= 10 return x == reverse ", "class Solution def productExceptSelf(self, nums): if not nums: return [] left_product = [1 for _ in xrange(len(nums))] for i in xrange(1, len(nums)): left_product[i] = left_product[i - 1] * nums[i - 1] right_product = 1 for i in xrange(len(nums) - 2, -1, -1): right_product *= nums[i + 1] left_product[i] = left_product[i] * right_product return left_product ", "class Solution def permuteUnique(self, nums): nums.sort() result = [] used = [False] * len(nums) self.permuteUniqueRecu(result, used, [], nums) return result def permuteUniqueRecu(self, result, used, cur, nums): if len(cur) == len(nums): result.append(cur + []) return for i in xrange(len(nums)): if used[i] or (i > 0 and nums[i-1] == nums[i] and not used[i-1]): continue used[i] = True cur.append(nums[i]) self.permuteUniqueRecu(result, used, cur, nums) cur.pop() used[i] = False ", "class Solution def permuteUnique(self, nums): solutions = [[]] for num in nums: next = [] for solution in solutions: for i in xrange(len(solution) + 1): candidate = solution[:i] + [num] + solution[i:] if candidate not in next: next.append(candidate) solutions = next return solutions ", "class Solution def validTicTacToe(self, board): def win(board, player): for i in xrange(3): if all(board[i][j] == player for j in xrange(3)): return True if all(board[j][i] == player for j in xrange(3)): return True return (player == board[1][1] == board[0][0] == board[2][2] or player == board[1][1] == board[0][2] == board[2][0]) FIRST, SECOND = ('X', 'O') x_count = sum(row.count(FIRST) for row in board) o_count = sum(row.count(SECOND) for row in board) if o_count not in {x_count-1, x_count}: return False if win(board, FIRST) and x_count-1 != o_count: return False if win(board, SECOND) and x_count != o_count: return False return True ", "class Solution def maximumPopulation(self, logs): MIN_YEAR, MAX_YEAR = 1950, 2050 years = [0]*(MAX_YEAR-MIN_YEAR+1) for s, e in logs: years[s-MIN_YEAR] += 1 years[e-MIN_YEAR] -= 1 result = 0 for i in xrange(len(years)): if i: years[i] += years[i-1] if years[i] > years[result]: result = i return result+MIN_YEAR ", "class Solution def maximumProcessableQueries(self, nums, queries): dp = [[float(\"-inf\")]*len(nums) for _ in xrange(len(nums))] dp[0][-1] = 0 for l in reversed(xrange(1, len(nums))): for i in xrange(len(nums)-(l-1)): j = i+(l-1) if i-1 >= 0: dp[i][j] = max(dp[i][j], dp[i-1][j]+(1 if nums[i-1] >= queries[dp[i-1][j]] else 0)) if j+1 < len(nums): dp[i][j] = max(dp[i][j], dp[i][j+1]+(1 if nums[j+1] >= queries[dp[i][j+1]] else 0)) if dp[i][j] == len(queries): return len(queries) return max(dp[i][i]+(1 if nums[i] >= queries[dp[i][i]] else 0) for i in xrange(len(nums))) ", "class Solution def maxNonOverlapping(self, nums, target): lookup = {0:-1} result, accu, right = 0, 0, -1 for i, num in enumerate(nums): accu += num if accu-target in lookup and lookup[accu-target] >= right: right = i result += 1 lookup[accu] = i return result ", "class Solution def maxDistance(self, colors): result = 0 for i, x in enumerate(colors): if x != colors[0]: result = max(result, i) if x != colors[-1]: result = max(result, len(colors)-1-i) return result ", "class Solution def openLock(self, deadends, target): dead = set(deadends) q = [\"0000\"] lookup = {\"0000\"} depth = 0 while q: next_q = [] for node in q: if node == target: return depth if node in dead: continue for i in xrange(4): n = int(node[i]) for d in (-1, 1): nn = (n+d) % 10 neighbor = node[:i] + str(nn) + node[i+1:] if neighbor not in lookup: lookup.add(neighbor) next_q.append(neighbor) q = next_q depth += 1 return -1 ", "class Solution def findComplement(self, num): return 2 ** (len(bin(num)) - 2) - 1 - num ", "class Solution def findComplement(self, num): i = 1 while i <= num: i <<= 1 return (i - 1) ^ num ", "class Solution def findComplement(self, num): bits = '{0:b}'.format(num) complement_bits = ''.join('1' if bit == '0' else '0' for bit in bits) return int(complement_bits, 2) ", "class Solution def maxEnvelopes(self, envelopes): def insert(target): left, right = 0, len(result) - 1 while left <= right: mid = left + (right - left) / 2 if result[mid] >= target: right = mid - 1 else: left = mid + 1 if left == len(result): result.append(target) else: result[left] = target result = [] envelopes.sort(lambda x, y: y[1] - x[1] if x[0] == y[0] else x[0] - y[0]) for envelope in envelopes: insert(envelope[1]) return len(result) ", "class Solution def queensAttacktheKing(self, queens, king): dirctions = [(-1, 0), (0, 1), (1, 0), (0, -1), (-1, 1), (1, 1), (1, -1), (-1, -1)] result = [] lookup = {(i, j) for i, j in queens} for dx, dy in dirctions: for i in xrange(1, 8): x, y = king[0] + dx*i, king[1] + dy*i if (x, y) in lookup: result.append([x, y]) break return result ", "class Solution def numberOfBeautifulIntegers(self, low, high, k): TIGHT, UNTIGHT, UNBOUND = range(3) def f(x): digits = map(int, str(x)) lookup = [[[[-1]*k for _ in xrange(2*len(digits)+1)] for _ in xrange(3)] for _ in xrange(len(digits))] def memoization(i, state, diff, total): if i == len(digits): return int(state != UNBOUND and diff == total == 0) if lookup[i][state][diff][total] == -1: result = int(i != 0 and diff == total == 0) for d in xrange(1 if i == 0 else 0, 10): new_state = state if state == TIGHT and d != digits[i]: new_state = UNTIGHT if d < digits[i] else UNBOUND new_diff = diff+(1 if d%2 == 0 else -1) new_total = (total*10+d)%k result += memoization(i+1, new_state, new_diff, new_total) lookup[i][state][diff][total] = result return lookup[i][state][diff][total] return memoization(0, TIGHT, 0, 0) return f(high)-f(low-1) ", "class Solution def numberOfBeautifulIntegers(self, low, high, k): TIGHT, UNTIGHT, UNBOUND = range(3) def f(x): digits = map(int, str(x)) dp = [[[0]*k for _ in xrange(2*len(digits)+1)] for _ in xrange(3)] for tight in xrange(2): for state in (TIGHT, UNTIGHT): dp[state][0][0] = 1 for i in reversed(xrange(len(digits))): new_dp = [[[0]*k for _ in xrange(2*len(digits)+1)] for _ in xrange(3)] for state in (TIGHT, UNTIGHT, UNBOUND): new_dp[state][0][0] = int(i != 0) for d in xrange(1 if i == 0 else 0, 10): new_state = state if state == TIGHT and d != digits[i]: new_state = UNTIGHT if d < digits[i] else UNBOUND for diff in xrange(-len(digits), len(digits)+1): new_diff = diff+(1 if d%2 == 0 else -1) for total in xrange(k): new_total = (total*10+d)%k new_dp[state][diff][total] += dp[new_state][new_diff][new_total] dp = new_dp return dp[TIGHT][0][0] return f(high)-f(low-1) ", "class Solution def numberOfBeautifulIntegers(self, low, high, k): def f(x): digits = map(int, str(x)) lookup = [[[[[-1]*k for _ in xrange(2*len(digits)+1)] for _ in xrange(2)] for _ in xrange(2)] for _ in xrange(len(digits))] def memoization(i, zero, tight, diff, total): if i == len(digits): return int(zero == diff == total == 0) if lookup[i][zero][tight][diff][total] == -1: result = 0 for d in xrange((digits[i] if tight else 9)+1): new_zero = int(zero and d == 0) new_tight = int(tight and d == digits[i]) new_diff = diff+((1 if d%2 == 0 else -1) if new_zero == 0 else 0) new_total = (total*10+d)%k result += memoization(i+1, new_zero, new_tight, new_diff, new_total) lookup[i][zero][tight][diff][total] = result return lookup[i][zero][tight][diff][total] return memoization(0, 1, 1, 0, 0) return f(high)-f(low-1) ", "class Solution def numberOfBeautifulIntegers(self, low, high, k): def f(x): digits = map(int, str(x)) dp = [[[[0]*k for _ in xrange(2*len(digits)+1)] for _ in xrange(2)] for _ in xrange(2)] for tight in xrange(2): dp[0][tight][0][0] = 1 for i in reversed(xrange(len(digits))): new_dp = [[[[0]*k for _ in xrange(2*len(digits)+1)] for _ in xrange(2)] for _ in xrange(2)] for zero in xrange(2): for tight in xrange(2): for d in xrange((digits[i] if tight else 9)+1): new_zero = int(zero and d == 0) new_tight = int(tight and d == digits[i]) for diff in xrange(-len(digits), len(digits)+1): new_diff = diff+((1 if d%2 == 0 else -1) if new_zero == 0 else 0) for total in xrange(k): new_total = (total*10+d)%k new_dp[zero][tight][diff][total] += dp[new_zero][new_tight][new_diff][new_total] dp = new_dp return dp[1][1][0][0] return f(high)-f(low-1) ", "class Solution def distinctSubarraysWithAtMostKOddIntegers(self, A, K): def countDistinct(A, left, right, trie): result = 0 for i in reversed(xrange(left, right+1)): if A[i] not in trie: result += 1 trie = trie[A[i]] return result _trie = lambda: collections.defaultdict(_trie) trie = _trie() result, left, count = 0, 0, 0 for right in xrange(len(A)): count += A[right]%2 while count > K: count -= A[left]%2 left += 1 result += countDistinct(A, left, right, trie) return result ", "class Solution def distinctSubarraysWithAtMostKOddIntegers(self, A, K): def countDistinct(A, left, right, trie): result = 0 for i in xrange(left, right+1): if A[i] not in trie: result += 1 trie = trie[A[i]] return result _trie = lambda: collections.defaultdict(_trie) trie = _trie() result = 0 for left in xrange(len(A)): count = 0 for right in xrange(left, len(A)): count += A[right]%2 if count > K: right -= 1 break result += countDistinct(A, left, right, trie) return result ", "class Solution def countGoodSubstrings(self, s): K = 3 result = 0 count = collections.Counter() for i in xrange(len(s)): if i >= K: count[s[i-K]] -= 1 if not count[s[i-K]]: del count[s[i-K]] count[s[i]] += 1 if len(count) == K: result += 1 return result ", "class Solution def getMinSwaps(self, num, k): def next_permutation(nums, begin, end): def reverse(nums, begin, end): left, right = begin, end-1 while left < right: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1 k, l = begin-1, begin for i in reversed(xrange(begin, end-1)): if nums[i] < nums[i+1]: k = i break else: reverse(nums, begin, end) return False for i in reversed(xrange(k+1, end)): if nums[i] > nums[k]: l = i break nums[k], nums[l] = nums[l], nums[k] reverse(nums, k+1, end) return True new_num = list(num) while k: next_permutation(new_num, 0, len(new_num)) k -= 1 result = 0 for i in xrange(len(new_num)): if new_num[i] == num[i]: continue for j in xrange(i+1, len(new_num)): if new_num[j] == num[i]: break result += j-i for j in reversed(xrange(i+1, j+1)): new_num[j], new_num[j-1] = new_num[j-1], new_num[j] return result ", "class Solution def reverseVowels(self, s): vowels = \"aeiou\" string = list(s) i, j = 0, len(s) - 1 while i < j: if string[i].lower() not in vowels: i += 1 elif string[j].lower() not in vowels: j -= 1 else: string[i], string[j] = string[j], string[i] i += 1 j -= 1 return \"\".join(string) ", "class Solution def mostBooked(self, n, meetings): meetings.sort() min_heap = [(meetings[0][0], i) for i in xrange(n)] result = [0]*n for s, e in meetings: while min_heap and min_heap[0][0] < s: _, i = heapq.heappop(min_heap) heapq.heappush(min_heap, (s, i)) e2, i = heapq.heappop(min_heap) heapq.heappush(min_heap, (e2+(e-s), i)) result[i] += 1 return max(xrange(n), key=lambda x:result[x]) import heapq ", "class Solution def mostBooked(self, n, meetings): meetings.sort() unused, used = range(n), [] result = [0]*n for s, e in meetings: while used and used[0][0] <= s: _, i = heapq.heappop(used) heapq.heappush(unused, i) if unused: i = heapq.heappop(unused) heapq.heappush(used, (e, i)) else: e2, i = heapq.heappop(used) heapq.heappush(used, (e2+(e-s), i)) result[i] += 1 return max(xrange(n), key=lambda x:result[x]) ", "class Solution def minimumString(self, a, b, c): def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j != -1 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix def KMP(text, pattern): prefix = getPrefix(pattern) j = -1 for i in xrange(len(text)): while j != -1 and pattern[j+1] != text[i]: j = prefix[j] if pattern[j+1] == text[i]: j += 1 if j+1 == len(pattern): return i-j return -1 def merge(a, b): if KMP(b, a) != -1: return b prefix = getPrefix(b+'#'+a) l = prefix[-1]+1 return a+b[l:] result = [merge(a, merge(b, c)), merge(a, merge(c, b)), merge(b, merge(a, c)), merge(b, merge(c, a)), merge(c, merge(a, b)), merge(c, merge(b, a))] return min(result, key=lambda x: (len(x), x)) ", "class Solution def minimumString(self, a, b, c): def merge(a, b): if a in b: return b l = next((l for l in reversed(xrange(1, min(len(a), len(b)))) if a[-l:] == b[:l]), 0) return a+b[l:] result = [merge(a, merge(b, c)), merge(a, merge(c, b)), merge(b, merge(a, c)), merge(b, merge(c, a)), merge(c, merge(a, b)), merge(c, merge(b, a))] return min(result, key=lambda x: (len(x), x)) ", "class Solution def isValid(self, word): VOWELS = \"aeiou\" if len(word) < 3: return False vowel = consonant = False for x in word: if x.isalpha(): if x.lower() in VOWELS: vowel = True else: consonant = True elif not x.isdigit(): return False return vowel and consonant ", "class Solution def superPow(self, a, b): def myPow(a, n, b): result = 1 x = a % b while n: if n & 1: result = result * x % b n >>= 1 x = x * x % b return result % b result = 1 for digit in b: result = myPow(result, 10, 1337) * myPow(a, digit, 1337) % 1337 return result ", "class Solution def numIslands2(self, m, n, positions): def node_id(node, n): return node[0] * n + node[1] def find_set(x): if set[x] != x: set[x] = find_set(set[x]) return set[x] def union_set(x, y): x_root, y_root = find_set(x), find_set(y) set[min(x_root, y_root)] = max(x_root, y_root) numbers = [] number = 0 directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] set = {} for position in positions: node = (position[0], position[1]) set[node_id(node, n)] = node_id(node, n) number += 1 for d in directions: neighbor = (position[0] + d[0], position[1] + d[1]) if 0 <= neighbor[0] < m and 0 <= neighbor[1] < n and node_id(neighbor, n) in set: if find_set(node_id(node, n)) != find_set(node_id(neighbor, n)): union_set(node_id(node, n), node_id(neighbor, n)) number -= 1 numbers.append(number) return numbers ", "class Solution def pathsWithMaxScore(self, board): MOD = 10**9+7 directions = [[1, 0], [0, 1], [1, 1]] dp = [[[0, 0] for r in xrange(len(board[0])+1)] for r in xrange(2)] dp[(len(board)-1)%2][len(board[0])-1] = [0, 1] for r in reversed(xrange(len(board))): for c in reversed(xrange(len(board[0]))): if board[r][c] in \"XS\": continue dp[r%2][c] = [0, 0] for dr, dc in directions: if dp[r%2][c][0] < dp[(r+dr)%2][c+dc][0]: dp[r%2][c] = dp[(r+dr)%2][c+dc][:] elif dp[r%2][c][0] == dp[(r+dr)%2][c+dc][0]: dp[r%2][c][1] = (dp[r%2][c][1]+dp[(r+dr)%2][c+dc][1]) % MOD if dp[r%2][c][1] and board[r][c] != 'E': dp[r%2][c][0] += int(board[r][c]) return dp[0][0] ", "class Solution def maxUncrossedLines(self, A, B): if len(A) < len(B): return self.maxUncrossedLines(B, A) dp = [[0 for _ in xrange(len(B)+1)] for _ in xrange(2)] for i in xrange(len(A)): for j in xrange(len(B)): dp[(i+1)%2][j+1] = max(dp[i%2][j] + int(A[i] == B[j]), dp[i%2][j+1], dp[(i+1)%2][j]) return dp[len(A)%2][len(B)] ", "class Solution def numberOfPoints(self, nums): nums.sort() result = 0 curr = nums[0] for i in xrange(1, len(nums)): if nums[i][0] <= curr[1]: curr[1] = max(curr[1], nums[i][1]) else: result += curr[1]-curr[0]+1 curr = nums[i] result += curr[1]-curr[0]+1 return result ", "class Solution def maxSizeSlices(self, slices): def maxSizeSlicesLinear(slices, start, end): dp = [[0]*(len(slices)//3+1) for _ in xrange(2)] for i in xrange(start, end): for j in reversed(xrange(1, min(((i-start+1)-1)//2+1, len(slices)//3)+1)): dp[i%2][j] = max(dp[(i-1)%2][j], dp[(i-2)%2][j-1] + slices[i]) return dp[(end-1)%2][len(slices)//3] return max(maxSizeSlicesLinear(slices, 0, len(slices)-1), maxSizeSlicesLinear(slices, 1, len(slices))) ", "class Solution def maxSizeSlices(self, slices): def maxSizeSlicesLinear(slices, start, end): dp = [[0]*(len(slices)//3+1) for _ in xrange(3)] for i in xrange(start, end): for j in xrange(1, min(((i-start+1)-1)//2+1, len(slices)//3)+1): dp[i%3][j] = max(dp[(i-1)%3][j], dp[(i-2)%3][j-1] + slices[i]) return dp[(end-1)%3][len(slices)//3] return max(maxSizeSlicesLinear(slices, 0, len(slices)-1), maxSizeSlicesLinear(slices, 1, len(slices))) ", "class Solution def updateBoard(self, board, click): if board[click[0]][click[1]] == 'M': board[click[0]][click[1]] = 'X' return board stk = [click] while stk: r, c = stk.pop() cnt = 0 adj = [] for dr in xrange(-1, 2): for dc in xrange(-1, 2): if dr == dc == 0: continue nr, nc = r+dr, c+dc if not (0 <= nr < len(board) and 0 <= nc < len(board[r])): continue if board[nr][nc] == 'M': cnt += 1 elif board[nr][nc] == 'E': adj.append((nr, nc)) if cnt: board[r][c] = chr(cnt + ord('0')) continue board[r][c] = 'B' for nr, nc in adj: board[nr][nc] = ' ' stk.append((nr, nc)) return board ", "class Solution def updateBoard(self, board, click): if board[click[0]][click[1]] == 'M': board[click[0]][click[1]] = 'X' return board q = [click] while q: new_q = [] for r, c in q: cnt = 0 adj = [] for dr in xrange(-1, 2): for dc in xrange(-1, 2): if dr == dc == 0: continue nr, nc = r+dr, c+dc if not (0 <= nr < len(board) and 0 <= nc < len(board[r])): continue if board[nr][nc] == 'M': cnt += 1 elif board[nr][nc] == 'E': adj.append((nr, nc)) if cnt: board[r][c] = chr(cnt + ord('0')) continue board[r][c] = 'B' for nr, nc in adj: board[nr][nc] = ' ' new_q.append((nr, nc)) q = new_q return board ", "class Solution def sumBase(self, n, k): result = 0 while n: n, r = divmod(n, k) result += r return result ", "class Solution def numMovesStonesII(self, stones): stones.sort() left, min_moves = 0, float(\"inf\") max_moves = max(stones[-1]-stones[1], stones[-2]-stones[0]) - (len(stones)-2) for right in xrange(len(stones)): while stones[right]-stones[left]+1 > len(stones): left += 1 if len(stones)-(right-left+1) == 1 and stones[right]-stones[left]+1 == len(stones)-1: min_moves = min(min_moves, 2) else: min_moves = min(min_moves, len(stones)-(right-left+1)) return [min_moves, max_moves] ", "class Solution def maximumGood(self, statements): def check(mask): return all(((mask>>j)&1) == statements[i][j] for i in xrange(len(statements)) if (mask>>i)&1 for j in xrange(len(statements[i])) if statements[i][j] != 2) def popcount(x): result = 0 while x: x &= x-1 result += 1 return result result = 0 for mask in xrange(1<<len(statements)): if check(mask): result = max(result, popcount(mask)) return result ", "class Solution def minSetSize(self, arr): counting_sort = [0]*len(arr) count = collections.Counter(arr) for c in count.itervalues(): counting_sort[c-1] += 1 result, total = 0, 0 for c in reversed(xrange(len(arr))): if not counting_sort[c]: continue count = min(counting_sort[c], ((len(arr)+1)//2 - total - 1)//(c+1) + 1) result += count total += count*(c+1) if total >= (len(arr)+1)//2: break return result ", "class Solution def isUnivalTree(self, root): s = [root] while s: node = s.pop() if not node: continue if node.val != root.val: return False s.append(node.left) s.append(node.right) return True ", "class Solution def isUnivalTree(self, root): return (not root.left or (root.left.val == root.val and self.isUnivalTree(root.left))) and (not root.right or (root.right.val == root.val and self.isUnivalTree(root.right))) ", "class Solution def sortArray(self, nums): def min_moves(d): def index(x): return d*(len(nums)-1) if x == 0 else x-d lookup = [False]*len(nums) result = len(nums) for i in xrange(len(nums)): if lookup[nums[i]]: continue l = 0 while not lookup[nums[i]]: lookup[nums[i]] = True l += 1 i = index(nums[i]) result -= 1 if l >= 2: result += 2 return result-2*int(nums[d*(len(nums)-1)] != 0) return min(min_moves(0), min_moves(1)) ", "class Solution def sortArray(self, nums): def min_moves(d): def index(x): return d*(len(nums)-1) if x == 0 else x-d a = nums[:] result = 0 for i in xrange(len(a)): l, has_zero = 1, (a[i] == 0) while index(a[i]) != i: j = index(a[i]) a[i], a[j] = a[j], a[i] l += 1 has_zero |= (a[i] == 0) if l >= 2: result += l-1 if has_zero else l+1 return result return min(min_moves(0), min_moves(1)) ", "class Solution def numSubarrayProductLessThanK(self, nums, k): if k <= 1: return 0 result, start, prod = 0, 0, 1 for i, num in enumerate(nums): prod *= num while prod >= k: prod /= nums[start] start += 1 result += i-start+1 return result ", "class Solution def maxScore(self, nums): def popcount(n): count = 0 while n: n &= n-1 count += 1 return count def bits(mask): result = [] i = 0 while mask: if mask&1: result.append(i) i += 1 mask >>= 1 return result dp = [0]*(2**len(nums)) for mask in xrange(3, len(dp)): cnt = popcount(mask) if cnt%2: continue for i, j in itertools.combinations(bits(mask), 2): dp[mask] = max(dp[mask], cnt//2*gcd(nums[i], nums[j]) + dp[mask^(1<<i)^(1<<j)]) return dp[-1] ", "class Solution def verifyPreorder(self, preorder): low, i = float(\"-inf\"), -1 for p in preorder: if p < low: return False while i >= 0 and p > preorder[i]: low = preorder[i] i -= 1 i += 1 preorder[i] = p return True ", "class Solution def verifyPreorder(self, preorder): low = float(\"-inf\") path = [] for p in preorder: if p < low: return False while path and p > path[-1]: low = path[-1] path.pop() path.append(p) return True ", "class Solution def minReorder(self, n, connections): lookup, graph = set(), collections.defaultdict(list) for u, v in connections: lookup.add(u*n+v) graph[v].append(u) graph[u].append(v) result = 0 stk = [(-1, 0)] while stk: parent, u = stk.pop() result += (parent*n+u in lookup) for v in reversed(graph[u]): if v == parent: continue stk.append((u, v)) return result import collections ", "class Solution def minReorder(self, n, connections): def dfs(n, lookup, graph, parent, u): result = (parent*n+u in lookup) for v in graph[u]: if v == parent: continue result += dfs(n, lookup, graph, u, v) return result lookup, graph = set(), collections.defaultdict(list) for u, v in connections: lookup.add(u*n+v) graph[v].append(u) graph[u].append(v) return dfs(n, lookup, graph, -1, 0) ", "class Solution def minImpossibleOR(self, nums): lookup = set(nums) return next(1<<i for i in xrange(31) if 1<<i not in lookup) ", "class Solution def appealSum(self, s): result = curr = 0 lookup = [-1]*26 for i, c in enumerate(s): result += (i-lookup[ord(c)-ord('a')])*(len(s)-i) lookup[ord(c)-ord('a')] = i return result ", "class Solution def appealSum(self, s): result = cnt = 0 lookup = [-1]*26 for i, c in enumerate(s): cnt += i-lookup[ord(c)-ord('a')] lookup[ord(c)-ord('a')] = i result += cnt return result ", "class Solution def maximizeSquareHoleArea(self, n, m, hBars, vBars): def max_gap(arr): result = l = 1 lookup = set(arr) while lookup: x = next(iter(lookup)) left = x while left-1 in lookup: left -= 1 right = x while right+1 in lookup: right += 1 for i in xrange(left, right+1): lookup.remove(i) result = max(result, (right-left+1)+1) return result return min(max_gap(hBars), max_gap(vBars))**2 ", "class Solution def maximizeSquareHoleArea(self, n, m, hBars, vBars): def max_gap(arr): arr.sort() result = l = 1 for i in xrange(len(arr)): l += 1 result = max(result, l) if i+1 != len(arr) and arr[i+1] != arr[i]+1: l = 1 return result return min(max_gap(hBars), max_gap(vBars))**2 ", "class Solution def widestPairOfIndices(self, nums1, nums2): lookup = {0:-1} result = total = 0 for i, (n1, n2) in enumerate(itertools.izip(nums1, nums2)): total += n1-n2 if total not in lookup: lookup[total] = i result = max(result, i-lookup[total]) return result ", "class Solution def insertIntoMaxTree(self, root, val): if not root: return TreeNode(val) if val > root.val: node = TreeNode(val) node.left = root return node curr = root while curr.right and curr.right.val > val: curr = curr.right node = TreeNode(val) curr.right, node.left = node, curr.right return root ", "class Solution def shortestBridge(self, A): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def get_islands(A): islands = [] done = set() for r, row in enumerate(A): for c, val in enumerate(row): if val == 0 or (r, c) in done: continue s = [(r, c)] lookup = set(s) while s: node = s.pop() for d in directions: nei = node[0]+d[0], node[1]+d[1] if not (0 <= nei[0] < len(A) and 0 <= nei[1] < len(A[0])) or nei in lookup or A[nei[0]][nei[1]] == 0: continue s.append(nei) lookup.add(nei) done |= lookup islands.append(lookup) if len(islands) == 2: break return islands lookup, target = get_islands(A) q = collections.deque([(node, 0) for node in lookup]) while q: node, dis = q.popleft() if node in target: return dis-1 for d in directions: nei = node[0]+d[0], node[1]+d[1] if not (0 <= nei[0] < len(A) and 0 <= nei[1] < len(A[0])) or nei in lookup: continue q.append((nei, dis+1)) lookup.add(nei) ", "class Solution def minStickers(self, stickers, target): def minStickersHelper(sticker_counts, target, dp): if \"\".join(target) in dp: return dp[\"\".join(target)] target_count = collections.Counter(target) result = float(\"inf\") for sticker_count in sticker_counts: if sticker_count[target[0]] == 0: continue new_target = [] for k in target_count.keys(): if target_count[k] > sticker_count[k]: new_target += [k]*(target_count[k] - sticker_count[k]) if len(new_target) != len(target): num = minStickersHelper(sticker_counts, new_target, dp) if num != -1: result = min(result, 1+num) dp[\"\".join(target)] = -1 if result == float(\"inf\") else result return dp[\"\".join(target)] sticker_counts = map(collections.Counter, stickers) dp = { \"\":0 } return minStickersHelper(sticker_counts, target, dp) ", "class Solution def maxNumOfSubstrings(self, s): def find_right_from_left(s, first, last, left): right, i = last[ord(s[left])-ord('a')], left while i <= right: if first[ord(s[i])-ord('a')] < left: return -1 right = max(right, last[ord(s[i])-ord('a')]) i += 1 return right first, last = [float(\"inf\")]*26, [float(\"-inf\")]*26 for i, c in enumerate(s): first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i) last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i) result = [\"\"] right = float(\"inf\") for left, c in enumerate(s): if left != first[ord(c)-ord('a')]: continue new_right = find_right_from_left(s, first, last, left) if new_right == -1: continue if left > right: result.append(\"\") right = new_right result[-1] = s[left:right+1] return result ", "class Solution def maxNumOfSubstrings(self, s): def find_right_from_left(s, first, last, left): right, i = last[ord(s[left])-ord('a')], left while i <= right: if first[ord(s[i])-ord('a')] < left: return -1 right = max(right, last[ord(s[i])-ord('a')]) i += 1 return right first, last = [float(\"inf\")]*26, [float(\"-inf\")]*26 for i, c in enumerate(s): first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i) last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i) intervals = [] for c in xrange(len(first)): if first[c] == float(\"inf\"): continue left, right = first[c], find_right_from_left(s, first, last, first[c]) if right != -1: intervals.append((right, left)) intervals.sort() result, prev = [], -1 for right, left in intervals: if left <= prev: continue result.append(s[left:right+1]) prev = right return result ", "class Solution def minimumDistance(self, points): def max_distance(exclude): max_sum = max((x+y, i) for i, (x, y) in enumerate(points) if i != exclude) min_sum = min((x+y, i) for i, (x, y) in enumerate(points) if i != exclude) max_diff = max((x-y, i) for i, (x, y) in enumerate(points) if i != exclude) min_diff = min((x-y, i) for i, (x, y) in enumerate(points) if i != exclude) return max((max_sum[0]-min_sum[0], max_sum[1], min_sum[1]), (max_diff[0]-min_diff[0], max_diff[1], min_diff[1])) _, i, j = max_distance(-1) return min(max_distance(i)[0], max_distance(j)[0]) ", "class Solution def maxScore(self, nums, x): dp = [float(\"-inf\")]*2 dp[nums[0]%2] = nums[0] for i in xrange(1, len(nums)): dp[nums[i]%2] = max(dp[nums[i]%2], dp[(nums[i]+1)%2]-x)+nums[i] return max(dp) ", "class Solution def maxTrailingZeros(self, grid): def factor(x): cnt = [0]*2 for i, p in enumerate([2, 5]): while x and x%p == 0: x //= p cnt[i] += 1 return cnt def add(a, b): return [x+y for x, y in itertools.izip(a, b)] def sub(a, b): return [x-y for x, y in itertools.izip(a, b)] left = [[None for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))] for i in xrange(len(grid)): left[i][0] = factor(grid[i][0]) for j in xrange(1, len(grid[0])): left[i][j] = add(left[i][j-1], factor(grid[i][j])) result = 0 for j in xrange(len(grid[0])): total = [0]*2 for i in xrange(len(grid)): total = add(total, factor(grid[i][j])) up = [0]*2 for i in xrange(len(grid)): right = sub(left[i][-1], left[i][j-1] if j else [0]*2) result = max(result, min(add(left[i][j], up)), min(add(right, up))) up = add(up, factor(grid[i][j])) down = sub(total, up) result = max(result, min(add(left[i][j], down)), min(add(right, down))) return result ", "class Solution def sampleStats(self, count): n = sum(count) mi = next(i for i in xrange(len(count)) if count[i]) * 1.0 ma = next(i for i in reversed(xrange(len(count))) if count[i]) * 1.0 mean = sum(i * v for i, v in enumerate(count)) * 1.0 / n mode = count.index(max(count)) * 1.0 for i in xrange(1, len(count)): count[i] += count[i-1] median1 = bisect.bisect_left(count, (n+1) // 2) median2 = bisect.bisect_left(count, (n+2) // 2) median = (median1+median2) / 2.0 return [mi, ma, mean, median, mode] ", "class Solution def mincostToHireWorkers(self, quality, wage, K): result, qsum = float(\"inf\"), 0 max_heap = [] for r, q in sorted([float(w)/q, q] for w, q in itertools.izip(wage, quality)): qsum += q heapq.heappush(max_heap, -q) if len(max_heap) > K: qsum -= -heapq.heappop(max_heap) if len(max_heap) == K: result = min(result, qsum*r) return result ", "class Solution def minimumTeachings(self, n, languages, friendships): language_sets = map(set, languages) candidates = set(i-1 for u, v in friendships if not language_sets[u-1] & language_sets[v-1] for i in [u, v]) count = collections.Counter() for i in candidates: count += collections.Counter(languages[i]) return len(candidates) - max(count.values() + [0]) ", "class Solution def partitionArray(self, nums, k): nums.sort() result, prev = 1, 0 for i in xrange(len(nums)): if nums[i]-nums[prev] <= k: continue prev = i result += 1 return result ", "class Solution def minimumTime(self, s): left = 0 result = left+(len(s)-0) for i in xrange(1, len(s)+1): left = min(left+2*(s[i-1] == '1'), i) result = min(result, left+(len(s)-i)) return result ", "class Solution def minimumTime(self, s): result, right = len(s), [0]*(len(s)+1) for i in reversed(xrange(len(s))): right[i] = min(right[i+1]+2*(s[i] == '1'), len(s)-i) left = 0 result = left+right[0] for i in xrange(1, len(s)+1): left = min(left+2*(s[i-1] == '1'), i) result = min(result, left+right[i]) return result ", "class Solution def tribonacci(self, n): def matrix_expo(A, K): result = [[int(i==j) for j in xrange(len(A))] for i in xrange(len(A))] while K: if K % 2: result = matrix_mult(result, A) A = matrix_mult(A, A) K /= 2 return result def matrix_mult(A, B): ZB = zip(*B) return [[sum(a*b for a, b in itertools.izip(row, col)) for col in ZB] for row in A] T = [[1, 1, 0], [1, 0, 1], [1, 0, 0]] return matrix_mult([[1, 0, 0]], matrix_expo(T, n))[0][1] ", "class Solution def tribonacci(self, n): a, b, c = 0, 1, 1 for _ in xrange(n): a, b, c = b, c, a+b+c return a ", "class Solution def minmaxGasDist(self, stations, K): def check(x): return sum(int(math.ceil((stations[i+1]-stations[i])/x))-1 for i in xrange(len(stations)-1)) <= K left, right = 0, stations[-1]-stations[0] while right-left > 1e-6: mid = left + (right-left)/2.0 if check(mid): right = mid else: left = mid return left ", "class Solution def findShortestCycle(self, n, edges): INF = float(\"inf\") def bfs(u): result = INF dist = [float(\"inf\")]*len(adj) dist[u] = 0 q = [u] while q: new_q = [] for u in q: for v in adj[u]: if dist[v] != INF: assert(abs(dist[v]-dist[u]) <= 1) if dist[v] != dist[u]-1: result = min(result, 1+dist[u]+dist[v]) continue dist[v] = dist[u]+1 new_q.append(v) if result != INF: break q = new_q return result adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) result = min(bfs(u) for u in xrange(n)) return result if result != INF else -1 ", "class Solution def maxScore(self, prices): cnt = collections.Counter() for i, x in enumerate(prices): cnt[x-i] += x return max(cnt.itervalues()) ", "class Solution def rankTeams(self, votes): count = {v: [0]*len(votes[0]) + [v] for v in votes[0]} for vote in votes: for i, v in enumerate(vote): count[v][i] -= 1 return \"\".join(sorted(votes[0], key=count.__getitem__)) ", "class Solution def searchInsert(self, nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) / 2 if nums[mid] >= target: right = mid - 1 else: left = mid + 1 return left ", "class Solution def maximumSubsequenceCount(self, text, pattern): result = cnt1 = cnt2 = 0 for c in text: if c == pattern[1]: result += cnt1 cnt2 += 1 if c == pattern[0]: cnt1 += 1 return result + max(cnt1, cnt2) ", "class Solution def maximumAverageSubtree(self, root): def maximumAverageSubtreeHelper(root, result): if not root: return [0.0, 0] s1, n1 = maximumAverageSubtreeHelper(root.left, result) s2, n2 = maximumAverageSubtreeHelper(root.right, result) s = s1+s2+root.val n = n1+n2+1 result[0] = max(result[0], s / n) return [s, n] result = [0] maximumAverageSubtreeHelper(root, result) return result[0] ", "class Solution def maximumCost(self, n, highways, k): if k+1 > n: return -1 adj = [[] for _ in xrange(n)] for c1, c2, t in highways: adj[c1].append((c2, t)) adj[c2].append((c1, t)) result = -1 if k != 1 else 0 dp = [[0, []] for _ in xrange((1<<n))] for i in xrange(n): dp[1<<i][1].append(i) for cnt in xrange(1, n+1): for choice in itertools.combinations(xrange(n), cnt): mask = reduce(lambda x, y:x|(1<<y), choice, 0) total, lasts = dp[mask] for u in lasts: for v, t in adj[u]: if mask&(1<<v): continue new_mask = mask|(1<<v) if total+t < dp[new_mask][0]: continue if total+t == dp[new_mask][0]: dp[new_mask][1].append(v) continue dp[new_mask][0] = total+t dp[new_mask][1] = [v] if bin(mask).count('1') == k: result = max(result, dp[new_mask][0]) return result ", "class Solution def maximumCost(self, n, highways, k): if k+1 > n: return -1 adj = [[] for _ in xrange(n)] for c1, c2, t in highways: adj[c1].append((c2, t)) adj[c2].append((c1, t)) result = -1 dp = [(u, 1<<u, 0) for u in xrange(n)] while dp: new_dp = [] for u, mask, total in dp: if bin(mask).count('1') == k+1: result = max(result, total) for v, t in adj[u]: if mask&(1<<v) == 0: new_dp.append((v, mask|(1<<v), total+t)) dp = new_dp return result ", "class Solution def minOperations(self, nums, k): lookup = [False]*k for i in reversed(xrange(len(nums))): if nums[i] > len(lookup) or lookup[nums[i]-1]: continue lookup[nums[i]-1] = True k -= 1 if not k: break return len(nums)-i ", "class Solution def compressedString(self, word): result = [] cnt = 0 for i in xrange(len(word)): cnt += 1 if cnt == 9 or (i+1 == len(word) or word[i+1] != word[i]): result.append(\"%s%s\" % (cnt, word[i])) cnt = 0 return \"\".join(result) ", "class Solution def diagonalSort(self, mat): lookup = collections.defaultdict(list) for i in xrange(len(mat)): for j in xrange(len(mat[0])): lookup[i-j].append(mat[i][j]) for v in lookup.itervalues(): v.sort() for i in reversed(xrange(len(mat))): for j in reversed(xrange(len(mat[0]))): mat[i][j] = lookup[i-j].pop() return mat ", "class Solution def minimumTotalDistance(self, robot, factory): robot.sort(), factory.sort() dp = [float(\"inf\")]*(len(robot)+1) dp[0] = 0 for i in xrange(len(factory)): prefix = 0 dq = collections.deque([(dp[0]-prefix, 0)]) for j in xrange(1, len(robot)+1): prefix += abs(robot[j-1]-factory[i][0]) if j-dq[0][1] == factory[i][1]+1: dq.popleft() while dq and dq[-1][0] >= dp[j]-prefix: dq.pop() dq.append((dp[j]-prefix, j)) dp[j] = dq[0][0]+prefix return dp[-1] import collections ", "class Solution def minimumTotalDistance(self, robot, factory): robot.sort(), factory.sort() dp = [float(\"inf\")]*(len(robot)+1) dp[0] = 0 for i in xrange(len(factory)): for j in reversed(xrange(1, len(robot)+1)): curr = 0 for k in xrange(min(factory[i][1], j)+1): dp[j] = min(dp[j], dp[j-k]+curr) if (j-1)-k >= 0: curr += abs(robot[(j-1)-k]-factory[i][0]) return dp[-1] ", "class Solution def mostPoints(self, questions): dp = [0]*(len(questions)+1) for i in reversed(xrange(len(dp)-1)): dp[i] = max(dp[i+1], questions[i][0] + (dp[i+1+questions[i][1]] if i+1+questions[i][1] < len(dp) else 0)) return dp[0] ", "class Solution def thousandSeparator(self, n): result = [] s = str(n) for i, c in enumerate(str(n)): if i and (len(s)-i)%3 == 0: result.append(\".\") result.append(c) return \"\".join(result) ", "class Solution def smallestFromLeaf(self, root): def dfs(node, candidate, result): if not node: return candidate.append(chr(ord('a') + node.val)) if not node.left and not node.right: result[0] = min(result[0], \"\".join(reversed(candidate))) dfs(node.left, candidate, result) dfs(node.right, candidate, result) candidate.pop() result = [\"~\"] dfs(root, [], result) return result[0] ", "class Solution def numberOfWays(self, startPos, endPos, k): MOD = 10**9+7 fact, inv, inv_fact = [[1]*2 for _ in xrange(3)] def nCr(n, k): while len(inv) <= n: fact.append(fact[-1]*len(inv) % MOD) inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) inv_fact.append(inv_fact[-1]*inv[-1] % MOD) return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD r = k-abs(endPos-startPos) return nCr(k, r//2) if r >= 0 and r%2 == 0 else 0 ", "class Solution def maxIncreasingCells(self, mat): lookup = collections.defaultdict(list) for i in xrange(len(mat)): for j in xrange(len(mat[0])): lookup[mat[i][j]].append((i, j)) dp = [[0]*len(mat[0]) for _ in xrange(len(mat))] row, col = [0]*len(mat), [0]*len(mat[0]) for x in sorted(lookup.iterkeys()): for i, j in lookup[x]: dp[i][j] = max(row[i], col[j])+1 for i, j in lookup[x]: row[i] = max(row[i], dp[i][j]) col[j] = max(col[j], dp[i][j]) return max(row) ", "class Solution def sortTheStudents(self, score, k): score.sort(key=lambda x: x[k], reverse=True) return score ", "class Solution def removeElements(self, head, val): dummy = ListNode(float(\"-inf\")) dummy.next = head prev, curr = dummy, dummy.next while curr: if curr.val == val: prev.next = curr.next else: prev = curr curr = curr.next return dummy.next ", "class Solution def minMovesToCaptureTheQueen(self, a, b, c, d, e, f): if a == e and not (a == c and (b-d)*(f-d) < 0): return 1 if b == f and not (b == d and (a-c)*(e-c) < 0): return 1 if c+d == e+f and not (c+d == a+b and (c-a)*(e-a) < 0): return 1 if c-d == e-f and not (c-d == a-b and (d-b)*(f-b) < 0): return 1 return 2 ", "class Solution def findRedundantConnection(self, edges): union_find = UnionFind(len(edges)+1) for edge in edges: if not union_find.union_set(*edge): return edge return [] ", "class Solution def pacificAtlantic(self, matrix): PACIFIC, ATLANTIC = 1, 2 def pacificAtlanticHelper(matrix, x, y, prev_height, prev_val, visited, res): if (not 0 <= x < len(matrix)) or (not 0 <= y < len(matrix[0])) or matrix[x][y] < prev_height or (visited[x][y] | prev_val) == visited[x][y]: return visited[x][y] |= prev_val if visited[x][y] == (PACIFIC | ATLANTIC): res.append((x, y)) for d in [(0, -1), (0, 1), (-1, 0), (1, 0)]: pacificAtlanticHelper(matrix, x + d[0], y + d[1], matrix[x][y], visited[x][y], visited, res) if not matrix: return [] res = [] m, n = len(matrix),len(matrix[0]) visited = [[0 for _ in xrange(n)] for _ in xrange(m)] for i in xrange(m): pacificAtlanticHelper(matrix, i, 0, float(\"-inf\"), PACIFIC, visited, res) pacificAtlanticHelper(matrix, i, n - 1, float(\"-inf\"), ATLANTIC, visited, res) for j in xrange(n): pacificAtlanticHelper(matrix, 0, j, float(\"-inf\"), PACIFIC, visited, res) pacificAtlanticHelper(matrix, m - 1, j, float(\"-inf\"), ATLANTIC, visited, res) return res ", "class Solution def getMaximumXor(self, nums, maximumBit): result = [0]*len(nums) mask = 2**maximumBit-1 for i in xrange(len(nums)): mask ^= nums[i] result[-1-i] = mask return result ", "class Solution def timeRequiredToBuy(self, tickets, k): return sum(min(x, tickets[k] if i <= k else tickets[k]-1) for i, x in enumerate(tickets)) ", "class Solution def isPathCrossing(self, path): x = y = 0 lookup = {(0, 0)} for c in path: if c == 'E': x += 1 elif c == 'W': x -= 1 elif c == 'N': y += 1 elif c == 'S': y -= 1 if (x, y) in lookup: return True lookup.add((x, y)) return False ", "class Solution def trimBST(self, root, L, R): if not root: return None if root.val < L: return self.trimBST(root.right, L, R) if root.val > R: return self.trimBST(root.left, L, R) root.left, root.right = self.trimBST(root.left, L, R), self.trimBST(root.right, L, R) return root ", "class Solution def reverseWords(self, s): def reverse(s, begin, end): for i in xrange((end - begin) // 2): s[begin + i], s[end - 1 - i] = s[end - 1 - i], s[begin + i] s, i = list(s), 0 for j in xrange(len(s) + 1): if j == len(s) or s[j] == ' ': reverse(s, i, j) i = j + 1 return \"\".join(s) ", "class Solution def reverseWords(self, s): reversed_words = [word[::-1] for word in s.split(' ')] return ' '.join(reversed_words) ", "class Solution def minimizedMaximum(self, n, quantities): def ceil_divide(a, b): return (a+(b-1))//b def check(n, quantities, x): return sum(ceil_divide(q, x) for q in quantities) <= n left, right = 1, max(quantities) while left <= right: mid = left+(right-left)//2 if check(n, quantities, mid): right = mid-1 else: left = mid+1 return left ", "class Solution def replaceElements(self, arr): curr_max = -1 for i in reversed(xrange(len(arr))): arr[i], curr_max = curr_max, max(curr_max, arr[i]) return arr ", "class Solution def busyStudent(self, startTime, endTime, queryTime): return sum(s <= queryTime <= e for s, e in itertools.izip(startTime, endTime)) ", "class Solution def orderlyQueue(self, S, K): if K == 1: return min(S[i:] + S[:i] for i in xrange(len(S))) return \"\".join(sorted(S)) ", "class Solution def minMoves(self, nums): return sum(nums) - len(nums) * min(nums) ", "class Solution def minimumCoins(self, prices): dp = [float(\"inf\")]*(len(prices)+1) dp[0] = 0 dq = collections.deque() j = 0 for i in xrange(len(prices)): while dq and dp[dq[-1]]+prices[dq[-1]] >= dp[i]+prices[i]: dq.pop() dq.append(i) while j+(j+1) < i: assert(len(dq) != 0) if dq[0] == j: dq.popleft() j += 1 dp[i+1] = dp[dq[0]]+prices[dq[0]] return dp[-1] from sortedcontainers import SortedList ", "class Solution def minimumCoins(self, prices): dp = [float(\"inf\")]*(len(prices)+1) dp[0] = 0 sl = SortedList() j = 0 for i in xrange(len(prices)): sl.add((dp[i]+prices[i], i)) while j+(j+1) < i: sl.remove(((dp[j]+prices[j], j))) j += 1 dp[i+1] = sl[0][0] return dp[-1] ", "class Solution def minimumCoins(self, prices): dp = [float(\"inf\")]*(len(prices)+1) dp[0] = 0 for i in xrange(len(prices)): for j in xrange(i//2, i+1): dp[i+1] = min(dp[i+1], dp[j]+prices[j]) return dp[-1] ", "class Solution def topKFrequent(self, nums, k): counts = collections.Counter(nums) buckets = [[] for _ in xrange(len(nums)+1)] for i, count in counts.iteritems(): buckets[count].append(i) result = [] for i in reversed(xrange(len(buckets))): for j in xrange(len(buckets[i])): result.append(buckets[i][j]) if len(result) == k: return result return result from random import randint ", "class Solution def topKFrequent(self, nums, k): counts = collections.Counter(nums) p = [] for key, val in counts.iteritems(): p.append((-val, key)) self.kthElement(p, k-1) result = [] for i in xrange(k): result.append(p[i][1]) return result def kthElement(self, nums, k): def PartitionAroundPivot(left, right, pivot_idx, nums): pivot_value = nums[pivot_idx] new_pivot_idx = left nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx] for i in xrange(left, right): if nums[i] < pivot_value: nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i] new_pivot_idx += 1 nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right] return new_pivot_idx left, right = 0, len(nums) - 1 while left <= right: pivot_idx = randint(left, right) new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums) if new_pivot_idx == k: return elif new_pivot_idx > k: right = new_pivot_idx - 1 else: left = new_pivot_idx + 1 ", "class Solution def topKFrequent(self, nums, k): return [key for key, _ in collections.Counter(nums).most_common(k)] ", "class Solution def checkInclusion(self, s1, s2): counts = collections.Counter(s1) l = len(s1) for i in xrange(len(s2)): if counts[s2[i]] > 0: l -= 1 counts[s2[i]] -= 1 if l == 0: return True start = i + 1 - len(s1) if start >= 0: counts[s2[start]] += 1 if counts[s2[start]] > 0: l += 1 return False ", "class Solution def canConstruct(self, ransomNote, magazine): counts = [0] * 26 letters = 0 for c in ransomNote: if counts[ord(c) - ord('a')] == 0: letters += 1 counts[ord(c) - ord('a')] += 1 for c in magazine: counts[ord(c) - ord('a')] -= 1 if counts[ord(c) - ord('a')] == 0: letters -= 1 if letters == 0: break return letters == 0 import collections ", "class Solution def canConstruct(self, ransomNote, magazine): return not collections.Counter(ransomNote) - collections.Counter(magazine) ", "class Solution def areaOfMaxDiagonal(self, dimensions): return max((l**2+w**2, l*w) for l, w in dimensions)[1] ", "class Solution def maxPerformance(self, n, speed, efficiency, k): MOD = 10**9 + 7 result, s_sum = 0, 0 min_heap = [] for e, s in sorted(itertools.izip(efficiency, speed), reverse=True): s_sum += s heapq.heappush(min_heap, s) if len(min_heap) > k: s_sum -= heapq.heappop(min_heap) result = max(result, s_sum*e) return result % MOD ", "class Solution def numberOfWays(self, n, m, k, source, dest): MOD = 10**9+7 def matrix_mult(A, B): ZB = zip(*B) return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A] def matrix_expo(A, K): result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))] while K: if K % 2: result = matrix_mult(result, A) A = matrix_mult(A, A) K /= 2 return result T = [[0, m-1, n-1, 0], [1, m-2, 0, n-1], [1, 0, n-2, m-1], [0, 1, 1, (n-2)+(m-2)]] dp = [0]*4 if source == dest: dp[0] = 1 elif source[0] == dest[0]: dp[1] = 1 elif source[1] == dest[1]: dp[2] = 1 else: dp[3] = 1 dp = matrix_mult([dp], matrix_expo(T, k))[0] return dp[0] ", "class Solution def numberOfWays(self, n, m, k, source, dest): MOD = 10**9+7 both_same = row_same = col_same = no_same = 0 if source == dest: both_same = 1 elif source[0] == dest[0]: row_same = 1 elif source[1] == dest[1]: col_same = 1 else: no_same = 1 for _ in xrange(k): both_same, row_same, col_same, no_same = (row_same+col_same)%MOD, (both_same*(m-1)+row_same*(m-2)+no_same)%MOD, (both_same*(n-1)+col_same*(n-2)+no_same)%MOD, (row_same*(n-1)+col_same*(m-1)+no_same*((n-2)+(m-2)))%MOD return both_same ", "class Solution def minimumPushes(self, word): def ceil_divide(a, b): return (a+b-1)//b return sum((i+1)*min(len(word)-i*(9-2+1), (9-2+1)) for i in xrange(ceil_divide(len(word), (9-2+1)))) import collections ", "class Solution def minimumPushes(self, word): return sum(x*(i//(9-2+1)+1) for i, x in enumerate(sorted(collections.Counter(word).itervalues(), reverse=True))) ", "class Solution def __init__(self): self.__buf4 = [''] * 4 self.__i4 = 0 self.__n4 = 0 def read(self, buf, n): i = 0 while i < n: if self.__i4 < self.__n4: buf[i] = self.__buf4[self.__i4] i += 1 self.__i4 += 1 else: self.__n4 = read4(self.__buf4) if self.__n4: self.__i4 = 0 else: break return i ", "class Solution def minInsertions(self, s): def longestCommonSubsequence(text1, text2): if len(text1) < len(text2): return self.longestCommonSubsequence(text2, text1) dp = [[0 for _ in xrange(len(text2)+1)] for _ in xrange(2)] for i in xrange(1, len(text1)+1): for j in xrange(1, len(text2)+1): dp[i%2][j] = dp[(i-1)%2][j-1]+1 if text1[i-1] == text2[j-1] else max(dp[(i-1)%2][j], dp[i%2][j-1]) return dp[len(text1)%2][len(text2)] return len(s)-longestCommonSubsequence(s, s[::-1]) ", "class Solution def findValidSplit(self, nums): def factorize(x): result = [] d = 2 while d*d <= x: e = 0 while x%d == 0: x //= d e += 1 if e: result.append([d, e]) d += 1 if d == 2 else 2 if x > 1: result.append([x, 1]) return result right = collections.Counter() for x in reversed(nums): for p, c in factorize(x): right[p] += c left = collections.Counter() cnt = 0 for i in xrange(len(nums)-1): for p, c in factorize(nums[i]): if not left[p]: cnt += 1 left[p] += c right[p] -= c if not right[p]: cnt -= 1 if not cnt: return i return -1 ", "class Solution def pushDominoes(self, dominoes): force = [0]*len(dominoes) f = 0 for i in xrange(len(dominoes)): if dominoes[i] == 'R': f = len(dominoes) elif dominoes[i] == 'L': f = 0 else: f = max(f-1, 0) force[i] += f f = 0 for i in reversed(xrange(len(dominoes))): if dominoes[i] == 'L': f = len(dominoes) elif dominoes[i] == 'R': f = 0 else: f = max(f-1, 0) force[i] -= f return \"\".join('.' if f == 0 else 'R' if f > 0 else 'L' for f in force) ", "class Solution def robotWithString(self, s): cnt = collections.Counter(s) result, stk = [], [] mn = 'a' for c in s: stk.append(c) cnt[c] -= 1 while mn < 'z' and cnt[mn] == 0: mn = chr(ord(mn)+1) while stk and stk[-1] <= mn: result.append(stk.pop()) return \"\".join(result) ", "class Solution def constructMaximumBinaryTree(self, nums): nodeStack = [] for num in nums: node = TreeNode(num) while nodeStack and num > nodeStack[-1].val: node.left = nodeStack.pop() if nodeStack: nodeStack[-1].right = node nodeStack.append(node) return nodeStack[0] ", "class Solution def splitIntoFibonacci(self, S): def startswith(S, k, x): y = 0 for i in xrange(k, len(S)): y = 10*y + int(S[i]) if y == x: return i-k+1 elif y > x: break return 0 MAX_INT = 2**31-1 a = 0 for i in xrange(len(S)-2): a = 10*a + int(S[i]) b = 0 for j in xrange(i+1, len(S)-1): b = 10*b + int(S[j]) fib = [a, b] k = j+1 while k < len(S): if fib[-2] > MAX_INT-fib[-1]: break c = fib[-2]+fib[-1] length = startswith(S, k, c) if length == 0: break fib.append(c) k += length else: return fib if b == 0: break if a == 0: break return [] ", "class Solution def mirrorReflection(self, p, q): return 2 if (p & -p) > (q & -q) else 0 if (p & -p) < (q & -q) else 1 ", "class Solution def mirrorReflection(self, p, q): def gcd(a, b): while b: a, b = b, a % b return a lcm = p*q // gcd(p, q) if lcm // p % 2 == 1: if lcm // q % 2 == 1: return 1 return 2 return 0 ", "class Solution def topKFrequent(self, words, k): counts = collections.Counter(words) p = [] for key, val in counts.iteritems(): p.append((-val, key)) self.kthElement(p, k-1) result = [] sorted_p = sorted(p[:k]) for i in xrange(k): result.append(sorted_p[i][1]) return result def kthElement(self, nums, k): def PartitionAroundPivot(left, right, pivot_idx, nums): pivot_value = nums[pivot_idx] new_pivot_idx = left nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx] for i in xrange(left, right): if nums[i] < pivot_value: nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i] new_pivot_idx += 1 nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right] return new_pivot_idx left, right = 0, len(nums) - 1 while left <= right: pivot_idx = randint(left, right) new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums) if new_pivot_idx == k: return elif new_pivot_idx > k: right = new_pivot_idx - 1 else: left = new_pivot_idx + 1 ", "class Solution def topKFrequent(self, words, k): class MinHeapObj(object): def __init__(self,val): self.val = val def __lt__(self,other): return self.val[1] > other.val[1] if self.val[0] == other.val[0] else self.val < other.val def __eq__(self,other): return self.val == other.val def __str__(self): return str(self.val) counts = collections.Counter(words) min_heap = [] for word, count in counts.iteritems(): heapq.heappush(min_heap, MinHeapObj((count, word))) if len(min_heap) == k+1: heapq.heappop(min_heap) result = [] while min_heap: result.append(heapq.heappop(min_heap).val[1]) return result[::-1] ", "class Solution def topKFrequent(self, words, k): counts = collections.Counter(words) buckets = [[] for _ in xrange(len(words)+1)] for word, count in counts.iteritems(): buckets[count].append(word) pairs = [] for i in reversed(xrange(len(words))): for word in buckets[i]: pairs.append((-i, word)) if len(pairs) >= k: break pairs.sort() return [pair[1] for pair in pairs[:k]] from collections import Counter ", "class Solution def topKFrequent(self, words, k): counter = Counter(words) candidates = counter.keys() candidates.sort(key=lambda w: (-counter[w], w)) return candidates[:k] ", "class Solution def canPermutePalindrome(self, s): return sum(v % 2 for v in collections.Counter(s).values()) < 2 ", "class Solution def rotateTheBox(self, box): result = [['.']*len(box) for _ in xrange(len(box[0]))] for i in xrange(len(box)): k = len(box[0])-1 for j in reversed(xrange(len(box[0]))): if box[i][j] == '.': continue if box[i][j] == '*': k = j result[k][-1-i] = box[i][j] k -= 1 return result ", "class Solution def numIslands(self, grid): def index(n, i, j): return i*n + j if not grid: return 0 zero_count = 0 union_find = UnionFind(len(grid)*len(grid[0])) for i in xrange(len(grid)): for j in xrange(len(grid[0])): if grid[i][j] == '1': if i and grid[i-1][j] == '1': union_find.union_set(index(len(grid[0]), i-1, j), index(len(grid[0]),i, j)) if j and grid[i][j-1] == '1': union_find.union_set(index(len(grid[0]), i, j-1), index(len(grid[0]), i, j)) else: zero_count += 1 return union_find.count-zero_count ", "class Solution def numIslands(self, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(grid, i, j): if grid[i][j] == '0': return False grid[i][j] = '0' stk = [(i, j)] while stk: r, c = stk.pop() for dr, dc in directions: nr, nc = r+dr, c+dc if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == '1'): continue grid[nr][nc] = '0' stk.append((nr, nc)) return True count = 0 for i in xrange(len(grid)): for j in xrange(len(grid[0])): if dfs(grid, i, j): count += 1 return count import collections ", "class Solution def numIslands(self, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def bfs(grid, i, j): if grid[i][j] == '0': return False grid[i][j] ='0' q = collections.deque([(i, j)]) while q: r, c = q.popleft() for dr, dc in directions: nr, nc = r+dr, c+dc if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == '1'): continue grid[nr][nc] = '0' q.append((nr, nc)) return True count = 0 for i in xrange(len(grid)): for j in xrange(len(grid[0])): if bfs(grid, i, j): count += 1 return count ", "class Solution def kMirror(self, k, n): def mirror(n, base, odd): result = n if odd: n //= base while n: result = result*base+n%base n //= base return result def num_gen(base): prefix_num, total = [1]*2, [base]*2 odd = 1 while True: x = mirror(prefix_num[odd], base, odd) prefix_num[odd] += 1 if prefix_num[odd] == total[odd]: total[odd] *= base odd ^= 1 yield x def reverse(n, base): result = 0 while n: result = result*base+n%base n = n//base return result def mirror_num(gen, base): while True: x = next(gen) if x == reverse(x, base): break return x base1, base2 = k, 10 gen = num_gen(base1) return sum(mirror_num(gen, base2) for _ in xrange(n)) ", "class Solution def kMirror(self, k, n): def num_gen(k): digits = ['0'] while True: for i in xrange(len(digits)//2, len(digits)): if int(digits[i])+1 < k: digits[i] = digits[-1-i] = str(int(digits[i])+1) break digits[i] = digits[-1-i] = '0' else: digits.insert(0, '1') digits[-1] = '1' yield \"\".join(digits) def mirror_num(gen): while True: x = int(next(gen, k), k) if str(x) == str(x)[::-1]: break return x gen = num_gen(k) return sum(mirror_num(gen) for _ in xrange(n)) ", "class Solution def maximumBobPoints(self, numArrows, aliceArrows): def check(mask, numArrows): score = 0 cnt = [0]*len(aliceArrows) i, base = 0, 1 for k, a in enumerate(aliceArrows): if mask&1: need = a+1 if need > numArrows: return 0, [0]*len(aliceArrows) numArrows -= need cnt[k] = need score += k mask >>= 1 cnt[-1] += numArrows return score, cnt result = [0]*len(aliceArrows) best = 0 for mask in xrange(1, 2**len(aliceArrows)): score, cnt = check(mask, numArrows) if score > best: best = score result = cnt return result ", "class Solution def minDeletions(self, s): count = collections.Counter(s) result = 0 lookup = set() for c in string.ascii_lowercase: for i in reversed(xrange(1, count[c]+1)): if i not in lookup: lookup.add(i) break result += 1 return result ", "class Solution def reverseWords(self, s): def reverse(s, begin, end): for i in xrange((end - begin) / 2): s[begin + i], s[end - 1 - i] = s[end - 1 - i], s[begin + i] reverse(s, 0, len(s)) i = 0 for j in xrange(len(s) + 1): if j == len(s) or s[j] == ' ': reverse(s, i, j) i = j + 1 ", "class Solution def maxTotalReward(self, rewardValues): mx = max(rewardValues) dp = 1 mask = (1<<mx)-1 for v in sorted(set(rewardValues)): x = dp&((1<<v)-1) dp |= (x<<v)&mask return mx+(dp.bit_length()-1) ", "class Solution def maxTotalReward(self, rewardValues): dp = 1 for v in sorted(set(rewardValues)): x = dp&((1<<v)-1) dp |= x<<v return dp.bit_length()-1 ", "class Solution def maxTotalReward(self, rewardValues): mx = max(rewardValues) dp = [False]*((mx-1)+1) dp[0] = True for v in sorted(set(rewardValues)): for x in xrange(min(v, mx-v)): dp[x+v] |= dp[x] return mx+next(x for x in reversed(xrange(len(dp))) if dp[x]) ", "class Solution def maxTotalReward(self, rewardValues): dp = [False]*((max(rewardValues)*2-1)+1) dp[0] = True for v in sorted(set(rewardValues)): for x in xrange(v): dp[x+v] |= dp[x] return next(x for x in reversed(xrange(len(dp))) if dp[x]) ", "class Solution def maximumBeauty(self, flowers): lookup = {} prefix = [0] result = float(\"-inf\") for i, f in enumerate(flowers): prefix.append(prefix[-1]+f if f > 0 else prefix[-1]) if not f in lookup: lookup[f] = i continue result = max(result, 2*f+prefix[i+1]-prefix[lookup[f]] if f < 0 else prefix[i+1]-prefix[lookup[f]]) return result ", "class Solution def minMoves2(self, nums): def kthElement(nums, k): def PartitionAroundPivot(left, right, pivot_idx, nums): pivot_value = nums[pivot_idx] new_pivot_idx = left nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx] for i in xrange(left, right): if nums[i] > pivot_value: nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i] new_pivot_idx += 1 nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right] return new_pivot_idx left, right = 0, len(nums) - 1 while left <= right: pivot_idx = randint(left, right) new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums) if new_pivot_idx == k: return nums[new_pivot_idx] elif new_pivot_idx > k: right = new_pivot_idx - 1 else: left = new_pivot_idx + 1 median = kthElement(nums, len(nums)//2) return sum(abs(num - median) for num in nums) def minMoves22(self, nums): median = sorted(nums)[len(nums) / 2] return sum(abs(num - median) for num in nums) ", "class Solution def minimumPartition(self, s, k): result = 1 curr = 0 for c in s: if int(c) > k: return -1 if curr*10+int(c) > k: result += 1 curr = 0 curr = curr*10+int(c) return result ", "class Solution def maximumWealth(self, accounts): return max(itertools.imap(sum, accounts)) ", "class Solution def minimumOneBitOperations(self, n): def gray_to_binary(n): result = 0 while n: result ^= n n >>= 1 return result return gray_to_binary(n) ", "class Solution def minimumOneBitOperations(self, n): result = 0 while n: result = -result - (n^(n-1)) n &= n-1 return abs(result) ", "class Solution def closetTarget(self, words, target, startIndex): INF = float(\"inf\") result = INF for i, w in enumerate(words): if w == target: result = min(result, (i-startIndex)%len(words), (startIndex-i)%len(words)) return result if result != INF else -1 ", "class Solution def maxNumber(self, n): return (1<<(n.bit_length()-1))-1 ", "class Solution def maximumRows(self, matrix, numSelect): def next_popcount(n): lowest_bit = n&-n left_bits = n+lowest_bit changed_bits = n^left_bits right_bits = (changed_bits//lowest_bit)>>2 return left_bits|right_bits masks = [reduce(lambda m, c: m|(matrix[r][-1-c]<<c), xrange(len(matrix[0])), 0) for r in xrange(len(matrix))] result = 0 mask = (1<<numSelect)-1 while mask < 1<<len(matrix[0]): result = max(result, sum((m&mask) == m for m in masks)) mask = next_popcount(mask) return result ", "class Solution def surfaceArea(self, grid): result = 0 for i in xrange(len(grid)): for j in xrange(len(grid)): if grid[i][j]: result += 2 + grid[i][j]*4 if i: result -= min(grid[i][j], grid[i-1][j])*2 if j: result -= min(grid[i][j], grid[i][j-1])*2 return result ", "class Solution def minCostToEqualizeArray(self, nums, cost1, cost2): MOD = 10**9+7 n = len(nums) mx = max(nums) total = mx*n-sum(nums) if n <= 2 or cost1*2 <= cost2: return total*cost1%MOD result = float(\"inf\") mn = min(nums) cnt1 = max((mx-mn)-(total-(mx-mn)), 0) cnt2 = total-cnt1 result = min(result, (cnt1+cnt2%2)*cost1 + cnt2//2*cost2) x, cnt1 = divmod(cnt1, (n-2)) total += n*x cnt2 = total-cnt1 result = min(result, (cnt1+cnt2%2)*cost1 + (cnt2//2)*cost2) for _ in xrange(2): total += n result = min(result, total%2*cost1 + total//2*cost2) return result%MOD ", "class Solution def sequentialDigits(self, low, high): result = [] q = collections.deque(range(1, 9)) while q: num = q.popleft() if num > high: continue if low <= num: result.append(num) if num%10+1 < 10: q.append(num*10+num%10+1) return result ", "class Solution def edgeScore(self, edges): score = [0]*len(edges) for u, v in enumerate(edges): score[v] += u return max(xrange(len(edges)), key=lambda x:score[x]) ", "class Solution def canMerge(self, trees): def find_leaves_and_roots(trees, leaf_vals_set, val_to_root): for root in trees: val_to_root[root.val] = root q = [root] while q: new_q = [] for node in q: if node.left is None and node.right is None: if node is not root: leaf_vals_set.add(node.val) continue if node.left: new_q.append(node.left) if node.right: new_q.append(node.right) q = new_q def find_root(trees, left_vals_set, val_to_root): root = None for node in trees: if node.val in leaf_vals_set: continue if root: return None root = node return root def merge_bsts(root, left_vals_set, val_to_root): if not root: return None del val_to_root[root.val] q = [(root, float(\"-inf\"), float(\"inf\"))] while q: new_q = [] for node, left, right in q: if not (left < node.val < right): return None if node.left: if node.left.val in leaf_vals_set and node.left.val in val_to_root: node.left = val_to_root[node.left.val] del val_to_root[node.left.val] new_q.append((node.left, left, node.val)) if node.right: if node.right.val in leaf_vals_set and node.right.val in val_to_root: node.right = val_to_root[node.right.val] del val_to_root[node.right.val] new_q.append((node.right, node.val, right)) q = new_q return root if not val_to_root else None leaf_vals_set, val_to_root = set(), {} find_leaves_and_roots(trees, leaf_vals_set, val_to_root) root = find_root(trees, leaf_vals_set, val_to_root) return merge_bsts(root, leaf_vals_set, val_to_root) ", "class Solution def removeDuplicates(self, S): result = [] for c in S: if result and result[-1] == c: result.pop() else: result.append(c) return \"\".join(result) ", "class Solution def numSubarrayBoundedMax(self, A, L, R): def count(A, bound): result, curr = 0, 0 for i in A : curr = curr + 1 if i <= bound else 0 result += curr return result return count(A, R) - count(A, L-1) ", "class Solution def numberOfSets(self, n, maxDistance, roads): def check(mask, dist): return all(dist[i][j] <= maxDistance for i in xrange(n) if mask&(1<<i) for j in xrange(i+1, n) if mask&(1<<j)) def floydWarshall(dist, k): for i in xrange(len(dist)): for j in xrange(i+1, len(dist[i])): dist[j][i] = dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) def backtracking(i, mask, dist): if i == n: result[0] += check(mask, dist) return for j in xrange(2): new_dist = [d[:] for d in dist] if j: floydWarshall(new_dist, i) backtracking(i+1, mask|(j<<i), new_dist) dist = [[0 if u == v else float(\"inf\") for v in xrange(n)] for u in xrange(n)] for u, v, w in roads: dist[u][v] = min(dist[u][v], w) dist[v][u] = min(dist[v][u], w) result = [0] backtracking(0, 0, [d[:] for d in dist]) return result[0] ", "class Solution def numberOfSets(self, n, maxDistance, roads): def check(mask, dist): return all(dist[i][j] <= maxDistance for i in xrange(n) if mask&(1<<i) for j in xrange(i+1, n) if mask&(1<<j)) def floydWarshall(mask, dist): for k in xrange(len(dist[0])): if mask&(1<<k) == 0: continue for i in xrange(len(dist)): if mask&(1<<i) == 0: continue for j in xrange(i+1, len(dist[i])): if mask&(1<<j) == 0: continue dist[j][i] = dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) return check(mask, dist) dist = [[0 if u == v else float(\"inf\") for v in xrange(n)] for u in xrange(n)] for u, v, w in roads: dist[u][v] = min(dist[u][v], w) dist[v][u] = min(dist[v][u], w) return sum(floydWarshall(mask, [d[:] for d in dist]) for mask in xrange(1<<n)) ", "class Solution def makeStringSorted(self, s): def inverse(n, m): i = len(inv) while len(inv) <= n: inv.append(inv[m%i]*(m-m//i) % m) i += 1 return inv[n] MOD = 10**9+7 count, result, comb_total = [0]*26, 0, 1 for i in reversed(xrange(len(s))): num = ord(s[i])-ord('a') count[num] += 1 comb_total = (comb_total*(len(s)-i))*inverse(count[num], MOD) result = (result + (comb_total*sum(count[:num]))*inverse(len(s)-i, MOD)) % MOD return result ", "class Solution def maxTwoEvents(self, events): events.sort() result = best = 0 min_heap = [] for left, right, v in events: heapq.heappush(min_heap, (right, v)) while min_heap and min_heap[0][0] < left: best = max(best, heapq.heappop(min_heap)[1]) result = max(result, best+v) return result ", "class Solution def minTrioDegree(self, n, edges): adj = [set() for _ in xrange(n+1)] degree = [0]*(n+1) for u, v in edges: adj[min(u, v)].add(max(u, v)) degree[u] += 1 degree[v] += 1 result = float(\"inf\") for u in xrange(1, n+1): for v in adj[u]: for w in adj[u]: if v < w and w in adj[v]: result = min(result, degree[u]+degree[v]+degree[w] - 6) return result if result != float(\"inf\") else -1 ", "class Solution def removeDigit(self, number, digit): i = next((i for i in xrange(len(number)-1) if digit == number[i] < number[i+1]), len(number)-1) if i+1 == len(number): i = next((i for i in reversed(xrange(len(number))) if digit == number[i])) return number[:i]+number[i+1:] ", "class Solution def maximumTastiness(self, price, k): def check(x): cnt = prev = 0 for i in xrange(len(price)): if prev and price[i]-prev < x: continue cnt += 1 if cnt == k: break prev = price[i] return cnt >= k price.sort() left, right = 1, price[-1]-price[0] while left <= right: mid = left + (right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right ", "class Solution def countTriplets(self, A): def FWT(A, v): B = A[:] d = 1 while d < len(B): for i in xrange(0, len(B), d << 1): for j in xrange(d): B[i+j] += B[i+j+d] * v d <<= 1 return B k = 3 n, max_A = 1, max(A) while n <= max_A: n *= 2 count = collections.Counter(A) B = [count[i] for i in xrange(n)] C = FWT(map(lambda x : x**k, FWT(B, 1)), -1) return C[0] import collections ", "class Solution def countTriplets(self, A): count = collections.defaultdict(int) for i in xrange(len(A)): for j in xrange(len(A)): count[A[i]&A[j]] += 1 result = 0 for k in xrange(len(A)): for v in count: if A[k]&v == 0: result += count[v] return result ", "class Solution def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount): def left(curr): return curr[-1] if len(curr)%n else 0 def up(curr): return curr[-n] if len(curr) >= n else 0 def count_total(curr, t, total): return (total - 30*((left(curr) == 1)+(up(curr) == 1)) + 20*((left(curr) == 2)+(up(curr) == 2)) + (120 - 30*((left(curr) != 0)+(up(curr) != 0)))*(t == 1) + ( 40 + 20*((left(curr) != 0)+(up(curr) != 0)))*(t == 2)) def iter_backtracking(i, e): result = 0 curr = [] stk = [(2, (i, e, 0))] while stk: step, params = stk.pop() if step == 2: i, e, total = params if len(curr) == m*n or (i == 0 and e == 0): result = max(result, total) continue if total + (i+e)*120 < result: continue if e > 0: stk.append((3, tuple())) stk.append((2, (i, e-1, count_total(curr, 2, total)))) stk.append((1, (2,))) if i > 0: stk.append((3, tuple())) stk.append((2, (i-1, e, count_total(curr, 1, total)))) stk.append((1, (1,))) if left(curr) or up(curr): stk.append((3, tuple())) stk.append((2, (i, e, total))) stk.append((1, (0,))) elif step == 1: x = params[0] curr.append(x) elif step == 3: curr.pop() return result return iter_backtracking(introvertsCount, extrovertsCount) ", "class Solution def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount): def left(curr): return curr[-1] if len(curr)%n else 0 def up(curr): return curr[-n] if len(curr) >= n else 0 def count_total(curr, t, total): return (total - 30*((left(curr) == 1)+(up(curr) == 1)) + 20*((left(curr) == 2)+(up(curr) == 2)) + (120 - 30*((left(curr) != 0)+(up(curr) != 0)))*(t == 1) + ( 40 + 20*((left(curr) != 0)+(up(curr) != 0)))*(t == 2)) def backtracking(i, e, total, curr, result): if len(curr) == m*n or (i == 0 and e == 0): result[0] = max(result[0], total) return if total + (i+e)*120 < result[0]: return if left(curr) or up(curr): curr.append(0) backtracking(i, e, total, curr, result) curr.pop() if i > 0: new_total = count_total(curr, 1, total) curr.append(1) backtracking(i-1, e, new_total, curr, result) curr.pop() if e > 0: new_total = count_total(curr, 2, total) curr.append(2) backtracking(i, e-1, new_total, curr, result) curr.pop() result = [0] backtracking(introvertsCount, extrovertsCount, 0, [], result) return result[0] ", "class Solution def minSteps(self, s, t): diff = collections.Counter(s) - collections.Counter(t) return sum(diff.itervalues()) ", "class Solution def sumOfDistancesInTree(self, N, edges): def dfs(graph, node, parent, count, result): for nei in graph[node]: if nei != parent: dfs(graph, nei, node, count, result) count[node] += count[nei] result[node] += result[nei]+count[nei] def dfs2(graph, node, parent, count, result): for nei in graph[node]: if nei != parent: result[nei] = result[node]-count[nei] + len(count)-count[nei] dfs2(graph, nei, node, count, result) graph = collections.defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) count = [1] * N result = [0] * N dfs(graph, 0, None, count, result) dfs2(graph, 0, None, count, result) return result ", "class Solution def smallestTrimmedNumbers(self, nums, queries): max_t = max(t for _, t in queries) lookup = [[] for _ in xrange(max_t+1)] for i, (k, t) in enumerate(queries): lookup[t].append((k, i)) result = [0]*len(queries) idxs = range(len(nums)) for l in xrange(1, max_t+1): cnt = [0]*10 for i in idxs: d = int(nums[i][-l]) cnt[d] += 1 for d in xrange(9): cnt[d+1] += cnt[d] new_idxs = [0]*len(nums) for i in reversed(idxs): d = int(nums[i][-l]) cnt[d] -= 1 new_idxs[cnt[d]] = i idxs = new_idxs for k, i in lookup[l]: result[i] = idxs[k-1] return result import random ", "class Solution def smallestTrimmedNumbers(self, nums, queries): def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 def compare(a, b): for i in xrange(len(nums[a])-t, len(nums[a])): if nums[a][i] < nums[b][i]: return True if nums[a][i] > nums[b][i]: return False return cmp(a, b) < 0 result = [] idxs = range(len(nums)) for k, t in queries: nth_element(idxs, k-1, compare=compare) result.append(idxs[k-1]) return result ", "class Solution def smallestTrimmedNumbers(self, nums, queries): def compare(a, b): for i in xrange(len(nums[a])-t, len(nums[a])): if nums[a][i] < nums[b][i]: return -1 if nums[a][i] > nums[b][i]: return 1 return cmp(a, b) max_t = max(t for _, t in queries) lookup = [[] for _ in xrange(max_t+1)] for i, (k, t) in enumerate(queries): lookup[t].append((k, i)) result = [0]*len(queries) idxs = range(len(nums)) for t in xrange(1, max_t+1): if not lookup[t]: continue idxs.sort(cmp=compare) for k, i in lookup[t]: result[i] = idxs[k-1] return result ", "class Solution def removeStars(self, s): result = [] for c in s: if c == '*': result.pop() else: result.append(c) return \"\".join(result) ", "class Solution def isValid(self, s): stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"} for parenthese in s: if parenthese in lookup: stack.append(parenthese) elif len(stack) == 0 or lookup[stack.pop()] != parenthese: return False return len(stack) == 0 ", "class Solution def minSpaceWastedKResizing(self, nums, k): INF = float(\"inf\") k += 1 dp = [[INF]*(k+1) for _ in xrange(len(nums)+1)] dp[0][0] = 0 for i in xrange(1, len(nums)+1): total = max_num = 0 for j in reversed(xrange(1, i+1)): total += nums[j-1] max_num = max(max_num, nums[j-1]) for m in xrange(1, k+1): if dp[j-1][m-1] != INF: dp[i][m] = min(dp[i][m], dp[j-1][m-1] + (max_num*(i-j+1)-total)) return dp[-1][-1] ", "class Solution def numDistinctIslands(self, grid): directions = {'l':[-1, 0], 'r':[ 1, 0], 'u':[ 0, 1], 'd':[ 0, -1]} def dfs(i, j, grid, island): if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] > 0): return False grid[i][j] *= -1 for k, v in directions.iteritems(): island.append(k) dfs(i+v[0], j+v[1], grid, island) return True islands = set() for i in xrange(len(grid)): for j in xrange(len(grid[0])): island = [] if dfs(i, j, grid, island): islands.add(\"\".join(island)) return len(islands) ", "class Solution def getCoprimes(self, nums, edges): def iter_dfs(nums, adj): result = [-1]*len(nums) path = collections.defaultdict(list) stk = [(1, (-1, 0, 0))] while stk: step, params = stk.pop() if step == 1: prev, node, depth = params stk.append((4, (node,))) stk.append((3, (prev, node, depth))) stk.append((2, (node,))) elif step == 2: node = params[0] max_d = -1 for x in path.iterkeys(): if fractions.gcd(nums[node], x) != 1: continue if path[x][-1][1] > max_d: max_d = path[x][-1][1] result[node] = path[x][-1][0] elif step == 3: prev, node, depth = params path[nums[node]].append((node, depth)) for nei in adj[node]: if nei == prev: continue stk.append((1, (node, nei, depth+1))) elif step == 4: node = params[0] path[nums[node]].pop() if not path[nums[node]]: path.pop(nums[node]) return result adj = collections.defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) return iter_dfs(nums, adj) import collections import fractions ", "class Solution def getCoprimes(self, nums, edges): def dfs(nums, adj, prev, node, depth, path, result): max_d = -1 for x in path.iterkeys(): if fractions.gcd(nums[node], x) != 1: continue if path[x][-1][1] > max_d: max_d = path[x][-1][1] result[node] = path[x][-1][0] path[nums[node]].append((node, depth)) for nei in adj[node]: if nei == prev: continue dfs(nums, adj, node, nei, depth+1, path, result) path[nums[node]].pop() if not path[nums[node]]: path.pop(nums[node]) adj = collections.defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) result = [-1]*len(nums) path = collections.defaultdict(list) dfs(nums, adj, -1, 0, 0, path, result) return result ", "class Solution def checkPossibility(self, nums): modified, prev = False, nums[0] for i in xrange(1, len(nums)): if prev > nums[i]: if modified: return False if i-2 < 0 or nums[i-2] <= nums[i]: prev = nums[i] modified = True else: prev = nums[i] return True ", "class Solution def visiblePoints(self, points, angle, location): arr, extra = [], 0 for p in points: if p == location: extra += 1 continue arr.append(math.atan2(p[1]-location[1], p[0]-location[0])) arr.sort() arr.extend([x + 2.0*math.pi for x in arr]) d = 2.0*math.pi * (angle/360.0) left = result = 0 for right in xrange(len(arr)): while arr[right]-arr[left] > d: left += 1 result = max(result, right-left+1) return result + extra ", "class Solution def maxOperations(self, nums): result = 1 target = nums[0]+nums[1] for i in xrange(2, len(nums)-1, 2): if nums[i]+nums[i+1] != target: break result += 1 return result ", "class Solution def minimumFinishTime(self, tires, changeTime, numLaps): def ceil_log2(x): return (x-1).bit_length() dp = [float(\"inf\")]*ceil_log2(changeTime+1) for f, r in tires: total = curr = f cnt = 0 while curr < changeTime+f: dp[cnt] = min(dp[cnt], total) curr *= r total += curr cnt += 1 dp2 = [float(\"inf\")]*numLaps for i in xrange(numLaps): dp2[i] = min((dp2[i-j-1]+changeTime if i-j-1 >= 0 else 0)+dp[j] for j in xrange(min(i+1, len(dp)))) return dp2[-1] ", "class Solution def maxNumberOfAlloys(self, n, k, budget, composition, stock, cost): def count(machine, budget): def cnt(x): return stock[x]//machine[x] idxs = range(n) idxs.sort(key=cnt) result = cnt(idxs[0]) prefix = curr = discount = 0 for i in xrange(n): curr += cost[idxs[i]]*machine[idxs[i]] discount += cost[idxs[i]]*(stock[idxs[i]]%machine[idxs[i]]) if i+1 != n and cnt(idxs[i+1])-cnt(idxs[i]) == 0: continue prefix += curr budget += discount curr = discount = 0 mn = min((cnt(idxs[i+1])-cnt(idxs[i]) if i+1 < n else float(\"inf\")), budget//prefix) if mn == 0: break budget -= prefix*mn result += mn return result return max(count(machine, budget) for machine in composition) ", "class Solution def maxNumberOfAlloys(self, n, k, budget, composition, stock, cost): def check(x): for machine in composition: curr = 0 for i in xrange(n): curr += max(x*machine[i]-stock[i], 0)*cost[i] if curr > budget: break if curr <= budget: return True return False left, right = 1, min(stock)+budget while left <= right: mid = left+(right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right ", "class Solution def numberOfGoodSubarraySplits(self, nums): MOD = 10**9+7 result, prev = 1, -1 for i in xrange(len(nums)): if nums[i] != 1: continue if prev != -1: result = (result*(i-prev))%MOD prev = i return result if prev != -1 else 0 ", "class Solution def findMaxAverage(self, nums, k): def getDelta(avg, nums, k): accu = [0.0] * (len(nums) + 1) minval_pos = None delta = 0.0 for i in xrange(len(nums)): accu[i+1] = nums[i] + accu[i] - avg if i >= (k-1): if minval_pos == None or accu[i-k+1] < accu[minval_pos]: minval_pos = i-k+1 if accu[i+1] - accu[minval_pos] >= 0: delta = max(delta, (accu[i+1] - accu[minval_pos]) / (i+1 - minval_pos)) return delta left, delta = min(nums), float(\"inf\") while delta > 1e-5: delta = getDelta(left, nums, k) left += delta return left ", "class Solution def minLength(self, s): stk = [] for c in s: if stk and ((stk[-1] == 'A' and c == 'B') or (stk[-1] == 'C' and c == 'D')): stk.pop() continue stk.append(c) return len(stk) ", "class Solution def numWays(self, words, target): MOD = 10**9+7 dp = [0]*(len(target)+1) dp[0] = 1 for i in xrange(len(words[0])): count = collections.Counter(w[i] for w in words) for j in reversed(xrange(len(target))): dp[j+1] += dp[j]*count[target[j]] % MOD return dp[-1] % MOD import collections ", "class Solution def numWays(self, words, target): MOD = 10**9+7 dp = [[0]*(len(target)+1) for _ in xrange(2)] for i in xrange(len(dp)): dp[i][0] = 1 for i in xrange(len(words[0])): count = collections.Counter(w[i] for w in words) for j in reversed(xrange(len(target))): dp[(i+1)%2][j+1] = dp[i%2][j+1]+dp[i%2][j]*count[target[j]] % MOD return dp[(len(words[0]))%2][-1] % MOD ", "class Solution def sortSentence(self, s): words = s.split() for i in xrange(len(words)): while int(words[i][-1])-1 != i: words[int(words[i][-1])-1], words[i] = words[i], words[int(words[i][-1])-1] return \" \".join(itertools.imap(lambda x: x[:-1], words)) ", "class Solution def canAliceWin(self, a, b): def is_closely_greater(a, b): return ord(a[0])-ord(b[0]) <= 1 and a > b result = True i, j = 0, -1 for _ in xrange(len({w[0] for w in a})+len({w[0] for w in b})): j = next((j for j in xrange(j+1, len(b)) if is_closely_greater(b[j], a[i])), len(b)) if j == len(b): break while j+1 < len(b) and b[j+1][0] == b[j][0]: j += 1 a, b, i, j, result = b, a, j, i, not result return result ", "class Solution def twoCitySchedCost(self, costs): def kthElement(nums, k, compare): def PartitionAroundPivot(left, right, pivot_idx, nums, compare): new_pivot_idx = left nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx] for i in xrange(left, right): if compare(nums[i], nums[right]): nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i] new_pivot_idx += 1 nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right] return new_pivot_idx left, right = 0, len(nums) - 1 while left <= right: pivot_idx = random.randint(left, right) new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare) if new_pivot_idx == k: return elif new_pivot_idx > k: right = new_pivot_idx - 1 else: left = new_pivot_idx + 1 kthElement(costs, len(costs)//2, lambda a, b: a[0]-a[1] < b[0]-b[1]) result = 0 for i in xrange(len(costs)): result += costs[i][0] if i < len(costs)//2 else costs[i][1] return result ", "class Solution def minCostClimbingStairs(self, cost): dp = [0] * 3 for i in reversed(xrange(len(cost))): dp[i%3] = cost[i] + min(dp[(i+1)%3], dp[(i+2)%3]) return min(dp[0], dp[1]) ", "class Solution def removeZeroSumSublists(self, head): curr = dummy = ListNode(0) dummy.next = head prefix = 0 lookup = collections.OrderedDict() while curr: prefix += curr.val node = lookup.get(prefix, curr) while prefix in lookup: lookup.popitem() lookup[prefix] = node node.next = curr.next curr = curr.next return dummy.next ", "class Solution def isStrictlyPalindromic(self, n): return False ", "class Solution def judgeSquareSum(self, c): for a in xrange(int(math.sqrt(c))+1): b = int(math.sqrt(c-a**2)) if a**2 + b**2 == c: return True return False ", "class Solution def sortColors(self, nums): def triPartition(nums, target): i, left, right = 0, 0, len(nums)-1 while i <= right: if nums[i] > target: nums[i], nums[right] = nums[right], nums[i] right -= 1 else: if nums[i] < target: nums[left], nums[i] = nums[i], nums[left] left += 1 i += 1 triPartition(nums, 1) ", "class Solution def maximumEvenSplit(self, finalSum): if finalSum%2: return [] result = [] i = 2 while i <= finalSum: result.append(i) finalSum -= i i += 2 result[-1] += finalSum return result ", "class Solution def findSmallestSetOfVertices(self, n, edges): result = [] lookup = set() for u, v in edges: lookup.add(v) for i in xrange(n): if i not in lookup: result.append(i) return result ", "class Solution def nthUglyNumber(self, n, a, b, c): def gcd(a, b): while b: a, b = b, a % b return a def lcm(x, y): return x//gcd(x, y)*y def count(x, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c): return x//a + x//b + x//c - (x//lcm_a_b + x//lcm_b_c + x//lcm_c_a) + x//lcm_a_b_c lcm_a_b, lcm_b_c, lcm_c_a = lcm(a, b), lcm(b, c), lcm(c, a) lcm_a_b_c = lcm(lcm_a_b, lcm_b_c) left, right = 1, 2*10**9 while left <= right: mid = left + (right-left)//2 if count(mid, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c) >= n: right = mid-1 else: left = mid+1 return left ", "class Solution def generateMatrix(self, n): matrix = [[0 for _ in xrange(n)] for _ in xrange(n)] left, right, top, bottom, num = 0, n - 1, 0, n - 1, 1 while left <= right and top <= bottom: for j in xrange(left, right + 1): matrix[top][j] = num num += 1 for i in xrange(top + 1, bottom): matrix[i][right] = num num += 1 for j in reversed(xrange(left, right + 1)): if top < bottom: matrix[bottom][j] = num num += 1 for i in reversed(xrange(top + 1, bottom)): if left < right: matrix[i][left] = num num += 1 left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1 return matrix ", "class Solution def catchMaximumAmountofPeople(self, team, dist): result = i = j = 0 while i < len(team) and j < len(team): if i+dist < j or team[i] != 1: i += 1 elif j+dist < i or team[j] != 0: j += 1 else: result += 1 i += 1 j += 1 return result ", "class Solution def catchMaximumAmountofPeople(self, team, dist): result = j = 0 for i in xrange(len(team)): if not team[i]: continue while j < i-dist: j += 1 while j <= min(i+dist, len(team)-1): if team[j] == 0: break j += 1 if j <= min(i+dist, len(team)-1): result += 1 j += 1 return result ", "class Solution def minimumOperations(self, num): lookup = [0]*10 for i in reversed(xrange(len(num))): if ((num[i] in \"05\" and lookup[0]) or (num[i] in \"27\" and lookup[5])): return (len(num)-i)-2 lookup[ord(num[i])-ord('0')] = 1 return len(num)-lookup[0] ", "class Solution def minArea(self, image, x, y): def binarySearch(left, right, find, image, has_one): while left <= right: mid = left + (right - left) / 2 if find(image, has_one, mid): right = mid - 1 else: left = mid + 1 return left searchColumns = lambda image, has_one, mid: any([int(row[mid]) for row in image]) == has_one left = binarySearch(0, y - 1, searchColumns, image, True) right = binarySearch(y + 1, len(image[0]) - 1, searchColumns, image, False) searchRows = lambda image, has_one, mid: any(itertools.imap(int, image[mid])) == has_one top = binarySearch(0, x - 1, searchRows, image, True) bottom = binarySearch(x + 1, len(image) - 1, searchRows, image, False) return (right - left) * (bottom - top) ", "class Solution def generateSentences(self, synonyms, text): def assign_id(x, lookup, inv_lookup): if x in lookup: return lookup[x] = len(lookup) inv_lookup[lookup[x]] = x lookup, inv_lookup = {}, {} for u, v in synonyms: assign_id(u, lookup, inv_lookup), assign_id(v, lookup, inv_lookup) union_find = UnionFind(len(lookup)) for u, v in synonyms: union_find.union_set(lookup[u], lookup[v]) groups = collections.defaultdict(list) for i in xrange(len(union_find.set)): groups[union_find.find_set(i)].append(i) result = [] for w in text.split(' '): if w not in lookup: result.append([w]) continue result.append(sorted(map(lambda x: inv_lookup[x], groups[union_find.find_set(lookup[w])]))) return [\" \".join(sentense) for sentense in itertools.product(*result)] ", "class Solution def minOperations(self, nums): def unique(nums): left = 0 for right in xrange(1, len(nums)): if nums[left] != nums[right]: left += 1 nums[left] = nums[right] return left def erase(nums, i): while len(nums) > i+1: nums.pop() n = len(nums) nums.sort() erase(nums, unique(nums)) result = l = 0 for i in xrange(len(nums)): if nums[i] <= nums[i-l]+n-1: l += 1 return n-l ", "class Solution def minOperations(self, nums): n = len(nums) nums = sorted(set(nums)) result = right = 0 for left in xrange(len(nums)): while right < len(nums) and nums[right] <= nums[left]+n-1: right += 1 result = max(result, right-left) return n-result ", "class Solution def gameResult(self, head): cnt = 0 while head: cnt += cmp(head.val, head.next.val) head = head.next.next return \"Tie\" if cnt == 0 else \"Odd\" if cnt < 0 else \"Even\" ", "class Solution def subsets(self, nums): nums.sort() result = [[]] for i in xrange(len(nums)): size = len(result) for j in xrange(size): result.append(list(result[j])) result[-1].append(nums[i]) return result ", "class Solution def subsets(self, nums): result = [] i, count = 0, 1 << len(nums) nums.sort() while i < count: cur = [] for j in xrange(len(nums)): if i & 1 << j: cur.append(nums[j]) result.append(cur) i += 1 return result ", "class Solution def subsets(self, nums): return self.subsetsRecu([], sorted(nums)) def subsetsRecu(self, cur, nums): if not nums: return [cur] return self.subsetsRecu(cur, nums[1:]) + self.subsetsRecu(cur + [nums[0]], nums[1:]) ", "class Solution def maximizeTheProfit(self, n, offers): lookup = [[] for _ in xrange(n)] for s, e, g in offers: lookup[e].append([s, g]) dp = [0]*(n+1) for e in xrange(n): dp[e+1] = dp[(e-1)+1] for s, g in lookup[e]: dp[e+1] = max(dp[e+1], dp[(s-1)+1]+g) return dp[-1] ", "class Solution def nextGreaterElement(self, findNums, nums): stk, lookup = [], {} for num in nums: while stk and num > stk[-1]: lookup[stk.pop()] = num stk.append(num) while stk: lookup[stk.pop()] = -1 return map(lambda x : lookup[x], findNums) ", "class Solution def deckRevealedIncreasing(self, deck): d = collections.deque() deck.sort(reverse=True) for i in deck: if d: d.appendleft(d.pop()) d.appendleft(i) return list(d) ", "class Solution def searchMatrix(self, matrix, target): if not matrix: return False m, n = len(matrix), len(matrix[0]) left, right = 0, m * n while left < right: mid = left + (right - left) / 2 if matrix[mid / n][mid % n] >= target: right = mid else: left = mid + 1 return left < m * n and matrix[left / n][left % n] == target ", "class Solution def getOrder(self, tasks): idx = range(len(tasks)) idx.sort(key=lambda x: tasks[x][0]) result, min_heap = [], [] i, time = 0, tasks[idx[0]][0] while i < len(idx) or min_heap: while i < len(idx) and tasks[idx[i]][0] <= time: heapq.heappush(min_heap, (tasks[idx[i]][1], idx[i])) i += 1 if not min_heap: time = tasks[idx[i]][0] continue t, j = heapq.heappop(min_heap) time += t result.append(j) return result ", "class Solution def checkWays(self, pairs): adj = collections.defaultdict(set) for x, y in pairs: adj[x].add(y) adj[y].add(x) n, mul = len(adj), False lookup = set() for node in sorted(adj.iterkeys(), key=lambda i: len(adj[i]), reverse=True): lookup.add(node) parent = 0 for x in adj[node]: if x not in lookup: continue if parent == 0 or len(adj[x]) < len(adj[parent]): parent = x if parent: if any(True for x in adj[node] if x != parent and x not in adj[parent]): return 0 mul |= len(adj[parent]) == len(adj[node]) elif len(adj[node]) != n-1: return 0 return 1 + mul ", "class Solution def matrixSum(self, nums): for row in nums: row.sort() return sum(max(nums[r][c] for r in xrange(len(nums))) for c in xrange(len(nums[0]))) ", "class Solution def countTime(self, time): result = 1 if time[4] == '?': result *= 10 if time[3] == '?': result *= 6 if time[1] == time[0] == '?': result *= 24 elif time[1] == '?': result *= 10 if time[0] != '2' else 4 elif time[0] == '?': result *= 3 if time[1] < '4' else 2 return result ", "class Solution def splitArray(self, nums, m): def check(nums, m, s): cnt, curr_sum = 1, 0 for num in nums: curr_sum += num if curr_sum > s: curr_sum = num cnt += 1 return cnt <= m left, right = max(nums), sum(nums) while left <= right: mid = left + (right - left) // 2 if check(nums, m, mid): right = mid - 1 else: left = mid + 1 return left ", "class Solution def maxRepeating(self, sequence, word): def getPrefix(pattern): prefix = [-1] * len(pattern) j = -1 for i in xrange(1, len(pattern)): while j > -1 and pattern[j + 1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix if len(sequence) < len(word): return 0 prefix = getPrefix(word) result, count, j, prev = 0, 0, -1, -1 for i in xrange(len(sequence)): while j > -1 and word[j+1] != sequence[i]: j = prefix[j] if word[j+1] == sequence[i]: j += 1 if j+1 == len(word): count = count+1 if i-prev == len(word) else 1 result = max(result, count) j, prev = -1, i return result ", "class Solution def maxRepeating(self, sequence, word): def getPrefix(pattern): prefix = [-1] * len(pattern) j = -1 for i in xrange(1, len(pattern)): while j > -1 and pattern[j + 1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix if len(sequence) < len(word): return 0 new_word = word*(len(sequence)//len(word)) prefix = getPrefix(new_word) result, j = 0, -1 for i in xrange(len(sequence)): while j > -1 and new_word[j+1] != sequence[i]: j = prefix[j] if new_word[j+1] == sequence[i]: j += 1 result = max(result, j+1) if j+1 == len(new_word): break return result//len(word) ", "class Solution def countPoints(self, points, queries): result = [] for i, j, r in queries: result.append(0) for x, y in points: if (x-i)**2+(y-j)**2 <= r**2: result[-1] += 1 return result ", "class Solution def reconstructQueue(self, people): people.sort(key=lambda h_k: (-h_k[0], h_k[1])) blocks = [[]] for p in people: index = p[1] for i, block in enumerate(blocks): if index <= len(block): break index -= len(block) block.insert(index, p) if len(block) * len(block) > len(people): blocks.insert(i+1, block[len(block)/2:]) del block[len(block)/2:] return [p for block in blocks for p in block] ", "class Solution def reconstructQueue(self, people): people.sort(key=lambda h_k1: (-h_k1[0], h_k1[1])) result = [] for p in people: result.insert(p[1], p) return result ", "class Solution def checkRecord(self, n): M = 1000000007 a0l0, a0l1, a0l2, a1l0, a1l1, a1l2 = 1, 0, 0, 0, 0, 0 for i in xrange(n+1): a0l2, a0l1, a0l0 = a0l1, a0l0, (a0l0 + a0l1 + a0l2) % M a1l2, a1l1, a1l0 = a1l1, a1l0, (a0l0 + a1l0 + a1l1 + a1l2) % M return a1l0 ", "class Solution def reachableNodes(self, edges, M, N): adj = [[] for _ in xrange(N)] for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) min_heap = [(0, 0)] best = collections.defaultdict(lambda: float(\"inf\")) best[0] = 0 count = collections.defaultdict(lambda: collections.defaultdict(int)) result = 0 while min_heap: curr_total, u = heapq.heappop(min_heap) if best[u] < curr_total: continue result += 1 for v, w in adj[u]: count[u][v] = min(w, M-curr_total) next_total = curr_total+w+1 if next_total <= M and next_total < best[v]: best[v] = next_total heapq.heappush(min_heap, (next_total, v)) for u, v, w in edges: result += min(w, count[u][v]+count[v][u]) return result ", "class Solution def maxPointsInsideSquare(self, points, s): INF = float(\"inf\") lookup = [INF for _ in xrange(26)] d = INF for c, (x, y) in itertools.izip(s, points): k = ord(c)-ord('a') mn2 = max(abs(x), abs(y)) if mn2 < lookup[k]: mn2, lookup[k] = lookup[k], mn2 d = min(d, mn2) return sum(mn1 < d for mn1 in lookup) ", "class Solution def pathSum(self, root, sum): def pathSumHelper(root, curr, sum, lookup): if root is None: return 0 curr += root.val result = lookup[curr-sum] if curr-sum in lookup else 0 lookup[curr] += 1 result += pathSumHelper(root.left, curr, sum, lookup) + pathSumHelper(root.right, curr, sum, lookup) lookup[curr] -= 1 if lookup[curr] == 0: del lookup[curr] return result lookup = collections.defaultdict(int) lookup[0] = 1 return pathSumHelper(root, 0, sum, lookup) ", "class Solution def pathSum(self, root, sum): def pathSumHelper(root, prev, sum): if root is None: return 0 curr = prev + root.val return int(curr == sum) + pathSumHelper(root.left, curr, sum) + pathSumHelper(root.right, curr, sum) if root is None: return 0 return pathSumHelper(root, 0, sum) + self.pathSum(root.left, sum) + self.pathSum(root.right, sum) ", "class Solution def equalFrequency(self, word): cnt = collections.Counter(collections.Counter(word).itervalues()) if len(cnt) > 2: return False if len(cnt) == 1: a = cnt.keys()[0] return a == 1 or cnt[a] == 1 a, b = cnt.keys() if a > b: a, b = b, a return (a == 1 and cnt[a] == 1) or (a+1 == b and cnt[b] == 1) import collections ", "class Solution def equalFrequency(self, word): cnt = collections.Counter(collections.Counter(word)) for c in word: cnt[c] -= 1 if len(collections.Counter(c for c in cnt.itervalues() if c)) == 1: return True cnt[c] += 1 return False ", "class Solution def toLowerCase(self, str): return \"\".join([chr(ord('a')+ord(c)-ord('A')) if 'A' <= c <= 'Z' else c for c in str]) ", "class Solution def maxSelectedElements(self, nums): nums.sort() result = 1 dp = [1]*2 for i in xrange(1, len(nums)): if nums[i] == nums[i-1]: dp[1] = dp[0]+1 elif nums[i] == nums[i-1]+1: dp[0] += 1 dp[1] += 1 elif nums[i] == nums[i-1]+2: dp[0] = dp[1]+1 dp[1] = 1 else: dp[0] = dp[1] = 1 result = max(result, dp[0], dp[1]) return result import collections ", "class Solution def maxSelectedElements(self, nums): nums.sort() dp = collections.defaultdict(int) dp[nums[0]] = dp[nums[0]+1] = 1 for i in xrange(1, len(nums)): if nums[i] == nums[i-1]: dp[nums[i]+1] = dp[nums[i]]+1 elif nums[i] == nums[i-1]+1: dp[nums[i]+1] = dp[nums[i]]+1 dp[nums[i]] = dp[nums[i]-1]+1 elif nums[i] == nums[i-1]+2: dp[nums[i]] = dp[nums[i]-1]+1 dp[nums[i]+1] = 1 else: dp[nums[i]] = dp[nums[i]+1] = 1 return max(dp.itervalues()) import collections ", "class Solution def maxSelectedElements(self, nums): nums.sort() dp = collections.defaultdict(int) for x in nums: dp[x+1] = dp[x]+1 dp[x] = dp[x-1]+1 return max(dp.itervalues()) ", "class Solution def jobScheduling(self, startTime, endTime, profit): jobs = sorted(itertools.izip(endTime, startTime, profit)) dp = [(0, 0)] for e, s, p in jobs: i = bisect.bisect_right(dp, (s+1, 0))-1 if dp[i][1]+p > dp[-1][1]: dp.append((e, dp[i][1]+p)) return dp[-1][1] import heapq ", "class Solution def jobScheduling(self, startTime, endTime, profit): min_heap = zip(startTime, endTime, profit) heapq.heapify(min_heap) result = 0 while min_heap: s, e, p = heapq.heappop(min_heap) if s < e: heapq.heappush(min_heap, (e, s, result+p)) else: result = max(result, p) return result ", "class Solution def uncommonFromSentences(self, A, B): count = collections.Counter(A.split()) count += collections.Counter(B.split()) return [word for word in count if count[word] == 1] ", "class Solution def minOperations(self, nums, x): target = sum(nums)-x result = -1 curr = left = 0 for right in xrange(len(nums)): curr += nums[right] while left < len(nums) and curr > target: curr -= nums[left] left += 1 if curr == target: result = max(result, right-left+1) return len(nums)-result if result != -1 else -1 ", "class Solution def smallestRepunitDivByK(self, K): if K % 2 == 0 or K % 5 == 0: return -1 result = 0 for N in xrange(1, K+1): result = (result*10+1) % K if not result: return N assert(False) return -1 ", "class Solution def countStudents(self, students, sandwiches): count = collections.Counter(students) for i, s in enumerate(sandwiches): if not count[s]: break count[s] -= 1 else: i = len(sandwiches) return len(sandwiches)-i ", "class Solution def maximumJumps(self, nums, target): dp = [-1]*len(nums) dp[0] = 0 for i in xrange(1, len(nums)): for j in xrange(i): if abs(nums[i]-nums[j]) <= target: if dp[j] != -1: dp[i] = max(dp[i], dp[j]+1) return dp[-1] ", "class Solution def numSpecial(self, mat): rows, cols = [0]*len(mat), [0]*len(mat[0]) for i in xrange(len(rows)): for j in xrange(len(cols)): if mat[i][j]: rows[i] += 1 cols[j] += 1 result = 0 for i in xrange(len(rows)): for j in xrange(len(cols)): if mat[i][j] == rows[i] == cols[j] == 1: result += 1 return result ", "class Solution def addMinimum(self, word): return 3*(sum(i-1 < 0 or word[i-1] >= word[i] for i in xrange(len(word))))-len(word) ", "class Solution def findIntegers(self, num): dp = [0] * 32 dp[0], dp[1] = 1, 2 for i in xrange(2, len(dp)): dp[i] = dp[i-1] + dp[i-2] result, prev_bit = 0, 0 for i in reversed(xrange(31)): if (num & (1 << i)) != 0: result += dp[i] if prev_bit == 1: result -= 1 break prev_bit = 1 else: prev_bit = 0 return result + 1 ", "class Solution def splitLoopedString(self, strs): tmp = [] for s in strs: tmp += max(s, s[::-1]) s = \"\".join(tmp) result, st = \"a\", 0 for i in xrange(len(strs)): body = \"\".join([s[st + len(strs[i]):], s[0:st]]) for p in strs[i], strs[i][::-1]: for j in xrange(len(strs[i])): if p[j] >= result[0]: result = max(result, \"\".join([p[j:], body, p[:j]])) st += len(strs[i]) return result ", "class Solution def minStartValue(self, nums): min_prefix, prefix = 0, 0 for num in nums: prefix += num min_prefix = min(min_prefix, prefix) return 1-min_prefix ", "class Solution def sortArrayByParity(self, A): i = 0 for j in xrange(len(A)): if A[j] % 2 == 0: A[i], A[j] = A[j], A[i] i += 1 return A ", "class Solution _num = [0] def numSquares(self, n): num = self._num while len(num) <= n: num += min(num[-i*i] for i in xrange(1, int(len(num)**0.5+1))) + 1, return num[n] ", "class Solution def minSwaps(self, s): def cost(s, x): diff = 0 for c in s: diff += int(c) != x x ^= 1 return diff//2 ones = s.count('1') zeros = len(s)-ones if abs(ones-zeros) > 1: return -1 if ones > zeros: return cost(s, 1) if ones < zeros: return cost(s, 0) return min(cost(s, 1), cost(s, 0)) ", "class Solution def getMaximumGold(self, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def backtracking(grid, i, j): result = 0 grid[i][j] *= -1 for dx, dy in directions: ni, nj = i+dx, j+dy if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj] > 0): continue result = max(result, backtracking(grid, ni, nj)) grid[i][j] *= -1 return grid[i][j] + result result = 0 for i in xrange(len(grid)): for j in xrange(len(grid[0])): if grid[i][j]: result = max(result, backtracking(grid, i, j)) return result ", "class Solution def findUnsortedSubarray(self, nums): n = len(nums) left, right = -1, -2 min_from_right, max_from_left = nums[-1], nums[0] for i in xrange(1, n): max_from_left = max(max_from_left, nums[i]) min_from_right = min(min_from_right, nums[n-1-i]) if nums[i] < max_from_left: right = i if nums[n-1-i] > min_from_right: left = n-1-i ", "class Solution def findUnsortedSubarray(self, nums): a = sorted(nums) left, right = 0, len(nums) -1 while (nums[left] == a[left] or nums[right] == a[right]): if right - left <= 1: return 0 if nums[left] == a[left]: left += 1 if nums[right] == a[right]: right -= 1 return right - left + 1 ", "class Solution def simplifiedFractions(self, n): lookup = set() for b in xrange(1, n+1): for a in xrange(1, b): g = fractions.gcd(a, b) lookup.add((a//g, b//g)) return map(lambda x: \"{}/{}\".format(*x), lookup) ", "class Solution def countBeautifulPairs(self, nums): def gcd(a, b): while b: a, b = b, a%b return a result = 0 cnt = [0]*10 for x in nums: for i in xrange(1, 10): if gcd(i, x%10) == 1: result += cnt[i] while x >= 10: x //= 10 cnt[x] += 1 return result ", "class Solution def repeatedStringMatch(self, A, B): def check(index): return all(A[(i+index) % len(A)] == c for i, c in enumerate(B)) M, p = 10**9+7, 113 p_inv = pow(p, M-2, M) q = (len(B)+len(A)-1) // len(A) b_hash, power = 0, 1 for c in B: b_hash += power * ord(c) b_hash %= M power = (power*p) % M a_hash, power = 0, 1 for i in xrange(len(B)): a_hash += power * ord(A[i%len(A)]) a_hash %= M power = (power*p) % M if a_hash == b_hash and check(0): return q power = (power*p_inv) % M for i in xrange(len(B), (q+1)*len(A)): a_hash = (a_hash-ord(A[(i-len(B))%len(A)])) * p_inv a_hash += power * ord(A[i%len(A)]) a_hash %= M if a_hash == b_hash and check(i-len(B)+1): return q if i < q*len(A) else q+1 return -1 ", "class Solution def primeSubOperation(self, nums): for i in xrange(len(nums)): j = bisect.bisect_left(PRIMES, nums[i]-nums[i-1] if i-1 >= 0 else nums[i]) if j-1 >= 0: nums[i] -= PRIMES[j-1] if i-1 >= 0 and nums[i-1] >=nums[i]: return False return True ", "class Solution def minimumCost(self, source, target, original, changed, cost): INF = float(\"inf\") lookups = collections.defaultdict(dict) for x in itertools.chain(original, changed): l = len(x) lookup = lookups[l] if x not in lookup: lookup[x] = len(lookup) def dijkstra(dist, start): best = [INF]*len(dist) best[start] = 0 min_heap = [(0, start)] while min_heap: curr, u = heapq.heappop(min_heap) if curr > best[u]: continue for v, w in enumerate(dist[u]): if best[v] <= curr+w: continue best[v] = curr+w heapq.heappush(min_heap, (best[v], v)) return best memo = {} def memoization(l, dist, u, v): if l not in memo: memo[l] = {} if u not in memo[l]: memo[l][u] = dijkstra(dist, u) return memo[l][u][v] dists = {l:[[0 if u == v else INF for v in xrange(len(lookup))] for u in xrange(len(lookup))] for l, lookup in lookups.iteritems()} for i in xrange(len(original)): l = len(original[i]) lookup, dist = lookups[l], dists[l] u, v = lookup[original[i]], lookup[changed[i]] dist[u][v] = min(dist[u][v], cost[i]) candidates = {len(x) for x in original} dp = [INF]*(max(len(x) for x in original)+1) dp[0] = 0 for i in xrange(len(source)): if dp[i%len(dp)] == INF: continue if source[i] == target[i]: dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)]) for l in candidates: if i+l > len(source): continue lookup, dist = lookups[l], dists[l] u, v = source[i:i+l], target[i:i+l] if u in lookup and v in lookup: dp[(i+l)%len(dp)] = min(dp[(i+l)%len(dp)], dp[i%len(dp)]+memoization(l, dist, lookup[u], lookup[v])) dp[i%len(dp)] = INF return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1 import collections import itertools ", "class Solution def minimumCost(self, source, target, original, changed, cost): INF = float(\"inf\") def floydWarshall(dist): for k in xrange(len(dist)): for i in xrange(len(dist)): if dist[i][k] == INF: continue for j in xrange(len(dist[i])): if dist[k][j] == INF: continue dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) lookups = collections.defaultdict(dict) for x in itertools.chain(original, changed): l = len(x) lookup = lookups[l] if x not in lookup: lookup[x] = len(lookup) dists = {l:[[0 if u == v else INF for v in xrange(len(lookup))] for u in xrange(len(lookup))] for l, lookup in lookups.iteritems()} for i in xrange(len(original)): l = len(original[i]) lookup, dist = lookups[l], dists[l] u, v = lookup[original[i]], lookup[changed[i]] dist[u][v] = min(dist[u][v], cost[i]) for dist in dists.itervalues(): floydWarshall(dist) candidates = {len(x) for x in original} dp = [INF]*(max(len(x) for x in original)+1) dp[0] = 0 for i in xrange(len(source)): if dp[i%len(dp)] == INF: continue if source[i] == target[i]: dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)]) for l in candidates: if i+l > len(source): continue lookup, dist = lookups[l], dists[l] u, v = source[i:i+l], target[i:i+l] if u in lookup and v in lookup: dp[(i+l)%len(dp)] = min(dp[(i+l)%len(dp)], dp[i%len(dp)]+dist[lookup[u]][lookup[v]]) dp[i%len(dp)] = INF return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1 import collections import itertools ", "class Solution def minimumCost(self, source, target, original, changed, cost): INF = float(\"inf\") lookup = {} for x in itertools.chain(original, changed): if x in lookup: continue lookup[x] = len(lookup) def dijkstra(start): best = {start:0} min_heap = [(0, start)] while min_heap: curr, u = heapq.heappop(min_heap) if curr > best[u]: continue if u not in dist: continue for v, w in dist[u].iteritems(): if v in best and best[v] <= curr+w: continue best[v] = curr+w heapq.heappush(min_heap, (best[v], v)) return best memo = {} def memoization(u, v): if u not in lookup: memo[u] = dijkstra(u) return memo[u][v] if v in memo[u] else INF dist = {} for i in xrange(len(original)): u, v = lookup[original[i]], lookup[changed[i]] if u not in dist: dist[u] = {v:INF} if v not in dist[u]: dist[u][v] = INF dist[u][v] = min(dist[u][v], cost[i]) candidates = {len(x) for x in original} dp = [INF]*(max(len(x) for x in original)+1) dp[0] = 0 for i in xrange(len(source)): if dp[i%len(dp)] == INF: continue if source[i] == target[i]: dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)]) for l in candidates: if i+l > len(source): continue u, v = source[i:i+l], target[i:i+l] if u in lookup and v in lookup: dp[(i+l)%len(dp)] = min(dp[(i+l)%len(dp)], dp[i%len(dp)]+memoization(lookup[u], lookup[v])) dp[i%len(dp)] = INF return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1 import collections import itertools ", "class Solution def minimumCost(self, source, target, original, changed, cost): INF = float(\"inf\") def floydWarshall(dist): for k in dist.iterkeys(): for i in dist.iterkeys(): if dist[i][k] == INF: continue for j in dist.iterkeys(): if dist[k][j] == INF: continue dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) lookup = {} buckets = collections.defaultdict(list) for x in itertools.chain(original, changed): l = len(x) if x in lookup: continue lookup[x] = len(lookup) buckets[len(x)].append(lookup[x]) dists = {l:{u:{v:0 if u == v else INF for v in lookup} for u in lookup} for l, lookup in buckets.iteritems()} for i in xrange(len(original)): l = len(original[i]) dist = dists[l] u, v = lookup[original[i]], lookup[changed[i]] dist[u][v] = min(dist[u][v], cost[i]) for dist in dists.itervalues(): floydWarshall(dist) candidates = {len(x) for x in original} dp = [INF]*(max(len(x) for x in original)+1) dp[0] = 0 for i in xrange(len(source)): if dp[i%len(dp)] == INF: continue if source[i] == target[i]: dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)]) for l in candidates: if i+l > len(source): continue dist = dists[l] u, v = source[i:i+l], target[i:i+l] if u in lookup and v in lookup: dp[(i+l)%len(dp)] = min(dp[(i+l)%len(dp)], dp[i%len(dp)]+dist[lookup[u]][lookup[v]]) dp[i%len(dp)] = INF return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1 import itertools import heapq ", "class Solution def minimumCost(self, source, target, original, changed, cost): INF = float(\"inf\") class Trie(object): def __init__(self): self.__nodes = [] self.__idxs = [] self.k = 0 self.__new_node() def __new_node(self): self.__nodes.append([-1]*26) self.__idxs.append(-1) return len(self.__nodes)-1 def add(self, s): curr = 0 for c in s: x = ord(c)-ord('a') if self.__nodes[curr][x] == -1: self.__nodes[curr][x] = self.__new_node() curr = self.__nodes[curr][x] if self.__idxs[curr] == -1: self.__idxs[curr] = self.k self.k += 1 return True, self.__idxs[curr] return False, self.__idxs[curr] def query(self, s): curr = 0 for c in s: curr = self.__nodes[curr][ord(c)-ord('a')] return self.__idxs[curr] def next(self, curr, c): return self.__nodes[curr][ord(c)-ord('a')] def id(self, curr): return self.__idxs[curr] trie = Trie() for x in itertools.chain(original, changed): trie.add(x) def dijkstra(start): best = {start:0} min_heap = [(0, start)] while min_heap: curr, u = heapq.heappop(min_heap) if curr > best[u]: continue if u not in dist: continue for v, w in dist[u].iteritems(): if v in best and best[v] <= curr+w: continue best[v] = curr+w heapq.heappush(min_heap, (best[v], v)) return best memo = {} def memoization(u, v): if u not in memo: memo[u] = dijkstra(u) return memo[u][v] if v in memo[u] else INF dist = {} for i in xrange(len(original)): u, v = trie.query(original[i]), trie.query(changed[i]) if u not in dist: dist[u] = {v:INF} if v not in dist[u]: dist[u][v] = INF dist[u][v] = min(dist[u][v], cost[i]) dp = [INF]*(max(len(x) for x in original)+1) dp[0] = 0 for i in xrange(len(source)): if dp[i%len(dp)] == INF: continue if source[i] == target[i]: dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)]) u = v = 0 for j in xrange(i, len(source)): u = trie.next(u, source[j]) v = trie.next(v, target[j]) if u == -1 or v == -1: break if trie.id(u) != -1 and trie.id(v) != -1: dp[(j+1)%len(dp)] = min(dp[(j+1)%len(dp)], dp[i%len(dp)]+memoization(trie.id(u), trie.id(v))) dp[i%len(dp)] = INF return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1 import itertools ", "class Solution def minimumCost(self, source, target, original, changed, cost): INF = float(\"inf\") class Trie(object): def __init__(self): self.__nodes = [] self.__idxs = [] self.k = 0 self.__new_node() def __new_node(self): self.__nodes.append([-1]*26) self.__idxs.append(-1) return len(self.__nodes)-1 def add(self, s): curr = 0 for c in s: x = ord(c)-ord('a') if self.__nodes[curr][x] == -1: self.__nodes[curr][x] = self.__new_node() curr = self.__nodes[curr][x] if self.__idxs[curr] == -1: self.__idxs[curr] = self.k self.k += 1 return True, self.__idxs[curr] return False, self.__idxs[curr] def query(self, s): curr = 0 for c in s: curr = self.__nodes[curr][ord(c)-ord('a')] return self.__idxs[curr] def next(self, curr, c): return self.__nodes[curr][ord(c)-ord('a')] def id(self, curr): return self.__idxs[curr] def floydWarshall(dist): for k in dist.iterkeys(): for i in dist.iterkeys(): if dist[i][k] == INF: continue for j in dist.iterkeys(): if dist[k][j] == INF: continue dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) trie = Trie() buckets = collections.defaultdict(list) for x in itertools.chain(original, changed): not_duplicated, i = trie.add(x) if not_duplicated: buckets[len(x)].append(i) dists = {l:{u:{v:0 if u == v else INF for v in lookup} for u in lookup} for l, lookup in buckets.iteritems()} for i in xrange(len(original)): l = len(original[i]) dist = dists[l] u, v = trie.query(original[i]), trie.query(changed[i]) dist[u][v] = min(dist[u][v], cost[i]) for dist in dists.itervalues(): floydWarshall(dist) dp = [INF]*(max(len(x) for x in original)+1) dp[0] = 0 for i in xrange(len(source)): if dp[i%len(dp)] == INF: continue if source[i] == target[i]: dp[(i+1)%len(dp)] = min(dp[(i+1)%len(dp)], dp[i%len(dp)]) u = v = 0 for j in xrange(i, len(source)): u = trie.next(u, source[j]) v = trie.next(v, target[j]) if u == -1 or v == -1: break if trie.id(u) != -1 and trie.id(v) != -1: dp[(j+1)%len(dp)] = min(dp[(j+1)%len(dp)], dp[i%len(dp)]+dists[j-i+1][trie.id(u)][trie.id(v)]) dp[i%len(dp)] = INF return dp[len(source)%len(dp)] if dp[len(source)%len(dp)] != INF else -1 ", "class Solution def removeTrailingZeros(self, num): return num[:next(i for i in reversed(xrange(len(num))) if num[i] != '0')+1] ", "class Solution def uniquePathsWithObstacles(self, obstacleGrid): m, n = len(obstacleGrid), len(obstacleGrid[0]) ways = [0]*n ways[0] = 1 for i in xrange(m): if obstacleGrid[i][0] == 1: ways[0] = 0 for j in xrange(n): if obstacleGrid[i][j] == 1: ways[j] = 0 elif j>0: ways[j] += ways[j-1] return ways[-1] ", "class Solution def countPalindromicSubsequence(self, s): first, last = [len(s)]*26, [-1]*26 for i, c in enumerate(s): first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i) last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i) return sum(len(set(s[i] for i in xrange(first[c]+1, last[c]))) for c in xrange(26)) ", "class Solution def minimumBeautifulSubstrings(self, s): max_pow_5 = 1 while max_pow_5*5 <= (1<<len(s))-1: max_pow_5 *= 5 dp = [float(\"inf\")]*(len(s)+1) dp[0] = 0 for i in xrange(len(s)): if s[i] == '0': continue curr = 0 for j in xrange(i, len(s)): curr = curr*2+int(s[j]) if max_pow_5%curr == 0: dp[j+1] = min(dp[j+1], dp[(i-1)+1]+1) return dp[-1] if dp[-1] != float(\"inf\") else -1 ", "class Solution def minimumBeautifulSubstrings(self, s): max_pow_5 = 1 while max_pow_5*5 <= (1<<len(s))-1: max_pow_5 *= 5 dp = [float(\"inf\")]*(len(s)+1) dp[0] = 0 for i in xrange(len(s)): curr = 0 for j in reversed(xrange(i+1)): curr += int(s[j])<<(i-j) if s[j] == '1' and max_pow_5%curr == 0: dp[i+1] = min(dp[i+1], dp[(j-1)+1]+1) return dp[-1] if dp[-1] != float(\"inf\") else -1 ", "class Solution def reverseList(self, head): dummy = ListNode(float(\"-inf\")) while head: dummy.next, head.next, head = head, dummy.next, head.next return dummy.next ", "class Solution def reverseList(self, head): [begin, end] = self.reverseListRecu(head) return begin def reverseListRecu(self, head): if not head: return [None, None] [begin, end] = self.reverseListRecu(head.next) if end: end.next = head head.next = None return [begin, head] else: return [head, head] ", "class Solution def maxValueOfCoins(self, piles, k): dp = [0] for pile in piles: new_dp = [0]*min(len(dp)+len(pile), k+1) for i in xrange(len(dp)): curr = 0 for j in xrange(min(k-i, len(pile))+1): new_dp[i+j] = max(new_dp[i+j], dp[i]+curr) curr += pile[j] if j < len(pile) else 0 dp = new_dp return dp[-1] ", "class Solution def maximumHappinessSum(self, happiness, k): happiness.sort(reverse=True) return sum(max(happiness[i]-i, 0) for i in xrange(k)) ", "class Solution def mostWordsFound(self, sentences): return 1+max(s.count(' ') for s in sentences) ", "class Solution def maxIntersectionCount(self, y): val_to_idx = {x:i for i, x in enumerate(sorted(set(y)))} cnts = [0]*(2*len(val_to_idx)+1) for i in xrange(len(y)-1): left, right = 2*val_to_idx[y[i]], 2*val_to_idx[y[i+1]]+(-1 if y[i] < y[i+1] else +1) cnts[min(left, right)] += 1 cnts[max(left, right)+1] -= 1 cnts[2*val_to_idx[y[-1]]] += 1 cnts[2*val_to_idx[y[-1]]+1] -= 1 result = cnt = 0 for c in cnts: cnt += c result = max(result, cnt) return result ", "class Solution def maxIntersectionCount(self, y): events = [] for i in xrange(len(y)-1): left, right = 2*y[i], 2*y[i+1]+(-1 if y[i] < y[i+1] else +1) events.append((min(left, right), +1)) events.append((max(left, right)+1, -1)) events.append((2*y[-1], +1)) events.append((2*y[-1]+1, -1)) events.sort() result = cnt = 0 for _, c in events: cnt += c result = max(result, cnt) return result ", "class Solution def minimumMoves(self, grid): def hungarian(a): if not a: return 0, [] n, m = len(a)+1, len(a[0])+1 u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1) for i in xrange(1, n): p[0] = i j0 = 0 dist, pre = [float(\"inf\")]*m, [-1]*m done = [False]*(m+1) while True: done[j0] = True i0, j1, delta = p[j0], None, float(\"inf\") for j in xrange(1, m): if done[j]: continue cur = a[i0-1][j-1]-u[i0]-v[j] if cur < dist[j]: dist[j], pre[j] = cur, j0 if dist[j] < delta: delta, j1 = dist[j], j for j in xrange(m): if done[j]: u[p[j]] += delta v[j] -= delta else: dist[j] -= delta j0 = j1 if not p[j0]: break while j0: j1 = pre[j0] p[j0], j0 = p[j1], j1 for j in xrange(1, m): if p[j]: ans[p[j]-1] = j-1 return -v[0], ans def dist(a, b): return abs(a[0]-b[0])+abs(a[1]-b[1]) src, dst = [], [] for i in xrange(len(grid)): for j in xrange(len(grid[0])): if grid[i][j]-1 >= 0: src.extend([(i, j)]*(grid[i][j]-1)) else: dst.append((i, j)) adj = [[dist(src[i], dst[j]) for j in xrange(len(dst))] for i in xrange(len(src))] return hungarian(adj)[0] from scipy.optimize import linear_sum_assignment as hungarian import itertools ", "class Solution def minimumMoves(self, grid): def dist(a, b): return abs(a[0]-b[0])+abs(a[1]-b[1]) src, dst = [], [] for i in xrange(len(grid)): for j in xrange(len(grid[0])): if grid[i][j]-1 >= 0: src.extend([(i, j)]*(grid[i][j]-1)) else: dst.append((i, j)) adj = [[dist(src[i], dst[j]) for j in xrange(len(dst))] for i in xrange(len(src))] return sum(adj[i][j] for i, j in itertools.izip(*hungarian(adj))) ", "class Solution def minimumMoves(self, grid): def dist(a, b): return abs(a[0]-b[0])+abs(a[1]-b[1]) def backtracking(curr): if curr == len(zero): return 0 result = float(\"inf\") i, j = zero[curr] for ni in xrange(len(grid)): for nj in xrange(len(grid[0])): if not (grid[ni][nj] >= 2): continue grid[ni][nj] -= 1 result = min(result, dist((i, j), (ni, nj))+backtracking(curr+1)) grid[ni][nj] += 1 return result zero = [(i, j) for i in xrange(len(grid)) for j in xrange(len(grid[0])) if grid[i][j] == 0] return backtracking(0) ", "class Solution def minKBitFlips(self, A, K): result, curr = 0, 0 for i in xrange(len(A)): if i >= K: curr -= A[i-K]//2 if curr & 1 ^ A[i] == 0: if i+K > len(A): return -1 A[i] += 2 curr, result = curr+1, result+1 return result ", "class Solution def maximumTripletValue(self, nums): left = SortedList() right = [0]*len(nums) for i in reversed(xrange(1, len(nums)-1)): right[i] = max(right[i+1], nums[i+1]) result = 0 for i in xrange(1, len(nums)-1): left.add(nums[i-1]) j = left.bisect_left(nums[i]) if j-1 >= 0 and right[i] > nums[i]: result = max(result, left[j-1]-nums[i]+right[i]) return result from sortedcontainers import SortedList ", "class Solution def maximumTripletValue(self, nums): left = SortedList() right = SortedList(nums[i] for i in xrange(1, len(nums))) result = 0 for i in xrange(1, len(nums)-1): left.add(nums[i-1]) right.remove(nums[i]) j = left.bisect_left(nums[i]) if j-1 >= 0 and right[-1] > nums[i]: result = max(result, left[j-1]-nums[i]+right[-1]) return result ", "class Solution def minWastedSpace(self, packages, boxes): MOD = 10**9+7 INF = float(\"inf\") packages.sort() result = INF for box in boxes: box.sort() if box[-1] < packages[-1]: continue curr = left = 0 for b in box: right = bisect.bisect_right(packages, b, left) curr += b * (right-left) left = right result = min(result, curr) return (result-sum(packages))%MOD if result != INF else -1 ", "class Solution def areSentencesSimilar(self, sentence1, sentence2): if len(sentence1) > len(sentence2): sentence1, sentence2 = sentence2, sentence1 count = 0 for idx in (lambda x:x, lambda x:-1-x): for i in xrange(len(sentence1)+1): c1 = sentence1[idx(i)] if i != len(sentence1) else ' ' c2 = sentence2[idx(i)] if i != len(sentence2) else ' ' if c1 != c2: break if c1 == ' ': count += 1 return count >= sentence1.count(' ')+1 ", "class Solution def minimumCoins(self, prices): dp = [float(\"inf\")]*(len(prices)+1) dp[0] = 0 dq = collections.deque() j = 0 for i in xrange(len(prices)): while dq and dp[dq[-1]]+prices[dq[-1]] >= dp[i]+prices[i]: dq.pop() dq.append(i) while j+(j+1) < i: assert(len(dq) != 0) if dq[0] == j: dq.popleft() j += 1 dp[i+1] = dp[dq[0]]+prices[dq[0]] return dp[-1] from sortedcontainers import SortedList ", "class Solution def minimumCoins(self, prices): dp = [float(\"inf\")]*(len(prices)+1) dp[0] = 0 sl = SortedList() j = 0 for i in xrange(len(prices)): sl.add((dp[i]+prices[i], i)) while j+(j+1) < i: sl.remove(((dp[j]+prices[j], j))) j += 1 dp[i+1] = sl[0][0] return dp[-1] ", "class Solution def smallestSufficientTeam(self, req_skills, people): lookup = {v: i for i, v in enumerate(req_skills)} dp = {0: []} for i, p in enumerate(people): his_skill_set = 0 for skill in p: if skill in lookup: his_skill_set |= 1 << lookup[skill] for skill_set, people in dp.items(): with_him = skill_set | his_skill_set if with_him == skill_set: continue if with_him not in dp or len(dp[with_him]) > len(people)+1: dp[with_him] = people + [i] return dp[(1<<len(req_skills))-1] ", "class Solution def stringMatching(self, words): trie = AhoTrie(words) lookup = set() for i in xrange(len(words)): trie.reset() for c in words[i]: for j in trie.step(c): if j != i: lookup.add(j) return [words[i] for i in lookup] ", "class Solution def stringMatching(self, words): def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j != -1 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix def kmp(text, pattern, prefix): if not pattern: return 0 if len(text) < len(pattern): return -1 j = -1 for i in xrange(len(text)): while j != -1 and pattern[j+1] != text[i]: j = prefix[j] if pattern[j+1] == text[i]: j += 1 if j+1 == len(pattern): return i-j return -1 result = [] for i, pattern in enumerate(words): prefix = getPrefix(pattern) for j, text in enumerate(words): if i != j and kmp(text, pattern, prefix) != -1: result.append(pattern) break return result ", "class Solution def stringMatching(self, words): result = [] for i, pattern in enumerate(words): for j, text in enumerate(words): if i != j and pattern in text: result.append(pattern) break return result ", "class Solution def shortestWordDistance(self, words, word1, word2): dist = float(\"inf\") is_same = (word1 == word2) i, index1, index2 = 0, None, None while i < len(words): if words[i] == word1: if is_same and index1 is not None: dist = min(dist, abs(index1 - i)) index1 = i elif words[i] == word2: index2 = i if index1 is not None and index2 is not None: dist = min(dist, abs(index1 - index2)) i += 1 return dist ", "class Solution def arraySign(self, nums): flag = 0 for x in nums: if not x: return 0 if x < 0: flag ^= 1 return -1 if flag else 1 ", "class Solution def spiralOrder(self, matrix): result = [] if matrix == []: return result left, right, top, bottom = 0, len(matrix[0]) - 1, 0, len(matrix) - 1 while left <= right and top <= bottom: for j in xrange(left, right + 1): result.append(matrix[top][j]) for i in xrange(top + 1, bottom): result.append(matrix[i][right]) for j in reversed(xrange(left, right + 1)): if top < bottom: result.append(matrix[bottom][j]) for i in reversed(xrange(top + 1, bottom)): if left < right: result.append(matrix[i][left]) left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1 return result ", "class Solution def makeEqual(self, words): cnt = collections.defaultdict(int) for w in words: for c in w: cnt[c] += 1 return all(v%len(words) == 0 for v in cnt.itervalues()) ", "class Solution def isToeplitzMatrix(self, matrix): return all(i == 0 or j == 0 or matrix[i-1][j-1] == val for i, row in enumerate(matrix) for j, val in enumerate(row)) ", "class Solution def isToeplitzMatrix(self, matrix): for row_index, row in enumerate(matrix): for digit_index, digit in enumerate(row): if not row_index or not digit_index: continue if matrix[row_index - 1][digit_index - 1] != digit: return False return True ", "class Solution def sortVowels(self, s): def inplace_counting_sort(nums, reverse=False): if not nums: return count = [0]*(max(nums)+1) for num in nums: count[num] += 1 for i in xrange(1, len(count)): count[i] += count[i-1] for i in reversed(xrange(len(nums))): while nums[i] >= 0: count[nums[i]] -= 1 j = count[nums[i]] nums[i], nums[j] = nums[j], ~nums[i] for i in xrange(len(nums)): nums[i] = ~nums[i] if reverse: nums.reverse() VOWELS = \"AEIOUaeiou\" LOOKUP = {x:i for i, x in enumerate(VOWELS)} vowels = [LOOKUP[x] for x in s if x in LOOKUP] inplace_counting_sort(vowels, reverse=True) return \"\".join(VOWELS[vowels.pop()] if x in LOOKUP else x for x in s) ", "class Solution def sortVowels(self, s): VOWELS = \"AEIOUaeiou\" LOOKUP = set(VOWELS) vowels = [x for x in s if x in LOOKUP] vowels.sort(reverse=True) return \"\".join(vowels.pop() if x in LOOKUP else x for x in s) ", "class Solution def getDirections(self, root, startValue, destValue): def iter_dfs(root, val): path = [] stk = [(1, (root,))] while stk: step, args = stk.pop() if step == 1: node = args[0] if node.val == val: path.reverse() return path for i, child in enumerate((node.left, node.right)): if not child: continue stk.append((3, None)) stk.append((1, (child,))) stk.append((2, (\"LR\"[i],))) elif step == 2: path.append(args[0]) elif step == 3: path.pop() return [] src = iter_dfs(root, startValue) dst = iter_dfs(root, destValue) while len(src) and len(dst) and src[-1] == dst[-1]: src.pop() dst.pop() dst.reverse() return \"\".join(['U']*len(src) + dst) ", "class Solution def getDirections(self, root, startValue, destValue): def dfs(node, val, path): if node.val == val: return True if node.left and dfs(node.left, val, path): path.append('L') elif node.right and dfs(node.right, val, path): path.append('R') return path src, dst = [], [] dfs(root, startValue, src) dfs(root, destValue, dst) while len(src) and len(dst) and src[-1] == dst[-1]: src.pop() dst.pop() dst.reverse() return \"\".join(['U']*len(src) + dst) ", "class Solution def rowAndMaximumOnes(self, mat): return max(([i, mat[i].count(1)] for i in xrange(len(mat))), key=lambda x: x[1]) ", "class Solution def maximumTripletValue(self, nums): NEG_INF = float(\"-inf\") result = 0 mx_diff = mx = NEG_INF for x in nums: if mx_diff != NEG_INF: result = max(result, mx_diff*x) if mx != NEG_INF: mx_diff = max(mx_diff, mx-x) mx = max(mx, x) return result ", "class Solution def winnerOfGame(self, colors): cnt1 = cnt2 = 0 for i in xrange(1, len(colors)-1): if not (colors[i-1] == colors[i] == colors[i+1]): continue if colors[i] == 'A': cnt1 += 1 else: cnt2 += 1 return cnt1 > cnt2 ", "class Solution def originalDigits(self, s): cnts = [Counter(_) for _ in [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]] order = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9] unique_chars = ['z', 'o', 'w', 't', 'u', 'f', 'x', 's', 'g', 'n'] cnt = Counter(list(s)) res = [] for i in order: while cnt[unique_chars[i]] > 0: cnt -= cnts[i] res.append(i) res.sort() return \"\".join(map(str, res)) ", "class Solution def mergeArrays(self, nums1, nums2): result = [] i = j = 0 while i < len(nums1) or j < len(nums2): if j == len(nums2) or (i < len(nums1) and nums1[i][0] < nums2[j][0]): if result and result[-1][0] == nums1[i][0]: result[-1][1] += nums1[i][1] else: result.append(nums1[i]) i += 1 else: if result and result[-1][0] == nums2[j][0]: result[-1][1] += nums2[j][1] else: result.append(nums2[j]) j += 1 return result ", "class Solution def maxRunTime(self, n, batteries): total = sum(batteries) for i in xrange(len(batteries)): batteries[i] = -batteries[i] heapq.heapify(batteries) while -batteries[0] > total//n: n -= 1 total -= -heapq.heappop(batteries) return total//n ", "class Solution def maxRunTime(self, n, batteries): def check(n, batteries, x): return sum(min(b, x) for b in batteries) >= n*x left, right = min(batteries), sum(batteries)//n while left <= right: mid = left + (right-left)//2 if not check(n, batteries, mid): right = mid-1 else: left = mid+1 return right ", "class Solution def areSentencesSimilar(self, words1, words2, pairs): if len(words1) != len(words2): return False lookup = set(map(tuple, pairs)) return all(w1 == w2 or (w1, w2) in lookup or (w2, w1) in lookup for w1, w2 in itertools.izip(words1, words2)) ", "class Solution def exist(self, board, word): visited = [[False for j in xrange(len(board[0]))] for i in xrange(len(board))] for i in xrange(len(board)): for j in xrange(len(board[0])): if self.existRecu(board, word, 0, i, j, visited): return True return False def existRecu(self, board, word, cur, i, j, visited): if cur == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[cur]: return False visited[i][j] = True result = self.existRecu(board, word, cur + 1, i + 1, j, visited) or self.existRecu(board, word, cur + 1, i - 1, j, visited) or self.existRecu(board, word, cur + 1, i, j + 1, visited) or self.existRecu(board, word, cur + 1, i, j - 1, visited) visited[i][j] = False return result ", "class Solution def nextPermutation(self, nums): k, l = -1, 0 for i in reversed(xrange(len(nums)-1)): if nums[i] < nums[i+1]: k = i break else: nums.reverse() return for i in reversed(xrange(k+1, len(nums))): if nums[i] > nums[k]: l = i break nums[k], nums[l] = nums[l], nums[k] nums[k+1:] = nums[:k:-1] ", "class Solution def nextPermutation(self, nums): k, l = -1, 0 for i in xrange(len(nums)-1): if nums[i] < nums[i+1]: k = i if k == -1: nums.reverse() return for i in xrange(k+1, len(nums)): if nums[i] > nums[k]: l = i nums[k], nums[l] = nums[l], nums[k] nums[k+1:] = nums[:k:-1] ", "class Solution def maxWidthRamp(self, A): result = 0 s = [] for i in A: if not s or A[s[-1]] > A[i]: s.append(i) for j in reversed(xrange(len(A))): while s and A[s[-1]] <= A[j]: result = max(result, j-s.pop()) return result ", "class Solution def transpose(self, A): result = [[None] * len(A) for _ in xrange(len(A[0]))] for r, row in enumerate(A): for c, val in enumerate(row): result[c][r] = val return result ", "class Solution def transpose(self, A): return zip(*A) ", "class Solution def minimumTime(self, nums1, nums2, x): dp = [0]*(len(nums1)+1) for i, (b, a) in enumerate(sorted(zip(nums2, nums1)), 1): for j in reversed(xrange(1, i+1)): dp[j] = max(dp[j], dp[j-1]+(a+j*b)) total1, total2 = sum(nums1), sum(nums2) return next((j for j in xrange(len(dp)) if (total1+j*total2)-dp[j] <= x), -1) ", "class Solution def findTargetSumWays(self, nums, S): def subsetSum(nums, S): dp = collections.defaultdict(int) dp[0] = 1 for n in nums: for i in reversed(xrange(n, S+1)): if i-n in dp: dp[i] += dp[i-n] return dp[S] total = sum(nums) if total < S or (S + total) % 2: return 0 P = (S + total) // 2 return subsetSum(nums, P) ", "class Solution def mctFromLeafValues(self, arr): result = 0 stk = [float(\"inf\")] for x in arr: while stk[-1] <= x: result += stk.pop() * min(stk[-1], x) stk.append(x) while len(stk) > 2: result += stk.pop() * stk[-1] return result ", "class Solution def preimageSizeFZF(self, K): def count_of_factorial_primes(n, p): cnt = 0 while n > 0: cnt += n//p n //= p return cnt p = 5 left, right = 0, p*K while left <= right: mid = left + (right-left)//2 if count_of_factorial_primes(mid, p) >= K: right = mid-1 else: left = mid+1 return p if count_of_factorial_primes(left, p) == K else 0 ", "class Solution def maximumImportance(self, n, roads): def inplace_counting_sort(nums, reverse=False): count = [0]*(max(nums)+1) for num in nums: count[num] += 1 for i in xrange(1, len(count)): count[i] += count[i-1] for i in reversed(xrange(len(nums))): while nums[i] >= 0: count[nums[i]] -= 1 j = count[nums[i]] nums[i], nums[j] = nums[j], ~nums[i] for i in xrange(len(nums)): nums[i] = ~nums[i] if reverse: nums.reverse() degree = [0]*n for a, b in roads: degree[a] += 1 degree[b] += 1 inplace_counting_sort(degree) return sum(i*x for i, x in enumerate(degree, 1)) ", "class Solution def maximumImportance(self, n, roads): degree = [0]*n for a, b in roads: degree[a] += 1 degree[b] += 1 degree.sort() return sum(i*x for i, x in enumerate(degree, 1)) ", "class Solution def mergeTriplets(self, triplets, target): result = [0]*3 for t in triplets: if all(t[i] <= target[i] for i in xrange(3)): result = [max(result[i], t[i]) for i in xrange(3)] return result == target ", "class Solution def maximumEnergy(self, energy, k): result = float(\"-inf\") for i in xrange(k): curr = 0 for j in reversed(xrange(((len(energy)-i)-1)%k, len(energy)-i, k)): curr += energy[j] result = max(result, curr) return result ", "class Solution def findMinHeightTrees(self, n, edges): if n == 1: return [0] neighbors = collections.defaultdict(set) for u, v in edges: neighbors[u].add(v) neighbors[v].add(u) pre_level, unvisited = [], set() for i in xrange(n): if len(neighbors[i]) == 1: pre_level.append(i) unvisited.add(i) while len(unvisited) > 2: cur_level = [] for u in pre_level: unvisited.remove(u) for v in neighbors[u]: if v in unvisited: neighbors[v].remove(u) if len(neighbors[v]) == 1: cur_level.append(v) pre_level = cur_level return list(unvisited) ", "class Solution def isPalindrome(self, head): reverse, fast = None, head while fast and fast.next: fast = fast.next.next head.next, reverse, head = reverse, head, head.next tail = head.next if fast else head is_palindrome = True while reverse: is_palindrome = is_palindrome and reverse.val == tail.val reverse.next, head, reverse = head, reverse, reverse.next tail = tail.next return is_palindrome ", "class Solution def minimumOperations(self, root): result = 0 q = [root] while q: new_q = [] for node in q: if node.left: new_q.append(node.left) if node.right: new_q.append(node.right) idx = range(len(q)) idx.sort(key=lambda x: q[x].val) for i in xrange(len(q)): while idx[i] != i: idx[idx[i]], idx[i] = idx[i], idx[idx[i]] result += 1 q = new_q return result ", "class Solution def isValid(self, code): def validText(s, i): j = i i = s.find(\"<\", i) return i != j, i def validCData(s, i): if s.find(\"<![CDATA[\", i) != i: return False, i j = s.find(\"]]>\", i) if j == -1: return False, i return True, j+3 def parseTagName(s, i): if s[i] != '<': return \"\", i j = s.find('>', i) if j == -1 or not (1 <= (j-1-i) <= 9): return \"\", i tag = s[i+1:j] for c in tag: if not (ord('A') <= ord(c) <= ord('Z')): return \"\", i return tag, j+1 def parseContent(s, i): while i < len(s): result, i = validText(s, i) if result: continue result, i = validCData(s, i) if result: continue result, i = validTag(s, i) if result: continue break return i def validTag(s, i): tag, j = parseTagName(s, i) if not tag: return False, i j = parseContent(s, j) k = j + len(tag) + 2 if k >= len(s) or s[j:k+1] != \"</\" + tag + \">\": return False, i return True, k+1 result, i = validTag(code, 0) return result and i == len(code) ", "class Solution def maximizeGreatness(self, nums): return len(nums)-max(collections.Counter(nums).itervalues()) ", "class Solution def maximizeGreatness(self, nums): nums.sort() left = 0 for right in xrange(len(nums)): if nums[right] > nums[left]: left += 1 return left ", "class Solution def putMarbles(self, weights, k): def nth_element(nums, n, left=0, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right right = len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 for i in xrange(len(weights)-1): weights[i] += weights[i+1] weights.pop() result = 0 nth_element(weights, (k-1)-1, compare=lambda a, b: a > b) result += sum(weights[i] for i in xrange(k-1)) nth_element(weights, (k-1)-1) result -= sum(weights[i] for i in xrange(k-1)) return result ", "class Solution def latestTimeCatchTheBus(self, buses, passengers, capacity): buses.sort() passengers.sort() cnt = j = 0 for i in xrange(len(buses)-1): while j < len(passengers) and passengers[j] <= buses[i]: cnt += 1 j += 1 cnt = max(cnt-capacity, 0) j -= max(cnt-capacity, 0) cnt = min(cnt, capacity) while j < len(passengers) and passengers[j] <= buses[-1] and cnt+1 <= capacity: cnt += 1 j += 1 return buses[-1] if cnt < capacity and (j-1 < 0 or passengers[j-1] != buses[-1]) else next(passengers[i]-1 for i in reversed(xrange(j)) if i-1 < 0 or passengers[i]-1 != passengers[i-1]) ", "class Solution def reorganizeString(self, S): counts = collections.Counter(S) if any(v > (len(S)+1)/2 for k, v in counts.iteritems()): return \"\" result = [] max_heap = [] for k, v in counts.iteritems(): heapq.heappush(max_heap, (-v, k)) while len(max_heap) > 1: count1, c1 = heapq.heappop(max_heap) count2, c2 = heapq.heappop(max_heap) if not result or c1 != result[-1]: result.extend([c1, c2]) if count1+1: heapq.heappush(max_heap, (count1+1, c1)) if count2+1: heapq.heappush(max_heap, (count2+1, c2)) return \"\".join(result) + (max_heap[0][1] if max_heap else '') ", "class Solution def mergeStones(self, stones, K): if (len(stones)-1) % (K-1): return -1 prefix = [0] for x in stones: prefix.append(prefix[-1]+x) dp = [[0]*len(stones) for _ in xrange(len(stones))] for l in xrange(K-1, len(stones)): for i in xrange(len(stones)-l): dp[i][i+l] = min(dp[i][j]+dp[j+1][i+l] for j in xrange(i, i+l, K-1)) if l % (K-1) == 0: dp[i][i+l] += prefix[i+l+1] - prefix[i] return dp[0][len(stones)-1] ", "class Solution def numberOfPaths(self, n, corridors): adj = [set() for _ in xrange(n)] for u, v in corridors: adj[min(u, v)-1].add(max(u, v)-1) return sum(k in adj[i] for i in xrange(n) for j in adj[i] for k in adj[j]) ", "class Solution def partitionDisjoint(self, A): B = A[:] for i in reversed(xrange(len(A)-1)): B[i] = min(B[i], B[i+1]) p_max = 0 for i in xrange(1, len(A)): p_max = max(p_max, A[i-1]) if p_max <= B[i]: return i ", "class Solution def minimumCost(self, n, edges, query): class UnionFind(object): def __init__(self, n): self.set = list(range(n)) self.rank = [0]*n self.w = [-1]*n def find_set(self, x): stk = [] while self.set[x] != x: stk.append(x) x = self.set[x] while stk: self.set[stk.pop()] = x return x def union_set(self, x, y, w): x, y = self.find_set(x), self.find_set(y) if x == y: self.w[x] &= w return False if self.rank[x] > self.rank[y]: x, y = y, x self.set[x] = self.set[y] if self.rank[x] == self.rank[y]: self.rank[y] += 1 self.w[y] &= self.w[x]&w return True def cost(self, x): return self.w[self.find_set(x)] uf = UnionFind(n) for u, v, w in edges: uf.union_set(u, v, w) result = [-1]*(len(query)) for i, (s, t) in enumerate(query): if uf.find_set(s) != uf.find_set(t): continue result[i] = uf.cost(s) if s != t else 0 return result ", "class Solution def eraseOverlapIntervals(self, intervals): intervals.sort(key=lambda interval: interval.start) result, prev = 0, 0 for i in xrange(1, len(intervals)): if intervals[i].start < intervals[prev].end: if intervals[i].end < intervals[prev].end: prev = i result += 1 else: prev = i return result ", "class Solution def checkTree(self, root): return root.val == root.left.val+root.right.val ", "class Solution def semiOrderedPermutation(self, nums): i, j = nums.index(1), nums.index(len(nums)) return i+((len(nums)-1)-j)-int(i > j) ", "class Solution def splitMessage(self, message, limit): cnt, l, total, base = 1, 1, len(message)+1, 1 while 3+l*2 < limit: if total+(3+l)*cnt <= limit*cnt: break cnt += 1 if cnt == base*10: l += 1 base *= 10 total += l if 3+l*2 >= limit: return [] result = [] j = 0 for i in xrange(cnt): l = limit-(3+len(str(i+1))+len(str(cnt))) result.append(\"%s<%s/%s>\"%(message[j:j+l], i+1, cnt)) j += l return result ", "class Solution def maxPower(self, stations, r, k): def min_power(): mn = float(\"inf\") curr = sum(stations[i] for i in xrange(r)) for i in xrange(len(stations)): if i+r < len(stations): curr += stations[i+r] if i >= r+1: curr -= stations[i-(r+1)] mn = min(mn, curr) return mn def check(target): arr = stations[:] curr = sum(arr[i] for i in xrange(r)) cnt = k for i in xrange(len(arr)): if i+r < len(arr): curr += arr[i+r] if i >= r+1: curr -= arr[i-(r+1)] if curr >= target: continue diff = target-curr if diff > cnt: return False cnt -= diff curr += diff if i+r < len(arr): arr[i+r] += diff return True mn = min_power() left, right = mn, mn+k while left <= right: mid = left + (right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right ", "class Solution def minimumRelativeLosses(self, prices, queries): def binary_search(left, right, check): while left <= right: mid = left + (right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left prices.sort() prefix = [0]*(len(prices)+1) for i in xrange(len(prices)): prefix[i+1] = prefix[i]+prices[i] result = [] for k, m in queries: cnt = binary_search(0, m-1, lambda x: k-(prices[-(m-x)]-k) <= prices[(x+1)-1]-0) a = prefix[-1]-prefix[-1-(m-cnt)]-(m-cnt)*k b = prefix[cnt]+(m-cnt)*k result.append(b-a) return result ", "class Solution def numberWays(self, hats): MOD = 10**9 + 7 HAT_SIZE = 40 hat_to_people = [[] for _ in xrange(HAT_SIZE)] for i in xrange(len(hats)): for h in hats[i]: hat_to_people[h-1].append(i) dp = [0]*(1<<len(hats)) dp[0] = 1 for people in hat_to_people: for mask in reversed(xrange(len(dp))): for p in people: if mask & (1<<p): continue dp[mask | (1<<p)] += dp[mask] dp[mask | (1<<p)] %= MOD return dp[-1] ", "class Solution def makePalindrome(self, s): return sum(s[i] != s[~i] for i in xrange(len(s)//2)) <= 2 ", "class Solution def makePalindrome(self, s): cnt = 0 left, right = 0, len(s)-1 while left < right: if s[left] != s[right]: cnt += 1 if cnt > 2: return False left += 1 right -= 1 return True ", "class Solution def findInteger(self, k, digit1, digit2): MAX_NUM_OF_DIGITS = 10 INT_MAX = 2**31-1 if digit1 < digit2: digit1, digit2 = digit2, digit1 total = 2 for l in xrange(1, MAX_NUM_OF_DIGITS+1): for mask in xrange(total): curr, bit = 0, total>>1 while bit: curr = curr*10 + (digit1 if mask&bit else digit2) bit >>= 1 if k < curr <= INT_MAX and curr%k == 0: return curr total <<= 1 return -1 ", "class Solution def countPartitions(self, nums, k): MOD = 10**9+7 if sum(nums) < 2*k: return 0 dp = [0]*k dp[0] = 1 for x in nums: for i in reversed(xrange(k-x)): dp[i+x] = (dp[i+x]+dp[i])%MOD return (pow(2, len(nums), MOD)-2*reduce(lambda total, x: (total+x)%MOD, dp, 0))%MOD ", "class Solution def maxScore(self, s): result, zeros, ones = 0, 0, 0 for i in xrange(1, len(s)-1): if s[i] == '0': zeros += 1 else: ones += 1 result = max(result, zeros-ones) return result + ones + (s[0] == '0') + (s[-1] == '1') ", "class Solution def isPowerOfTwo(self, n): return n > 0 and (n & (n - 1)) == 0 ", "class Solution def isPowerOfTwo(self, n): return n > 0 and (n & ~-n) == 0 ", "class Solution def maxProduct(self, A): global_max, local_max, local_min = float(\"-inf\"), 1, 1 for x in A: local_max, local_min = max(x, local_max * x, local_min * x), min(x, local_max * x, local_min * x) global_max = max(global_max, local_max) return global_max ", "class Solution def maxProduct(self, A): global_max, local_max, local_min = float(\"-inf\"), 1, 1 for x in A: local_max = max(1, local_max) if x > 0: local_max, local_min = local_max * x, local_min * x else: local_max, local_min = local_min * x, local_max * x global_max = max(global_max, local_max) return global_max ", "class Solution def canMeasureWater(self, x, y, z): def gcd(a, b): while b: a, b = b, a%b return a return z == 0 or ((z <= x + y) and (z % gcd(x, y) == 0)) ", "class Solution def rotateRight(self, head, k): if not head or not head.next: return head n, cur = 1, head while cur.next: cur = cur.next n += 1 cur.next = head cur, tail = head, cur for _ in xrange(n - k % n): tail = cur cur = cur.next tail.next = None return cur ", "class Solution def reverseStr(self, s, k): s = list(s) for i in xrange(0, len(s), 2*k): s[i:i+k] = reversed(s[i:i+k]) return \"\".join(s) ", "class Solution def prisonAfterNDays(self, cells, N): N -= max(N-1, 0) // 14 * 14 for i in xrange(N): cells = [0] + [cells[i-1] ^ cells[i+1] ^ 1 for i in xrange(1, 7)] + [0] return cells ", "class Solution def prisonAfterNDays(self, cells, N): cells = tuple(cells) lookup = {} while N: lookup[cells] = N N -= 1 cells = tuple([0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in xrange(1, 7)] + [0]) if cells in lookup: assert(lookup[cells] - N in (1, 7, 14)) N %= lookup[cells] - N break while N: N -= 1 cells = tuple([0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in xrange(1, 7)] + [0]) return list(cells) ", "class Solution def minimumScore(self, s, t): right = [-1]*len(s) j = len(t)-1 for i in reversed(xrange(len(s))): if j >= 0 and t[j] == s[i]: j -= 1 right[i] = j result = j+1 left = 0 for i in xrange(len(s)): result = max(min(result, right[i]-left+1), 0) if left < len(t) and t[left] == s[i]: left += 1 result = min(result, len(t)-left) return result ", "class Solution def differByOne(self, dict): MOD, P = 10**9+7, 113 hashes = [0]*len(dict) for i, word in enumerate(dict): for c in word: hashes[i] = (P*hashes[i] + (ord(c)-ord('a'))) % MOD base = 1 for p in reversed(xrange(len(dict[0]))): lookup = collections.defaultdict(list) for i, word in enumerate(dict): new_hash = (hashes[i] - base*(ord(word[p])-ord('a'))) % MOD if new_hash in lookup: for j in lookup[new_hash]: if dict[j][:p]+dict[j][p+1:] == word[:p]+word[p+1:]: return True lookup[new_hash].append(i) base = P*base % MOD return False ", "class Solution def validSubarrays(self, nums): result = 0 s = [] for num in nums: while s and s[-1] > num: s.pop() s.append(num); result += len(s) return result ", "class Solution def splitArraySameAverage(self, A): def possible(total, n): for i in xrange(1, n//2+1): if total*i%n == 0: return True return False n, s = len(A), sum(A) if not possible(n, s): return False sums = [set() for _ in xrange(n//2+1)] sums[0].add(0) for num in A: for i in reversed(xrange(1, n//2+1)): for prev in sums[i-1]: sums[i].add(prev+num) for i in xrange(1, n//2+1): if s*i%n == 0 and s*i//n in sums[i]: return True return False ", "class Solution def __init__(self, w): self.__prefix_sum = list(w) for i in xrange(1, len(w)): self.__prefix_sum[i] += self.__prefix_sum[i-1] def pickIndex(self): target = random.randint(0, self.__prefix_sum[-1]-1) return bisect.bisect_right(self.__prefix_sum, target) ", "class Solution def networkDelayTime(self, times, N, K): adj = [[] for _ in xrange(N)] for u, v, w in times: adj[u-1].append((v-1, w)) result = 0 lookup = set() best = collections.defaultdict(lambda: float(\"inf\")) best[K-1] = 0 min_heap = [(0, K-1)] while min_heap and len(lookup) != N: result, u = heapq.heappop(min_heap) lookup.add(u) if best[u] < result: continue for v, w in adj[u]: if v in lookup: continue if result+w < best[v]: best[v] = result+w heapq.heappush(min_heap, (result+w, v)) return result if len(lookup) == N else -1 ", "class Solution def sumIndicesWithKSetBits(self, nums, k): def next_popcount(n): lowest_bit = n&-n left_bits = n+lowest_bit changed_bits = n^left_bits right_bits = (changed_bits//lowest_bit)>>2 return left_bits|right_bits result = 0 i = (1<<k)-1 while i < len(nums): result += nums[i] if i == 0: break i = next_popcount(i) return result ", "class Solution def sumIndicesWithKSetBits(self, nums, k): def popcount(x): return bin(x)[1:].count('1') return sum(x for i, x in enumerate(nums) if popcount(i) == k) ", "class Solution def minCostSetTime(self, startAt, moveCost, pushCost, targetSeconds): def cost(m, s): if not (0 <= m <= 99 and s <= 99): return float(\"inf\") result = 0 curr = startAt for x in map(int, list(str(m*100 + s))): result += (moveCost if x != curr else 0)+pushCost curr = x return result m, s = divmod(targetSeconds, 60) return min(cost(m, s), cost(m-1, s+60)) ", "class Solution def isBoomerang(self, points): return (points[0][0] - points[1][0]) * (points[0][1] - points[2][1]) - (points[0][0] - points[2][0]) * (points[0][1] - points[1][1]) != 0 ", "class Solution def maxValue(self, n, index, maxSum): def check(n, index, maxSum, x): y = max(x-index, 0) total = (x+y)*(x-y+1)//2 y = max(x-((n-1)-index), 0) total += (x+y)*(x-y+1)//2 return total-x <= maxSum maxSum -= n left, right = 0, maxSum while left <= right: mid = left + (right-left)//2 if not check(n, index, maxSum, mid): right = mid-1 else: left = mid+1 return 1+right ", "class Solution def splitWordsBySeparator(self, words, separator): return [w for word in words for w in word.split(separator) if w] ", "class Solution def numSubmatrixSumTarget(self, matrix, target): if len(matrix) > len(matrix[0]): return self.numSubmatrixSumTarget(map(list, zip(*matrix)), target) for i in xrange(len(matrix)): for j in xrange(len(matrix[i])-1): matrix[i][j+1] += matrix[i][j] result = 0 for i in xrange(len(matrix)): prefix_sum = [0]*len(matrix[i]) for j in xrange(i, len(matrix)): lookup = collections.defaultdict(int) lookup[0] = 1 for k in xrange(len(matrix[j])): prefix_sum[k] += matrix[j][k] if prefix_sum[k]-target in lookup: result += lookup[prefix_sum[k]-target] lookup[prefix_sum[k]] += 1 return result ", "class Solution def removeDuplicates(self, A): if not A: return 0 last, i, same = 0, 1, False while i < len(A): if A[last] != A[i] or not same: same = A[last] == A[i] last += 1 A[last] = A[i] i += 1 return last + 1 ", "class Solution def totalCost(self, costs, k, candidates): left, right = candidates, max(len(costs)-candidates, candidates)-1 min_heap1, min_heap2 = costs[:left], costs[right+1:] heapq.heapify(min_heap1), heapq.heapify(min_heap2) result = 0 for _ in xrange(k): if not min_heap2 or (min_heap1 and min_heap1[0] <= min_heap2[0]): result += heapq.heappop(min_heap1) if left <= right: heapq.heappush(min_heap1, costs[left]) left += 1 else: result += heapq.heappop(min_heap2) if left <= right: heapq.heappush(min_heap2, costs[right]) right -= 1 return result ", "class Solution def nearestExit(self, maze, entrance): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = ' ' entrance = tuple(entrance) left = set([entrance]) right = set([(r, 0) for r in xrange(len(maze)-1) if maze[r][0] == '.' and (r, 0) != entrance] + [(len(maze)-1, c) for c in xrange(len(maze[0])-1) if maze[len(maze)-1][c] == '.' and (len(maze)-1, c) != entrance] + [(r, len(maze[0])-1) for r in reversed(xrange(1, len(maze))) if maze[r][len(maze[0])-1] == '.' and (r, len(maze[0])-1) != entrance] + [(0, c) for c in reversed(xrange(1, len(maze[0]))) if maze[0][c] == '.' and (0, c) != entrance]) steps = 0 while left: for (r, c) in left: maze[r][c] = visited new_left = set() for (r, c) in left: if (r, c) in right: return steps for dr, dc in directions: nr, nc = r+dr, c+dc if not (0 <= nr < len(maze) and 0 <= nc < len(maze[0]) and maze[nr][nc] == '.'): continue new_left.add((nr, nc)) left = new_left steps += 1 if len(left) > len(right): left, right = right, left return -1 ", "class Solution def nearestExit(self, maze, entrance): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = ' ' entrance = tuple(entrance) maze[entrance[0]][entrance[1]] = visited q = [(entrance, 0)] while q: new_q = [] for (r, c), step in q: if (r, c) != entrance and (r in (0, len(maze)-1) or c in (0, len(maze[0])-1)): return step for dr, dc in directions: nr, nc = r+dr, c+dc if not (0 <= nr < len(maze) and 0 <= nc < len(maze[0]) and maze[nr][nc] == '.'): continue maze[nr][nc] = visited q.append(((nr, nc), step+1)) q = new_q return -1 ", "class Solution def minimizeArrayValue(self, nums): def ceil_divide(a, b): return (a+b-1)//b result = curr = 0 for i, x in enumerate(nums): curr += x result = max(result, ceil_divide(curr, i+1)) return result ", "class Solution def tallestBillboard(self, rods): def dp(A): lookup = collections.defaultdict(int) lookup[0] = 0 for x in A: for d, y in lookup.items(): lookup[d+x] = max(lookup[d+x], y) lookup[abs(d-x)] = max(lookup[abs(d-x)], y + min(d, x)) return lookup left, right = dp(rods[:len(rods)//2]), dp(rods[len(rods)//2:]) return max(left[d]+right[d]+d for d in left if d in right) ", "class Solution def numPermsDISequence(self, S): dp = [1]*(len(S)+1) for c in S: if c == \"I\": dp = dp[:-1] for i in xrange(1, len(dp)): dp[i] += dp[i-1] else: dp = dp[1:] for i in reversed(xrange(len(dp)-1)): dp[i] += dp[i+1] return dp[0] % (10**9+7) ", "class Solution def sumRemoteness(self, grid): DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1)) def bfs(i, j): total, cnt = grid[i][j], 1 grid[i][j] = -1 q = [(i, j)] while q: new_q = [] for i, j in q: for di, dj in DIRECTIONS: ni, nj = i+di, j+dj if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj] != -1): continue total += grid[ni][nj] cnt += 1 grid[ni][nj] = -1 new_q.append((ni, nj)) q = new_q return total, cnt groups = [bfs(i, j) for i in xrange(len(grid)) for j in xrange(len(grid[0])) if grid[i][j] != -1] total = sum(t for t, _ in groups) return sum((total-t)*c for t, c in groups) ", "class Solution def twoSumLessThanK(self, A, K): A.sort() result = -1 left, right = 0, len(A)-1 while left < right: if A[left]+A[right] >= K: right -= 1 else: result = max(result, A[left]+A[right]) left += 1 return result ", "class Solution def getRow(self, rowIndex): result = [0] * (rowIndex + 1) for i in xrange(rowIndex + 1): old = result[0] = 1 for j in xrange(1, i + 1): old, result[j] = result[j], old + result[j] return result def getRow2(self, rowIndex): row = [1] for _ in range(rowIndex): row = [x + y for x, y in zip([0] + row, row + [0])] return row def getRow3(self, rowIndex): if rowIndex == 0: return [1] res = [1, 1] def add(nums): res = nums[:1] for i, j in enumerate(nums): if i < len(nums) - 1: res += [nums[i] + nums[i + 1]] res += nums[:1] return res while res[1] < rowIndex: res = add(res) return res ", "class Solution def getRow(self, rowIndex): result = [1] for i in range(1, rowIndex + 1): result = [1] + [result[j - 1] + result[j] for j in xrange(1, i)] + [1] return result ", "class Solution def waysToBuyPensPencils(self, total, cost1, cost2): def gcd(a, b): while b: a, b = b, a%b return a def ceil_divide(a, b): return (a+b-1)//b def arithmetic_progression_sum(a, d, l): return (a+(a+(l-1)*d))*l//2 if cost1 < cost2: cost1, cost2 = cost2, cost1 lcm = cost1*cost2//gcd(cost1, cost2) result = 0 d = lcm//cost2 for i in xrange(min(total//cost1+1, lcm//cost1)): cnt = (total-i*cost1)//cost2+1 l = ceil_divide(cnt, d) result += arithmetic_progression_sum(cnt, -d, l) return result ", "class Solution def waysToBuyPensPencils(self, total, cost1, cost2): if cost1 < cost2: cost1, cost2 = cost2, cost1 return sum((total-i*cost1)//cost2+1 for i in xrange(total//cost1+1)) ", "class Solution def sumOddLengthSubarrays(self, arr): def ceil_divide(a, b): return (a+(b-1))//b return sum(x * ceil_divide((i-0+1)*((len(arr)-1)-i+1), 2) for i, x in enumerate(arr)) ", "class Solution def maximumProduct(self, nums): min1, min2 = float(\"inf\"), float(\"inf\") max1, max2, max3 = float(\"-inf\"), float(\"-inf\"), float(\"-inf\") for n in nums: if n <= min1: min2 = min1 min1 = n elif n <= min2: min2 = n if n >= max1: max3 = max2 max2 = max1 max1 = n elif n >= max2: max3 = max2 max2 = n elif n >= max3: max3 = n return max(min1 * min2 * max1, max1 * max2 * max3) ", "class Solution def processQueries(self, queries, m): bit = BIT(2*m+1) lookup = {} for i in xrange(1, m+1): bit.add(m+i, 1) lookup[i] = m+i result, curr = [], m for q in queries: i = lookup.pop(q) result.append(bit.sum(i-1)) bit.add(i, -1) lookup[q] = curr bit.add(curr, 1) curr -= 1 return result ", "class Solution def PredictTheWinner(self, nums): if len(nums) % 2 == 0 or len(nums) == 1: return True dp = [0] * len(nums) for i in reversed(xrange(len(nums))): dp[i] = nums[i] for j in xrange(i+1, len(nums)): dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1]) return dp[-1] >= 0 ", "class Solution def runningSum(self, nums): for i in xrange(len(nums)-1): nums[i+1] += nums[i] return nums ", "class Solution def reverse(self, x): if x < 0: return -self.reverse(-x) result = 0 while x: result = result * 10 + x % 10 x //= 10 return result if result <= 0x7fffffff else 0 def reverse2(self, x): if x < 0: x = int(str(x)[::-1][-1] + str(x)[::-1][:-1]) else: x = int(str(x)[::-1]) x = 0 if abs(x) > 0x7FFFFFFF else x return x def reverse3(self, x): s = cmp(x, 0) r = int(repr(s * x)[::-1]) return s * r * (r < 2 ** 31) ", "class Solution def probabilityOfHeads(self, prob, target): dp = [0.0]*(target+1) dp[0] = 1.0 for p in prob: for i in reversed(xrange(target+1)): dp[i] = (dp[i-1] if i >= 1 else 0.0)*p + dp[i]*(1-p) return dp[target] ", "class Solution def pyramidTransition(self, bottom, allowed): def pyramidTransitionHelper(bottom, edges, lookup): def dfs(bottom, edges, new_bottom, idx, lookup): if idx == len(bottom)-1: return pyramidTransitionHelper(\"\".join(new_bottom), edges, lookup) for i in edges[ord(bottom[idx])-ord('A')][ord(bottom[idx+1])-ord('A')]: new_bottom[idx] = chr(i+ord('A')) if dfs(bottom, edges, new_bottom, idx+1, lookup): return True return False if len(bottom) == 1: return True if bottom in lookup: return False lookup.add(bottom) for i in xrange(len(bottom)-1): if not edges[ord(bottom[i])-ord('A')][ord(bottom[i+1])-ord('A')]: return False new_bottom = ['A']*(len(bottom)-1) return dfs(bottom, edges, new_bottom, 0, lookup) edges = [[[] for _ in xrange(7)] for _ in xrange(7)] for s in allowed: edges[ord(s[0])-ord('A')][ord(s[1])-ord('A')].append(ord(s[2])-ord('A')) return pyramidTransitionHelper(bottom, edges, set()) ", "class Solution def minimumEffortPath(self, heights): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] dst = (len(heights)-1, len(heights[0])-1) dist = [[float(\"inf\")]*len(heights[0]) for _ in xrange(len(heights))] dist[0][0] = 0; min_heap = [(0, 0, 0)] lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))] while min_heap: d, r, c = heapq.heappop(min_heap) if lookup[r][c]: continue lookup[r][c] = True if (r, c) == dst: return d for dr, dc in directions: nr, nc = r+dr, c+dc if not (0 <= nr < len(heights) and 0 <= nc < len(heights[0]) and not lookup[nr][nc]): continue nd = max(d, abs(heights[nr][nc]-heights[r][c])) if nd < dist[nr][nc]: dist[nr][nc] = nd heapq.heappush(min_heap, (nd, nr, nc)) return -1 import collections class UnionFind(object): def __init__(self, n): self.set = range(n) self.rank = [0]*n def find_set(self, x): stk = [] while self.set[x] != x: stk.append(x) x = self.set[x] while stk: self.set[stk.pop()] = x return x def union_set(self, x, y): x_root, y_root = map(self.find_set, (x, y)) if x_root == y_root: return False if self.rank[x_root] < self.rank[y_root]: self.set[x_root] = y_root elif self.rank[x_root] > self.rank[y_root]: self.set[y_root] = x_root else: self.set[y_root] = x_root self.rank[x_root] += 1 return True ", "class Solution def minimumEffortPath(self, heights): def index(n, i, j): return i*n + j diffs = [] for i in xrange(len(heights)): for j in xrange(len(heights[0])): if i > 0: diffs.append((abs(heights[i][j]-heights[i-1][j]), index(len(heights[0]), i-1, j), index(len(heights[0]), i, j))) if j > 0: diffs.append((abs(heights[i][j]-heights[i][j-1]), index(len(heights[0]), i, j-1), index(len(heights[0]), i, j))) diffs.sort() union_find = UnionFind(len(heights)*len(heights[0])) for d, i, j in diffs: if union_find.union_set(i, j): if union_find.find_set(index(len(heights[0]), 0, 0)) == union_find.find_set(index(len(heights[0]), len(heights)-1, len(heights[0])-1)): return d return 0 ", "class Solution def minimumEffortPath(self, heights): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def check(heights, x): lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))] left, right = {(0, 0)}, {(len(heights)-1, len(heights[0])-1)} while left: for r, c in left: lookup[r][c] = True new_left = set() for r, c in left: if (r, c) in right: return True for dr, dc in directions: nr, nc = r+dr, c+dc if not (0 <= nr < len(heights) and 0 <= nc < len(heights[0]) and abs(heights[nr][nc]-heights[r][c]) <= x and not lookup[nr][nc]): continue new_left.add((nr, nc)) left = new_left if len(left) > len(right): left, right = right, left return False left, right = 0, 10**6 while left <= right: mid = left + (right-left)//2 if check(heights, mid): right = mid-1 else: left = mid+1 return left import collections ", "class Solution def minimumEffortPath(self, heights): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def check(heights, x): lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))] q = collections.deque([(0, 0)]) while q: r, c = q.popleft() if (r, c) == (len(heights)-1, len(heights[0])-1): return True for dr, dc in directions: nr, nc = r+dr, c+dc if not (0 <= nr < len(heights) and 0 <= nc < len(heights[0]) and abs(heights[nr][nc]-heights[r][c]) <= x and not lookup[nr][nc]): continue lookup[nr][nc] = True q.append((nr, nc)) return False left, right = 0, 10**6 while left <= right: mid = left + (right-left)//2 if check(heights, mid): right = mid-1 else: left = mid+1 return left ", "class Solution def minimumEffortPath(self, heights): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def check(heights, x): lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))] stk = [(0, 0)] while stk: r, c = stk.pop() if (r, c) == (len(heights)-1, len(heights[0])-1): return True for dr, dc in directions: nr, nc = r+dr, c+dc if not (0 <= nr < len(heights) and 0 <= nc < len(heights[0]) and abs(heights[nr][nc]-heights[r][c]) <= x and not lookup[nr][nc]): continue lookup[nr][nc] = True stk.append((nr, nc)) return False left, right = 0, 10**6 while left <= right: mid = left + (right-left)//2 if check(heights, mid): right = mid-1 else: left = mid+1 return left ", "class Solution def maximumWhiteTiles(self, tiles, carpetLen): tiles.sort() result = right = gap = 0 for left, (l, _) in enumerate(tiles): if left-1 >= 0: gap -= tiles[left][0]-tiles[left-1][1]-1 r = l+carpetLen-1 while right+1 < len(tiles) and r+1 >= tiles[right+1][0]: right += 1 gap += tiles[right][0]-tiles[right-1][1]-1 result = max(result, min(tiles[right][1]-tiles[left][0]+1, carpetLen)-gap) return result ", "class Solution def maximumWhiteTiles(self, tiles, carpetLen): tiles.sort() result = left = gap = 0 for right in xrange(len(tiles)): if right-1 >= 0: gap += tiles[right][0]-tiles[right-1][1]-1 l = tiles[right][1]-carpetLen+1 while not (tiles[left][1]+1 >= l): left += 1 gap -= tiles[left][0]-tiles[left-1][1]-1 result = max(result, min(tiles[right][1]-tiles[left][0]+1, carpetLen)-gap) return result import bisect ", "class Solution def maximumWhiteTiles(self, tiles, carpetLen): tiles.sort() prefix = [0]*(len(tiles)+1) for i, (l, r) in enumerate(tiles): prefix[i+1] = prefix[i]+(r-l+1) result = 0 for left, (l, _) in enumerate(tiles): r = l+carpetLen-1 right = bisect.bisect_right(tiles, [r+1])-1 extra = max(tiles[right][1]-r, 0) result = max(result, (prefix[right+1]-prefix[left])-extra) return result import bisect ", "class Solution def maximumWhiteTiles(self, tiles, carpetLen): tiles.sort() prefix = [0]*(len(tiles)+1) for i, (l, r) in enumerate(tiles): prefix[i+1] = prefix[i]+(r-l+1) result = 0 for right, (_, r) in enumerate(tiles): l = r-carpetLen+1 left = bisect.bisect_right(tiles, [l]) if left-1 >= 0 and tiles[left-1][1]+1 >= l: left -= 1 extra = max(l-tiles[left][0], 0) result = max(result, (prefix[right+1]-prefix[left])-extra) return result ", "class Solution def maxCompatibilitySum(self, students, mentors): def hungarian(a): if not a: return 0, [] n, m = len(a)+1, len(a[0])+1 u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1) for i in xrange(1, n): p[0] = i j0 = 0 dist, pre = [float(\"inf\")]*m, [-1]*m done = [False]*(m+1) while True: done[j0] = True i0, j1, delta = p[j0], None, float(\"inf\") for j in xrange(1, m): if done[j]: continue cur = a[i0-1][j-1]-u[i0]-v[j] if cur < dist[j]: dist[j], pre[j] = cur, j0 if dist[j] < delta: delta, j1 = dist[j], j for j in xrange(m): if done[j]: u[p[j]] += delta v[j] -= delta else: dist[j] -= delta j0 = j1 if not p[j0]: break while j0: j1 = pre[j0] p[j0], j0 = p[j1], j1 for j in xrange(1, m): if p[j]: ans[p[j]-1] = j-1 return -v[0], ans def score(s, m): return sum(int(a == b) for a, b in itertools.izip(s, m)) return -hungarian([[-score(s, m) for m in mentors] for s in students])[0] ", "class Solution def maxCompatibilitySum(self, students, mentors): def popcount(n): result = 0 while n: n &= n-1 result += 1 return result def masks(vvi): result = [] for vi in vvi: mask, bit = 0, 1 for i in xrange(len(vi)): if vi[i]: mask |= bit bit <<= 1 result.append(mask) return result nums1, nums2 = masks(students), masks(mentors) dp = [(0, 0)]*(2**len(nums2)) for mask in xrange(len(dp)): bit = 1 for i in xrange(len(nums2)): if (mask&bit) == 0: dp[mask|bit] = max(dp[mask|bit], (dp[mask][0]+(len(students[0])-popcount(nums1[dp[mask][1]]^nums2[i])), dp[mask][1]+1)) bit <<= 1 return dp[-1][0] ", "class Solution def minAreaFreeRect(self, points): points.sort() points = [complex(*z) for z in points] lookup = collections.defaultdict(list) for P, Q in itertools.combinations(points, 2): lookup[P-Q].append((P+Q) / 2) result = float(\"inf\") for A, candidates in lookup.iteritems(): for P, Q in itertools.combinations(candidates, 2): if A.real * (P-Q).real + A.imag * (P-Q).imag == 0.0: result = min(result, abs(A) * abs(P-Q)) return result if result < float(\"inf\") else 0.0 ", "class Solution def wonderfulSubstrings(self, word): ALPHABET_SIZE = 10 count = [0]*(2**ALPHABET_SIZE) count[0] = 1 result = curr = 0 for c in word: curr ^= 1<<(ord(c)-ord('a')) result += count[curr] result += sum(count[curr^(1<<i)] for i in xrange(ALPHABET_SIZE)) count[curr] += 1 return result ", "class Solution def isAnagram(self, s, t): if len(s) != len(t): return False count = collections.defaultdict(int) for c in s: count[c] += 1 for c in t: count[c] -= 1 if count[c] < 0: return False return True ", "class Solution def isAnagram(self, s, t): return collections.Counter(s) == collections.Counter(t) ", "class Solution def isAnagram(self, s, t): return sorted(s) == sorted(t) ", "class Solution def wordSubsets(self, A, B): count = collections.Counter() for b in B: for c, n in collections.Counter(b).items(): count[c] = max(count[c], n) result = [] for a in A: count = collections.Counter(a) if all(count[c] >= count[c] for c in count): result.append(a) return result ", "class Solution def sortItems(self, n, m, group, beforeItems): for i in xrange(n): if group[i] == -1: group[i] = m m += 1 global_group = Topo() for i in xrange(m): global_group.add_node(i) local_groups = collections.defaultdict(Topo) for i in xrange(n): local_groups[group[i]].add_node(i) for i in xrange(n): for j in beforeItems[i]: if group[i] == group[j]: local_groups[group[i]].add_edge(j, i) else: global_group.add_edge(group[j], group[i]); result = [] global_order = global_group.sort() if global_order is None: return [] for i in global_order: local_order = local_groups[i].sort(); if local_order is None: return [] for x in local_order: result.append(x) return result ", "class Solution def taskSchedulerII(self, tasks, space): lookup = collections.defaultdict(int) result = 0 for t in tasks: result = max(lookup[t], result+1) lookup[t] = result+space+1 return result ", "class Solution def mergeAlternately(self, word1, word2): result = [] i = 0 while i < len(word1) or i < len(word2): if i < len(word1): result.append(word1[i]) if i < len(word2): result.append(word2[i]) i += 1 return \"\".join(result) ", "class Solution def possibleToStamp(self, grid, stampHeight, stampWidth): prefix = [[0]*(len(grid[0])+1) for _ in xrange(len(grid)+1)] fit = [[0]*len(grid[0]) for _ in xrange(len(grid))] for i in xrange(len(grid)): for j in xrange(len(grid[0])): prefix[i+1][j+1] = prefix[i+1][j]+prefix[i][j+1]-prefix[i][j]+(1^grid[i][j]) if i+1 >= stampHeight and j+1 >= stampWidth: x, y = i+1-stampHeight, j+1-stampWidth fit[i][j] = int(prefix[i+1][j+1]-prefix[x][j+1]-prefix[i+1][y]+prefix[x][y] == stampWidth*stampHeight) prefix2 = [[0]*(len(grid[0])+1) for _ in xrange(len(grid)+1)] for i in xrange(len(grid)): for j in xrange(len(grid[0])): prefix2[i+1][j+1] = prefix2[i+1][j]+prefix2[i][j+1]-prefix2[i][j]+fit[i][j] for i in xrange(len(grid)): for j in xrange(len(grid[0])): x, y = min(i+stampHeight, len(grid)), min(j+stampWidth, len(grid[0])) if not grid[i][j] and not prefix2[x][y]-prefix2[i][y]-prefix2[x][j]+prefix2[i][j]: return False return True ", "class Solution def sumPrefixScores(self, words): _trie = lambda: collections.defaultdict(_trie) trie = _trie() for w in words: curr = trie for c in w: curr = curr[c] curr[\"_cnt\"] = curr[\"_cnt\"]+1 if \"_cnt\" in curr else 1 result = [] for w in words: cnt = 0 curr = trie for c in w: curr = curr[c] cnt += curr[\"_cnt\"] result.append(cnt) return result ", "class Solution def replaceNonCoprimes(self, nums): def gcd(a, b): while b: a, b = b, a%b return a result = [] for x in nums: while True: g = gcd(result[-1] if result else 1, x) if g == 1: break x *= result.pop()//g result.append(x) return result ", "class Solution def countRestrictedPaths(self, n, edges): MOD = 10**9+7 adj = [[] for _ in xrange(n)] for u, v, w in edges: adj[u-1].append((v-1, w)) adj[v-1].append((u-1, w)) dist = [float(\"inf\")]*n dp = [0]*n dist[n-1] = 0 dp[n-1] = 1 min_heap = [(0, n-1)] while min_heap: w, u = heapq.heappop(min_heap) if w > dist[u]: continue for v, d in adj[u]: if w+d < dist[v]: dist[v] = w+d heapq.heappush(min_heap, (dist[v], v)) elif w > dist[v]: dp[u] = (dp[u]+dp[v])%MOD if u == 0: break return dp[0] ", "class Solution def canConvert(self, str1, str2): if str1 == str2: return True lookup = {} for i, j in itertools.izip(str1, str2): if lookup.setdefault(i, j) != j: return False return len(set(str2)) < 26 ", "class Solution def platesBetweenCandles(self, s, queries): left, prefix = [0]*len(s), {} curr, cnt = -1, 0 for i in xrange(len(s)): if s[i] == '|': curr = i cnt += 1 prefix[i] = cnt left[i] = curr right = [0]*len(s) curr = len(s) for i in reversed(xrange(len(s))): if s[i] == '|': curr = i right[i] = curr return [max((left[r]-right[l]+1) - (prefix[left[r]]-prefix[right[l]]+1), 0) for l, r in queries] ", "class Solution def rearrangeString(self, s, k): if not k: return s cnts = collections.Counter(s) bucket_cnt = max(cnts.itervalues()) if not ((bucket_cnt-1)*k+sum(x == bucket_cnt for x in cnts.itervalues()) <= len(s)): return \"\" result = [0]*len(s) i = (len(s)-1)%k for c in itertools.chain((c for c, v in cnts.iteritems() if v == bucket_cnt), (c for c, v in cnts.iteritems() if v != bucket_cnt)): for _ in xrange(cnts[c]): result[i] = c i += k if i >= len(result): i = (i-1)%k return \"\".join(result) import collections import itertools ", "class Solution def rearrangeString(self, s, k): if not k: return s cnts = collections.Counter(s) bucket_cnt = (len(s)+k-1)//k if not (max(cnts.itervalues()) <= bucket_cnt and cnts.values().count(bucket_cnt) <= (len(s)-1)%k+1): return \"\" result = [0]*len(s) i = 0 for c in itertools.chain((c for c, v in cnts.iteritems() if v == bucket_cnt), (c for c, v in cnts.iteritems() if v <= bucket_cnt-2), (c for c, v in cnts.iteritems() if v == bucket_cnt-1)): for _ in xrange(cnts[c]): result[i] = c i += k if i >= len(result): i = i%k+1 return \"\".join(result) import collections import itertools ", "class Solution def rearrangeString(self, s, k): cnts = collections.Counter(s) bucket_cnt = max(cnts.itervalues()) buckets = [[] for _ in xrange(bucket_cnt)] i = 0 for c in itertools.chain((c for c, v in cnts.iteritems() if v == bucket_cnt), (c for c, v in cnts.iteritems() if v == bucket_cnt-1), (c for c, v in cnts.iteritems() if v <= bucket_cnt-2)): for _ in xrange(cnts[c]): buckets[i].append(c) i = (i+1) % max(cnts[c], bucket_cnt-1) if any(len(buckets[i]) < k for i in xrange(len(buckets)-1)): return \"\" return \"\".join(map(lambda x : \"\".join(x), buckets)) from collections import Counter from heapq import heappush, heappop ", "class Solution def rearrangeString(self, s, k): if k <= 1: return s cnts = Counter(s) heap = [] for c, cnt in cnts.iteritems(): heappush(heap, [-cnt, c]) result = [] while heap: used_cnt_chars = [] for _ in xrange(min(k, len(s) - len(result))): if not heap: return \"\" cnt_char = heappop(heap) result.append(cnt_char[1]) cnt_char[0] += 1 if cnt_char[0] < 0: used_cnt_chars.append(cnt_char) for cnt_char in used_cnt_chars: heappush(heap, cnt_char) return \"\".join(result) ", "class Solution def minimumOperations(self, nums, start, goal): MAX_X = 1000 nums = [y for y in nums if y and any(0 <= nx <= MAX_X for nx in (y, goal-y, goal+y, goal^y))] q = [(start, 0)] lookup = {start} while q: new_q = [] for x, steps in q: for y in nums: for nx in (x+y, x-y, x^y): if nx == goal: return steps+1 if not (0 <= nx <= MAX_X) or nx in lookup: continue lookup.add(nx) q.append((nx, steps+1)) q = new_q return -1 ", "class Solution def minimumTotalCost(self, nums1, nums2): cnt = collections.Counter() result = 0 for i, (x, y) in enumerate(itertools.izip(nums1, nums2)): if x != y: continue cnt[x] += 1 result += i if not cnt: return 0 majority = max(cnt.iterkeys(), key=lambda x: cnt[x]) remain = cnt[majority]-(sum(cnt.itervalues())-cnt[majority]) if remain <= 0: return result for i, (x, y) in enumerate(itertools.izip(nums1, nums2)): if x == y or majority in (x, y): continue result += i remain -= 1 if not remain: return result return -1 ", "class Solution def findMaximumXOR(self, nums): class Trie(object): def __init__(self, bit_length): self.__nodes = [] self.__new_node() self.__bit_length = bit_length def __new_node(self): self.__nodes.append([-1]*2) return len(self.__nodes)-1 def insert(self, num): curr = 0 for i in reversed(xrange(self.__bit_length)): x = num>>i if self.__nodes[curr][x&1] == -1: self.__nodes[curr][x&1] = self.__new_node() curr = self.__nodes[curr][x&1] def query(self, num): result = curr = 0 for i in reversed(xrange(self.__bit_length)): result <<= 1 x = num>>i if self.__nodes[curr][1^(x&1)] != -1: curr = self.__nodes[curr][1^(x&1)] result |= 1 else: curr = self.__nodes[curr][x&1] return result trie = Trie(max(nums).bit_length()) result = 0 for num in nums: trie.insert(num) result = max(result, trie.query(num)) return result ", "class Solution def findMaximumXOR(self, nums): result = 0 for i in reversed(xrange(max(nums).bit_length())): result <<= 1 prefixes = set() for n in nums: prefixes.add(n >> i) for p in prefixes: if (result | 1) ^ p in prefixes: result |= 1 break return result ", "class Solution def minimumLength(self, s): left, right = 0, len(s)-1 while left < right: if s[left] != s[right]: break c = s[left] while left <= right: if s[left] != c: break left += 1 while left <= right: if s[right] != c: break right -= 1 return right-left+1 ", "class Solution def minimumTimeToInitialState(self, word, k): def ceil_divide(a, b): return (a+b-1)//b def z_function(s): z = [0]*len(s) l, r = 0, 0 for i in xrange(1, len(z)): if i <= r: z[i] = min(r-i+1, z[i-l]) while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]: z[i] += 1 if i+z[i]-1 > r: l, r = i, i+z[i]-1 return z z = z_function(word) for i in xrange(k, len(word), k): if z[i] == len(word)-i: return i//k return ceil_divide(len(word), k) ", "class Solution def findMinArrowShots(self, points): if not points: return 0 points.sort() result = 0 i = 0 while i < len(points): j = i + 1 right_bound = points[i][1] while j < len(points) and points[j][0] <= right_bound: right_bound = min(right_bound, points[j][1]) j += 1 result += 1 i = j return result ", "class Solution def sortPeople(self, names, heights): order = range(len(names)) order.sort(key=lambda x: heights[x], reverse=True) return [names[i] for i in order] ", "class Solution def numWays(self, n, k): if n == 0: return 0 elif n == 1: return k ways = [0] * 3 ways[0] = k ways[1] = (k - 1) * ways[0] + k for i in xrange(2, n): ways[i % 3] = (k - 1) * (ways[(i - 1) % 3] + ways[(i - 2) % 3]) return ways[(n - 1) % 3] ", "class Solution def numWays(self, n, k): if n == 0: return 0 elif n == 1: return k ways = [0] * n ways[0] = k ways[1] = (k - 1) * ways[0] + k for i in xrange(2, n): ways[i] = (k - 1) * (ways[i - 1] + ways[i - 2]) return ways[n - 1] ", "class Solution def subsetXORSum(self, nums): result = 0 for x in nums: result |= x return result * 2**(len(nums)-1) ", "class Solution def videoStitching(self, clips, T): if T == 0: return 0 result = 1 curr_reachable, reachable = 0, 0 clips.sort() for left, right in clips: if left > reachable: break elif left > curr_reachable: curr_reachable = reachable result += 1 reachable = max(reachable, right) if reachable >= T: return result return -1 ", "class Solution def isMatch(self, s, p): count = 0 p_ptr, s_ptr, last_s_ptr, last_p_ptr = 0, 0, -1, -1 while s_ptr < len(s): if p_ptr < len(p) and (s[s_ptr] == p[p_ptr] or p[p_ptr] == '?'): s_ptr += 1 p_ptr += 1 elif p_ptr < len(p) and p[p_ptr] == '*': p_ptr += 1 last_s_ptr = s_ptr last_p_ptr = p_ptr elif last_p_ptr != -1: last_s_ptr += 1 s_ptr = last_s_ptr p_ptr = last_p_ptr else: assert(count <= (len(p)+1) * (len(s)+1)) return False count += 1 while p_ptr < len(p) and p[p_ptr] == '*': p_ptr += 1 count += 1 assert(count <= (len(p)+1) * (len(s)+1)) return p_ptr == len(p) ", "class Solution def isMatch(self, s, p): k = 2 result = [[False for j in xrange(len(p) + 1)] for i in xrange(k)] result[0][0] = True for i in xrange(1, len(p) + 1): if p[i-1] == '*': result[0][i] = result[0][i-1] for i in xrange(1,len(s) + 1): result[i % k][0] = False for j in xrange(1, len(p) + 1): if p[j-1] != '*': result[i % k][j] = result[(i-1) % k][j-1] and (s[i-1] == p[j-1] or p[j-1] == '?') else: result[i % k][j] = result[i % k][j-1] or result[(i-1) % k][j] return result[len(s) % k][len(p)] ", "class Solution def isMatch(self, s, p): result = [[False for j in xrange(len(p) + 1)] for i in xrange(len(s) + 1)] result[0][0] = True for i in xrange(1, len(p) + 1): if p[i-1] == '*': result[0][i] = result[0][i-1] for i in xrange(1,len(s) + 1): result[i][0] = False for j in xrange(1, len(p) + 1): if p[j-1] != '*': result[i][j] = result[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == '?') else: result[i][j] = result[i][j-1] or result[i-1][j] return result[len(s)][len(p)] ", "class Solution def isMatch(self, s, p): if not p or not s: return not s and not p if p[0] != '*': if p[0] == s[0] or p[0] == '?': return self.isMatch(s[1:], p[1:]) else: return False else: while len(s) > 0: if self.isMatch(s, p[1:]): return True s = s[1:] return self.isMatch(s, p[1:]) ", "class Solution def countMatchingSubarrays(self, nums, pattern): def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j+1 > 0 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix def KMP(text, pattern): prefix = getPrefix(pattern) j = -1 for i, x in enumerate(text): while j+1 > 0 and pattern[j+1] != x: j = prefix[j] if pattern[j+1] == x: j += 1 if j+1 == len(pattern): yield i-j j = prefix[j] return sum(1 for _ in KMP((cmp(nums[i+1], nums[i]) for i in xrange(len(nums)-1)), pattern)) ", "class Solution def countMatchingSubarrays(self, nums, pattern): def check(i): return all(nums[i+j] == pattern[j] for j in xrange(len(pattern))) for i in xrange(len(nums)-1): nums[i] = cmp(nums[i+1], nums[i]) return sum(check(i) for i in xrange(len(nums)-len(pattern)+1)) ", "class Solution def smallestRangeI(self, A, K): return max(0, max(A) - min(A) - 2*K) ", "class Solution def maximumSubarraySum(self, nums, k): prefix = collections.defaultdict(lambda: float(\"inf\")) curr = 0 result = float(\"-inf\") for x in nums: prefix[x] = min(prefix[x], curr) curr += x result = max(result, curr-prefix[x-k], curr-prefix[x+k]) return result if result != float(\"-inf\") else 0 ", "class Solution def countDistinctStrings(self, s, k): MOD = 10**9+7 return pow(2, len(s)-k+1, MOD) ", "class Solution def minAbbreviation(self, target, dictionary): def bits_to_abbr_len(targets, bits): total = 0 pre = 0 for i in xrange(len(target)): if bits & 1: if i - pre > 0: total += len(str(i - pre)) pre = i + 1 total += 1 elif i == len(target) - 1: total += len(str(i - pre + 1)) bits >>= 1 return total def bits_to_abbr(targets, bits): abbr = [] pre = 0 for i in xrange(len(target)): if bits & 1: if i - pre > 0: abbr.append(str(i - pre)) pre = i + 1 abbr.append(target[i]) elif i == len(target) - 1: abbr.append(str(i - pre + 1)) bits >>= 1 return \"\".join(abbr) diffs = [] for word in dictionary: if len(word) != len(target): continue diffs.append(sum(2**i for i, c in enumerate(word) if target[i] != c)) if not diffs: return str(len(target)) result = 2**len(target)-1 for mask in xrange(2**len(target)): if all(d & mask for d in diffs) and bits_to_abbr_len(target, mask) < bits_to_abbr_len(target, result): result = mask return bits_to_abbr(target, result) ", "class Solution def minAbbreviation(self, target, dictionary): def bits_to_abbr(targets, bits): abbr = [] pre = 0 for i in xrange(len(target)): if bits & 1: if i - pre > 0: abbr.append(str(i - pre)) pre = i + 1 abbr.append(target[i]) elif i == len(target) - 1: abbr.append(str(i - pre + 1)) bits >>= 1 return \"\".join(abbr) diffs = [] for word in dictionary: if len(word) != len(target): continue diffs.append(sum(2**i for i, c in enumerate(word) if target[i] != c)) if not diffs: return str(len(target)) result = target for mask in xrange(2**len(target)): abbr = bits_to_abbr(target, mask) if all(d & mask for d in diffs) and len(abbr) < len(result): result = abbr return result ", "class Solution def findSecondMinimumValue(self, root): def findSecondMinimumValueHelper(root, max_heap, lookup): if not root: return if root.val not in lookup: heapq.heappush(max_heap, -root.val) lookup.add(root.val) if len(max_heap) > 2: lookup.remove(-heapq.heappop(max_heap)) findSecondMinimumValueHelper(root.left, max_heap, lookup) findSecondMinimumValueHelper(root.right, max_heap, lookup) max_heap, lookup = [], set() findSecondMinimumValueHelper(root, max_heap, lookup) if len(max_heap) < 2: return -1 return -max_heap[0] ", "class Solution def kthFactor(self, n, k): def kth_factor(n, k=0): mid = None i = 1 while i*i <= n: if not n%i: mid = i k -= 1 if not k: break i += 1 return mid, -k mid, count = kth_factor(n) total = 2*count-(mid*mid == n) if k > total: return -1 result = kth_factor(n, k if k <= count else total-(k-1))[0] return result if k <= count else n//result ", "class Solution def kthFactor(self, n, k): result = [] i = 1 while i*i <= n: if not n%i: if i*i != n: result.append(i) k -= 1 if not k: return i i += 1 return -1 if k > len(result) else n//result[-k] ", "class Solution def merge(self, intervals): intervals.sort() result = [] for interval in intervals: if not result or interval[0] > result[-1][1]: result.append(interval) else: result[-1][1] = max(result[-1][1], interval[1]) return result ", "class Solution def numTriplets(self, nums1, nums2): def two_product(nums, i): count = 0 lookup = collections.defaultdict(int) for num in nums: if i%num: continue count += lookup[i//num] lookup[num] += 1 return count result = 0 for num in nums1: result += two_product(nums2, num**2) for num in nums2: result += two_product(nums1, num**2) return result ", "class Solution def connect(self, root): head = root pre = Node(0) cur = pre while root: while root: if root.left: cur.next = root.left cur = cur.next if root.right: cur.next = root.right cur = cur.next root = root.next root, cur = pre.next, pre cur.next = None return head ", "class Solution def trimMean(self, arr): P = 20 def nth_element(nums, n, left=0, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right right = len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 k = len(arr)//P nth_element(arr, k-1) nth_element(arr, len(arr)-k, left=k) return float(sum(arr[i] for i in xrange(k, len(arr)-k)))/(len(arr)-2*k) ", "class Solution def minimumSubarrayLength(self, nums, k): def update(x, d, curr): for i in xrange(len(cnt)): if x < (1<<i): break if not (x&(1<<i)): continue if cnt[i] == 0: curr ^= 1<<i cnt[i] += d if cnt[i] == 0: curr ^= 1<<i return curr total = reduce(lambda x, y: x|y, nums) if total < k: return -1 cnt = [0]*total.bit_length() result = len(nums) left = curr = 0 for right in xrange(len(nums)): curr = update(nums[right], +1, curr) while left <= right and curr >= k: result = min(result, right-left+1) curr = update(nums[left], -1, curr) left += 1 return result ", "class Solution def maxDistance(self, nums1, nums2): result = i = j = 0 while i < len(nums1) and j < len(nums2): if nums1[i] > nums2[j]: i += 1 else: result = max(result, j-i) j += 1 return result ", "class Solution def beautifulSubsets(self, nums, k): def count(x): y = x while y-k in cnt: y -= k dp = [1, 0] for i in xrange(y, x+1, k): dp = [dp[0]+dp[1], dp[0]*((1<<cnt[i])-1)] return sum(dp) cnt = collections.Counter(nums) return reduce(operator.mul, (count(i) for i in cnt.iterkeys() if i+k not in cnt))-1 ", "class Solution def maxProduct(self, s): def manacher(s): s = '^#' + '#'.join(s) + '#$' P = [0]*len(s) C, R = 0, 0 for i in xrange(1, len(s)-1): i_mirror = 2*C-i if R > i: P[i] = min(R-i, P[i_mirror]) while s[i+1+P[i]] == s[i-1-P[i]]: P[i] += 1 if i+P[i] > R: C, R = i, i+P[i] return P P = manacher(s) q = collections.deque() left = [0] for i in xrange(len(s)): while q and q[0][1] < i: q.popleft() left.append(max(left[-1], 1+2*(i-q[0][0]) if q else 1)) q.append((i, i+P[2*i+2]//2)) q = collections.deque() result = right = 0 for i in reversed(xrange(len(s))): while q and q[0][1] > i: q.popleft() right = max(right, 1+2*(q[0][0]-i) if q else 1) q.append((i, i-P[2*i+2]//2)) result = max(result, left[i]*right) return result ", "class Solution def maxProduct(self, s): def manacher(s): s = '^#' + '#'.join(s) + '#$' P = [0]*len(s) C, R = 0, 0 for i in xrange(1, len(s)-1): i_mirror = 2*C-i if R > i: P[i] = min(R-i, P[i_mirror]) while s[i+1+P[i]] == s[i-1-P[i]]: P[i] += 1 if i+P[i] > R: C, R = i, i+P[i] return P import operator def accumulate(iterable, func=operator.add, initial=None): it = iter(iterable) total = initial if initial is None: try: total = next(it) except StopIteration: return yield total for element in it: total = func(total, element) yield total def fin_max_len(s): P = manacher(s) intervals = [[(i-2)//2-P[i]//2, (i-2)//2+P[i]//2] for i in xrange(2,len(P)-2, 2)] dp = [0]*len(s) for l, r in reversed(intervals): dp[r] = r-l+1 for i in reversed(xrange(len(s)-1)): dp[i] = max(dp[i], dp[i+1]-2) return list(accumulate(dp, max, 0)) l1, l2 = fin_max_len(s), fin_max_len(s[::-1])[::-1] return max(x*y for x, y in itertools.izip(l1, l2)) ", "class Solution def maxProduct(self, root): MOD = 10**9 + 7 def dfs(root, total, result): if not root: return 0 subtotal = dfs(root.left, total, result)+dfs(root.right, total, result)+root.val result[0] = max(result[0], subtotal*(total-subtotal) ) return subtotal result = [0] dfs(root, dfs(root, 0, result), result) return result[0] % MOD ", "class Solution def secondMinimum(self, n, edges, time, change): def bi_bfs(adj, start, target): left, right = {start}, {target} lookup = set() result = steps = 0 while left and (not result or result+2 > steps): for u in left: lookup.add(u) new_left = set() for u in left: if u in right: if not result: result = steps elif result < steps: return result+1 for v in adj[u]: if v in lookup: continue new_left.add(v) left = new_left steps += 1 if len(left) > len(right): left, right = right, left return result+2 def calc_time(time, change, dist): result = 0 for _ in xrange(dist): if result//change%2: result = (result//change+1)*change result += time return result adj = [[] for _ in xrange(n)] for u, v in edges: adj[u-1].append(v-1) adj[v-1].append(u-1) return calc_time(time, change, bi_bfs(adj, 0, n-1)) ", "class Solution def secondMinimum(self, n, edges, time, change): INF = float(\"inf\") def bfs(adj, start): q = [start] dist = [INF]*len(adj) dist[start] = 0 while q: new_q = [] for u in q: for v in adj[u]: if dist[v] != INF: continue dist[v] = dist[u]+1 new_q.append(v) q = new_q return dist def calc_time(time, change, dist): result = 0 for _ in xrange(dist): if result//change%2: result = (result//change+1)*change result += time return result adj = [[] for _ in xrange(n)] for u, v in edges: adj[u-1].append(v-1) adj[v-1].append(u-1) dist_to_end, dist_to_start = bfs(adj, 0), bfs(adj, n-1) dist = dist_to_end[n-1]+2 for i in xrange(n): if dist_to_end[i]+dist_to_start[i] == dist_to_end[n-1]: continue dist = min(dist, dist_to_end[i]+dist_to_start[i]) if dist == dist_to_end[n-1]+1: break return calc_time(time, change, dist) ", "class Solution def findContestMatch(self, n): matches = map(str, range(1, n+1)) while len(matches)/2: matches = [\"({},{})\".format(matches[i], matches[-i-1]) for i in xrange(len(matches)/2)] return matches[0] ", "class Solution def countGoodRectangles(self, rectangles): result = mx = 0 for l, w in rectangles: side = min(l, w) if side > mx: result, mx = 1, side elif side == mx: result += 1 return result ", "class Solution def eatenApples(self, apples, days): min_heap = [] result = i = 0 while i < len(apples) or min_heap: if i < len(apples) and apples[i] > 0: heapq.heappush(min_heap, [i+days[i], i]) while min_heap and (min_heap[0][0] <= i or apples[min_heap[0][1]] == 0): heapq.heappop(min_heap) if min_heap: apples[min_heap[0][1]] -= 1 result += 1 i += 1 return result ", "class Solution def isValidBST(self, root): prev, cur = None, root while cur: if cur.left is None: if prev and prev.val >= cur.val: return False prev = cur cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: node.right = cur cur = cur.left else: if prev and prev.val >= cur.val: return False node.right = None prev = cur cur = cur.right return True ", "class Solution def isValidBST(self, root): return self.isValidBSTRecu(root, float(\"-inf\"), float(\"inf\")) def isValidBSTRecu(self, root, low, high): if root is None: return True return low < root.val and root.val < high and self.isValidBSTRecu(root.left, low, root.val) and self.isValidBSTRecu(root.right, root.val, high) ", "class Solution def shortestBeautifulSubstring(self, s, k): def check(r1, r2): if r1[1]-r1[0]+1 > r2[1]-r2[0]+1: return False if r1[1]-r1[0]+1 < r2[1]-r2[0]+1: return True for i, j in itertools.izip(xrange(r1[0], r1[1]+1), xrange(r2[0], r2[1]+1)): if s[i] != s[j]: return s[i] < s[j] return False result = [] left = curr = 0 for right in xrange(len(s)): curr += s[right] == '1' while curr == k+1: curr -= s[left] == '1' left += 1 while left < len(s) and s[left] == '0': left += 1 if curr == k: if not result or check([left, right], result): result = [left, right] return s[result[0]:result[1]+1] if result else \"\" ", "class Solution def minOperations(self, n): return (n//2)*((n+1)//2) ", "class Solution def sortList(self, head): if head == None or head.next == None: return head fast, slow, prev = head, head, None while fast != None and fast.next != None: prev, fast, slow = slow, fast.next.next, slow.next prev.next = None sorted_l1 = self.sortList(head) sorted_l2 = self.sortList(slow) return self.mergeTwoLists(sorted_l1, sorted_l2) def mergeTwoLists(self, l1, l2): dummy = ListNode(0) cur = dummy while l1 != None and l2 != None: if l1.val <= l2.val: cur.next, cur, l1 = l1, l1, l1.next else: cur.next, cur, l2 = l2, l2, l2.next if l1 != None: cur.next = l1 if l2 != None: cur.next = l2 return dummy.next ", "class Solution def minFlips(self, mat): directions = [(0, 0), (0, 1), (1, 0), (0, -1), (-1, 0)] start = sum(val << r*len(mat[0])+c for r, row in enumerate(mat) for c, val in enumerate(row)) q = collections.deque([(start, 0)]) lookup = {start} while q: state, step = q.popleft() if not state: return step for r in xrange(len(mat)): for c in xrange(len(mat[0])): new_state = state for dr, dc in directions: nr, nc = r+dr, c+dc if 0 <= nr < len(mat) and 0 <= nc < len(mat[0]): new_state ^= 1 << nr*len(mat[0])+nc if new_state in lookup: continue lookup.add(new_state) q.append((new_state, step+1)) return -1 ", "class Solution def solve(self, board): if not board: return q = collections.deque() for i in xrange(len(board)): if board[i][0] == 'O': board[i][0] = 'V' q.append((i, 0)) if board[i][len(board[0])-1] == 'O': board[i][len(board[0])-1] = 'V' q.append((i, len(board[0])-1)) for j in xrange(1, len(board[0])-1): if board[0][j] == 'O': board[0][j] = 'V' q.append((0, j)) if board[len(board)-1][j] == 'O': board[len(board)-1][j] = 'V' q.append((len(board)-1, j)) while q: i, j = q.popleft() for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]: if 0 <= x < len(board) and 0 <= y < len(board[0]) and board[x][y] == 'O': board[x][y] = 'V' q.append((x, y)) for i in xrange(len(board)): for j in xrange(len(board[0])): if board[i][j] != 'V': board[i][j] = 'X' else: board[i][j] = 'O' ", "class Solution def singleNonDuplicate(self, nums): left, right = 0, len(nums)-1 while left <= right: mid = left + (right - left) / 2 if not (mid%2 == 0 and mid+1 < len(nums) and nums[mid] == nums[mid+1]) and not (mid%2 == 1 and nums[mid] == nums[mid-1]): right = mid-1 else: left = mid+1 return nums[left] ", "class Solution def maxLength(self, arr): def bitset(s): result = 0 for c in s: if result & power[ord(c)-ord('a')]: return 0 result |= power[ord(c)-ord('a')] return result def number_of_one(n): result = 0 while n: n &= n-1 result += 1 return result dp = [0] for x in arr: x_set = bitset(x) if not x_set: continue curr_len = len(dp) for i in xrange(curr_len): if dp[i] & x_set: continue dp.append(dp[i] | x_set) return max(number_of_one(s_set) for s_set in dp) ", "class Solution def maxLength(self, arr): def bitset(s): result = 0 for c in s: if result & power[ord(c)-ord('a')]: return 0 result |= power[ord(c)-ord('a')] return result bitsets = [bitset(x) for x in arr] result = 0 for i in xrange(power[len(arr)]): curr_bitset, curr_len = 0, 0 while i: j = i & -i i ^= j j = log2[j] if not bitsets[j] or (curr_bitset & bitsets[j]): break curr_bitset |= bitsets[j] curr_len += len(arr[j]) else: result = max(result, curr_len) return result ", "class Solution def minimumFuelCost(self, roads, seats): def ceil_divide(a, b): return (a+b-1)//b def iter_dfs(): result = 0 stk = [(1, (0, -1, 0, [1]))] while stk: step, args = stk.pop() if step == 1: u, p, d, ret = args stk.append((3, (d, ret))) for v in adj[u]: if v == p: continue new_ret = [1] stk.append((2, (new_ret, ret))) stk.append((1, (v, u, d+1, new_ret))) elif step == 2: new_ret, ret = args ret[0] += new_ret[0] elif step == 3: d, ret = args if d: result += ceil_divide(ret[0], seats) return result adj = [[] for _ in xrange(len(roads)+1)] for u, v in roads: adj[u].append(v) adj[v].append(u) return iter_dfs() ", "class Solution def minimumFuelCost(self, roads, seats): def ceil_divide(a, b): return (a+b-1)//b def dfs(u, p, d): cnt = 1+sum(dfs(v, u, d+1) for v in adj[u] if v != p) if d: result[0] += ceil_divide(cnt, seats) return cnt adj = [[] for _ in xrange(len(roads)+1)] for u, v in roads: adj[u].append(v) adj[v].append(u) result = [0] dfs(0, -1, 0) return result[0] ", "class Solution def maxProfit(self, prices, profits): NEG_INF = float(\"-inf\") def query(sl, k): j = sl.bisect_left((k,)) return sl[j-1][1] if j-1 >= 0 else NEG_INF def update(sl, k, v): j = sl.bisect_left((k,)) if j < len(sl) and sl[j][0] == k: if not (sl[j][1] < v): return del sl[j] elif not (j-1 < 0 or sl[j-1][1] < v): return sl.add((k, v)) while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]: del sl[j+1] result = NEG_INF sl1, sl2 = SortedList(), SortedList() for price, profit in itertools.izip(prices, profits): result = max(result, query(sl2, price)+profit) update(sl1, price, profit) update(sl2, price, query(sl1, price)+profit) return result if result != NEG_INF else -1 from sortedcontainers import SortedList ", "class Solution def maxProfit(self, prices, profits): NEG_INF = float(\"-inf\") right = [NEG_INF]*len(prices) sl = SortedList() for i in reversed(xrange(len(prices))): j = sl.bisect_left((-prices[i],)) if j-1 >= 0: right[i] = sl[j-1][1] if not (j-1 < 0 or sl[j-1][1] < profits[i]): continue sl.add((-prices[i], profits[i])) j = sl.bisect_left((-prices[i], profits[i])) while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]: del sl[j+1] result = NEG_INF sl = SortedList() for i in xrange(len(prices)): j = sl.bisect_left((prices[i],)) if j-1 >= 0: result = max(result, sl[j-1][1]+profits[i]+right[i]) if not (j-1 < 0 or sl[j-1][1] < profits[i]): continue sl.add((prices[i], profits[i])) j = sl.bisect_left((prices[i], profits[i])) while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]: del sl[j+1] return result if result != NEG_INF else -1 import itertools ", "class Solution def maxProfit(self, prices, profits): NEG_INF = float(\"-inf\") class BIT(object): def __init__(self, n, default=0, fn=lambda x, y: x+y): self.__bit = [NEG_INF]*(n+1) self.__default = default self.__fn = fn def update(self, i, val): i += 1 while i < len(self.__bit): self.__bit[i] = self.__fn(self.__bit[i], val) i += (i & -i) def query(self, i): i += 1 ret = self.__default while i > 0: ret = self.__fn(ret, self.__bit[i]) i -= (i & -i) return ret price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))} result = NEG_INF bit1, bit2 = BIT(len(price_to_idx), default=NEG_INF, fn=max), BIT(len(price_to_idx), default=NEG_INF, fn=max) for price, profit in itertools.izip(prices, profits): result = max(result, bit2.query(price_to_idx[price]-1)+profit) bit1.update(price_to_idx[price], profit) bit2.update(price_to_idx[price], bit1.query(price_to_idx[price]-1)+profit) return result if result != NEG_INF else -1 import itertools ", "class Solution def maxProfit(self, prices, profits): NEG_INF = float(\"-inf\") class SegmentTree(object): def __init__(self, N, build_fn=lambda _: None, query_fn=lambda x, y: max(x, y), update_fn=lambda x, y: max(x, y)): self.tree = [None]*(2*2**((N-1).bit_length())) self.base = len(self.tree)//2 self.query_fn = query_fn self.update_fn = update_fn for i in xrange(self.base, self.base+N): self.tree[i] = build_fn(i-self.base) for i in reversed(xrange(1, self.base)): self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1]) def update(self, i, h): x = self.base+i self.tree[x] = self.update_fn(self.tree[x], h) while x > 1: x //= 2 self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1]) def query(self, L, R): if L > R: return None L += self.base R += self.base left = right = None while L <= R: if L & 1: left = self.query_fn(left, self.tree[L]) L += 1 if R & 1 == 0: right = self.query_fn(self.tree[R], right) R -= 1 L //= 2 R //= 2 return self.query_fn(left, right) price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))} result = NEG_INF st1, st2 = SegmentTree(len(price_to_idx)), SegmentTree(len(price_to_idx)) for price, profit in itertools.izip(prices, profits): mx2 = st2.query(0, price_to_idx[price]-1) if mx2 is not None: result = max(result, mx2+profit) st1.update(price_to_idx[price], profit) mx1 = st1.query(0, price_to_idx[price]-1) if mx1 is not None: st2.update(price_to_idx[price], mx1+profit) return result if result != NEG_INF else -1 ", "class Solution def maxProfit(self, prices, profits): NEG_INF = float(\"-inf\") class SegmentTree(object): def __init__(self, N, build_fn=lambda _: None, query_fn=lambda x, y: max(x, y), update_fn=lambda x, y: max(x, y)): self.tree = [None]*(2*2**((N-1).bit_length())) self.base = len(self.tree)//2 self.query_fn = query_fn self.update_fn = update_fn for i in xrange(self.base, self.base+N): self.tree[i] = build_fn(i-self.base) for i in reversed(xrange(1, self.base)): self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1]) def update(self, i, h): x = self.base+i self.tree[x] = self.update_fn(self.tree[x], h) while x > 1: x //= 2 self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1]) def query(self, L, R): if L > R: return None L += self.base R += self.base left = right = None while L <= R: if L & 1: left = self.query_fn(left, self.tree[L]) L += 1 if R & 1 == 0: right = self.query_fn(self.tree[R], right) R -= 1 L //= 2 R //= 2 return self.query_fn(left, right) price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))} right = [NEG_INF]*len(prices) st = SegmentTree(len(price_to_idx)) for i in reversed(xrange(len(prices))): right[i] = st.query(price_to_idx[prices[i]]+1, len(price_to_idx)-1) st.update(price_to_idx[prices[i]], profits[i]) result = NEG_INF st = SegmentTree(len(price_to_idx)) for i in xrange(len(prices)): left = st.query(0, price_to_idx[prices[i]]-1) if left is not None and right[i] is not None: result = max(result, left+profits[i]+right[i]) st.update(price_to_idx[prices[i]], profits[i]) return result if result != NEG_INF else -1 ", "class Solution def maxUniqueSplit(self, s): def popcount(n): count = 0 while n: n &= n-1 count += 1 return count result = 1 total = 2**(len(s)-1) mask = 0 while mask < total: if popcount(mask) < result: mask += 1 continue lookup, curr, base = set(), [], total//2 for i in xrange(len(s)): curr.append(s[i]) if (mask&base) or base == 0: if \"\".join(curr) in lookup: mask = (mask | (base-1)) + 1 if base else mask+1 break lookup.add(\"\".join(curr)) curr = [] base >>= 1 else: result = max(result, len(lookup)) mask += 1 return result ", "class Solution def minCostToSupplyWater(self, n, wells, pipes): w = [[c, 0, i] for i, c in enumerate(wells, 1)] p = [[c, i, j] for i, j, c in pipes] result = 0 union_find = UnionFind(n+1) for c, x, y in sorted(w+p): if not union_find.union_set(x, y): continue result += c if union_find.count == 1: break return result ", "class Solution def minimumChanges(self, s, k): divisors = [[] for _ in xrange(len(s)+1)] for i in xrange(1, len(divisors)): for j in xrange(i, len(divisors), i): divisors[j].append(i) dp = [[{} for _ in xrange(len(s))] for _ in xrange(len(s))] for l in xrange(1, len(s)+1): for left in xrange(len(s)-l+1): right = left+l-1 for d in divisors[l]: dp[left][right][d] = (dp[left+d][right-d][d] if left+d < right-d else 0)+sum(s[left+i] != s[(right-(d-1))+i] for i in xrange(d)) dp2 = [[min(dp[i][j][d] for d in divisors[j-i+1] if d != j-i+1) if i < j else 0 for j in xrange(len(s))] for i in xrange(len(s))] dp3 = [len(s)]*(len(s)+1) dp3[0] = 0 for l in xrange(k): new_dp3 = [len(s)]*(len(s)+1) for i in xrange(len(s)): for j in xrange(l*2, i): new_dp3[i+1]= min(new_dp3[i+1], dp3[j]+dp2[j][i]) dp3 = new_dp3 return dp3[len(s)] ", "class Solution def minimumChanges(self, s, k): divisors = [[] for _ in xrange(len(s)+1)] for i in xrange(1, len(divisors)): for j in xrange(i, len(divisors), i): divisors[j].append(i) dp = [[{} for _ in xrange(len(s))] for _ in xrange(len(s))] for l in xrange(1, len(s)+1): for left in xrange(len(s)-l+1): right = left+l-1 for d in divisors[l]: dp[left][right][d] = (dp[left+d][right-d][d] if left+d < right-d else 0)+sum(s[left+i] != s[(right-(d-1))+i] for i in xrange(d)) dp2 = [[len(s)]*(k+1) for _ in xrange(len(s)+1)] dp2[0][0] = 0 for i in xrange(len(s)): for j in xrange(i): c = min(dp[j][i][d] for d in divisors[i-j+1] if d != i-j+1) for l in xrange(k): dp2[i+1][l+1] = min(dp2[i+1][l+1], dp2[j][l]+c) return dp2[len(s)][k] ", "class Solution def minimumChanges(self, s, k): def min_dist(left, right): return min(sum(s[left+i] != s[right-((i//d+1)*d-1)+(i%d)] for i in xrange((right-left+1)//2)) for d in divisors[right-left+1]) divisors = [[] for _ in xrange(len(s)+1)] for i in xrange(1, len(divisors)): for j in xrange(i+i, len(divisors), i): divisors[j].append(i) dp = [[len(s)]*(k+1) for _ in xrange(len(s)+1)] dp[0][0] = 0 for i in xrange(len(s)): for j in xrange(i): c = min_dist(j, i) for l in xrange(k): dp[i+1][l+1] = min(dp[i+1][l+1], dp[j][l]+c) return dp[len(s)][k] ", "class Solution def findTarget(self, root, k): class BSTIterator(object): def __init__(self, root, forward): self.__node = root self.__forward = forward self.__s = [] self.__cur = None self.next() def val(self): return self.__cur def next(self): while self.__node or self.__s: if self.__node: self.__s.append(self.__node) self.__node = self.__node.left if self.__forward else self.__node.right else: self.__node = self.__s.pop() self.__cur = self.__node.val self.__node = self.__node.right if self.__forward else self.__node.left break if not root: return False left, right = BSTIterator(root, True), BSTIterator(root, False) while left.val() < right.val(): if left.val() + right.val() == k: return True elif left.val() + right.val() < k: left.next() else: right.next() return False ", "class Solution def romanToInt(self, s): numeral_map = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\":100, \"D\": 500, \"M\": 1000} decimal = 0 for i in xrange(len(s)): if i > 0 and numeral_map[s[i]] > numeral_map[s[i - 1]]: decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]] else: decimal += numeral_map[s[i]] return decimal ", "class Solution def sumSubarrayMins(self, A): M = 10**9 + 7 left, s1 = [0]*len(A), [] for i in xrange(len(A)): count = 1 while s1 and s1[-1][0] > A[i]: count += s1.pop()[1] left[i] = count s1.append([A[i], count]) right, s2 = [0]*len(A), [] for i in reversed(xrange(len(A))): count = 1 while s2 and s2[-1][0] >= A[i]: count += s2.pop()[1] right[i] = count s2.append([A[i], count]) return sum(a*l*r for a, l, r in itertools.izip(A, left, right)) % M ", "class Solution def wateringPlants(self, plants, capacity): result, can = len(plants), capacity for i, x in enumerate(plants): if can < x: result += 2*i can = capacity can -= x return result ", "class Solution def triangleType(self, nums): nums.sort() a, b, c = nums if a+b <= c: return \"none\" if a == b == c: return \"equilateral\" if a == b or b == c: return \"isosceles\" return \"scalene\" ", "class Solution def maxAbsoluteSum(self, nums): curr = mx = mn = 0 for num in nums: curr += num mx = max(mx, curr) mn = min(mn, curr) return mx-mn ", "class Solution def minimumSubstringsInPartition(self, s): INF = float(\"inf\") dp = [INF]*(len(s)+1) dp[0] = 0 for i in xrange(len(s)): cnt = [0]*26 d = mx = 0 for j in reversed(xrange(i+1)): k = ord(s[j])-ord('a') if cnt[k] == 0: d += 1 cnt[k] += 1 mx = max(mx, cnt[k]) if d*mx == i-j+1: dp[i+1] = min(dp[i+1], dp[j]+1) return dp[-1] ", "class Solution def middleNode(self, head): slow, fast = head, head while fast and fast.next: slow, fast = slow.next, fast.next.next return slow ", "class Solution def permute(self, num): result = [] used = [False] * len(num) self.permuteRecu(result, used, [], num) return result def permuteRecu(self, result, used, cur, num): if len(cur) == len(num): result.append(cur[:]) return for i in xrange(len(num)): if not used[i]: used[i] = True cur.append(num[i]) self.permuteRecu(result, used, cur, num) cur.pop() used[i] = False ", "class Solution def permute(self, nums): res = [] self.dfs(nums, [], res) return res def dfs(self, nums, path, res): if not nums: res.append(path) for i in xrange(len(nums)): self.dfs(nums[:i] + nums[i+1:], path + [nums[i]], res) ", "class Solution def merge(self, A, m, B, n): last, i, j = m + n - 1, m - 1, n - 1 while i >= 0 and j >= 0: if A[i] > B[j]: A[last] = A[i] last, i = last - 1, i - 1 else: A[last] = B[j] last, j = last - 1, j - 1 while j >= 0: A[last] = B[j] last, j = last - 1, j - 1 ", "class Solution def maxProfit(self, inventory, orders): MOD = 10**9+7 def check(inventory, orders, x): return count(inventory, x) > orders def count(inventory, x): return sum(count-x+1 for count in inventory if count >= x) left, right = 1, max(inventory) while left <= right: mid = left + (right-left)//2 if not check(inventory, orders, mid): right = mid-1 else: left = mid+1 return (sum((left+cnt)*(cnt-left+1)//2 for cnt in inventory if cnt >= left) + (left-1)*(orders-count(inventory, left)))% MOD ", "class Solution def minSum(self, nums1, nums2): total1 = sum(max(x, 1) for x in nums1) total2 = sum(max(x, 1) for x in nums2) if total1 < total2: return total2 if 0 in nums1 else -1 if total1 > total2: return total1 if 0 in nums2 else -1 return total1 ", "class Solution def validateStackSequences(self, pushed, popped): i = 0 s = [] for v in pushed: s.append(v) while s and i < len(popped) and s[-1] == popped[i]: s.pop() i += 1 return i == len(popped) ", "class Solution def equationsPossible(self, equations): union_find = UnionFind(26) for eqn in equations: x = ord(eqn[0]) - ord('a') y = ord(eqn[3]) - ord('a') if eqn[1] == '=': union_find.union_set(x, y) for eqn in equations: x = ord(eqn[0]) - ord('a') y = ord(eqn[3]) - ord('a') if eqn[1] == '!': if union_find.find_set(x) == union_find.find_set(y): return False return True ", "class Solution def equationsPossible(self, equations): graph = [[] for _ in xrange(26)] for eqn in equations: x = ord(eqn[0]) - ord('a') y = ord(eqn[3]) - ord('a') if eqn[1] == '!': if x == y: return False else: graph[x].append(y) graph[y].append(x) color = [None]*26 c = 0 for i in xrange(26): if color[i] is not None: continue c += 1 stack = [i] while stack: node = stack.pop() for nei in graph[node]: if color[nei] is not None: continue color[nei] = c stack.append(nei) for eqn in equations: if eqn[1] != '!': continue x = ord(eqn[0]) - ord('a') y = ord(eqn[3]) - ord('a') if color[x] is not None and color[x] == color[y]: return False return True ", "class Solution def maxNumberOfBalloons(self, text): TARGET = \"balloon\" source_count = collections.Counter(text) target_count = collections.Counter(TARGET) return min(source_count[c]//target_count[c] for c in target_count.iterkeys()) ", "class Solution def fullJustify(self, words, maxWidth): def addSpaces(i, spaceCnt, maxWidth, is_last): if i < spaceCnt: return 1 if is_last else (maxWidth // spaceCnt) + int(i < maxWidth % spaceCnt) return 0 def connect(words, maxWidth, begin, end, length, is_last): s = [] n = end - begin for i in xrange(n): s += words[begin + i], s += ' ' * addSpaces(i, n - 1, maxWidth - length, is_last), line = \"\".join(s) if len(line) < maxWidth: line += ' ' * (maxWidth - len(line)) return line res = [] begin, length = 0, 0 for i in xrange(len(words)): if length + len(words[i]) + (i - begin) > maxWidth: res += connect(words, maxWidth, begin, i, length, False), begin, length = i, 0 length += len(words[i]) res += connect(words, maxWidth, begin, len(words), length, True), return res ", "class Solution def twoSum(self, nums, target): start, end = 0, len(nums) - 1 while start != end: sum = nums[start] + nums[end] if sum > target: end -= 1 elif sum < target: start += 1 else: return [start + 1, end + 1] ", "class Solution def ladderLength(self, beginWord, endWord, wordList): words = set(wordList) if endWord not in words: return 0 left, right = {beginWord}, {endWord} ladder = 2 while left: words -= left new_left = set() for word in left: for new_word in (word[:i]+c+word[i+1:] for i in xrange(len(beginWord)) for c in ascii_lowercase): if new_word not in words: continue if new_word in right: return ladder new_left.add(new_word) left = new_left ladder += 1 if len(left) > len(right): left, right = right, left return 0 ", "class Solution def ladderLength(self, beginWord, endWord, wordList): lookup = set(wordList) if endWord not in lookup: return 0 ladder = 2 q = [beginWord] while q: new_q = [] for word in q: for i in xrange(len(word)): for j in ascii_lowercase: new_word = word[:i] + j + word[i+1:] if new_word == endWord: return ladder if new_word in lookup: lookup.remove(new_word) new_q.append(new_word) q = new_q ladder += 1 return 0 ", "class Solution def mergeSimilarItems(self, items1, items2): return sorted((Counter(dict(items1))+Counter(dict(items2))).iteritems()) ", "class Solution def minCost(self, grid): directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] def a_star(grid, b, t): f, dh = 0, 1 closer, detour = [b], [] lookup = set() while closer or detour: if not closer: f += dh closer, detour = detour, closer b = closer.pop() if b in lookup: continue lookup.add(b) if b == t: return f for nd, (dr, dc) in enumerate(directions, 1): nb = (b[0]+dr, b[1]+dc) if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and nb not in lookup): continue (closer if nd == grid[b[0]][b[1]] else detour).append(nb) return -1 return a_star(grid, (0, 0), (len(grid)-1, len(grid[0])-1)) import collections ", "class Solution def minCost(self, grid): directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] b, t = (0, 0), (len(grid)-1, len(grid[0])-1) dq = collections.deque([(b, 0)]) lookup = set() while dq: b, d = dq.popleft() if b in lookup: continue lookup.add(b) if b == t: return d for nd, (dr, dc) in enumerate(directions, 1): nb = (b[0]+dr, b[1]+dc) if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and nb not in lookup): continue if nd == grid[b[0]][b[1]]: dq.appendleft((nb, d)) else: dq.append((nb, d+1)) return -1 ", "class Solution def reverseWords(self, s): return ' '.join(reversed(s.split())) ", "class Solution def getNumberOfBacklogOrders(self, orders): MOD = 10**9 + 7 buy, sell = [], [] for p, a, t in orders: if t == 0: heapq.heappush(buy, [-p, a]) else: heapq.heappush(sell, [p, a]) while sell and buy and sell[0][0] <= -buy[0][0]: k = min(buy[0][1], sell[0][1]) tmp = heapq.heappop(buy) tmp[1] -= k if tmp[1]: heapq.heappush(buy, tmp) tmp = heapq.heappop(sell) tmp[1] -= k if tmp[1]: heapq.heappush(sell, tmp) return reduce(lambda x, y: (x+y) % MOD, (a for _, a in buy + sell)) ", "class Solution def numsSameConsecDiff(self, N, K): curr = range(10) for i in xrange(N-1): curr = [x*10 + y for x in curr for y in set([x%10 + K, x%10 - K]) if x and 0 <= y < 10] return curr ", "class Solution def subarraysDivByK(self, A, K): count = collections.defaultdict(int) count[0] = 1 result, prefix = 0, 0 for a in A: prefix = (prefix+a) % K result += count[prefix] count[prefix] += 1 return result ", "class Solution def twoEditWords(self, queries, dictionary): MOD = (1<<64)-59 BASE = 113 POW = [1] def add(a, b): return (a+b)%MOD def mult(a, b): return (a*b)%MOD def pow(i): while not (i < len(POW)): POW.append(mult(POW[-1], BASE)) return POW[i] lookup = set() for w in dictionary: h = reduce(lambda h, i: add(h, mult(ord(w[i])-ord('a'), pow(i))), xrange(len(w)), 0) for i, c in enumerate(w): for x in string.ascii_lowercase: if x == c: continue lookup.add(add(h, mult(ord(x)-ord(c), pow(i)))) result = [] for w in queries: h = reduce(lambda h, i: add(h, mult(ord(w[i])-ord('a'), pow(i))), xrange(len(w)), 0) for i, c in enumerate(w): for x in string.ascii_lowercase: if x == c: continue if add(h, mult(ord(x)-ord(c), pow(i))) in lookup: break else: continue result.append(w) break return result import itertools ", "class Solution def twoEditWords(self, queries, dictionary): return [q for q in queries if any(sum(c1 != c2 for c1, c2 in itertools.izip(q, d)) <= 2 for d in dictionary)] ", "class Solution def minimumSum(self, nums): INF = float(\"inf\") right = [INF]*len(nums) curr = INF for i in reversed(xrange(len(nums))): right[i] = curr curr = min(curr, nums[i]) result = curr = INF for i in xrange(len(nums)): if curr < nums[i] > right[i]: result = min(result, curr+nums[i]+right[i]) curr = min(curr, nums[i]) return result if result != INF else -1 ", "class Solution def minimumSum(self, nums): INF = float(\"inf\") left = [INF]*len(nums) curr = INF for i in xrange(len(nums)): left[i] = curr curr = min(curr, nums[i]) right = [INF]*len(nums) curr = INF for i in reversed(xrange(len(nums))): right[i] = curr curr = min(curr, nums[i]) result = INF for i in xrange(len(nums)): if left[i] < nums[i] > right[i]: result = min(result, left[i]+nums[i]+right[i]) return result if result != INF else -1 ", "class Solution def minSideJumps(self, obstacles): result, lanes = 0, set([2]) for i in xrange(len(obstacles)-1): lanes.discard(obstacles[i+1]) if lanes: continue result += 1 lanes = set(j for j in xrange(1, 4) if j not in [obstacles[i], obstacles[i+1]]) return result ", "class Solution def minSideJumps(self, obstacles): dp = [1, 0, 1] for i in obstacles: if i: dp[i-1] = float(\"inf\") for j in xrange(3): if j+1 != i: dp[j] = min(dp[0]+(j != 0), dp[1]+(j != 1), dp[2]+(j != 2)) return min(dp) ", "class Solution def numberOfPaths(self, grid, k): MOD = 10**9+7 dp = [[0 for _ in xrange(k)] for _ in xrange(len(grid[0]))] dp[0][0] = 1 for i in xrange(len(grid)): for j in xrange(len(grid[0])): dp[j] = [((dp[j-1][(l-grid[i][j])%k] if j-1 >= 0 else 0)+dp[j][(l-grid[i][j])%k])%MOD for l in xrange(k)] return dp[-1][0] ", "class Solution def smallestNumber(self, num): def inplace_counting_sort(nums, reverse=False): count = [0]*(max(nums)+1) for num in nums: count[num] += 1 for i in xrange(1, len(count)): count[i] += count[i-1] for i in reversed(xrange(len(nums))): while nums[i] >= 0: count[nums[i]] -= 1 j = count[nums[i]] nums[i], nums[j] = nums[j], ~nums[i] for i in xrange(len(nums)): nums[i] = ~nums[i] if reverse: nums.reverse() sign = 1 if num >= 0 else -1 nums = map(int, list(str(abs(num)))) inplace_counting_sort(nums, reverse=(sign == -1)) i = next((i for i in xrange(len(nums)) if nums[i] != 0), 0) nums[0], nums[i] = nums[i], nums[0] return sign*int(\"\".join(map(str, nums))) ", "class Solution def smallestNumber(self, num): sign = 1 if num >= 0 else -1 nums = sorted(str(abs(num)), reverse=(sign == -1)) i = next((i for i in xrange(len(nums)) if nums[i] != '0'), 0) nums[0], nums[i] = nums[i], nums[0] return sign*int(\"\".join(nums)) ", "class Solution def numberOfSubstrings(self, s): result = 0 cnt = collections.Counter() for c in s: cnt[c] += 1 result += cnt[c] return result import collections ", "class Solution def numberOfSubstrings(self, s): return sum(v*(v+1)//2 for v in collections.Counter(s).itervalues()) ", "class Solution def suggestedProducts(self, products, searchWord): trie = TrieNode() for i in xrange(len(products)): trie.insert(products, i) result = [[] for _ in xrange(len(searchWord))] for i, c in enumerate(searchWord): if c not in trie.leaves: break trie = trie.leaves[c] result[i] = map(lambda x: products[x], trie.infos) return result class TrieNode2(object): def __init__(self): self.__TOP_COUNT = 3 self.leaves = collections.defaultdict(TrieNode2) self.infos = [] def insert(self, words, i): curr = self for c in words[i]: curr = curr.leaves[c] curr.add_info(i) def add_info(self, i): if len(self.infos) == self.__TOP_COUNT: return self.infos.append(i) ", "class Solution def suggestedProducts(self, products, searchWord): products.sort() trie = TrieNode2() for i in xrange(len(products)): trie.insert(products, i) result = [[] for _ in xrange(len(searchWord))] for i, c in enumerate(searchWord): if c not in trie.leaves: break trie = trie.leaves[c] result[i] = map(lambda x: products[x], trie.infos) return result import bisect ", "class Solution def suggestedProducts(self, products, searchWord): products.sort() result = [] prefix = \"\" for i, c in enumerate(searchWord): prefix += c start = bisect.bisect_left(products, prefix) new_products = [] for j in xrange(start, len(products)): if not (i < len(products[j]) and products[j][i] == c): break new_products.append(products[j]) products = new_products result.append(products[:3]) return result ", "class Solution def secondGreaterElement(self, nums): result, stk1, stk2 = [-1]*len(nums), [], [] for i, x in enumerate(nums): while stk2 and nums[stk2[-1]] < x: result[stk2.pop()] = x tmp = [] while stk1 and nums[stk1[-1]] < x: tmp.append(stk1.pop()) stk1.append(i) for x in reversed(tmp): stk2.append(x) return result ", "class Solution def findNthDigit(self, n): digit_len = 1 while n > digit_len * 9 * (10 ** (digit_len-1)): n -= digit_len * 9 * (10 ** (digit_len-1)) digit_len += 1 num = 10 ** (digit_len-1) + (n-1)/digit_len nth_digit = num / (10 ** ((digit_len-1) - ((n-1)%digit_len))) nth_digit %= 10 return nth_digit ", "class Solution def countSubTrees(self, n, edges, labels): def iter_dfs(labels, adj, node, parent, result): stk = [(1, (node, parent, [0]*26))] while stk: step, params = stk.pop() if step == 1: node, parent, ret = params stk.append((4, (node, ret))) stk.append((2, (node, parent, reversed(adj[node]), ret))) elif step == 2: node, parent, it, ret = params child = next(it, None) if not child or child == parent: continue ret2 = [0]*26 stk.append((2, (node, parent, it, ret))) stk.append((3, (ret2, ret))) stk.append((1, (child, node, ret2))) elif step == 3: ret2, ret = params for k in xrange(len(ret2)): ret[k] += ret2[k] else: node, ret = params ret[ord(labels[node]) - ord('a')] += 1 result[node] += ret[ord(labels[node]) - ord('a')] adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) result = [0]*n iter_dfs(labels, adj, 0, -1, result) return result import collections ", "class Solution def countSubTrees(self, n, edges, labels): def dfs(labels, adj, node, parent, result): count = [0]*26 for child in adj[node]: if child == parent: continue new_count = dfs(labels, adj, child, node, result) for k in xrange(len(new_count)): count[k] += new_count[k] count[ord(labels[node]) - ord('a')] += 1 result[node] = count[ord(labels[node]) - ord('a')] return count adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) result = [0]*n dfs(labels, adj, 0, -1, result) return result ", "class Solution def minTaps(self, n, ranges): def jump_game(A): jump_count, reachable, curr_reachable = 0, 0, 0 for i, length in enumerate(A): if i > reachable: return -1 if i > curr_reachable: curr_reachable = reachable jump_count += 1 reachable = max(reachable, i+length) return jump_count max_range = [0]*(n+1) for i, r in enumerate(ranges): left, right = max(i-r, 0), min(i+r, n) max_range[left] = max(max_range[left], right-left) return jump_game(max_range) ", "class Solution def numberOfGoodPaths(self, vals, edges): edges.sort(key=lambda x: max(vals[x[0]], vals[x[1]])) uf = UnionFind(vals) return len(vals)+sum(uf.union_set(i, j, max(vals[i], vals[j])) for i, j in edges) ", "class Solution def sumScores(self, s): def z_function(s): z = [0]*len(s) l, r = 0, 0 for i in xrange(1, len(z)): if i <= r: z[i] = min(r-i+1, z[i-l]) while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]: z[i] += 1 if i+z[i]-1 > r: l, r = i, i+z[i]-1 return z z = z_function(s) z[0] = len(s) return sum(z) ", "class Solution def minLengthAfterRemovals(self, nums): mx = max(collections.Counter(nums).itervalues()) return mx-(len(nums)-mx) if mx > (len(nums)-mx) else len(nums)%2 ", "class Solution def maximizeXor(self, nums, queries): nums.sort() max_val = max(nums[-1], max(queries, key=lambda x: x[0])[0]) queries = sorted(enumerate(queries), key=lambda x: x[1][1]) trie = Trie(max_val.bit_length()) result = [-1]*len(queries) j = 0 for i, (x, m) in queries: while j < len(nums) and nums[j] <= m: trie.insert(nums[j]) j += 1 result[i] = trie.query(x) return result ", "class Solution def validUtf8(self, data): count = 0 for c in data: if count == 0: if (c >> 5) == 0b110: count = 1 elif (c >> 4) == 0b1110: count = 2 elif (c >> 3) == 0b11110: count = 3 elif (c >> 7): return False else: if (c >> 6) != 0b10: return False count -= 1 return count == 0 ", "class Solution def maximumPoints(self, edges, coins, k): NEG_INF = float(\"-inf\") def dfs(u, p, base): if base >= max_base: return 0 if lookup[u]&base: return NEG_INF lookup[u] |= base return max(((coins[u]//base)-k)+sum(dfs(v, u, base) for v in adj[u] if v != p), (coins[u]//(base<<1))+sum(dfs(v, u, base<<1) for v in adj[u] if v != p) if (coins[u]//base)-k < coins[u]//(base*2) else NEG_INF) adj = [[] for _ in xrange(len(coins))] for u, v in edges: adj[u].append(v) adj[v].append(u) max_base = 1<<max(coins).bit_length() lookup = [0]*len(coins) return dfs(0, -1, 1) ", "class Solution def maximumPoints(self, edges, coins, k): def memoization(u, p, d): if d >= max_d: return 0 if lookup[u][d] is None: lookup[u][d] = max(((coins[u]>>d)-k)+sum(memoization(v, u, d) for v in adj[u] if v != p), (coins[u]>>(d+1))+sum(memoization(v, u, d+1) for v in adj[u] if v != p)) return lookup[u][d] adj = [[] for _ in xrange(len(coins))] for u, v in edges: adj[u].append(v) adj[v].append(u) max_d = max(coins).bit_length() lookup = [[None]*max_d for _ in xrange(len(coins))] return memoization(0, -1, 0) ", "class Solution def partition(self, s): is_palindrome = [[False] * len(s) for i in xrange(len(s))] for i in reversed(xrange(len(s))): for j in xrange(i, len(s)): is_palindrome[i][j] = s[i] == s[j] and ((j - i < 2) or is_palindrome[i + 1][j - 1]) sub_partition = [[] for _ in xrange(len(s))] for i in reversed(xrange(len(s))): for j in xrange(i, len(s)): if is_palindrome[i][j]: if j + 1 < len(s): for p in sub_partition[j + 1]: sub_partition[i].append([s[i:j + 1]] + p) else: sub_partition[i].append([s[i:j + 1]]) return sub_partition[0] ", "class Solution def partition(self, s): result = [] self.partitionRecu(result, [], s, 0) return result def partitionRecu(self, result, cur, s, i): if i == len(s): result.append(list(cur)) else: for j in xrange(i, len(s)): if self.isPalindrome(s[i: j + 1]): cur.append(s[i: j + 1]) self.partitionRecu(result, cur, s, j + 1) cur.pop() def isPalindrome(self, s): for i in xrange(len(s) / 2): if s[i] != s[-(i + 1)]: return False return True ", "class Solution def maximumSwap(self, num): digits = list(str(num)) left, right = 0, 0 max_idx = len(digits)-1 for i in reversed(xrange(len(digits))): if digits[i] > digits[max_idx]: max_idx = i elif digits[max_idx] > digits[i]: left, right = i, max_idx digits[left], digits[right] = digits[right], digits[left] return int(\"\".join(digits)) ", "class Solution def minimumCost(self, sentence, k): def lens(sentence): j = len(sentence)-1 for i in reversed(xrange(-1, len(sentence))): if i == -1 or sentence[i] == ' ': yield j-i j = i-1 word_lens, dp = [], [] t = -1 for l in lens(sentence): word_lens.append(l) dp.append(float(\"inf\")) t += l+1 if t <= k: dp[-1] = 0 continue total = l for j in reversed(xrange(len(dp)-1)): dp[-1] = min(dp[-1], dp[j] + (k-total)**2) total += (word_lens[j]+1) if total > k: word_lens = word_lens[j:] dp = dp[j:] break return dp[-1] if dp else 0 ", "class Solution def minimumCost(self, sentence, k): word_lens = [] j = 0 for i in xrange(len(sentence)+1): if i != len(sentence) and sentence[i] != ' ': continue word_lens.append(i-j) j = i+1 dp = [float(\"inf\")]*(len(word_lens)) i, total = len(word_lens)-1, -1 while i >= 0 and total + (word_lens[i]+1) <= k: total += (word_lens[i]+1) dp[i] = 0 i -= 1 for i in reversed(xrange(i+1)): total = word_lens[i] for j in xrange(i+1, len(dp)): dp[i] = min(dp[i], dp[j] + (k-total)**2) total += (word_lens[j]+1) if total > k: break return dp[0] ", "class Solution def minimumCost(self, sentence, k): word_lens = [] j = 0 for i in xrange(len(sentence)+1): if i != len(sentence) and sentence[i] != ' ': continue word_lens.append(i-j) j = i+1 dp = [float(\"inf\")]*(1+(len(word_lens)-1)) dp[0] = 0 for i in xrange(1, (len(word_lens)-1)+1): total = word_lens[i-1] for j in reversed(xrange(i)): dp[i] = min(dp[i], dp[j] + (k-total)**2) if j-1 < 0: continue total += (word_lens[j-1]+1) if total > k: break i, total = len(word_lens)-1, -1 while i >= 0 and total + (word_lens[i]+1) <= k: total += (word_lens[i]+1) i -= 1 return min(dp[j] for j in xrange(i+1, len(dp))) ", "class Solution def singleNumber(self, A): return reduce(operator.xor, A) ", "class Solution def recoverTree(self, root): return self.MorrisTraversal(root) def MorrisTraversal(self, root): if root is None: return broken = [None, None] pre, cur = None, root while cur: if cur.left is None: self.detectBroken(broken, pre, cur) pre = cur cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: node.right =cur cur = cur.left else: self.detectBroken(broken, pre, cur) node.right = None pre = cur cur = cur.right broken[0].val, broken[1].val = broken[1].val, broken[0].val return root def detectBroken(self, broken, pre, cur): if pre and pre.val > cur.val: if broken[0] is None: broken[0] = pre broken[1] = cur ", "class Solution def maxSumAfterPartitioning(self, A, K): W = K+1 dp = [0]*W for i in xrange(len(A)): curr_max = 0 for k in xrange(1, min(K, i+1) + 1): curr_max = max(curr_max, A[i-k+1]) dp[i % W] = max(dp[i % W], (dp[(i-k) % W] if i >= k else 0) + curr_max*k) return dp[(len(A)-1) % W] ", "class Solution def makeLargestSpecial(self, S): result = [] anchor = count = 0 for i, v in enumerate(S): count += 1 if v == '1' else -1 if count == 0: result.append(\"1{}0\".format(self.makeLargestSpecial(S[anchor+1:i]))) anchor = i+1 result.sort(reverse = True) return \"\".join(result) ", "class Solution def matrixScore(self, A): R, C = len(A), len(A[0]) result = 0 for c in xrange(C): col = 0 for r in xrange(R): col += A[r][c] ^ A[r][0] result += max(col, R-col) * 2**(C-1-c) return result ", "class Solution def minCost(self, startPos, homePos, rowCosts, colCosts): [x0, y0], [x1, y1] = startPos, homePos return (sum(rowCosts[i] for i in xrange(min(x0, x1), max(x0, x1)+1))-rowCosts[x0]) + (sum(colCosts[i] for i in xrange(min(y0, y1), max(y0, y1)+1))-colCosts[y0]) ", "class Solution def minDominoRotations(self, A, B): intersect = reduce(set.__and__, [set(d) for d in itertools.izip(A, B)]) if not intersect: return -1 x = intersect.pop() return min(len(A)-A.count(x), len(B)-B.count(x)) ", "class Solution def sortEvenOdd(self, nums): def partition(index, nums): for i in xrange(len(nums)): j = i while nums[i] >= 0: j = index(j) nums[i], nums[j] = nums[j], ~nums[i] for i in xrange(len(nums)): nums[i] = ~nums[i] def inplace_counting_sort(nums, left, right, reverse=False): if right-left+1 == 0: return count = [0]*(max(nums[i] for i in xrange(left, right+1))+1) for i in xrange(left, right+1): count[nums[i]] += 1 for i in xrange(1, len(count)): count[i] += count[i-1] for i in reversed(xrange(left, right+1)): while nums[i] >= 0: count[nums[i]] -= 1 j = left+count[nums[i]] nums[i], nums[j] = nums[j], ~nums[i] for i in xrange(left, right+1): nums[i] = ~nums[i] if reverse: while left < right: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1 partition(lambda i: i//2 if i%2 == 0 else (len(nums)+1)//2+i//2, nums) inplace_counting_sort(nums, 0, (len(nums)+1)//2-1) inplace_counting_sort(nums, (len(nums)+1)//2, len(nums)-1, True) partition(lambda i: 2*i if i < (len(nums)+1)//2 else 1+2*(i-(len(nums)+1)//2), nums) return nums ", "class Solution def sortEvenOdd(self, nums): def partition(index, nums): for i in xrange(len(nums)): j = i while nums[i] >= 0: j = index(j) nums[i], nums[j] = nums[j], ~nums[i] for i in xrange(len(nums)): nums[i] = ~nums[i] partition(lambda i: i//2 if i%2 == 0 else (len(nums)+1)//2+i//2, nums) nums[:(len(nums)+1)//2], nums[(len(nums)+1)//2:] = sorted(nums[:(len(nums)+1)//2]), sorted(nums[(len(nums)+1)//2:], reverse=True) partition(lambda i: 2*i if i < (len(nums)+1)//2 else 1+2*(i-(len(nums)+1)//2), nums) return nums ", "class Solution def sortEvenOdd(self, nums): nums[::2], nums[1::2] = sorted(nums[::2]), sorted(nums[1::2], reverse=True) return nums ", "class Solution def maxStarSum(self, vals, edges, k): def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 adj = [[] for _ in xrange(len(vals))] for u, v in edges: if vals[v] > 0: adj[u].append(v) if vals[u] > 0: adj[v].append(u) result = float(\"-inf\") for u in xrange(len(vals)): if 1 <= k <= len(adj[u]): nth_element(adj[u], k-1, lambda a, b: vals[a] > vals[b]) result = max(result, vals[u]+sum(vals[adj[u][i]] for i in range(min(k, len(adj[u]))))) return result ", "class Solution def sortFeatures(self, features, responses): features_set = set(features) order = {word: i for i, word in enumerate(features)} freq = collections.defaultdict(int) for r in responses: for word in set(r.split(' ')): if word in features_set: freq[word] += 1 features.sort(key=lambda x: (-freq[x], order[x])) return features ", "class Solution def numberOfEmployeesWhoMetTarget(self, hours, target): return sum(x >= target for x in hours) ", "class Solution def buildWall(self, height, width, bricks): MOD = 10**9+7 def backtracking(height, width, bricks, total, mask, lookup, patterns): if mask in lookup: return lookup.add(mask) if total >= width: if total == width: patterns.append(mask^(1<<width)) return for x in bricks: backtracking(height, width, bricks, total+x, mask|(1<<(total+x)), lookup, patterns) patterns, lookup = [], set() backtracking(height, width, bricks, 0, 0, lookup, patterns) adj = [[j for j, r2 in enumerate(patterns) if not (r1 & r2)] for r1 in patterns] dp = [[1]*len(patterns), [0]*len(patterns)] for i in xrange(height-1): dp[(i+1)%2] = [sum(dp[i%2][k] for k in adj[j]) % MOD for j in xrange(len(patterns))] return sum(dp[(height-1)%2]) % MOD class Solution_TLE(object): def buildWall(self, height, width, bricks): MOD = 10**9+7 def backtracking(height, width, bricks, total, mask, lookup, patterns): if mask in lookup: return lookup.add(mask) if total >= width: if total == width: patterns.append(mask^(1<<width)) return for x in bricks: backtracking(height, width, bricks, total+x, mask|(1<<(total+x)), lookup, patterns) def matrix_mult(A, B): ZB = zip(*B) return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A] def matrix_expo(A, K): result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))] while K: if K % 2: result = matrix_mult(result, A) A = matrix_mult(A, A) K /= 2 return result patterns, lookup = [], set() backtracking(height, width, bricks, 0, 0, lookup, patterns) return reduce(lambda x,y: (x+y)%MOD, matrix_mult([[1]*len(patterns)], matrix_expo([[int((mask1 & mask2) == 0) for mask2 in patterns] for mask1 in patterns], height-1))[0], 0) ", "class Solution def wordsAbbreviation(self, dict): def isUnique(prefix, words): return sum(word.startswith(prefix) for word in words) == 1 def toAbbr(prefix, word): abbr = prefix + str(len(word) - 1 - len(prefix)) + word[-1] return abbr if len(abbr) < len(word) else word abbr_to_word = collections.defaultdict(set) word_to_abbr = {} for word in dict: prefix = word[:1] abbr_to_word[toAbbr(prefix, word)].add(word) for abbr, conflicts in abbr_to_word.iteritems(): if len(conflicts) > 1: for word in conflicts: for i in xrange(2, len(word)): prefix = word[:i] if isUnique(prefix, conflicts): word_to_abbr[word] = toAbbr(prefix, word) break else: word_to_abbr[conflicts.pop()] = abbr return [word_to_abbr[word] for word in dict] ", "class Solution def minimumChairs(self, s): result = curr = 0 for x in s: curr += +1 if x == \"E\" else -1 result = max(result, curr) return result ", "class Solution def minDepth(self, root): if root is None: return 0 if root.left and root.right: return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 else: return max(self.minDepth(root.left), self.minDepth(root.right)) + 1 ", "class Solution def frequencySort(self, s): freq = collections.defaultdict(int) for c in s: freq[c] += 1 counts = [\"\"] * (len(s)+1) for c in freq: counts[freq[c]] += c result = \"\" for count in reversed(xrange(len(counts)-1)): for c in counts[count]: result += c * count return result ", "class Solution def divisibleTripletCount(self, nums, d): result = 0 cnt = collections.Counter() for i in xrange(len(nums)): for j in xrange(i+1, len(nums)): if (nums[i]+nums[j])%d in cnt: result += cnt[(nums[i]+nums[j])%d] cnt[-nums[i]%d] += 1 return result import collections ", "class Solution def divisibleTripletCount(self, nums, d): result = 0 cnt = collections.Counter() for i in xrange(len(nums)): if nums[i]%d in cnt: result += cnt[nums[i]%d] for j in xrange(i): cnt[-(nums[i]+nums[j])%d] += 1 return result import collections ", "class Solution def divisibleTripletCount(self, nums, d): result = 0 for i in xrange(len(nums)): cnt = collections.Counter() for j in xrange(i+1, len(nums)): result += cnt[nums[j]%d] cnt[-(nums[i]+nums[j])%d] += 1 return result ", "class Solution def maxGcdSum(self, nums, k): def gcd(a, b): while b: a, b = b, a%b return a result = prefix = 0 dp = [] for right, x in enumerate(nums): dp.append((right, x, prefix)) prefix += x new_dp = [] for left, g, p in dp: ng = gcd(g, x) if not new_dp or new_dp[-1][1] != ng: new_dp.append((left, ng, p)) dp = new_dp for left, g, p in dp: if right-left+1 < k: break result = max(result, (prefix-p)*g) return result ", "class Solution def maxGcdSum(self, nums, k): def gcd(a, b): while b: a, b = b, a%b return a prefix = [0]*(len(nums)+1) for i, x in enumerate(nums): prefix[i+1] = prefix[i]+x result = 0 dp = [] for right, x in enumerate(nums): dp.append((right, x)) new_dp = [] for left, g in dp: ng = gcd(g, x) if not new_dp or new_dp[-1][1] != ng: new_dp.append((left, ng)) dp = new_dp for left, g in dp: if right-left+1 < k: break result = max(result, (prefix[right+1]-prefix[left])*g) return result class Solution3_TLE(object): def maxGcdSum(self, nums, k): def gcd(a, b): while b: a, b = b, a%b return a def binary_search_right(left, right, check): while left <= right: mid = left + (right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right class SparseTable(object): def __init__(self, arr, fn): self.fn = fn self.bit_length = [0] n = len(arr) k = n.bit_length()-1 for i in xrange(k+1): self.bit_length.extend(i+1 for _ in xrange(min(1<<i, (n+1)-len(self.bit_length)))) self.st = [[0]*n for _ in xrange(k+1)] self.st[0] = arr[:] for i in xrange(1, k+1): for j in xrange((n-(1<<i))+1): self.st[i][j] = fn(self.st[i-1][j], self.st[i-1][j+(1<<(i-1))]) def query(self, L, R): i = self.bit_length[R-L+1]-1 return self.fn(self.st[i][L], self.st[i][R-(1<<i)+1]) prefix = [0]*(len(nums)+1) for i, x in enumerate(nums): prefix[i+1] = prefix[i]+x result = 0 rmq = SparseTable(nums, gcd) for left, x in enumerate(nums): right = left while right < len(nums): g = rmq.query(left, right) right = binary_search_right(right, len(nums)-1, lambda x: rmq.query(left, x) >= g) if right-left+1 >= k: result = max(result, (prefix[right+1]-prefix[left])*g) right += 1 return result ", "class Solution def minimumOperationsToMakeKPeriodic(self, word, k): cnt = collections.Counter(word[i:i+k]for i in xrange(0, len(word), k)) return len(word)//k-max(cnt.itervalues()) ", "class Solution def stoneGameIII(self, stoneValue): dp = [float(\"-inf\")]*3 dp[len(stoneValue)%3] = 0 for i in reversed(xrange(len(stoneValue))): max_dp, curr = float(\"-inf\"), 0 for j in xrange(min(3, len(stoneValue)-i)): curr += stoneValue[i+j] max_dp = max(max_dp, curr-dp[(i+j+1)%3]) dp[i%3] = max_dp return [\"Tie\", \"Alice\", \"Bob\"][cmp(dp[0], 0)] ", "class Solution def commonFactors(self, a, b): def gcd(a, b): while b: a, b = b, a%b return a g = gcd(a, b) result = 0 x = 1 while x*x <= g: if g%x == 0: result += 1 if g//x == x else 2 x += 1 return result ", "class Solution def removeDuplicates(self, A): if not A: return 0 last = 0 for i in xrange(len(A)): if A[last] != A[i]: last += 1 A[last] = A[i] return last + 1 ", "class Solution def canPartition(self, nums): s = sum(nums) if s % 2: return False dp = [False] * (s/2 + 1) dp[0] = True for num in nums: for i in reversed(xrange(1, len(dp))): if num <= i: dp[i] = dp[i] or dp[i - num] return dp[-1] ", "class Solution def thirdMax(self, nums): count = 0 top = [float(\"-inf\")] * 3 for num in nums: if num > top[0]: top[0], top[1], top[2] = num, top[0], top[1] count += 1 elif num != top[0] and num > top[1]: top[1], top[2] = num, top[1] count += 1 elif num != top[0] and num != top[1] and num >= top[2]: top[2] = num count += 1 if count < 3: return top[0] return top[2] ", "class Solution def levelOrder(self, root): if not root: return [] result, q = [], [root] while q: result.append([node.val for node in q]) q = [child for node in q for child in node.children if child] return result ", "class Solution def minMutation(self, start, end, bank): lookup = {} for b in bank: lookup[b] = False q = deque([(start, 0)]) while q: cur, level = q.popleft() if cur == end: return level for i in xrange(len(cur)): for c in ['A', 'T', 'C', 'G']: if cur[i] == c: continue next_str = cur[:i] + c + cur[i+1:] if next_str in lookup and lookup[next_str] == False: q.append((next_str, level+1)) lookup[next_str] = True return -1 ", "class Solution def minMovesToSeat(self, seats, students): seats.sort() students.sort() return sum(abs(a-b) for a, b in itertools.izip(seats, students)) ", "class Solution def maxNumEdgesToRemove(self, n, edges): result = 0 union_find_a, union_find_b = UnionFind(n), UnionFind(n) for t, i, j in edges: if t != 3: continue a = union_find_a.union_set(i-1, j-1) b = union_find_b.union_set(i-1, j-1) if not a and not b: result += 1 for t, i, j in edges: if t == 1: if not union_find_a.union_set(i-1, j-1): result += 1 elif t == 2: if not union_find_b.union_set(i-1, j-1): result += 1 return result if union_find_a.count == union_find_b.count == 1 else -1 ", "class Solution def minOperations(self, target, arr): lookup = {x:i for i, x in enumerate(target)} lis = [] for x in arr: if x not in lookup: continue i = bisect.bisect_left(lis, lookup[x]) if i == len(lis): lis.append(lookup[x]) else: lis[i] = lookup[x] return len(target)-len(lis) class SegmentTree(object): def __init__(self, N, build_fn=lambda x, y: [y]*(2*x), query_fn=lambda x, y: y if x is None else max(x, y), update_fn=lambda x, y: y, default_val=0): self.N = N self.H = (N-1).bit_length() self.query_fn = query_fn self.update_fn = update_fn self.default_val = default_val self.tree = build_fn(N, default_val) self.lazy = [None]*N def __apply(self, x, val): self.tree[x] = self.update_fn(self.tree[x], val) if x < self.N: self.lazy[x] = self.update_fn(self.lazy[x], val) def update(self, L, R, h): def pull(x): while x > 1: x //= 2 self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1]) if self.lazy[x] is not None: self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]) L += self.N R += self.N L0, R0 = L, R while L <= R: if L & 1: self.__apply(L, h) L += 1 if R & 1 == 0: self.__apply(R, h) R -= 1 L //= 2 R //= 2 pull(L0) pull(R0) def query(self, L, R): def push(x): n = 2**self.H while n != 1: y = x // n if self.lazy[y] is not None: self.__apply(y*2, self.lazy[y]) self.__apply(y*2 + 1, self.lazy[y]) self.lazy[y] = None n //= 2 result = None if L > R: return result L += self.N R += self.N push(L) push(R) while L <= R: if L & 1: result = self.query_fn(result, self.tree[L]) L += 1 if R & 1 == 0: result = self.query_fn(result, self.tree[R]) R -= 1 L //= 2 R //= 2 return result def __str__(self): showList = [] for i in xrange(self.N): showList.append(self.query(i, i)) return \",\".join(map(str, showList)) ", "class Solution def minOperations(self, target, arr): lookup = {x:i for i, x in enumerate(target)} st = SegmentTree(len(lookup)) for x in arr: if x not in lookup: continue st.update(lookup[x], lookup[x], st.query(0, lookup[x]-1)+1 if lookup[x] >= 1 else 1) return len(target)-(st.query(0, len(lookup)-1) if len(lookup) >= 1 else 0) ", "class Solution def isSameTree(self, p, q): if p is None and q is None: return True if p is not None and q is not None: return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) return False ", "class Solution def minCostII(self, costs): return min(reduce(self.combine, costs)) if costs else 0 def combine(self, tmp, house): smallest, k, i = min(tmp), len(tmp), tmp.index(min(tmp)) tmp, tmp[i] = [smallest] * k, min(tmp[:i] + tmp[i+1:]) return map(sum, zip(tmp, house)) ", "class Solution def minCostII(self, costs): if not costs: return 0 n = len(costs) k = len(costs[0]) min_cost = [costs[0], [0] * k] for i in xrange(1, n): smallest, second_smallest = float(\"inf\"), float(\"inf\") for j in xrange(k): if min_cost[(i - 1) % 2][j] < smallest: smallest, second_smallest = min_cost[(i - 1) % 2][j], smallest elif min_cost[(i - 1) % 2][j] < second_smallest: second_smallest = min_cost[(i - 1) % 2][j] for j in xrange(k): min_j = smallest if min_cost[(i - 1) % 2][j] != smallest else second_smallest min_cost[i % 2][j] = costs[i][j] + min_j return min(min_cost[(n - 1) % 2]) ", "class Solution def restoreArray(self, adjacentPairs): adj = collections.defaultdict(list) for u, v in adjacentPairs: adj[u].append(v) adj[v].append(u) result = next([x, adj[x][0]] for x in adj if len(adj[x]) == 1) while len(result) != len(adjacentPairs)+1: result.append(adj[result[-1]][adj[result[-1]][0] == result[-2]]) return result ", "class Solution def minimumVisitedCells(self, grid): m, n = len(grid), len(grid[0]) uf1 = [UnionFind(n+1) for _ in xrange(m)] uf2 = [UnionFind(m+1) for _ in xrange(n)] d, i, j = 1, 0, 0 q = [(i, j)] uf1[i].union_set(j, j+1) uf2[j].union_set(i, i+1) while q: new_q = [] for i, j in q: if (i, j) == (m-1, n-1): return d while uf1[i].right_set(j) <= min(j+grid[i][j], n-1): k = uf1[i].right_set(j) new_q.append((i, k)) uf2[k].union_set(i, i+1) uf1[i].union_set(k, k+1) while uf2[j].right_set(i) <= min(i+grid[i][j], m-1): k = uf2[j].right_set(i) new_q.append((k, j)) uf1[k].union_set(j, j+1) uf2[j].union_set(k, k+1) q = new_q d += 1 return -1 from sortedcontainers import SortedList class Solution2_TLE(object): def minimumVisitedCells(self, grid): m, n = len(grid), len(grid[0]) sl1 = [SortedList(xrange(n)) for _ in xrange(m)] sl2 = [SortedList(xrange(m)) for _ in xrange(n)] d, i, j = 1, 0, 0 q = [(i, j)] while q: new_q = [] for i, j in q: if (i, j) == (m-1, n-1): return d for k in list(sl1[i].irange(j+1, min(j+grid[i][j], n-1))): new_q.append((i, k)) sl2[k].remove(i) sl1[i].remove(k) for k in list(sl2[j].irange(i+1, min(i+grid[i][j], m-1))): new_q.append((k, j)) sl1[k].remove(j) sl2[j].remove(k) q = new_q d += 1 return -1 ", "class Solution def stringCount(self, n): MOD = 10**9+7 return (pow(26, n, MOD)- (25+25+25+n)*pow(25, n-1, MOD)+ (24+24+24+n+n+0)*pow(24, n-1, MOD)- (23+n+0+0)*pow(23, n-1, MOD))%MOD ", "class Solution def stringCount(self, n): MOD = 10**9+7 L, E, EE, T = [1<<i for i in xrange(4)] dp = [0]*(1<<4) dp[0] = 1 for _ in xrange(n): new_dp = [0]*(1<<4) for mask in xrange(len(dp)): new_dp[mask|L] = (new_dp[mask|L]+dp[mask])%MOD if not (mask & E): new_dp[mask|E] = (new_dp[mask|E]+dp[mask])%MOD else: new_dp[mask|EE] = (new_dp[mask|EE]+dp[mask])%MOD new_dp[mask|T] = (new_dp[mask|T]+dp[mask])%MOD new_dp[mask] = (new_dp[mask]+23*dp[mask])%MOD dp = new_dp return dp[-1] ", "class Solution def maxVacationDays(self, flights, days): if not days or not flights: return 0 dp = [[0] * len(days) for _ in xrange(2)] for week in reversed(xrange(len(days[0]))): for cur_city in xrange(len(days)): dp[week % 2][cur_city] = days[cur_city][week] + dp[(week+1) % 2][cur_city] for dest_city in xrange(len(days)): if flights[cur_city][dest_city] == 1: dp[week % 2][cur_city] = max(dp[week % 2][cur_city], days[dest_city][week] + dp[(week+1) % 2][dest_city]) return dp[0][0] ", "class Solution def maxDistToClosest(self, seats): prev, result = -1, 1 for i in xrange(len(seats)): if seats[i]: if prev < 0: result = i else: result = max(result, (i-prev)//2) prev = i return max(result, len(seats)-1-prev) ", "class Solution def newInteger(self, n): result, base = 0, 1 while n > 0: result += (n%9) * base n /= 9 base *= 10 return result ", "class Solution def findGameWinner(self, n): return n%6 != 1 ", "class Solution def findGameWinner(self, n): grundy = [0, 1] for i in xrange(2, n): grundy[i%2] = (grundy[(i-1)%2]+1)^(grundy[(i-2)%2]+1) return grundy[(n-1)%2] > 0 ", "class Solution def maximumBeauty(self, flowers, newFlowers, target, full, partial): flowers.sort() n = bisect.bisect_left(flowers, target) prefix, suffix = 0, sum(flowers[i] for i in xrange(n)) result = left = 0 for right in xrange(n+1): if right: suffix -= flowers[right-1] total = newFlowers-((n-right)*target-suffix) if total < 0: continue while not (left == right or (left and (total+prefix)//left <= flowers[left])): prefix += flowers[left] left += 1 mn = min((total+prefix)//left if left else 0, target-1) result = max(result, mn*partial+(len(flowers)-right)*full) return result import bisect ", "class Solution def maximumBeauty(self, flowers, newFlowers, target, full, partial): flowers.sort() n = bisect.bisect_left(flowers, target) prefix = [0]*(n+1) for i in xrange(n): prefix[i+1] = prefix[i]+flowers[i] result = suffix = 0 left = n for right in reversed(xrange(n+1)): if right != n: suffix += flowers[right] total = newFlowers-((n-right)*target-suffix) if total < 0: continue left = min(left, right) while not (left == 0 or (prefix[left]-prefix[left-1])*left-prefix[left] <= total): left -= 1 mn = min((total+prefix[left])//left if left else 0, target-1) result = max(result, mn*partial+(len(flowers)-right)*full) return result import bisect ", "class Solution def maximumBeauty(self, flowers, newFlowers, target, full, partial): def check(prefix, total, x): return x and (total+prefix[x])//x <= prefix[x+1]-prefix[x] def binary_search(prefix, total, left, right): while left <= right: mid = left+(right-left)//2 if check(prefix, total, mid): right = mid-1 else: left = mid+1 return left flowers.sort() n = bisect.bisect_left(flowers, target) prefix = [0]*(n+1) for i in xrange(n): prefix[i+1] = prefix[i]+flowers[i] suffix = sum(flowers[i] for i in xrange(n)) result = left = 0 for right in xrange(n+1): if right: suffix -= flowers[right-1] total = newFlowers-((n-right)*target-suffix) if total < 0: continue left = binary_search(prefix, total, 0, right-1) mn = min((total+prefix[left])//left if left else 0, target-1) result = max(result, mn*partial+(len(flowers)-right)*full) return result import bisect ", "class Solution def maximumBeauty(self, flowers, newFlowers, target, full, partial): def check(prefix, total, x): return (prefix[x]-prefix[x-1])*x-prefix[x] <= total def binary_search_right(prefix, total, left, right): while left <= right: mid = left+(right-left)//2 if not check(prefix, total, mid): right = mid-1 else: left = mid+1 return right flowers.sort() n = bisect.bisect_left(flowers, target) prefix = [0]*(n+1) for i in xrange(n): prefix[i+1] = prefix[i]+flowers[i] result = suffix = 0 left = n for right in reversed(xrange(n+1)): if right != n: suffix += flowers[right] total = newFlowers-((n-right)*target-suffix) if total < 0: break left = binary_search_right(prefix, total, 1, right) mn = min((total+prefix[left])//left if left else 0, target-1) result = max(result, mn*partial+(len(flowers)-right)*full) return result ", "class Solution def minimumCost(self, n, highways, discounts): adj = [[] for _ in xrange(n)] for u, v, w in highways: adj[u].append((v, w)) adj[v].append((u, w)) src, dst = 0, n-1 best = collections.defaultdict(lambda: collections.defaultdict(lambda: float(\"inf\"))) best[src][discounts] = 0 min_heap = [(0, src, discounts)] while min_heap: result, u, k = heapq.heappop(min_heap) if best[u][k] < result: continue if u == dst: return result for v, w in adj[u]: if result+w < best[v][k]: best[v][k] = result+w heapq.heappush(min_heap, (result+w, v, k)) if k > 0 and result+w//2 < best[v][k-1]: best[v][k-1] = result+w//2 heapq.heappush(min_heap, (result+w//2, v, k-1)) return -1 ", "class Solution def findNonMinOrMax(self, nums): mx, mn = float(\"-inf\"), float(\"inf\") result = -1 for x in nums: if mn < x < mx: return x if x < mn: result = mn mn = x if x > mx: result = mx mx = x return result if mn < result < mx else -1 ", "class Solution def findNonMinOrMax(self, nums): mx, mn = max(nums), min(nums) return next((x for x in nums if x not in (mx, mn)), -1) ", "class Solution def maxSpending(self, values): m, n = len(values), len(values[0]) min_heap = [(values[i].pop(), i) for i in xrange(m)] heapq.heapify(min_heap) result = 0 for d in xrange(1, m*n+1): x, i = heapq.heappop(min_heap) result += x*d if values[i]: heapq.heappush(min_heap, (values[i].pop(), i)) return result ", "class Solution def largestSumAfterKNegations(self, A, K): def kthElement(nums, k, compare): def PartitionAroundPivot(left, right, pivot_idx, nums, compare): new_pivot_idx = left nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx] for i in xrange(left, right): if compare(nums[i], nums[right]): nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i] new_pivot_idx += 1 nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right] return new_pivot_idx left, right = 0, len(nums) - 1 while left <= right: pivot_idx = random.randint(left, right) new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare) if new_pivot_idx == k: return elif new_pivot_idx > k: right = new_pivot_idx - 1 else: left = new_pivot_idx + 1 kthElement(A, K, lambda a, b: a < b) remain = K for i in xrange(K): if A[i] < 0: A[i] = -A[i] remain -= 1 return sum(A) - ((remain)%2)*min(A)*2 ", "class Solution def largestSumAfterKNegations(self, A, K): A.sort() remain = K for i in xrange(K): if A[i] >= 0: break A[i] = -A[i] remain -= 1 return sum(A) - (remain%2)*min(A)*2 ", "class Solution def tupleSameProduct(self, nums): result = 0 count = collections.Counter() for i in xrange(len(nums)): for j in xrange(i+1, len(nums)): result += count[nums[i]*nums[j]] count[nums[i]*nums[j]] += 1 return 8*result ", "class Solution def validSubarraySize(self, nums, threshold): stk = [-1] for i in xrange(len(nums)+1): while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] >= nums[i]): if nums[stk.pop()]*((i-1)-stk[-1]) > threshold: return (i-1)-stk[-1] stk.append(i) return -1 ", "class Solution def stoneGameIX(self, stones): count = collections.Counter(x%3 for x in stones) if count[0]%2 == 0: return count[1] and count[2] return abs(count[1]-count[2]) >= 3 ", "class Solution def largeGroupPositions(self, S): result = [] i = 0 for j in xrange(len(S)): if j == len(S)-1 or S[j] != S[j+1]: if j-i+1 >= 3: result.append([i, j]) i = j+1 return result ", "class Solution def reinitializePermutation(self, n): def discrete_log(a, b, m): a %= m b %= m n = int(m**0.5)+1 an = pow(a, n, m) vals = {} curr = b for q in xrange(n+1): vals[curr] = q curr = curr*a % m curr = 1 for p in xrange(1, n+1): curr = curr*an % m if curr in vals: return n*p-vals[curr] return -1 return 1+discrete_log(2, n//2, n-1) ", "class Solution def reinitializePermutation(self, n): if n == 2: return 1 result, i = 0, 1 while not result or i != 1: i = (i*2)%(n-1) result += 1 return result ", "class Solution def reinitializePermutation(self, n): result, i = 0, 1 while not result or i != 1: i = (i//2 if not i%2 else n//2+(i-1)//2) result += 1 return result ", "class Solution def getMinimumDifference(self, root): def inorderTraversal(root, prev, result): if not root: return (result, prev) result, prev = inorderTraversal(root.left, prev, result) if prev: result = min(result, root.val - prev.val) return inorderTraversal(root.right, root, result) return inorderTraversal(root, None, float(\"inf\"))[0] ", "class Solution def minimumIndex(self, nums): def boyer_moore_majority_vote(): result, cnt = None, 0 for x in nums: if not cnt: result = x if x == result: cnt += 1 else: cnt -= 1 return result m = boyer_moore_majority_vote() total, cnt = nums.count(m), 0 for i, x in enumerate(nums): if x == m: cnt += 1 if cnt*2 > i+1 and (total-cnt)*2 > len(nums)-(i+1): return i return -1 ", "class Solution NUMBER_OF_WORKERS = 8 def __init__(self): self.__cv = threading.Condition() self.__q = Queue.Queue() def crawl(self, startUrl, htmlParser): SCHEME = \"http://\" def hostname(url): pos = url.find('/', len(SCHEME)) if pos == -1: return url return url[:pos] def worker(htmlParser, lookup): while True: from_url = self.__q.get() if from_url is None: break name = hostname(from_url) for to_url in htmlParser.getUrls(from_url): if name != hostname(to_url): continue with self.__cv: if to_url not in lookup: lookup.add(to_url) self.__q.put(to_url) self.__q.task_done() workers = [] self.__q = Queue.Queue() self.__q.put(startUrl) lookup = set([startUrl]) for i in xrange(self.NUMBER_OF_WORKERS): t = threading.Thread(target=worker, args=(htmlParser, lookup)) t.start() workers.append(t) self.__q.join() for t in workers: self.__q.put(None) for t in workers: t.join() return list(lookup) import threading import collections ", "class Solution NUMBER_OF_WORKERS = 8 def __init__(self): self.__cv = threading.Condition() self.__q = collections.deque() self.__working_count = 0 def crawl(self, startUrl, htmlParser): SCHEME = \"http://\" def hostname(url): pos = url.find('/', len(SCHEME)) if pos == -1: return url return url[:pos] def worker(htmlParser, lookup): while True: with self.__cv: while not self.__q: self.__cv.wait() from_url = self.__q.popleft() if from_url is None: break self.__working_count += 1 name = hostname(from_url) for to_url in htmlParser.getUrls(from_url): if name != hostname(to_url): continue with self.__cv: if to_url not in lookup: lookup.add(to_url) self.__q.append(to_url) self.__cv.notifyAll() with self.__cv: self.__working_count -= 1 if not self.__q and not self.__working_count: self.__cv.notifyAll() workers = [] self.__q = collections.deque([startUrl]) lookup = set([startUrl]) for i in xrange(self.NUMBER_OF_WORKERS): t = threading.Thread(target=worker, args=(htmlParser, lookup)) t.start() workers.append(t) with self.__cv: while self.__q or self.__working_count: self.__cv.wait() for i in xrange(self.NUMBER_OF_WORKERS): self.__q.append(None) self.__cv.notifyAll() for t in workers: t.join() return list(lookup) ", "class Solution def canSeePersonsCount(self, heights): result = [0]*len(heights) stk = [] for i, h in enumerate(heights): while stk and heights[stk[-1]] < h: result[stk.pop()] += 1 if stk: result[stk[-1]] += 1 if stk and heights[stk[-1]] == h: stk.pop() stk.append(i) return result ", "class Solution def canSeePersonsCount(self, heights): result = [0]*len(heights) stk = [] for i in reversed(xrange(len(heights))): cnt = 0 while stk and heights[stk[-1]] < heights[i]: stk.pop() cnt += 1 result[i] = cnt+1 if stk else cnt if stk and heights[stk[-1]] == heights[i]: stk.pop() stk.append(i) return result ", "class Solution def regionsBySlashes(self, grid): def index(n, i, j, k): return (i*n + j)*4 + k union_find = UnionFind(len(grid)**2 * 4) N, E, S, W = range(4) for i in xrange(len(grid)): for j in xrange(len(grid)): if i: union_find.union_set(index(len(grid), i-1, j, S), index(len(grid),i, j, N)) if j: union_find.union_set(index(len(grid), i, j-1, E), index(len(grid), i, j, W)) if grid[i][j] != \"/\": union_find.union_set(index(len(grid), i, j, N), index(len(grid), i, j, E)) union_find.union_set(index(len(grid), i, j, S), index(len(grid), i, j, W)) if grid[i][j] != \"\\\\\": union_find.union_set(index(len(grid), i, j, W), index(len(grid), i, j, N)) union_find.union_set(index(len(grid), i, j, E), index(len(grid), i, j, S)) return union_find.count ", "class Solution def rectangleArea(self, rectangles): OPEN, CLOSE = 1, -1 events = [] X = set() for x1, y1, x2, y2 in rectangles: events.append((y1, OPEN, x1, x2)) events.append((y2, CLOSE, x1, x2)) X.add(x1) X.add(x2) events.sort() X = sorted(X) Xi = {x: i for i, x in enumerate(X)} st = SegmentTreeNode(0, len(X)-1) result = 0 cur_x_sum = 0 cur_y = events[0][0] for y, typ, x1, x2 in events: result += cur_x_sum * (y-cur_y) cur_x_sum = st.update(X, Xi[x1], Xi[x2], typ) cur_y = y return result % (10**9+7) ", "class Solution def minDifference(self, nums, queries): INF = float(\"inf\") prefix = [[0]*(max(nums)+1)] for num in nums: prefix.append(prefix[-1][:]) prefix[-1][num] += 1 result = [] for l, r in queries: min_diff, prev = INF, -1 for num in xrange(len(prefix[0])): if not (prefix[l][num] < prefix[r+1][num]): continue if prev != -1: min_diff = min(min_diff, num-prev) prev = num result.append(min_diff if min_diff != INF else -1) return result import bisect ", "class Solution def minDifference(self, nums, queries): INF = float(\"inf\") idxs = [[] for _ in xrange(max(nums)+1)] for i, num in enumerate(nums): idxs[num].append(i) result = [] for l, r in queries: min_diff, prev = INF, -1 for num in xrange(len(idxs)): i = bisect.bisect_left(idxs[num], l) if not (i < len(idxs[num]) and idxs[num][i] <= r): continue if prev != -1: min_diff = min(min_diff, num-prev) prev = num result.append(min_diff if min_diff != INF else -1) return result ", "class Solution def makeConnected(self, n, connections): if len(connections) < n-1: return -1 union_find = UnionFind(n) for i, j in connections: union_find.union_set(i, j) return union_find.count - 1 import collections ", "class Solution def makeConnected(self, n, connections): def dfs(i, lookup): if i in lookup: return 0 lookup.add(i) if i in G: for j in G[i]: dfs(j, lookup) return 1 if len(connections) < n-1: return -1 G = collections.defaultdict(list) for i, j in connections: G[i].append(j) G[j].append(i) lookup = set() return sum(dfs(i, lookup) for i in xrange(n)) - 1 ", "class Solution def fixedRatio(self, s, num1, num2): lookup = collections.Counter() lookup[0] = 1 result = curr = 0 for c in s: curr += -num2 if c == '0' else +num1 result += lookup[curr] lookup[curr] += 1 return result ", "class Solution def maximumStrongPairXor(self, nums): class Trie(object): def __init__(self, bit_length): self.__nodes = [] self.__cnts = [] self.__new_node() self.__bit_length = bit_length def __new_node(self): self.__nodes.append([-1]*2) self.__cnts.append(0) return len(self.__nodes)-1 def update(self, num, d): curr = 0 for i in reversed(xrange(self.__bit_length)): x = num>>i if self.__nodes[curr][x&1] == -1: self.__nodes[curr][x&1] = self.__new_node() curr = self.__nodes[curr][x&1] self.__cnts[curr] += d def query(self, num): result = curr = 0 for i in reversed(xrange(self.__bit_length)): result <<= 1 x = num>>i if self.__nodes[curr][1^(x&1)] != -1 and self.__cnts[self.__nodes[curr][1^(x&1)]]: curr = self.__nodes[curr][1^(x&1)] result |= 1 else: curr = self.__nodes[curr][x&1] return result nums.sort() trie = Trie(nums[-1].bit_length()) result = j = 0 for i, num in enumerate(nums): trie.update(num, +1) while not (nums[i] <= 2*nums[j]) : trie.update(nums[j], -1) j += 1 result = max(result, trie.query(num)) return result ", "class Solution def maximumStrongPairXor(self, nums): class Trie(object): def __init__(self, bit_length): self.__nodes = [] self.__mins = [] self.__maxs = [] self.__new_node() self.__bit_length = bit_length def __new_node(self): self.__nodes.append([-1]*2) self.__mins.append(float(\"inf\")) self.__maxs.append(float(\"-inf\")) return len(self.__nodes)-1 def insert(self, num): curr = 0 for i in reversed(xrange(self.__bit_length)): x = num>>i if self.__nodes[curr][x&1] == -1: self.__nodes[curr][x&1] = self.__new_node() curr = self.__nodes[curr][x&1] self.__mins[curr] = min(self.__mins[curr], num) self.__maxs[curr] = max(self.__maxs[curr], num) def query(self, num): result = curr = 0 for i in reversed(xrange(self.__bit_length)): result <<= 1 x = num>>i y = (result|1)^x assert(x != y) if (self.__nodes[curr][y&1] != -1 and ((x > y and num <= 2*self.__maxs[self.__nodes[curr][y&1]]) or (x < y and self.__mins[self.__nodes[curr][y&1]] <= 2*num))): result |= 1 curr = self.__nodes[curr][y&1] else: curr = self.__nodes[curr][1^(y&1)] return result trie = Trie(max(nums).bit_length()) result = 0 for num in nums: trie.insert(num) result = max(result, trie.query(num)) return result ", "class Solution def maximumStrongPairXor(self, nums): result = 0 for i in reversed(xrange(max(nums).bit_length())): prefix_min, prefix_max = {}, {} for x in nums: y = x>>i if y not in prefix_min: prefix_min[y] = prefix_max[y] = x prefix_min[y] = min(prefix_min[y], x) prefix_max[y] = max(prefix_max[y], x) result <<= 1 for x in prefix_min.iterkeys(): y = (result|1)^x assert(x != y) if y in prefix_max and prefix_min[max(x, y)] <= 2*prefix_max[min(x, y)]: result |= 1 break return result ", "class Solution def numUniqueEmails(self, emails): def convert(email): name, domain = email.split('@') name = name[:name.index('+')] return \"\".join([\"\".join(name.split(\".\")), '@', domain]) lookup = set() for email in emails: lookup.add(convert(email)) return len(lookup) ", "class Solution def minimumLines(self, stockPrices): def gcd(a, b): while b: a, b = b, a%b return a stockPrices.sort() result = 0 prev = None for i in xrange(1, len(stockPrices)): dy, dx = stockPrices[i][1]-stockPrices[i-1][1], stockPrices[i][0]-stockPrices[i-1][0] g = gcd(dy, dx) if not prev or prev != (dy//g, dx//g): prev = (dy//g, dx//g) result += 1 return result ", "class Solution def findPermutationDifference(self, s, t): lookup = [-1]*26 for i, x in enumerate(s): lookup[ord(x)-ord('a')] = i return sum(abs(lookup[ord(x)-ord('a')]-i)for i, x in enumerate(t)) ", "class Solution def numberOfUniqueGoodSubsequences(self, binary): MOD = 10**9+7 ends0, ends1 = 0, 0 has_zero = False for b in binary: if b == '1': ends1 = (ends0+ends1+1)%MOD else: ends0 = (ends0+ends1)%MOD has_zero = True return (ends0+ends1+int(has_zero))%MOD ", "class Solution def missingNumber(self, arr): def check(arr, d, x): return arr[x] != arr[0] + d*x d = (arr[-1]-arr[0])//len(arr) left, right = 0, len(arr)-1 while left <= right: mid = left + (right-left)//2 if check(arr, d, mid): right = mid-1 else: left = mid+1 return arr[0] + d*left ", "class Solution def missingNumber(self, arr): return (min(arr)+max(arr))*(len(arr)+1)//2 - sum(arr) ", "class Solution def minimumEffort(self, tasks): tasks.sort(key=lambda x: x[1]-x[0]) result = 0 for a, m in tasks: result = max(result+a, m) return result ", "class Solution def minimumEffort(self, tasks): tasks.sort(key=lambda x: x[0]-x[1]) result = curr = 0 for a, m in tasks: result += max(m-curr, 0) curr = max(curr, m)-a return result ", "class Solution def printTree(self, root): def getWidth(root): if not root: return 0 return 2 * max(getWidth(root.left), getWidth(root.right)) + 1 def getHeight(root): if not root: return 0 return max(getHeight(root.left), getHeight(root.right)) + 1 def preorderTraversal(root, level, left, right, result): if not root: return mid = left + (right-left)/2 result[level][mid] = str(root.val) preorderTraversal(root.left, level+1, left, mid-1, result) preorderTraversal(root.right, level+1, mid+1, right, result) h, w = getHeight(root), getWidth(root) result = [[\"\"] * w for _ in xrange(h)] preorderTraversal(root, 0, 0, w-1, result) return result ", "class Solution def validWordSquare(self, words): for i in xrange(len(words)): for j in xrange(len(words[i])): if j >= len(words) or i >= len(words[j]) or words[j][i] != words[i][j]: return False return True ", "class Solution def maximumsSplicedArray(self, nums1, nums2): def kadane(a): result = curr = 0 for x in a: curr = max(curr+x, 0) result = max(result, curr) return result return max(sum(nums1)+kadane((nums2[i]-nums1[i] for i in xrange(len(nums1)))), sum(nums2)+kadane((nums1[i]-nums2[i] for i in xrange(len(nums2))))) ", "class Solution def minGroupsForValidAssignment(self, nums): INF = float(\"inf\") def ceil_divide(a, b): return (a+b-1)//b def count(x): result = 0 for c in cnt.itervalues(): if c%x > c//x: return INF result += ceil_divide(c, x+1) return result cnt = collections.Counter(nums) for i in reversed(xrange(1, min(cnt.itervalues())+1)): c = count(i) if c != INF: return c return 0 ", "class Solution def maxProfitAssignment(self, difficulty, profit, worker): jobs = zip(difficulty, profit) jobs.sort() worker.sort() result, i, max_profit = 0, 0, 0 for ability in worker: while i < len(jobs) and jobs[i][0] <= ability: max_profit = max(max_profit, jobs[i][1]) i += 1 result += max_profit return result ", "class Solution def minAbsoluteSumDiff(self, nums1, nums2): MOD = 10**9+7 sorted_nums1 = sorted(nums1) result = max_change = 0 for i in xrange(len(nums2)): diff = abs(nums1[i]-nums2[i]) result = (result+diff)%MOD if diff < max_change: continue j = bisect.bisect_left(sorted_nums1, nums2[i]) if j != len(sorted_nums1): max_change = max(max_change, diff-abs(sorted_nums1[j]-nums2[i])) if j != 0: max_change = max(max_change, diff-abs(sorted_nums1[j-1]-nums2[i])) return (result-max_change)%MOD ", "class Solution def simplifyPath(self, path): stack, tokens = [], path.split(\"/\") for token in tokens: if token == \"..\" and stack: stack.pop() elif token != \"..\" and token != \".\" and token: stack.append(token) return \"/\" + \"/\".join(stack) ", "class Solution def numOfStrings(self, patterns, word): trie = AhoTrie(patterns) return sum(len(trie.step(c)) for c in word) ", "class Solution def numOfStrings(self, patterns, word): def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j != -1 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix def kmp(text, pattern): if not pattern: return 0 prefix = getPrefix(pattern) if len(text) < len(pattern): return -1 j = -1 for i in xrange(len(text)): while j != -1 and pattern[j+1] != text[i]: j = prefix[j] if pattern[j+1] == text[i]: j += 1 if j+1 == len(pattern): return i-j return -1 return sum(kmp(word, pattern) != -1 for pattern in patterns) ", "class Solution def numOfStrings(self, patterns, word): return sum(pattern in word for pattern in patterns) ", "class Solution def splitCircularLinkedList(self, list): head1 = list slow, fast = head1, head1.next while head1 != fast.next: slow = slow.next fast = fast.next.next if head1 != fast.next.next else fast.next head2 = slow.next slow.next, fast.next = head1, head2 return [head1, head2] ", "class Solution def findMedianSortedArrays(self, nums1, nums2): len1, len2 = len(nums1), len(nums2) if (len1 + len2) % 2 == 1: return self.getKth(nums1, nums2, (len1 + len2)/2 + 1) else: return (self.getKth(nums1, nums2, (len1 + len2)/2) + self.getKth(nums1, nums2, (len1 + len2)/2 + 1)) * 0.5 def getKth(self, A, B, k): m, n = len(A), len(B) if m > n: m, n = n, m A, B = B, A left, right = 0, m - 1 while left <= right: mid = left + (right - left) / 2 if 0 <= k - 1 - mid < n and A[mid] >= B[k - 1 - mid]: right = mid - 1 else: left = mid + 1 Ai_minus_1 = A[left - 1] if left - 1 >= 0 else float(\"-inf\") Bj = B[k - 1 - left] if k - 1 - left >= 0 else float(\"-inf\") return max(Ai_minus_1, Bj) class Solution_Generic(object): def findMedianSortedArrays(self, nums1, nums2): array = [nums1, nums2] total = sum(len(nums) for nums in array) if total % 2 == 1: return self.getKth(array, total//2 + 1) else: return (self.getKth(array, total//2) + self.getKth(array, total//2 + 1)) * 0.5 def getKth(self, arrays, k): def binary_search(array, left, right, target, check): while left <= right: mid = left + (right-left)//2 if check(array, mid, target): right = mid-1 else: left = mid+1 return left def check(arrays, num, target): res = 0 for array in arrays: if array: res += binary_search(array, 0, len(array) - 1, num, lambda array, x, y: array[x] > y) return res >= target left, right = float(\"inf\"), float(\"-inf\") for array in arrays: if array: left = min(left, array[0]) right = max(right, array[-1]) return binary_search(arrays, left, right, k, check) class Solution_3(object): def findMedianSortedArrays(self, A, B): if A is None and B is None: return -1.0 lenA = len(A) lenB = len(B) lenn = lenA + lenB indexA,indexB,indexC = 0,0,0 C = [False for i in xrange(lenn)] while indexA < lenA and indexB < lenB: if A[indexA] < B[indexB]: C[indexC] = A[indexA] indexC += 1 indexA += 1 else: C[indexC] = B[indexB] indexC += 1 indexB += 1 while indexA < lenA: C[indexC] = A[indexA] indexC += 1 indexA += 1 while indexB < lenB: C[indexC] = B[indexB] indexC += 1 indexB += 1 indexM1 = (lenn - 1) / 2 indexM2 = lenn / 2 if (lenn % 2 == 0): return (C[indexM1] + C[indexM2]) / 2.0 else: return C[indexM2] / 1.0 ", "class Solution def maximalRectangle(self, matrix): def largestRectangleArea(heights): stk, result, i = [-1], 0, 0 for i in xrange(len(heights)+1): while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]): result = max(result, heights[stk.pop()]*((i-1)-stk[-1])) stk.append(i) return result if not matrix: return 0 result = 0 heights = [0]*len(matrix[0]) for i in xrange(len(matrix)): for j in xrange(len(matrix[0])): heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0 result = max(result, largestRectangleArea(heights)) return result ", "class Solution def maximalRectangle(self, matrix): if not matrix: return 0 result = 0 m = len(matrix) n = len(matrix[0]) L = [0 for _ in xrange(n)] H = [0 for _ in xrange(n)] R = [n for _ in xrange(n)] for i in xrange(m): left = 0 for j in xrange(n): if matrix[i][j] == '1': L[j] = max(L[j], left) H[j] += 1 else: L[j] = 0 H[j] = 0 R[j] = n left = j + 1 right = n for j in reversed(xrange(n)): if matrix[i][j] == '1': R[j] = min(R[j], right) result = max(result, H[j] * (R[j] - L[j])) else: right = j return result ", "class Solution def solveEquation(self, equation): a, b, side = 0, 0, 1 for eq, sign, num, isx in re.findall('(=)|([-+]?)(\\d*)(x?)', equation): if eq: side = -1 elif isx: a += side * int(sign + '1') * int(num or 1) elif num: b -= side * int(sign + num) return 'x=%d' % (b / a) if a else 'No solution' if b else 'Infinite solutions' ", "class Solution def bestRotation(self, A): N = len(A) change = [1] * N for i in xrange(N): change[(i-A[i]+1)%N] -= 1 for i in xrange(1, N): change[i] += change[i-1] return change.index(max(change)) ", "class Solution def equalDigitFrequency(self, s): MOD = 10**9+7 D = 27 lookup = set() for i in xrange(len(s)): cnt = collections.Counter() h = max_cnt = 0 for j in xrange(i, len(s)): d = ord(s[j])-ord('0')+1 h = (h*D+d)%MOD cnt[d] += 1 max_cnt = max(max_cnt, cnt[d]) if len(cnt)*max_cnt == j-i+1: lookup.add(h) return len(lookup) ", "class Solution def maximizeSquareArea(self, m, n, hFences, vFences): MOD = 10**9+7 def diff(arr, x): arr.append(1) arr.append(x) return {abs(arr[i]-arr[j]) for i in xrange(len(arr)) for j in xrange(i+1, len(arr))} lookup = diff(hFences, m) result = -1 for x in diff(vFences, n): if x in lookup: result = max(result, x**2) return result%MOD if result != -1 else -1 ", "class Solution def maximizeSquareArea(self, m, n, hFences, vFences): MOD = 10**9+7 def diff(arr, x, check): arr.append(1) arr.append(x) for i in xrange(len(arr)): for j in xrange(i+1, len(arr)): if not check: lookup.add(abs(arr[i]-arr[j])) continue if abs(arr[i]-arr[j]) in lookup: result[0] = max(result[0], (arr[i]-arr[j])**2) if len(hFences) > len(vFences): hFences, vFences = vFences, hFences m, n = n, m result = [-1] lookup = set() diff(hFences, m, False) diff(vFences, n, True) return result[0]%MOD if result[0] != -1 else -1 ", "class Solution def productQueries(self, n, queries): MOD = 10**9+7 prefix = [0] i = 0 while (1<<i) <= n: if n&(1<<i): prefix.append(prefix[-1]+i) i += 1 return [pow(2, prefix[r+1]-prefix[l], MOD) for l, r in queries] ", "class Solution def movesToStamp(self, stamp, target): M, N = len(stamp), len(target) q = collections.deque() lookup = [False]*N result = [] A = [] for i in xrange(N-M+1): made, todo = set(), set() for j, c in enumerate(stamp): if c == target[i+j]: made.add(i+j) else: todo.add(i+j) A.append((made, todo)) if todo: continue result.append(i) for m in made: if lookup[m]: continue q.append(m) lookup[m] = True while q: i = q.popleft() for j in xrange(max(0, i-M+1), min(N-M, i)+1): made, todo = A[j] if i not in todo: continue todo.discard(i) if todo: continue result.append(j) for m in made: if lookup[m]: continue q.append(m) lookup[m] = True return result[::-1] if all(lookup) else [] ", "class Solution def maxStrength(self, nums): if all(x <= 0 for x in nums) and sum(x < 0 for x in nums) <= 1: return max(nums) result = reduce(lambda x, y: x*y, (x for x in nums if x)) return result if result > 0 else result//max(x for x in nums if x < 0) ", "class Solution def minOperations(self, nums): def ceil_divide(a, b): return (a+b-1)//b cnt = collections.Counter(nums) return sum(ceil_divide(x, 3) for x in cnt.itervalues()) if all(x >= 2 for x in cnt.itervalues()) else -1 ", "class Solution def subdomainVisits(self, cpdomains): result = collections.defaultdict(int) for domain in cpdomains: count, domain = domain.split() count = int(count) frags = domain.split('.') curr = [] for i in reversed(xrange(len(frags))): curr.append(frags[i]) result[\".\".join(reversed(curr))] += count return [\"{} {}\".format(count, domain) for domain, count in result.iteritems()] ", "class Solution def topStudents(self, positive_feedback, negative_feedback, report, student_id, k): def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 pos, neg = set(positive_feedback), set(negative_feedback) arr = [] for i, r in itertools.izip(student_id, report): score = sum(3 if w in pos else -1 if w in neg else 0 for w in r.split()) arr.append((-score, i)) nth_element(arr, k-1) return [i for _, i in sorted(arr[:k])] ", "class Solution def wiggleMaxLength(self, nums): if len(nums) < 2: return len(nums) length, up = 1, None for i in xrange(1, len(nums)): if nums[i - 1] < nums[i] and (up is None or up is False): length += 1 up = True elif nums[i - 1] > nums[i] and (up is None or up is True): length += 1 up = False return length ", "class Solution def timeTaken(self, arrival, state): def go_until(t): while curr[0] <= t and any(q): if not q[direction[0]]: direction[0] ^= 1 result[q[direction[0]].popleft()] = curr[0] curr[0] += 1 UNKNOWN, ENTERING, EXITING = range(-1, 1+1) result = [0]*len(arrival) curr, direction = [float(\"-inf\")], [UNKNOWN] q = [collections.deque(), collections.deque()] for i, (a, s) in enumerate(itertools.izip(arrival, state)): go_until(a-1) q[s].append(i) if not (a <= curr[0]): curr, direction = [a], [EXITING] go_until(float(\"inf\")) return result ", "class Solution def minPartitions(self, n): return int(max(n)) ", "class Solution def tilingRectangle(self, n, m): def find_next(board): for i in xrange(len(board)): for j in xrange(len(board[0])): if not board[i][j]: return i, j return -1, -1 def find_max_length(board, i, j): max_length = 1 while i+max_length-1 < len(board) and j+max_length-1 < len(board[0]): for r in xrange(i, i+max_length-1): if board[r][j+max_length-1]: return max_length-1 for c in xrange(j, j+max_length): if board[i+max_length-1][c]: return max_length-1 max_length += 1 return max_length-1 def fill(board, i, j, length, val): for r in xrange(i, i+length): for c in xrange(j, j+length): board[r][c] = val def backtracking(board, count, result): if count >= result[0]: return i, j = find_next(board) if (i, j) == (-1, -1): result[0] = min(result[0], count) return max_length = find_max_length(board, i, j) for k in reversed(xrange(1, max_length+1)): fill(board, i, j, k, 1) backtracking(board, count+1, result) fill(board, i, j, k, 0) if m > n: return self.tilingRectangle(m, n) board = [[0]*m for _ in xrange(n)] result = [float(\"inf\")] backtracking(board, 0, result) return result[0] ", "class Solution def getProbability(self, balls): def nCrs(n): c = 1 for k in xrange(n+1): yield c c *= n-(k+1)+1 c //= k+1 def nCr(n, r): if n-r < r: return nCr(n, n-r) c = 1 for k in xrange(1, r+1): c *= n-k+1 c //= k return c dp = collections.defaultdict(int) dp[0, 0] = 1 for n in balls: new_dp = collections.defaultdict(int) for (ndiff, cdiff), count in dp.iteritems(): for k, new_count in enumerate(nCrs(n)): new_ndiff = ndiff+(k-(n-k)) new_cdiff = cdiff-1 if k == 0 else (cdiff+1 if k == n else cdiff) new_dp[new_ndiff, new_cdiff] += count*new_count dp = new_dp total = sum(balls) return float(dp[0, 0])/nCr(total, total//2) ", "class Solution def minTimeToType(self, word): return (min((ord(word[0])-ord('a'))%26, (ord('a')-ord(word[0]))%26)+1) + sum(min((ord(word[i])-ord(word[i-1]))%26, (ord(word[i-1])-ord(word[i]))%26)+1 for i in xrange(1, len(word))) ", "class Solution def shortestDistance(self, maze, start, destination): start, destination = tuple(start), tuple(destination) def neighbors(maze, node): for dir in [(-1, 0), (0, 1), (0, -1), (1, 0)]: cur_node, dist = list(node), 0 while 0 <= cur_node[0]+dir[0] < len(maze) and 0 <= cur_node[1]+dir[1] < len(maze[0]) and not maze[cur_node[0]+dir[0]][cur_node[1]+dir[1]]: cur_node[0] += dir[0] cur_node[1] += dir[1] dist += 1 yield dist, tuple(cur_node) heap = [(0, start)] visited = set() while heap: dist, node = heapq.heappop(heap) if node in visited: continue if node == destination: return dist visited.add(node) for neighbor_dist, neighbor in neighbors(maze, node): heapq.heappush(heap, (dist+neighbor_dist, neighbor)) return -1 ", "class Solution def minimumObstacles(self, grid): directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] def a_star(grid, b, t): f, dh = 0, 1 closer, detour = [b], [] lookup = set() while closer or detour: if not closer: f += dh closer, detour = detour, closer b = closer.pop() if b in lookup: continue lookup.add(b) if b == t: return f for dr, dc in directions: nb = (b[0]+dr, b[1]+dc) if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and nb not in lookup): continue (closer if not grid[b[0]][b[1]] else detour).append(nb) return -1 return a_star(grid, (0, 0), (len(grid)-1, len(grid[0])-1)) import collections ", "class Solution def minimumObstacles(self, grid): directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] b, t = (0, 0), (len(grid)-1, len(grid[0])-1) dq = collections.deque([(b, 0)]) lookup = set() while dq: b, d = dq.popleft() if b in lookup: continue lookup.add(b) if b == t: return d for dr, dc in directions: nb = (b[0]+dr, b[1]+dc) if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and nb not in lookup): continue if not grid[b[0]][b[1]]: dq.appendleft((nb, d)) else: dq.append((nb, d+1)) return -1 ", "class Solution def maxPartitionsAfterOperations(self, s, k): def popcount(n): n = (n & 0x55555555) + ((n >> 1) & 0x55555555) n = (n & 0x33333333) + ((n >> 2) & 0x33333333) n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F) n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF) n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF) return n left = [0]*(len(s)+1) left_mask = [0]*(len(s)+1) cnt = mask = 0 for i in xrange(len(s)): mask |= 1<<(ord(s[i])-ord('a')) if popcount(mask) > k: cnt += 1 mask = 1<<(ord(s[i])-ord('a')) left[i+1] = cnt left_mask[i+1] = mask right = [0]*(len(s)+1) right_mask = [0]*(len(s)+1) cnt = mask = 0 for i in reversed(xrange(len(s))): mask |= 1<<(ord(s[i])-ord('a')) if popcount(mask) > k: cnt += 1 mask = 1<<(ord(s[i])-ord('a')) right[i] = cnt right_mask[i] = mask result = 0 for i in xrange(len(s)): curr = left[i]+right[i+1] mask = left_mask[i]|right_mask[i+1] if popcount(left_mask[i]) == popcount(right_mask[i+1]) == k and popcount(mask) != 26: curr += 3 elif popcount(mask)+int(popcount(mask) != 26) > k: curr += 2 else: curr += 1 result = max(result, curr) return result ", "class Solution def maximumGroups(self, grades): return int(((1+8*len(grades))**0.5-1)/2.0) ", "class Solution def maxSubArray(self, nums): result, curr = float(\"-inf\"), float(\"-inf\") for x in nums: curr = max(curr+x, x) result = max(result, curr) return result ", "class Solution def numOfBurgers(self, tomatoSlices, cheeseSlices): return [tomatoSlices//2-cheeseSlices, 2*cheeseSlices - tomatoSlices//2] if tomatoSlices%2 == 0 and 2*cheeseSlices <= tomatoSlices <= 4*cheeseSlices else [] ", "class Solution def numberOfSubstrings(self, s): result, left = 0, [-1]*3 for right, c in enumerate(s): left[ord(c)-ord('a')] = right result += min(left)+1 return result ", "class Solution def numberOfSubstrings(self, s): result, left, count = 0, 0, [0]*3 for right, c in enumerate(s): count[ord(s[right])-ord('a')] += 1 while all(count): count[ord(s[left])-ord('a')] -= 1 left += 1 result += left return result ", "class Solution def numberOfSubstrings(self, s): result, right, count = 0, 0, [0]*3 for left, c in enumerate(s): while right < len(s) and not all(count): count[ord(s[right])-ord('a')] += 1 right += 1 if all(count): result += (len(s)-1) - (right-1) + 1 count[ord(c)-ord('a')] -= 1 return result ", "class Solution def maxOperations(self, nums): def memoization(left, right, target, lookup): if not right-left+1 >= 2: return 0 if lookup[left][right] == -1: lookup[left][right] = max(1+memoization(left+2, right-0, target, lookup) if nums[left]+nums[left+1] == target else 0, 1+memoization(left+1, right-1, target, lookup) if nums[left]+nums[right] == target else 0, 1+memoization(left+0, right-2, target, lookup) if nums[right-1]+nums[right] == target else 0) return lookup[left][right] return max(memoization(0, len(nums)-1, target, [[-1]*(len(nums)) for _ in xrange(len(nums))]) for target in {nums[0]+nums[1], nums[0]+nums[-1], nums[-2]+nums[-1]}) ", "class Solution def shortestDistance(self, grid): def bfs(grid, dists, cnts, x, y): dist, m, n = 0, len(grid), len(grid[0]) visited = [[False for _ in xrange(n)] for _ in xrange(m)] pre_level = [(x, y)] visited[x][y] = True while pre_level: dist += 1 cur_level = [] for i, j in pre_level: for dir in [(-1, 0), (1, 0), (0, -1), (0, 1)]: I, J = i+dir[0], j+dir[1] if 0 <= I < m and 0 <= J < n and grid[I][J] == 0 and not visited[I][J]: cnts[I][J] += 1 dists[I][J] += dist cur_level.append((I, J)) visited[I][J] = True pre_level = cur_level m, n, cnt = len(grid), len(grid[0]), 0 dists = [[0 for _ in xrange(n)] for _ in xrange(m)] cnts = [[0 for _ in xrange(n)] for _ in xrange(m)] for i in xrange(m): for j in xrange(n): if grid[i][j] == 1: cnt += 1 bfs(grid, dists, cnts, i, j) shortest = float(\"inf\") for i in xrange(m): for j in xrange(n): if dists[i][j] < shortest and cnts[i][j] == cnt: shortest = dists[i][j] return shortest if shortest != float(\"inf\") else -1 ", "class Solution def minSessions(self, tasks, sessionTime): dp = [float(\"inf\") for _ in xrange(1<<len(tasks))] dp[0] = 0 for mask in xrange(len(dp)-1): basis = 1 for task in tasks: new_mask = mask|basis basis <<= 1 if new_mask == mask: continue if dp[mask]%sessionTime + task > sessionTime: task += sessionTime-dp[mask]%sessionTime dp[new_mask] = min(dp[new_mask], dp[mask]+task) return (dp[-1]+sessionTime-1)//sessionTime ", "class Solution def minSessions(self, tasks, sessionTime): dp = [[float(\"inf\")]*2 for _ in xrange(1<<len(tasks))] dp[0] = [0, sessionTime] for mask in xrange(len(dp)-1): basis = 1 for task in tasks: new_mask = mask|basis basis <<= 1 if new_mask == mask: continue if dp[mask][1]+task <= sessionTime: dp[new_mask] = min(dp[new_mask], [dp[mask][0], dp[mask][1]+task]) else: dp[new_mask] = min(dp[new_mask], [dp[mask][0]+1, task]) return dp[-1][0] ", "class Solution def mergeNodes(self, head): curr, zero = head.next, head while curr: if curr.val: zero.val += curr.val else: zero.next = curr if curr.next else None zero = curr curr = curr.next return head ", "class Solution def minimumJumps(self, forbidden, a, b, x): max_f = max(forbidden) max_val = x+b if a >= b else max(x, max_f)+a+(b+a) lookup = set() for pos in forbidden: lookup.add((pos, True)) lookup.add((pos, False)) result = 0 q = [(0, True)] lookup.add((0, True)) while q: new_q = [] for pos, can_back in q: if pos == x: return result if pos+a <= max_val and (pos+a, True) not in lookup: lookup.add((pos+a, True)) new_q.append((pos+a, True)) if not can_back: continue if pos-b >= 0 and (pos-b, False) not in lookup: lookup.add((pos-b, False)) new_q.append((pos-b, False)) q = new_q result += 1 return -1 ", "class Solution def isMatch(self, s, p): k = 3 result = [[False for j in xrange(len(p) + 1)] for i in xrange(k)] result[0][0] = True for i in xrange(2, len(p) + 1): if p[i-1] == '*': result[0][i] = result[0][i-2] for i in xrange(1,len(s) + 1): if i > 1: result[0][0] = False for j in xrange(1, len(p) + 1): if p[j-1] != '*': result[i % k][j] = result[(i-1) % k][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.') else: result[i % k][j] = result[i % k][j-2] or (result[(i-1) % k][j] and (s[i-1] == p[j-2] or p[j-2] == '.')) return result[len(s) % k][len(p)] ", "class Solution def isMatch(self, s, p): result = [[False for j in xrange(len(p) + 1)] for i in xrange(len(s) + 1)] result[0][0] = True for i in xrange(2, len(p) + 1): if p[i-1] == '*': result[0][i] = result[0][i-2] for i in xrange(1,len(s) + 1): for j in xrange(1, len(p) + 1): if p[j-1] != '*': result[i][j] = result[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.') else: result[i][j] = result[i][j-2] or (result[i-1][j] and (s[i-1] == p[j-2] or p[j-2] == '.')) return result[len(s)][len(p)] ", "class Solution def isMatch(self, s, p): p_ptr, s_ptr, last_s_ptr, last_p_ptr = 0, 0, -1, -1 last_ptr = [] while s_ptr < len(s): if p_ptr < len(p) and (p_ptr == len(p) - 1 or p[p_ptr + 1] != '*') and (s_ptr < len(s) and (p[p_ptr] == s[s_ptr] or p[p_ptr] == '.')): s_ptr += 1 p_ptr += 1 elif p_ptr < len(p) - 1 and (p_ptr != len(p) - 1 and p[p_ptr + 1] == '*'): p_ptr += 2 last_ptr.append([s_ptr, p_ptr]) elif last_ptr: [last_s_ptr, last_p_ptr] = last_ptr.pop() while last_ptr and p[last_p_ptr - 2] != s[last_s_ptr] and p[last_p_ptr - 2] != '.': [last_s_ptr, last_p_ptr] = last_ptr.pop() if p[last_p_ptr - 2] == s[last_s_ptr] or p[last_p_ptr - 2] == '.': last_s_ptr += 1 s_ptr = last_s_ptr p_ptr = last_p_ptr last_ptr.append([s_ptr, p_ptr]) else: return False else: return False while p_ptr < len(p) - 1 and p[p_ptr] == '.' and p[p_ptr + 1] == '*': p_ptr += 2 return p_ptr == len(p) ", "class Solution def isMatch(self, s, p): if not p: return not s if len(p) == 1 or p[1] != '*': if len(s) > 0 and (p[0] == s[0] or p[0] == '.'): return self.isMatch(s[1:], p[1:]) else: return False else: while len(s) > 0 and (p[0] == s[0] or p[0] == '.'): if self.isMatch(s, p[2:]): return True s = s[1:] return self.isMatch(s, p[2:]) ", "class Solution def minProcessingTime(self, processorTime, tasks): K = 4 processorTime.sort() tasks.sort(reverse=True) result = 0 for i in xrange(len(processorTime)): for j in xrange(K): result = max(result, processorTime[i]+tasks[i*K+j]) return result ", "class Solution def __init__(self): def dayOfMonth(M): return (28 if (M == 2) else 31-(M-1)%7%2) self.__lookup = [0]*12 for M in xrange(1, len(self.__lookup)): self.__lookup[M] += self.__lookup[M-1]+dayOfMonth(M) def daysBetweenDates(self, date1, date2): def num_days(date): Y, M, D = map(int, date.split(\"-\")) leap = 1 if M > 2 and (((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0)) else 0 return (Y-1)*365 + ((Y-1)//4 - (Y-1)//100 + (Y-1)//400) + self.__lookup[M-1]+D+leap return abs(num_days(date1) - num_days(date2)) import datetime ", "class Solution def daysBetweenDates(self, date1, date2): delta = datetime.datetime.strptime(date1, \"%Y-%m-%d\") delta -= datetime.datetime.strptime(date2, \"%Y-%m-%d\") return abs(delta.days) ", "class Solution def separateDigits(self, nums): result = [] for x in reversed(nums): while x: result.append(x%10) x //= 10 result.reverse() return result ", "class Solution def separateDigits(self, nums): return [int(c) for x in nums for c in str(x)] ", "class Solution def numRollsToTarget(self, d, f, target): MOD = 10**9+7 dp = [[0 for _ in xrange(target+1)] for _ in xrange(2)] dp[0][0] = 1 for i in xrange(1, d+1): dp[i%2] = [0 for _ in xrange(target+1)] for k in xrange(1, f+1): for j in xrange(k, target+1): dp[i%2][j] = (dp[i%2][j] + dp[(i-1)%2][j-k]) % MOD return dp[d%2][target] % MOD ", "class Solution def removeOnes(self, grid): rows = [0]*len(grid) mask, bit = 0, 1 for _ in xrange(len(grid[0])): mask += bit bit <<= 1 for i in xrange(len(grid)): rows[i] = mask mask <<= len(grid[0]) cols = [0]*len(grid[0]) mask, bit = 0, 1 for _ in xrange(len(grid)): mask += bit bit <<= len(grid[0]) for j in xrange(len(grid[0])): cols[j] = mask mask <<= 1 full_mask = (1<<(len(grid)*len(grid[0])))-1 masks = [[full_mask for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))] target, bit = 0, 1 for i in xrange(len(grid)): for j in xrange(len(grid[0])): target += bit*grid[i][j] masks[i][j] -= (rows[i]+cols[j]-bit) bit <<= 1 dp = [float(\"inf\") for _ in xrange(target+1)] dp[0] = 0 for mask in xrange(1, target+1): for i in xrange(len(grid)): for j in xrange(len(grid[0])): if grid[i][j]: dp[mask] = min(dp[mask], dp[mask&masks[i][j]]+1) return dp[target] ", "class Solution def percentageLetter(self, s, letter): return 100*s.count(letter)//len(s) ", "class Solution def minimumSeconds(self, land): DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1)) lookup = [[-1 if land[i][j] == \"*\" else 0 for j in xrange(len(land[0]))] for i in xrange(len(land))] q = [(i, j, -1) for i in xrange(len(land)) for j in xrange(len(land[0])) if land[i][j] == \"*\"] q.append(next((i, j, 1) for i in xrange(len(land)) for j in xrange(len(land[0])) if land[i][j] == \"S\")) lookup[q[-1][0]][q[-1][1]] = 1 while q: new_q = [] for i, j, d in q: if land[i][j] == \"D\": return d-1 for di, dj in DIRECTIONS: ni, nj = i+di, j+dj if not (0 <= ni < len(land) and 0 <= nj < len(land[0]) and land[ni][nj] != \"X\" and lookup[ni][nj] != -1): continue if d != -1 and lookup[ni][nj] == 0: lookup[ni][nj] = 1 new_q.append((ni, nj, d+1)) elif d == -1 and land[ni][nj] != \"D\": lookup[ni][nj] = -1 new_q.append((ni, nj, -1)) q = new_q return -1 ", "class Solution def minimumSeconds(self, land): DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1)) lookup1 = [[0 if land[i][j] == \"*\" else -1 for j in xrange(len(land[0]))] for i in xrange(len(land))] lookup2 = [[-1]*len(land[0]) for _ in xrange(len(land))] q1 = [(i, j) for i in xrange(len(land)) for j in xrange(len(land[0])) if land[i][j] == \"*\"] q2 = [next((i, j) for i in xrange(len(land)) for j in xrange(len(land[0])) if land[i][j] == \"S\")] lookup2[q2[0][0]][q2[0][1]] = 0 while q1 or q2: new_q1, new_q2 = [], [] for i, j in q1: for di, dj in DIRECTIONS: ni, nj = i+di, j+dj if not (0 <= ni < len(land) and 0 <= nj < len(land[0]) and land[ni][nj] != \"X\" and land[ni][nj] != \"D\" and lookup1[ni][nj] == -1): continue lookup1[ni][nj] = 0 new_q1.append((ni, nj)) for i, j in q2: if land[i][j] == \"D\": return lookup2[i][j] for di, dj in DIRECTIONS: ni, nj = i+di, j+dj if not (0 <= ni < len(land) and 0 <= nj < len(land[0]) and land[ni][nj] != \"X\" and lookup2[ni][nj] == lookup1[ni][nj] == -1): continue lookup2[ni][nj] = lookup2[i][j]+1 new_q2.append((ni, nj)) q1, q2 = new_q1, new_q2 return -1 ", "class Solution def sumOfFlooredPairs(self, nums): MOD = 10**9+7 prefix, counter = [0]*(max(nums)+1), collections.Counter(nums) for num, cnt in counter.iteritems(): for j in xrange(num, len(prefix), num): prefix[j] += counter[num] for i in xrange(len(prefix)-1): prefix[i+1] += prefix[i] return reduce(lambda total, num: (total+prefix[num])%MOD, nums, 0) ", "class Solution def numOfWays(self, nums): def iter_dfs(nums): result = [0] stk = [[1, [nums, result]]] while stk: step, params = stk.pop() if step == 1: nums, ret = params if len(nums) <= 2: ret[0] = 1 continue left = [v for v in nums if v < nums[0]] right = [v for v in nums if v > nums[0]] ret[0] = dp[len(left)+len(right)][len(left)] ret1, ret2 = [0], [0] stk.append([2, [ret1, ret2, ret]]) stk.append([1, [right, ret2]]) stk.append([1, [left, ret1]]) elif step == 2: ret1, ret2, ret = params ret[0] = ret[0]*ret1[0] % MOD ret[0] = ret[0]*ret2[0] % MOD return result[0] return (iter_dfs(nums)-1)%MOD ", "class Solution def numOfWays(self, nums): def dfs(nums): if len(nums) <= 2: return 1 left = [v for v in nums if v < nums[0]] right = [v for v in nums if v > nums[0]] result = dp[len(left)+len(right)][len(left)] result = result*dfs(left) % MOD result = result*dfs(right) % MOD return result return (dfs(nums)-1)%MOD ", "class Solution def shoppingOffers(self, price, special, needs): def shoppingOffersHelper(price, special, needs, i): if i == len(special): return sum(map(lambda x, y: x*y, price, needs)) result = shoppingOffersHelper(price, special, needs, i+1) for j in xrange(len(needs)): needs[j] -= special[i][j] if all(need >= 0 for need in needs): result = min(result, special[i][-1] + shoppingOffersHelper(price, special, needs, i)) for j in xrange(len(needs)): needs[j] += special[i][j] return result return shoppingOffersHelper(price, special, needs, 0) ", "class Solution def minimumOperations(self, nums): k = 3 dp = [0]*k for x in nums: dp[x-1] += 1 for i in xrange(x, len(dp)): dp[i] = max(dp[i], dp[i-1]) return len(nums)-dp[-1] ", "class Solution def minNumberOperations(self, target): return target[0]+sum(max(target[i]-target[i-1], 0) for i in xrange(1, len(target))) import itertools ", "class Solution def minNumberOperations(self, target): return sum(max(b-a, 0) for b, a in itertools.izip(target, [0]+target)) ", "class Solution def minimumTotalPrice(self, n, edges, price, trips): def iter_dfs(u, target): stk = [(1, (u, -1))] while stk: step, args = stk.pop() if step == 1: u, p = args lookup[u] += 1 if u == target: return stk.append((2, (u,))) for v in reversed(adj[u]): if v == p: continue stk.append((1, (v, u))) elif step == 2: u = args[0] lookup[u] -= 1 lookup[u] += 1 if u == target: return True for v in adj[u]: if v == p: continue if dfs(v, u, target): return True lookup[u] -= 1 return False def iter_dfs2(): result = [price[0]*lookup[0], (price[0]//2)*lookup[0]] stk = [(1, (0, -1, result))] while stk: step, args = stk.pop() if step == 1: u, p, ret = args for v in reversed(adj[u]): if v == p: continue new_ret = [price[v]*lookup[v], (price[v]//2)*lookup[v]] stk.append((2, (new_ret, ret))) stk.append((1, (v, u, new_ret))) elif step == 2: new_ret, ret = args ret[0] += min(new_ret) ret[1] += new_ret[0] return min(result) adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) lookup = [0]*n for u, v in trips: iter_dfs(u, v) return iter_dfs2() ", "class Solution def minimumTotalPrice(self, n, edges, price, trips): def dfs(u, p, target): lookup[u] += 1 if u == target: return True for v in adj[u]: if v == p: continue if dfs(v, u, target): return True lookup[u] -= 1 return False def dfs2(u, p): full, half = price[u]*lookup[u], price[u]//2*lookup[u] for v in adj[u]: if v == p: continue f, h = dfs2(v, u) full += min(f, h) half += f return full, half adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) lookup = [0]*n for u, v in trips: dfs(u, -1, v) return min(dfs2(0, -1)) ", "class Solution def findRestaurant(self, list1, list2): lookup = {} for i, s in enumerate(list1): lookup[s] = i result = [] min_sum = float(\"inf\") for j, s in enumerate(list2): if j > min_sum: break if s in lookup: if j + lookup[s] < min_sum: result = [s] min_sum = j + lookup[s] elif j + lookup[s] == min_sum: result.append(s) return result ", "class Solution def wordBreak(self, s, wordDict): n = len(s) max_len = 0 for string in wordDict: max_len = max(max_len, len(string)) can_break = [False for _ in xrange(n + 1)] valid = [[False] * n for _ in xrange(n)] can_break[0] = True for i in xrange(1, n + 1): for l in xrange(1, min(i, max_len) + 1): if can_break[i-l] and s[i-l:i] in wordDict: valid[i-l][i-1] = True can_break[i] = True result = [] if can_break[-1]: self.wordBreakHelper(s, valid, 0, [], result) return result def wordBreakHelper(self, s, valid, start, path, result): if start == len(s): result.append(\" \".join(path)) return for i in xrange(start, len(s)): if valid[start][i]: path += [s[start:i+1]] self.wordBreakHelper(s, valid, i + 1, path, result) path.pop() ", "class Solution def canTransform(self, start, end): if start.count('X') != end.count('X'): return False i, j = 0, 0 while i < len(start) and j < len(end): while i < len(start) and start[i] == 'X': i += 1 while j < len(end) and end[j] == 'X': j += 1 if (i < len(start)) != (j < len(end)): return False elif i < len(start) and j < len(end): if start[i] != end[j] or (start[i] == 'L' and i < j) or (start[i] == 'R' and i > j): return False i += 1 j += 1 return True ", "class Solution def getMaximumConsecutive(self, coins): coins.sort() result = 1 for c in coins: if c > result: break result += c return result ", "class Solution def closedIsland(self, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def fill(grid, i, j): if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 0): return False grid[i][j] = 1 for dx, dy in directions: fill(grid, i+dx, j+dy) return True for j in xrange(len(grid[0])): fill(grid, 0, j) fill(grid, len(grid)-1, j) for i in xrange(1, len(grid)): fill(grid, i, 0) fill(grid, i, len(grid[0])-1) result = 0 for i in xrange(1, len(grid)-1): for j in xrange(1, len(grid[0])-1): if fill(grid, i, j): result += 1 return result ", "class Solution def scoreOfStudents(self, s, answers): MAX_ANS = 1000 n = (len(s)+1)//2 dp = [[set() for _ in xrange(n)] for _ in xrange(n)] for i in xrange(n): dp[i][i].add(int(s[i*2])) for l in xrange(1, n): for left in xrange(n-l): right = left+l for k in xrange(left, right): if s[2*k+1] == '+': dp[left][right].update((x+y for x in dp[left][k] for y in dp[k+1][right] if x+y <= MAX_ANS)) else: dp[left][right].update((x*y for x in dp[left][k] for y in dp[k+1][right] if x*y <= MAX_ANS)) target = eval(s) return sum(5 if ans == target else 2 if ans in dp[0][-1] else 0 for ans in answers) ", "class Solution def scoreOfStudents(self, s, answers): MAX_ANS = 1000 def evaluate(s): def compute(operands, operators): right, left = operands.pop(), operands.pop() operands.append(ops[operators.pop()](left, right)) ops = {'+':operator.add, '*':operator.mul} precedence = {'+':0, '*':1} operands, operators, operand = [], [], 0 for c in s: if c.isdigit(): operands.append(int(c)) else: while operators and precedence[operators[-1]] >= precedence[c]: compute(operands, operators) operators.append(c) while operators: compute(operands, operators) return operands[-1] n = (len(s)+1)//2 dp = [[set() for _ in xrange(n)] for _ in xrange(n)] for i in xrange(n): dp[i][i].add(int(s[i*2])) for l in xrange(1, n): for left in xrange(n-l): right = left+l for k in xrange(left, right): if s[2*k+1] == '+': dp[left][right].update((x+y for x in dp[left][k] for y in dp[k+1][right] if x+y <= MAX_ANS)) else: dp[left][right].update((x*y for x in dp[left][k] for y in dp[k+1][right] if x*y <= MAX_ANS)) target = evaluate(s) return sum(5 if ans == target else 2 if ans in dp[0][-1] else 0 for ans in answers) ", "class Solution def minCost(self, maxTime, edges, passingFees): adj = [[] for i in xrange(len(passingFees))] for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) best = collections.defaultdict(lambda:float(\"inf\")) best[0] = 0 min_heap = [(passingFees[0], 0, 0)] while min_heap: result, u, w = heapq.heappop(min_heap) if w > maxTime: continue if u == len(passingFees)-1: return result for v, nw in adj[u]: if w+nw < best[v]: best[v] = w+nw heapq.heappush(min_heap, (result+passingFees[v], v, w+nw)) return -1 ", "class Solution def numSteps(self, s): result, carry = 0, 0 for i in reversed(xrange(1, len(s))): if int(s[i]) + carry == 1: carry = 1 result += 2 else: result += 1 return result+carry ", "class Solution def numberOfNodes(self, n, queries): def bfs(): result = 0 q = [(1, 0)] while q: new_q = [] for u, curr in q: curr ^= cnt[u]%2 result += curr for v in xrange(2*u, min(2*u+1, n)+1): q.append((v, curr)) q = new_q return result cnt = collections.Counter(queries) return bfs() import collections ", "class Solution def numberOfNodes(self, n, queries): def iter_dfs(): result = 0 stk = [(1, 0)] while stk: u, curr = stk.pop() curr ^= cnt[u]%2 result += curr for v in reversed(xrange(2*u, min(2*u+1, n)+1)): stk.append((v, curr)) return result cnt = collections.Counter(queries) return iter_dfs() import collections ", "class Solution def numberOfNodes(self, n, queries): def dfs(u, curr): curr ^= cnt[u]%2 return curr+sum(dfs(v, curr) for v in xrange(2*u, min(2*u+1, n)+1)) cnt = collections.Counter(queries) return dfs(1, 0) ", "class Solution def maximumInvitations(self, grid): adj = collections.defaultdict(list) for i in xrange(len(grid)): for j in xrange(len(grid[0])): if not grid[i][j]: continue adj[j].append(i) return len(bipartiteMatch(adj)[0]) ", "class Solution def maximumInvitations(self, grid): def augment(grid, u, lookup, match): for v in xrange(V): if not get_grid(u, v) or v in lookup: continue lookup.add(v) if v not in match or augment(grid, match[v], lookup, match): match[v] = u return True return False def hungarian(grid): match = {} for i in xrange(U): augment(grid, i, set(), match) return len(match) U, V = min(len(grid), len(grid[0])), max(len(grid), len(grid[0])) get_grid = (lambda x, y: grid[x][y]) if len(grid) < len(grid[0]) else (lambda x, y: grid[y][x]) return hungarian(grid) import collections ", "class Solution def maximumInvitations(self, grid): def augment(adj, u, lookup, match): for v in adj[u]: if v in lookup: continue lookup.add(v) if v not in match or augment(adj, match[v], lookup, match): match[v] = u return True return False def hungarian(adj): match = {} for i in adj.iterkeys(): augment(adj, i, set(), match) return len(match) adj = collections.defaultdict(list) for i in xrange(len(grid)): for j in xrange(len(grid[0])): if not grid[i][j]: continue if len(grid) < len(grid[0]): adj[i].append(j) else: adj[j].append(i) return hungarian(adj) ", "class Solution def splitArray(self, nums): if len(nums) < 7: return False accumulated_sum = [0] * len(nums) accumulated_sum[0] = nums[0] for i in xrange(1, len(nums)): accumulated_sum[i] = accumulated_sum[i-1] + nums[i] for j in xrange(3, len(nums)-3): lookup = set() for i in xrange(1, j-1): if accumulated_sum[i-1] == accumulated_sum[j-1] - accumulated_sum[i]: lookup.add(accumulated_sum[i-1]) for k in xrange(j+2, len(nums)-1): if accumulated_sum[-1] - accumulated_sum[k] == accumulated_sum[k-1] - accumulated_sum[j] and accumulated_sum[k - 1] - accumulated_sum[j] in lookup: return True return False ", "class Solution def minimumRemoval(self, beans): beans.sort() return sum(beans) - max(x*(len(beans)-i)for i, x in enumerate(beans)) ", "class Solution def reorderList(self, head): if head == None or head.next == None: return head fast, slow, prev = head, head, None while fast != None and fast.next != None: fast, slow, prev = fast.next.next, slow.next, slow current, prev.next, prev = slow, None, None while current != None: current.next, prev, current = prev, current, current.next l1, l2 = head, prev dummy = ListNode(0) current = dummy while l1 != None and l2 != None: current.next, current, l1 = l1, l1, l1.next current.next, current, l2 = l2, l2, l2.next return dummy.next ", "class Solution def smallestNumber(self, n): result = [] for d in reversed(xrange(2, 9+1)): while n%d == 0: result.append(d) n //= d return \"\".join(map(str, reversed(result))) or \"1\" if n == 1 else \"-1\" ", "class Solution def robotSim(self, commands, obstacles): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] x, y, i = 0, 0, 0 lookup = set(map(tuple, obstacles)) result = 0 for cmd in commands: if cmd == -2: i = (i-1) % 4 elif cmd == -1: i = (i+1) % 4 else: for k in xrange(cmd): if (x+directions[i][0], y+directions[i][1]) not in lookup: x += directions[i][0] y += directions[i][1] result = max(result, x*x + y*y) return result ", "class Solution def maxPoints(self, points): dp = points[0] for i in xrange(1, len(points)): prefix = [0]*len(points[i]) prefix[0] = dp[0] for j in xrange(1, len(points[i])): prefix[j] = max(prefix[j-1], dp[j]+j) suffix = [0]*len(points[i]) suffix[-1] = dp[-1]-(len(points[i])-1) for j in reversed(xrange(len(points[i])-1)): suffix[j] = max(suffix[j+1], dp[j]-j) new_dp = [0]*len(points[i]) for j in xrange(len(points[i])): new_dp[j] = max(prefix[j]-j, suffix[j]+j)+points[i][j] dp = new_dp return max(dp) ", "class Solution def minEdgeReversals(self, n, edges): def iter_dfs1(): result = 0 stk = [(0, -1)] while stk: u, p = stk.pop() for v in adj[u].iterkeys(): if v == p: continue result += adj[u][v] stk.append((v, u)) return result def iter_dfs2(curr): result = [-1]*n stk = [(0, curr)] while stk: u, curr = stk.pop() result[u] = curr for v in adj[u].iterkeys(): if result[v] == -1: stk.append((v, curr-adj[u][v]+adj[v][u])) return result adj = collections.defaultdict(dict) for u, v in edges: adj[u][v] = 0 adj[v][u] = 1 return iter_dfs2(iter_dfs1()) ", "class Solution def minEdgeReversals(self, n, edges): def dfs1(u, p): return sum(adj[u][v]+dfs1(v, u) for v in adj[u] if v != p) def dfs2(u, curr): result[u] = curr for v in adj[u]: if result[v] == -1: dfs2(v, curr-adj[u][v]+adj[v][u]) adj = collections.defaultdict(dict) for u, v in edges: adj[u][v] = 0 adj[v][u] = 1 result = [-1]*n dfs2(0, dfs1(0, -1)) return result ", "class Solution def shortestPath(self, grid, k): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dot(a, b): return a[0]*b[0]+a[1]*b[1] def g(a, b): return abs(a[0]-b[0])+abs(a[1]-b[1]) def a_star(grid, b, t, k): f, dh = g(b, t), 2 closer, detour = [(b, k)], [] lookup = {} while closer or detour: if not closer: f += dh closer, detour = detour, closer b, k = closer.pop() if b == t: return f if b in lookup and lookup[b] >= k: continue lookup[b] = k for dx, dy in directions: nb = (b[0]+dx, b[1]+dy) if not (0 <= nb[0] < len(grid) and 0 <= nb[1] < len(grid[0]) and (grid[nb[0]][nb[1]] == 0 or k > 0) and (nb not in lookup or lookup[nb] < k)): continue (closer if dot((dx, dy), (t[0]-b[0], t[1]-b[1])) > 0 else detour).append((nb, k-int(grid[nb[0]][nb[1]] == 1))) return -1 return a_star(grid, (0, 0), (len(grid)-1, len(grid[0])-1), k) ", "class Solution def winnerSquareGame(self, n): dp = [False]*(n+1) for i in xrange(1, n+1): j = 1 while j*j <= i: if not dp[i-j*j]: dp[i] = True break j += 1 return dp[-1] ", "class Solution def nextGreaterElements(self, nums): result, stk = [0] * len(nums), [] for i in reversed(xrange(2*len(nums))): while stk and stk[-1] <= nums[i % len(nums)]: stk.pop() result[i % len(nums)] = stk[-1] if stk else -1 stk.append(nums[i % len(nums)]) return result ", "class Solution def minOperationsToFlip(self, expression): def compute(operands, operators): right, left = operands.pop(), operands.pop() operands.append(ops[operators.pop()](left, right)) ops = {'&':lambda x, y: [min(x[0], y[0]), min(x[1]+y[1], min(x[1], y[1])+1)], '|':lambda x, y: [min(x[0]+y[0], min(x[0], y[0])+1), min(x[1], y[1])]} precedence = {'&':0, '|':0} operands, operators = [], [] for c in expression: if c.isdigit(): operands.append([int(c != '0'), int(c != '1')]) elif c == '(': operators.append(c) elif c == ')': while operators[-1] != '(': compute(operands, operators) operators.pop() elif c in precedence: while operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[c]: compute(operands, operators) operators.append(c) while operators: compute(operands, operators) return max(operands[-1]) ", "class Solution def minOperationsToFlip(self, expression): stk = [[None]*3] for c in expression: if c == '(': stk.append([None]*3) elif c in {')', '0', '1'}: if c == ')': dp0, dp1, _ = stk.pop() else: dp0, dp1 = int(c != '0'), int(c != '1') if stk[-1][2] == '&': stk[-1] = [min(stk[-1][0], dp0), min(stk[-1][1]+dp1, min(stk[-1][1], dp1)+1), None] elif stk[-1][2] == '|': stk[-1] = [min(stk[-1][0]+dp0, min(stk[-1][0], dp0)+1), min(stk[-1][1], dp1), None] else: stk[-1] = [dp0, dp1, None] else: stk[-1][2] = c return max(stk[0][0], stk[0][1]) ", "class Solution def minMoves(self, nums, limit): diff = [0]*(2*(limit+1)) for i in xrange(len(nums)//2): left, right = nums[i], nums[-1-i] diff[min(left, right)+1] -= 1 diff[left+right] -= 1 diff[left+right+1] += 1 diff[max(left, right)+limit+1] += 1 result = count = len(nums) for total in xrange(2, 2*limit+1): count += diff[total] result = min(result, count) return result ", "class Solution def reachNumber(self, target): target = abs(target) k = int(math.ceil((-1+math.sqrt(1+8*target))/2)) target -= k*(k+1)/2 return k if target%2 == 0 else k+1+k%2 ", "class Solution def reachNumber(self, target): target = abs(target) k = 0 while target > 0: k += 1 target -= k return k if target%2 == 0 else k+1+k%2 ", "class Solution def maxSumTwoNoOverlap(self, A, L, M): for i in xrange(1, len(A)): A[i] += A[i-1] result, L_max, M_max = A[L+M-1], A[L-1], A[M-1] for i in xrange(L+M, len(A)): L_max = max(L_max, A[i-M] - A[i-L-M]) M_max = max(M_max, A[i-L] - A[i-L-M]) result = max(result, L_max + A[i] - A[i-M], M_max + A[i] - A[i-L]) return result ", "class Solution def numPoints(self, points, r): def count_points(points, r, i): angles = [] for j in xrange(len(points)): if i == j: continue dx, dy = points[i][0]-points[j][0], points[i][1]-points[j][1] d = math.sqrt(dx**2 + dy**2) if d > 2*r: continue delta, angle = math.acos(d/(2*r)), math.atan2(dy, dx) angles.append((angle-delta, 0)), angles.append((angle+delta, 1)) angles.sort() result, count = 1, 1 for _, is_closed in angles: if not is_closed: count += 1 else: count -= 1 result = max(result, count) return result return max(count_points(points, r, i) for i in xrange(len(points))) ", "class Solution def maxTaskAssign(self, tasks, workers, pills, strength): def check(tasks, workers, pills, strength, x): t = SortedList(tasks[:x]) for worker in workers[-x:]: i = t.bisect_right(worker)-1 if i != -1: t.pop(i) continue if pills: i = t.bisect_right(worker+strength)-1 if i != -1: t.pop(i) pills -= 1 continue return False return True tasks.sort() workers.sort() left, right = 1, min(len(workers), len(tasks)) while left <= right: mid = left + (right-left)//2 if not check(tasks, workers, pills, strength, mid): right = mid-1 else: left = mid+1 return right from sortedcontainers import SortedList ", "class Solution def maxTaskAssign(self, tasks, workers, pills, strength): def check(tasks, workers, pills, strength, x): w = SortedList(workers[-x:]) for task in tasks[-x:]: i = w.bisect_left(task) if i != len(w): w.pop(i) continue if pills: i = w.bisect_left(task-strength) if i != len(w): w.pop(i) pills -= 1 continue return False return True tasks.sort(reverse=True) workers.sort() left, right = 1, min(len(workers), len(tasks)) while left <= right: mid = left + (right-left)//2 if not check(tasks, workers, pills, strength, mid): right = mid-1 else: left = mid+1 return right import bisect ", "class Solution def maxTaskAssign(self, tasks, workers, pills, strength): def check(tasks, workers, pills, strength, x): t = tasks[:x] for worker in workers[-x:]: i = bisect.bisect_right(t, worker)-1 if i != -1: t.pop(i) continue if pills: i = bisect.bisect_right(t, worker+strength)-1 if i != -1: t.pop(i) pills -= 1 continue return False return True tasks.sort() workers.sort() left, right = 1, min(len(workers), len(tasks)) while left <= right: mid = left + (right-left)//2 if not check(tasks, workers, pills, strength, mid): right = mid-1 else: left = mid+1 return right import bisect ", "class Solution def maxTaskAssign(self, tasks, workers, pills, strength): def check(tasks, workers, pills, strength, x): w = workers[-x:] for task in tasks[-x:]: i = bisect.bisect_left(w, task) if i != len(w): w.pop(i) continue if pills: i = bisect.bisect_left(w, task-strength) if i != len(w): w.pop(i) pills -= 1 continue return False return True tasks.sort(reverse=True) workers.sort() left, right = 1, min(len(workers), len(tasks)) while left <= right: mid = left + (right-left)//2 if not check(tasks, workers, pills, strength, mid): right = mid-1 else: left = mid+1 return right ", "class Solution def maxDepth(self, root): if root is None: return 0 else: return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 ", "class Solution def multiply(self, num1, num2): result = [0]*(len(num1)+len(num2)) for i in reversed(xrange(len(num1))): for j in reversed(xrange(len(num2))): result[i+j+1] += int(num1[i])*int(num2[j]) result[i+j] += result[i+j+1]//10 result[i+j+1] %= 10 for i in xrange(len(result)): if result[i]: break return \"\".join(map(lambda x: str(x), result[i:])) ", "class Solution def multiply(self, num1, num2): num1, num2 = num1[::-1], num2[::-1] result = [0]*(len(num1)+len(num2)) for i in xrange(len(num1)): for j in xrange(len(num2)): result[i+j] += int(num1[i])*int(num2[j]) result[i+j+1] += result[i+j]//10 result[i+j] %= 10 for i in reversed(xrange(len(result))): if result[i]: break return \"\".join(map(str, result[i::-1])) ", "class Solution def multiply(self, num1, num2): return str(int(num1) * int(num2)) ", "class Solution def xorQueries(self, arr, queries): for i in xrange(1, len(arr)): arr[i] ^= arr[i-1] return [arr[right] ^ arr[left-1] if left else arr[right] for left, right in queries] ", "class Solution def maxSatisfaction(self, satisfaction): satisfaction.sort(reverse=True) result, curr = 0, 0 for x in satisfaction: curr += x if curr <= 0: break result += curr return result ", "class Solution def removeSubfolders(self, folder): def dfs(curr, path, result): if \"_end\" in curr: result.append(\"/\" + \"/\".join(path)) return for c in curr: if c == \"_end\": continue path.append(c) dfs(curr[c], path, result) path.pop() _trie = lambda: collections.defaultdict(_trie) trie = _trie() for f in folder: f_list = f.split(\"/\") reduce(dict.__getitem__, itertools.islice(f_list, 1, len(f_list)), trie).setdefault(\"_end\") result = [] dfs(trie, [], result) return result ", "class Solution def maximumBinaryString(self, binary): result = list(binary) zeros = ones = 0 for i, c in enumerate(result): if c == '0': zeros += 1 elif zeros == 0: ones += 1 result[i] = '1' if ones != len(result): result[zeros+ones-1] = '0' return \"\".join(result) ", "class Solution def nthMagicalNumber(self, N, A, B): def gcd(a, b): while b: a, b = b, a % b return a def check(A, B, N, lcm, target): return target//A + target//B - target//lcm >= N lcm = A*B // gcd(A, B) left, right = min(A, B), max(A, B)*N while left <= right: mid = left + (right-left)//2 if check(A, B, N, lcm, mid): right = mid-1 else: left = mid+1 return left % (10**9 + 7) ", "class Solution def missingNumber(self, nums): return reduce(operator.xor, nums, reduce(operator.xor, xrange(len(nums) + 1))) ", "class Solution def missingNumber(self, nums): return sum(xrange(len(nums)+1)) - sum(nums) ", "class Solution def maximizeSum(self, nums, k): return max(nums)*k+k*(k-1)//2 ", "class Solution def hasPath(self, maze, start, destination): def neighbors(maze, node): for i, j in [(-1, 0), (0, 1), (0, -1), (1, 0)]: x, y = node while 0 <= x + i < len(maze) and 0 <= y + j < len(maze[0]) and not maze[x+i][y+j]: x += i y += j yield x, y start, destination = tuple(start), tuple(destination) queue = collections.deque([start]) visited = set() while queue: node = queue.popleft() if node in visited: continue if node == destination: return True visited.add(node) for neighbor in neighbors(maze, node): queue.append(neighbor) return False ", "class Solution def minCut(self, s): lookup = [[False for j in xrange(len(s))] for i in xrange(len(s))] mincut = [len(s) - 1 - i for i in xrange(len(s) + 1)] for i in reversed(xrange(len(s))): for j in xrange(i, len(s)): if s[i] == s[j] and (j - i < 2 or lookup[i + 1][j - 1]): lookup[i][j] = True mincut[i] = min(mincut[i], mincut[j + 1] + 1) return mincut[0] ", "class Solution def calculateTime(self, keyboard, word): lookup = {c:i for i, c in enumerate(keyboard)} result, prev = 0, 0 for c in word: result += abs(lookup[c]-prev) prev = lookup[c] return result ", "class Solution def myAtoi(self, str): INT_MAX = 2147483647 INT_MIN = -2147483648 result = 0 if not str: return result i = 0 while i < len(str) and str[i].isspace(): i += 1 if len(str) == i: return result sign = 1 if str[i] == \"+\": i += 1 elif str[i] == \"-\": sign = -1 i += 1 while i < len(str) and '0' <= str[i] <= '9': if result > (INT_MAX - int(str[i])) / 10: return INT_MAX if sign > 0 else INT_MIN result = result * 10 + int(str[i]) i += 1 return sign * result ", "class Solution def seePeople(self, heights): def count(h, stk): cnt = 0 while stk and stk[-1] < h: stk.pop() cnt += 1 if stk: cnt += 1 if not stk or stk[-1] != h: stk.append(h) return cnt result = [[0]*len(heights[0]) for _ in xrange(len(heights))] for i in xrange(len(heights)): stk = [] for j in reversed(xrange(len(heights[0]))): result[i][j] += count(heights[i][j], stk) for j in xrange(len(heights[0])): stk = [] for i in reversed(xrange(len(heights))): result[i][j] += count(heights[i][j], stk) return result ", "class Solution def seePeople(self, heights): def count(heights, i, stk): cnt = 0 while stk and heights(stk[-1]) < heights(i): stk.pop() cnt += 1 if stk: cnt += 1 if stk and heights(stk[-1]) == heights(i): stk.pop() stk.append(i) return cnt result = [[0]*len(heights[0]) for _ in xrange(len(heights))] for i in xrange(len(heights)): stk = [] for j in reversed(xrange(len(heights[0]))): result[i][j] += count(lambda x: heights[i][x], j, stk) for j in xrange(len(heights[0])): stk = [] for i in reversed(xrange(len(heights))): result[i][j] += count(lambda x: heights[x][j], i, stk) return result ", "class Solution def seePeople(self, heights): def count(heights, i, stk, add): while stk and heights(stk[-1]) < heights(i): increase(stk.pop()) if stk: increase(stk[-1]) if stk and heights(stk[-1]) == heights(i): stk.pop() stk.append(i) result = [[0]*len(heights[0]) for _ in xrange(len(heights))] for i in xrange(len(heights)): stk = [] def increase(x): result[i][x] += 1 for j in xrange(len(heights[0])): count(lambda x: heights[i][x], j, stk, add) for j in xrange(len(heights[0])): stk = [] def increase(x): result[x][j] += 1 for i in xrange(len(heights)): count(lambda x: heights[x][j], i, stk, add) return result ", "class Solution def sumEvenGrandparent(self, root): def sumEvenGrandparentHelper(root, p, gp): return sumEvenGrandparentHelper(root.left, root.val, p) + sumEvenGrandparentHelper(root.right, root.val, p) + (root.val if gp is not None and gp % 2 == 0 else 0) if root else 0 return sumEvenGrandparentHelper(root, None, None) ", "class Solution def smallestSubsequence(self, text): count = collections.Counter(text) lookup, stk = set(), [] for c in text: if c not in lookup: while stk and stk[-1] > c and count[stk[-1]]: lookup.remove(stk.pop()) stk += c lookup.add(c) count[c] -= 1 return \"\".join(stk) ", "class Solution def xorOperation(self, n, start): def xorNums(n, start): def xorNumsBeginEven(n, start): assert(start%2 == 0) return ((n//2)%2)^((start+n-1) if n%2 else 0) return start^xorNumsBeginEven(n-1, start+1) if start%2 else xorNumsBeginEven(n, start) return int(n%2 and start%2) + 2*xorNums(n, start//2) import operator ", "class Solution def xorOperation(self, n, start): return reduce(operator.xor, (i for i in xrange(start, start+2*n, 2))) ", "class Solution def reverseOnlyLetters(self, S): def getNext(S): for i in reversed(xrange(len(S))): if S[i].isalpha(): yield S[i] result = [] letter = getNext(S) for i in xrange(len(S)): if S[i].isalpha(): result.append(letter.next()) else: result.append(S[i]) return \"\".join(result) ", "class Solution def getMaxFunctionValue(self, receiver, k): def find_cycles(adj): result = [] lookup = [0]*len(adj) idx = 0 for u in xrange(len(adj)): prev = idx while not lookup[u]: idx += 1 lookup[u] = idx u = adj[u] if lookup[u] > prev: result.append((u, idx-lookup[u]+1)) return result def find_prefixes(): lookup = [(-1, -1)]*len(receiver) prefixes = [[0] for _ in xrange(len(cycles))] for idx, (u, l) in enumerate(cycles): for i in xrange(l): lookup[u] = (idx, i) prefixes[idx].append(prefixes[idx][i]+u) u = receiver[u] return lookup, prefixes def get_sum(prefix, i, cnt): l = len(prefix)-1 q, r = divmod(cnt, l) return (q*prefix[-1]+ (prefix[min(i+r, l)]-prefix[i])+ (prefix[max(((i+r)-l, 0))]-prefix[0])) def start_inside_cycle(): result = 0 for u, l in cycles: for _ in xrange(l): idx, i = lookup[u] result = max(result, get_sum(prefixes[idx], i, k+1)) u = receiver[u] return result def start_outside_cycle(): result = 0 degree = [0]*len(receiver) for x in receiver: degree[x] += 1 for u in xrange(len(receiver)): if degree[u]: continue curr = 0 dq = collections.deque() while lookup[u][0] == -1: curr += u dq.append(u) if len(dq) == k+1: result = max(result, curr) curr -= dq.popleft() u = receiver[u] idx, i = lookup[u] while dq: result = max(result, curr+get_sum(prefixes[idx], i, (k+1)-len(dq))) curr -= dq.popleft() return result cycles = find_cycles(receiver) lookup, prefixes = find_prefixes() return max(start_inside_cycle(), start_outside_cycle()) ", "class Solution def getMaxFunctionValue(self, receiver, k): l = (k+1).bit_length() P = [receiver[:] for _ in xrange(l)] S = [range(len(receiver)) for _ in xrange(l)] for i in xrange(1, len(P)): for u in xrange(len(receiver)): P[i][u] = P[i-1][P[i-1][u]] S[i][u] = S[i-1][u]+S[i-1][P[i-1][u]] result = 0 for u in xrange(len(receiver)): curr = 0 for i in xrange(l): if (k+1)&(1<<i): curr += S[i][u] u = P[i][u] result = max(result, curr) return result ", "class Solution def findRepeatedDnaSequences(self, s): dict, rolling_hash, res = {}, 0, [] for i in xrange(len(s)): rolling_hash = ((rolling_hash << 3) & 0x3fffffff) | (ord(s[i]) & 7) if rolling_hash not in dict: dict[rolling_hash] = True elif dict[rolling_hash]: res.append(s[i - 9: i + 1]) dict[rolling_hash] = False return res def findRepeatedDnaSequences2(self, s): l, r = [], [] if len(s) < 10: return [] for i in range(len(s) - 9): l.extend([s[i:i + 10]]) return [k for k, v in collections.Counter(l).items() if v > 1] ", "class Solution def substringXorQueries(self, s, queries): mx = max(a^b for a, b in queries) lookup = {} for i in xrange(len(s)): curr = 0 for j in xrange(i, len(s)): curr = (curr<<1)+int(s[j]) if curr > mx: break if curr not in lookup: lookup[curr] = [i, j] if s[i] == '0': break return [lookup[a^b] if a^b in lookup else [-1, -1] for a, b in queries] ", "class Solution def maxKDivisibleComponents(self, n, edges, values, k): def bfs(): result = 0 dp = [x%k for x in values] cnt = [len(adj[u]) for u in xrange(len(adj))] q = [u for u in xrange(n) if cnt[u] == 1] while q: new_q = [] for u in q: if not dp[u]: result += 1 for v in adj[u]: dp[v] = (dp[v]+dp[u])%k cnt[v] -= 1 if cnt[v] == 1: new_q.append(v) q = new_q return max(result, 1) adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) return bfs() ", "class Solution def sameEndSubstringCount(self, s, queries): prefix = [[0]*26] for i in xrange(len(s)): prefix.append(prefix[-1][:]) prefix[-1][ord(s[i])-ord('a')] += 1 result = [0]*len(queries) for i, (l, r) in enumerate(queries): for j in xrange(26): cnt = prefix[r+1][j]-prefix[l][j] result[i] += (1+cnt)*cnt//2 return result ", "class Solution def findMinimumTime(self, tasks): tasks.sort(key=lambda x: x[1]) lookup = set() for s, e, d in tasks: d -= sum(i in lookup for i in xrange(s, e+1)) for i in reversed(xrange(1, e+1)): if d <= 0: break if i in lookup: continue lookup.add(i) d -= 1 return len(lookup) ", "class Solution def numSquarefulPerms(self, A): def dfs(candidate, x, left, count, result): count[x] -= 1 if left == 0: result[0] += 1 for y in candidate[x]: if count[y]: dfs(candidate, y, left-1, count, result) count[x] += 1 count = collections.Counter(A) candidate = {i: {j for j in count if int((i+j)**0.5) ** 2 == i+j} for i in count} result = [0] for x in count: dfs(candidate, x, len(A)-1, count, result) return result[0] ", "class Solution def minimumHammingDistance(self, source, target, allowedSwaps): def iter_flood_fill(adj, node, lookup, idxs): stk = [node] while stk: node = stk.pop() if node in lookup: continue lookup.add(node) idxs.append(node) for child in adj[node]: stk.append(child) adj = [set() for i in xrange(len(source))] for i, j in allowedSwaps: adj[i].add(j) adj[j].add(i) result = 0 lookup = set() for i in xrange(len(source)): if i in lookup: continue idxs = [] iter_flood_fill(adj, i, lookup, idxs) source_cnt = collections.Counter([source[i] for i in idxs]) target_cnt = collections.Counter([target[i] for i in idxs]) diff = source_cnt-target_cnt result += sum(diff.itervalues()) return result import collections class UnionFind(object): def __init__(self, n): self.set = range(n) self.rank = [0]*n def find_set(self, x): stk = [] while self.set[x] != x: stk.append(x) x = self.set[x] while stk: self.set[stk.pop()] = x return x def union_set(self, x, y): x_root, y_root = map(self.find_set, (x, y)) if x_root == y_root: return False if self.rank[x_root] < self.rank[y_root]: self.set[x_root] = y_root elif self.rank[x_root] > self.rank[y_root]: self.set[y_root] = x_root else: self.set[y_root] = x_root self.rank[x_root] += 1 return True ", "class Solution def minimumHammingDistance(self, source, target, allowedSwaps): uf = UnionFind(len(source)) for x, y in allowedSwaps: uf.union_set(x, y) groups = collections.defaultdict(set) for i in xrange(len(source)): groups[uf.find_set(i)].add(i) result = 0 for idxs in groups.itervalues(): source_cnt = collections.Counter([source[i] for i in idxs]) target_cnt = collections.Counter([target[i] for i in idxs]) diff = source_cnt-target_cnt result += sum(diff.itervalues()) return result ", "class Solution def minOperationsQueries(self, n, edges, queries): adj = [[] for _ in xrange(n)] for u, v, w in edges: w -= 1 adj[u].append((v, w)) adj[v].append((u, w)) pairs = collections.defaultdict(set) for a, b in queries: pairs[a].add(b), pairs[b].add(a) tree_infos = TreeInfos(adj, pairs) result = [0]*len(queries) for i, (a, b) in enumerate(queries): lca = tree_infos.lca[min(a, b), max(a, b)] result[i] = (tree_infos.D[a]+tree_infos.D[b]-2*tree_infos.D[lca])-max(tree_infos.CNT[a][w]+tree_infos.CNT[b][w]-2*tree_infos.CNT[lca][w] for w in xrange(MAX_W)) return result import collections from functools import partial class TreeInfos2(object): def __init__(self, adj): def preprocess(u, p, w): D[u] = 1 if p == -1 else D[p]+1 if p != -1: P[u].append(p) i = 0 while i < len(P[u]) and i < len(P[P[u][i]]): P[u].append(P[P[u][i]][i]) i += 1 C[0] += 1 L[u] = C[0] if w != -1: cnt[w] += 1 CNT[u] = cnt[:] def divide(u, p, w): stk.append(partial(postprocess, u, w)) for i in reversed(xrange(len(adj[u]))): v, nw = adj[u][i] if v == p: continue stk.append(partial(divide, v, u, nw)) stk.append(partial(preprocess, u, p, w)) def postprocess(u, w): R[u] = C[0] if w != -1: cnt[w] -= 1 N = len(adj) L, R, D, P, C = [0]*N, [0]*N, [0]*N, [[] for _ in xrange(N)], [-1] CNT = [[0]*MAX_W for _ in xrange(N)] cnt = [0]*MAX_W stk = [] stk.append(partial(divide, 0, -1, -1)) while stk: stk.pop()() assert(C[0] == N-1) self.L, self.R, self.D, self.P = L, R, D, P self.CNT = CNT def is_ancestor(self, a, b): return self.L[a] <= self.L[b] <= self.R[b] <= self.R[a] def lca(self, a, b): if self.D[a] > self.D[b]: a, b = b, a if self.is_ancestor(a, b): return a for i in reversed(xrange(len(self.P[a]))): if i < len(self.P[a]) and not self.is_ancestor(self.P[a][i], b): a = self.P[a][i] return self.P[a][0] MAX_W = 26 ", "class Solution def minOperationsQueries(self, n, edges, queries): adj = [[] for _ in xrange(n)] for u, v, w in edges: w -= 1 adj[u].append((v, w)) adj[v].append((u, w)) tree_infos = TreeInfos2(adj) result = [0]*len(queries) for i, (a, b) in enumerate(queries): lca = tree_infos.lca(a, b) result[i] = (tree_infos.D[a]+tree_infos.D[b]-2*tree_infos.D[lca])-max(tree_infos.CNT[a][w]+tree_infos.CNT[b][w]-2*tree_infos.CNT[lca][w] for w in xrange(MAX_W)) return result ", "class Solution def maximumSum(self, nums): return max(sum(nums[i*x**2-1] for x in xrange(1, int((len(nums)//i)**0.5)+1)) for i in xrange(1, len(nums)+1)) ", "class Solution def minSubArrayLen(self, s, nums): start = 0 sum = 0 min_size = float(\"inf\") for i in xrange(len(nums)): sum += nums[i] while sum >= s: min_size = min(min_size, i - start + 1) sum -= nums[start] start += 1 return min_size if min_size != float(\"inf\") else 0 ", "class Solution def minSubArrayLen(self, s, nums): min_size = float(\"inf\") sum_from_start = [n for n in nums] for i in xrange(len(sum_from_start) - 1): sum_from_start[i + 1] += sum_from_start[i] for i in xrange(len(sum_from_start)): end = self.binarySearch(lambda x, y: x <= y, sum_from_start, i, len(sum_from_start), sum_from_start[i] - nums[i] + s) if end < len(sum_from_start): min_size = min(min_size, end - i + 1) return min_size if min_size != float(\"inf\") else 0 def binarySearch(self, compare, A, start, end, target): while start < end: mid = start + (end - start) / 2 if compare(target, A[mid]): end = mid else: start = mid + 1 return start ", "class Solution def takeCharacters(self, s, k): cnt = [0]*3 for c in s: cnt[ord(c)-ord('a')] += 1 if min(cnt) < k: return -1 result = left = 0 for right in xrange(len(s)): cnt[ord(s[right])-ord('a')] -= 1 while cnt[ord(s[right])-ord('a')] < k: cnt[ord(s[left])-ord('a')] += 1 left += 1 result = max(result, right-left+1) return len(s)-result ", "class Solution def maxSum(self, grid): def total(i, j): return (grid[i][j]+grid[i][j+1]+grid[i][j+2]+ grid[i+1][j+1]+ grid[i+2][j]+grid[i+2][j+1]+grid[i+2][j+2]) return max(total(i, j) for i in xrange(len(grid)-2) for j in xrange(len(grid[0])-2)) ", "class Solution def minimumTime(self, time, totalTrips): def check(time, totalTrips, x): return sum(x//t for t in time) >= totalTrips left, right = 1, max(time)*totalTrips while left <= right: mid = left + (right-left)//2 if check(time, totalTrips, mid): right = mid-1 else: left = mid+1 return left ", "class Solution def minimumOperations(self, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def iter_dfs(grid, i, j, lookup, adj): if lookup[i][j]: return lookup[i][j] = True stk = [(i, j, (i+j)%2)] while stk: i, j, color = stk.pop() for di, dj in directions: ni, nj = i+di, j+dj if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj]): continue if not color: adj[len(grid[0])*ni+nj].append(len(grid[0])*i+j) if lookup[ni][nj]: continue lookup[ni][nj] = True stk.append((ni, nj, color^1)) adj = collections.defaultdict(list) lookup = [[False]*len(grid[0]) for _ in xrange(len(grid))] for i in xrange(len(grid)): for j in xrange(len(grid[0])): if not grid[i][j]: continue iter_dfs(grid, i, j, lookup, adj) return len(bipartiteMatch(adj)[0]) ", "class Solution def shortestPathLength(self, graph): dp = [[float(\"inf\")]*(len(graph)) for _ in xrange(1 << len(graph))] q = collections.deque() for i in xrange(len(graph)): dp[1 << i][i] = 0 q.append((1 << i, i)) while q: state, node = q.popleft() steps = dp[state][node] for nei in graph[node]: new_state = state | (1 << nei) if dp[new_state][nei] == float(\"inf\"): dp[new_state][nei] = steps+1 q.append((new_state, nei)) return min(dp[-1]) ", "class Solution def getSubarrayBeauty(self, nums, k, x): result = [] sl = SortedList() for i, v in enumerate(nums): if i-k >= 0: sl.remove(nums[i-k]) sl.add(v) if i-k+1 >= 0: result.append(min(sl[x-1], 0)) return result ", "class Solution def largestWordCount(self, messages, senders): cnt = collections.Counter() for m, s in itertools.izip(messages, senders): cnt[s] += m.count(' ')+1 return max((k for k in cnt.iterkeys()), key=lambda x: (cnt[x], x)) ", "class Solution def mySqrt(self, x): if x < 2: return x left, right = 1, x // 2 while left <= right: mid = left + (right - left) // 2 if mid > x / mid: right = mid - 1 else: left = mid + 1 return left - 1 ", "class Solution def findLadders(self, beginWord, endWord, wordList): def backtracking(tree, beginWord, word): return [[beginWord]] if word == beginWord else [path + [word] for new_word in tree[word] for path in backtracking(tree, beginWord, new_word)] words = set(wordList) if endWord not in words: return [] tree = defaultdict(set) is_found, left, right, is_reversed = False, {beginWord}, {endWord}, False while left: words -= left new_left = set() for word in left: for new_word in (word[:i]+c+word[i+1:] for i in xrange(len(beginWord)) for c in ascii_lowercase): if new_word not in words: continue if new_word in right: is_found = True else: new_left.add(new_word) tree[new_word].add(word) if not is_reversed else tree[word].add(new_word) if is_found: break left = new_left if len(left) > len(right): left, right, is_reversed = right, left, not is_reversed return backtracking(tree, beginWord, endWord) ", "class Solution def findLadders(self, beginWord, endWord, wordList): dictionary = set(wordList) result, cur, visited, found, trace = [], [beginWord], set([beginWord]), False, defaultdict(list) while cur and not found: for word in cur: visited.add(word) next = set() for word in cur: for i in xrange(len(word)): for c in ascii_lowercase: candidate = word[:i] + c + word[i + 1:] if candidate not in visited and candidate in dictionary: if candidate == endWord: found = True next.add(candidate) trace[candidate].append(word) cur = next if found: self.backtrack(result, trace, [], endWord) return result def backtrack(self, result, trace, path, word): if not trace[word]: path.append(word) result.append(path[::-1]) path.pop() else: for prev in trace[word]: path.append(word) self.backtrack(result, trace, path, prev) path.pop() ", "class Solution def minSkips(self, dist, speed, hoursBefore): def ceil(a, b): return (a+b-1)//b dp = [0]*((len(dist)-1)+1) for i, d in enumerate(dist): for j in reversed(xrange(len(dp))): dp[j] = ceil(dp[j]+d, speed)*speed if i < len(dist)-1 else dp[j]+d if j-1 >= 0: dp[j] = min(dp[j], dp[j-1]+d) target = hoursBefore*speed for i in xrange(len(dist)): if dp[i] <= target: return i return -1 ", "class Solution def canPartitionKSubsets(self, nums, k): def dfs(nums, target, used, todo, lookup): if lookup[used] is None: targ = (todo-1)%target + 1 lookup[used] = any(dfs(nums, target, used | (1<<i), todo-num, lookup) for i, num in enumerate(nums) if ((used>>i) & 1) == 0 and num <= targ) return lookup[used] total = sum(nums) if total%k or max(nums) > total//k: return False lookup = [None] * (1 << len(nums)) lookup[-1] = True return dfs(nums, total//k, 0, total, lookup) ", "class Solution def canPartitionKSubsets(self, nums, k): def dfs(nums, target, i, subset_sums): if i == len(nums): return True for k in xrange(len(subset_sums)): if subset_sums[k]+nums[i] > target: continue subset_sums[k] += nums[i] if dfs(nums, target, i+1, subset_sums): return True subset_sums[k] -= nums[i] if not subset_sums[k]: break return False total = sum(nums) if total%k != 0 or max(nums) > total//k: return False nums.sort(reverse=True) subset_sums = [0] * k return dfs(nums, total//k, 0, subset_sums) ", "class Solution def plusOne(self, head): if not head: return None dummy = ListNode(0) dummy.next = head left, right = dummy, head while right.next: if right.val != 9: left = right right = right.next if right.val != 9: right.val += 1 else: left.val += 1 right = left.next while right: right.val = 0 right = right.next return dummy if dummy.val else dummy.next ", "class Solution def plusOne(self, head): def reverseList(head): dummy = ListNode(0) curr = head while curr: dummy.next, curr.next, curr = curr, dummy.next, curr.next return dummy.next rev_head = reverseList(head) curr, carry = rev_head, 1 while curr and carry: curr.val += carry carry = curr.val / 10 curr.val %= 10 if carry and curr.next is None: curr.next = ListNode(0) curr = curr.next return reverseList(rev_head) ", "class Solution def minimumCosts(self, regular, express, expressCost): result = [] dp = [0, expressCost] for r, e in itertools.izip(regular, express): dp = [min(dp[0]+r, dp[1]+e), min(dp[0]+(r+expressCost), dp[1]+e)] result.append(min(dp[0], dp[1])) return result ", "class Solution def minimumIncompatibility(self, nums, k): inf = (len(nums)-1)*(len(nums)//k)+1 def backtracking(nums, d, lookup): if not nums: return 0 if nums not in lookup: ret = inf for new_nums in itertools.combinations(nums, d): new_nums_set = set(new_nums) if len(new_nums_set) < d: continue left = [] for num in nums: if num in new_nums_set: new_nums_set.remove(num) continue left.append(num) ret = min(ret, max(new_nums)-min(new_nums) + backtracking(tuple(left), d, lookup)) lookup[nums] = ret return lookup[nums] result = backtracking(tuple(nums), len(nums)//k, {}) return result if result != inf else -1 class Solution_TLE(object): def minimumIncompatibility(self, nums, k): inf = (len(nums)-1)*(len(nums)//k)+1 POW = [1] for i in xrange(len(nums)): POW.append(POW[-1]<<1) def popcount(n): result = 0 while n: n &= n - 1 result += 1 return result def find_candidates(nums, k): total = POW[len(nums)]-1 m = len(nums)//k result = [inf]*(total+1) for mask in xrange(total+1): if popcount(mask) != m: continue lookup = 0 mx, mn = 0, inf for i in xrange(len(nums)): if mask&POW[i] == 0: continue if lookup&POW[nums[i]]: break lookup |= POW[nums[i]] mx = max(mx, nums[i]) mn = min(mn, nums[i]) else: result[mask] = mx-mn return result candidates = find_candidates(nums, k) m = len(nums)//k total = POW[len(nums)]-1 dp = [inf]*(total+1) dp[0] = 0 for mask in xrange(total+1): if popcount(mask) % m != 0: continue submask = mask while submask: dp[mask] = min(dp[mask], dp[mask-submask] + candidates[submask]) submask = (submask-1)&mask return dp[-1] if dp[-1] != inf else -1 import collections import sortedcontainers class Solution_Wrong_Greedy_SortedList(object): def minimumIncompatibility(self, nums, k): def greedy(nums, k, is_reversed): count = collections.Counter(nums) if max(count.itervalues()) > k: return -1 ordered_set = sortedcontainers.SortedList(count.iterkeys()) freq_to_nodes = collections.defaultdict(collections.OrderedDict) for x in ordered_set: freq_to_nodes[count[x]][x] = count[x] stks = [[] for _ in xrange(k)] curr = 0 while ordered_set: if len(stks)-curr in freq_to_nodes: for x in freq_to_nodes[len(stks)-curr].iterkeys(): for i in xrange(curr, len(stks)): stks[i].append(x) count.pop(x) ordered_set.remove(x) freq_to_nodes.pop(len(stks)-curr) to_remove = [] direction = (lambda x:x) if not is_reversed else reversed for x in direction(ordered_set): stks[curr].append(x) freq_to_nodes[count[x]].pop(x) if not freq_to_nodes[count[x]]: freq_to_nodes.pop(count[x]) count[x] -= 1 if not count[x]: count.pop(x) to_remove.append(x) else: freq_to_nodes[count[x]][x] = count[x] if len(stks[curr]) == len(nums)//k: curr += 1 break for x in to_remove: ordered_set.remove(x) return sum([max(stk)-min(stk) for stk in stks]) return min(greedy(nums, k, False), greedy(nums, k, True)) import collections from random import randint, seed class SkipNode(object): def __init__(self, level=0, val=None): self.val = val self.nexts = [None]*level self.prevs = [None]*level class SkipList(object): P_NUMERATOR, P_DENOMINATOR = 1, 2 MAX_LEVEL = 32 def __init__(self, end=float(\"inf\"), can_duplicated=False, cmp=lambda x, y: x < y): seed(0) self.__head = SkipNode() self.__len = 0 self.__can_duplicated = can_duplicated self.__cmp = cmp self.add(end) self.__end = self.find(end) def begin(self): return self.__head.nexts[0] def end(self): return self.__end def lower_bound(self, target): return self.__lower_bound(target, self.__find_prev_nodes(target)) def find(self, target): return self.__find(target, self.__find_prev_nodes(target)) def add(self, val): if not self.__can_duplicated and self.find(val): return self.find(val), False node = SkipNode(self.__random_level(), val) if len(self.__head.nexts) < len(node.nexts): self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts))) prevs = self.__find_prev_nodes(val) for i in xrange(len(node.nexts)): node.nexts[i] = prevs[i].nexts[i] if prevs[i].nexts[i]: prevs[i].nexts[i].prevs[i] = node prevs[i].nexts[i] = node node.prevs[i] = prevs[i] self.__len += 1 return node if self.__can_duplicated else (node, True) def remove(self, it): prevs = it.prevs curr = self.__find(it.val, prevs) if not curr: return self.__end self.__len -= 1 for i in reversed(xrange(len(curr.nexts))): prevs[i].nexts[i] = curr.nexts[i] if curr.nexts[i]: curr.nexts[i].prevs[i] = prevs[i] if not self.__head.nexts[i]: self.__head.nexts.pop() return curr.nexts[0] def __lower_bound(self, val, prevs): if prevs: candidate = prevs[0].nexts[0] if candidate: return candidate return None def __find(self, val, prevs): candidate = self.__lower_bound(val, prevs) if candidate and candidate.val == val: return candidate return None def __find_prev_nodes(self, val): prevs = [None]*len(self.__head.nexts) curr = self.__head for i in reversed(xrange(len(self.__head.nexts))): while curr.nexts[i] and self.__cmp(curr.nexts[i].val, val): curr = curr.nexts[i] prevs[i] = curr return prevs def __random_level(self): level = 1 while randint(1, SkipList.P_DENOMINATOR) <= SkipList.P_NUMERATOR and level < SkipList.MAX_LEVEL: level += 1 return level def __iter__(self): it = self.begin() while it != self.end(): yield it.val it = it.nexts[0] def __len__(self): return self.__len-1 def __str__(self): result = [] for i in reversed(xrange(len(self.__head.nexts))): result.append([]) curr = self.__head.nexts[i] while curr: result[-1].append(str(curr.val)) curr = curr.nexts[i] return \"\\n\".join(map(lambda x: \"->\".join(x), result)) class Solution_Wrong_Greedy_SkipList(object): def minimumIncompatibility(self, nums, k): def greedy(nums, k, is_reversed): count = collections.Counter(nums) if max(count.itervalues()) > k: return -1 ordered_set = SkipList() if not is_reversed else SkipList(end=float(\"-inf\"), cmp=lambda x, y: x > y) freq_to_nodes = collections.defaultdict(collections.OrderedDict) for x in sorted(count.keys(), reverse=is_reversed): ordered_set.add(x) freq_to_nodes[count[x]][x] = count[x] stks = [[] for _ in xrange(k)] curr = 0 while ordered_set: if len(stks)-curr in freq_to_nodes: for x in freq_to_nodes[len(stks)-curr].iterkeys(): for i in xrange(curr, len(stks)): stks[i].append(x) count.pop(x) ordered_set.remove(ordered_set.find(x)) freq_to_nodes.pop(len(stks)-curr) it = ordered_set.begin() while it != ordered_set.end(): x = it.val stks[curr].append(x) freq_to_nodes[count[x]].pop(x) if not freq_to_nodes[count[x]]: freq_to_nodes.pop(count[x]) count[x] -= 1 if not count[x]: count.pop(x) it = ordered_set.remove(it) else: freq_to_nodes[count[x]][x] = count[x] it = it.nexts[0] if len(stks[curr]) == len(nums)//k: curr += 1 break return sum([max(stk)-min(stk) for stk in stks]) return min(greedy(nums, k, False), greedy(nums, k, True)) import collections class Solution_Wrong_Greedy(object): def minimumIncompatibility(self, nums, k): def greedy(nums, k, is_reversed): count = collections.Counter(nums) if max(count.itervalues()) > k: return -1 sorted_keys = sorted(count.keys(), reverse=is_reversed) stks = [[] for _ in xrange(k)] curr, remain = 0, len(nums) while remain: for x in sorted_keys: if count[x] != len(stks)-curr: continue for i in xrange(curr, len(stks)): stks[i].append(x) remain -= count[x] count[x] = 0 for x in sorted_keys: if not count[x]: continue stks[curr].append(x) remain -= 1 count[x] -= 1 if len(stks[curr]) == len(nums)//k: curr += 1 break return sum([max(stk)-min(stk) for stk in stks]) return min(greedy(nums, k, False), greedy(nums, k, True)) ", "class Solution def countBlocks(self, nums): def binary_search_right(left, right, check): while left <= right: mid = left + (right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right n = nums.size() result = left = 0 while left != n: target = nums.at(left) left = binary_search_right(left, n-1, lambda x: nums.at(x) == target)+1 result += 1 return result ", "class Solution def findMaximums(self, nums): def find_bound(nums, direction, init): result = [0]*len(nums) stk = [init] for i in direction(xrange(len(nums))): while stk[-1] != init and nums[stk[-1]] >= nums[i]: stk.pop() result[i] = stk[-1] stk.append(i) return result left = find_bound(nums, lambda x: x, -1) right = find_bound(nums, reversed, len(nums)) result = [-1]*len(nums) for i, v in enumerate(nums): result[((right[i]-1)-left[i])-1] = max(result[((right[i]-1)-left[i])-1], v) for i in reversed(xrange(len(nums)-1)): result[i] = max(result[i], result[i+1]) return result ", "class Solution def restoreIpAddresses(self, s): result = [] self.restoreIpAddressesRecur(result, s, 0, \"\", 0) return result def restoreIpAddressesRecur(self, result, s, start, current, dots): if (4 - dots) * 3 < len(s) - start or (4 - dots) > len(s) - start: return if start == len(s) and dots == 4: result.append(current[:-1]) else: for i in xrange(start, start + 3): if len(s) > i and self.isValid(s[start:i + 1]): current += s[start:i + 1] + '.' self.restoreIpAddressesRecur(result, s, i + 1, current, dots + 1) current = current[:-(i - start + 2)] def isValid(self, s): if len(s) == 0 or (s[0] == '0' and s != \"0\"): return False return int(s) < 256 ", "class Solution def connectSticks(self, sticks): heapq.heapify(sticks) result = 0 while len(sticks) > 1: x, y = heapq.heappop(sticks), heapq.heappop(sticks) result += x+y heapq.heappush(sticks, x+y) return result ", "class Solution def minOperations(self, nums): def popcount(n): result = 0 while n: n &= n-1 result += 1 return result result, max_len = 0, 1 for num in nums: result += popcount(num) max_len = max(max_len, num.bit_length()) return result + (max_len-1) ", "class Solution def maxPoints(self, grid, queries): directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] min_heap = [(grid[0][0], 0, 0)] lookup = [[False]*len(grid[0]) for _ in xrange(len(grid))] lookup[0][0] = True mx = 0 cnt = collections.Counter() while min_heap: curr, i, j = heapq.heappop(min_heap) mx = max(mx, curr) cnt[mx] += 1 for di, dj in directions: ni, nj = i+di, j+dj if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and not lookup[ni][nj]): continue lookup[ni][nj] = True heapq.heappush(min_heap, (grid[ni][nj], ni, nj)) vals = sorted(cnt.iterkeys()) prefix = [0]*(len(vals)+1) for i in xrange(len(vals)): prefix[i+1] += prefix[i]+cnt[vals[i]] return map(lambda x: prefix[bisect.bisect_left(vals, x)], queries) ", "class Solution def reverseOddLevels(self, root): q = [root] parity = 0 while q: if parity: left, right = 0, len(q)-1 while left < right: q[left].val, q[right].val = q[right].val, q[left].val left += 1 right -= 1 if not q[0].left: break new_q = [] for node in q: new_q.append(node.left) new_q.append(node.right) q = new_q parity ^= 1 return root ", "class Solution def smallestGoodBase(self, n): num = int(n) max_len = int(math.log(num,2)) for l in xrange(max_len, 1, -1): b = int(num ** (l**-1)) if (b**(l+1)-1) // (b-1) == num: return str(b) return str(num-1) ", "class Solution def sumOfSquares(self, nums): result = 0 for i in xrange(1, int(len(nums)**0.5)+1): if len(nums)%i: continue result += nums[i-1]**2 if len(nums)//i != i: result += nums[len(nums)//i-1]**2 return result ", "class Solution def primePalindrome(self, N): def is_prime(n): if n < 2 or n % 2 == 0: return n == 2 return all(n % d for d in xrange(3, int(n**.5) + 1, 2)) if 8 <= N <= 11: return 11 for i in xrange(10**(len(str(N))//2), 10**5): j = int(str(i) + str(i)[-2::-1]) if j >= N and is_prime(j): return j ", "class Solution def isPerfectSquare(self, num): left, right = 1, num while left <= right: mid = left + (right - left) / 2 if mid >= num / mid: right = mid - 1 else: left = mid + 1 return left == num / left and num % left == 0 ", "class Solution def countPairs(self, root, distance): def iter_dfs(distance, root): result = 0 stk = [(1, (root, [collections.Counter()]))] while stk: step, params = stk.pop() if step == 1: node, ret = params if not node: continue if not node.left and not node.right: ret[0][0] = 1 continue left, right = [collections.Counter()], [collections.Counter()] stk.append((2, (left, right, ret))) stk.append((1, (node.right, right))) stk.append((1, (node.left, left))) else: left, right, ret = params for left_d, left_c in left[0].iteritems(): for right_d,right_c in right[0].iteritems(): if left_d+right_d+2 <= distance: result += left_c*right_c ret[0] = collections.Counter({k+1:v for k,v in (left[0]+right[0]).iteritems()}) return result return iter_dfs(distance, root) import collections ", "class Solution def countPairs(self, root, distance): def dfs(distance, node): if not node: return 0, collections.Counter() if not node.left and not node.right: return 0, collections.Counter([0]) left, right = dfs(distance, node.left), dfs(distance, node.right) result = left[0]+right[0] for left_d, left_c in left[1].iteritems(): for right_d,right_c in right[1].iteritems(): if left_d+right_d+2 <= distance: result += left_c*right_c return result, collections.Counter({k+1:v for k,v in (left[1]+right[1]).iteritems()}) return dfs(distance, root)[0] ", "class Solution def minimumMoves(self, arr): dp = [[0 for _ in xrange(len(arr)+1)] for _ in xrange(len(arr)+1)] for l in xrange(1, len(arr)+1): for i in xrange(len(arr)-l+1): j = i+l-1 if l == 1: dp[i][j] = 1 else: dp[i][j] = 1+dp[i+1][j] if arr[i] == arr[i+1]: dp[i][j] = min(dp[i][j], 1+dp[i+2][j]) for k in xrange(i+2, j+1): if arr[i] == arr[k]: dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k+1][j]) return dp[0][len(arr)-1] ", "class Solution def numSplits(self, s): left_count, right_count = collections.Counter(), collections.Counter(s) result = 0 for c in s: left_count[c] += 1 right_count[c] -= 1 if not right_count[c]: del right_count[c] if len(left_count) == len(right_count): result += 1 return result ", "class Solution def deleteDuplicates(self, head): dummy = ListNode(0) pre, cur = dummy, head while cur: if cur.next and cur.next.val == cur.val: val = cur.val while cur and cur.val == val: cur = cur.next pre.next = cur else: pre.next = cur pre = cur cur = cur.next return dummy.next ", "class Solution def minimumMountainRemovals(self, nums): left_lis_len = [0]*len(nums) lis = [] for i in xrange(len(nums)-1): j = bisect.bisect_left(lis, nums[i]) if j == len(lis): lis.append(nums[i]) else: lis[j] = nums[i] left_lis_len[i] = j max_len = 0 lis = [] for i in reversed(xrange(1, len(nums))): j = bisect.bisect_left(lis, nums[i]) if j == len(lis): lis.append(nums[i]) else: lis[j] = nums[i] if i < len(nums)-1: max_len = max(max_len, left_lis_len[i]+j) return len(nums) - (1+max_len) ", "class Solution def minSwaps(self, data): total_count = sum(data) result, count, left = 0, 0, 0 for i in xrange(len(data)): count += data[i] if i-left+1 > total_count: count -= data[left] left += 1 result = max(result, count) return total_count-result ", "class Solution def sortLinkedList(self, head): tail, curr, head.next = head, head.next, None while curr: if curr.val > 0: curr.next, tail.next, tail, curr = None, curr, curr, curr.next else: curr.next, head, curr = head, curr, curr.next return head ", "class Solution def numDistinctIslands2(self, grid): directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] def dfs(i, j, grid, island): if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] > 0): return False grid[i][j] *= -1 island.append((i, j)) for d in directions: dfs(i+d[0], j+d[1], grid, island) return True def normalize(island): shapes = [[] for _ in xrange(8)] for x, y in island: rotations_and_reflections = [[ x, y], [ x, -y], [-x, y], [-x, -y], [ y, x], [ y, -x], [-y, x], [-y, -x]] for i in xrange(len(rotations_and_reflections)): shapes[i].append(rotations_and_reflections[i]) for shape in shapes: shape.sort() origin = list(shape[0]) for p in shape: p[0] -= origin[0] p[1] -= origin[1] return min(shapes) islands = set() for i in xrange(len(grid)): for j in xrange(len(grid[0])): island = [] if dfs(i, j, grid, island): islands.add(str(normalize(island))) return len(islands) ", "class Solution def findPrimePairs(self, n): def linear_sieve_of_eratosthenes(n): primes = [] spf = [-1]*(n+1) for i in xrange(2, n+1): if spf[i] == -1: spf[i] = i primes.append(i) for p in primes: if i*p > n or p > spf[i]: break spf[i*p] = p return spf spf = linear_sieve_of_eratosthenes(n) return [[i, n-i] for i in xrange(2, n//2+1) if spf[i] == i and spf[n-i] == n-i] ", "class Solution def maxFont(self, text, w, h, fonts, fontInfo): def check(count, w, h, fonts, fontInfo, x): return (fontInfo.getHeight(fonts[x]) <= h and sum(cnt * fontInfo.getWidth(fonts[x], c) for c, cnt in count.iteritems()) <= w) count = collections.Counter(text) left, right = 0, len(fonts)-1 while left <= right: mid = left + (right-left)//2 if not check(count, w, h, fonts, fontInfo, mid): right = mid-1 else: left = mid+1 return fonts[right] if right >= 0 else -1 ", "class Solution def countPaths(self, grid): MOD = 10**9+7 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] in_degree = [[0]*len(grid[0]) for _ in xrange(len(grid))] q = [] for i in xrange(len(grid)): for j in xrange(len(grid[0])): for di, dj in directions: ni, nj = i+di, j+dj if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[i][j] > grid[ni][nj]: in_degree[i][j] += 1 if not in_degree[i][j]: q.append((i, j)) dp = [[1]*len(grid[0]) for _ in xrange(len(grid))] result = 0 while q: new_q = [] for i, j in q: result = (result+dp[i][j])%MOD for di, dj in directions: ni, nj = i+di, j+dj if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[i][j] < grid[ni][nj]): continue dp[ni][nj] = (dp[ni][nj]+dp[i][j])%MOD in_degree[ni][nj] -= 1 if not in_degree[ni][nj]: new_q.append((ni, nj)) q = new_q return result ", "class Solution def countPaths(self, grid): MOD = 10**9+7 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def memoization(grid, i, j, lookup): if not lookup[i][j]: lookup[i][j] = 1 for di, dj in directions: ni, nj = i+di, j+dj if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[i][j] < grid[ni][nj]: lookup[i][j] = (lookup[i][j]+memoization(grid, ni, nj, lookup)) % MOD return lookup[i][j] lookup = [[0]*len(grid[0]) for _ in xrange(len(grid))] return sum(memoization(grid, i, j, lookup) for i in xrange(len(grid)) for j in xrange(len(grid[0]))) % MOD ", "class Solution def minRefuelStops(self, target, startFuel, stations): max_heap = [] stations.append((target, float(\"inf\"))) result = prev = 0 for location, capacity in stations: startFuel -= location - prev while max_heap and startFuel < 0: startFuel += -heapq.heappop(max_heap) result += 1 if startFuel < 0: return -1 heapq.heappush(max_heap, -capacity) prev = location return result ", "class Solution def spiralMatrix(self, m, n, head): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] result = [[-1]*n for _ in xrange(m)] i = j = d = 0 while head: result[i][j] = head.val if not (0 <= i+directions[d][0] < m and 0 <= j+directions[d][1] < n and result[i+directions[d][0]][j+directions[d][1]] == -1): d = (d+1)%4 i, j = i+directions[d][0], j+directions[d][1] head = head.next return result ", "class Solution def minimumOperations(self, grid): INF = float(\"inf\") MAX_VALUE = 9 dp = [0]*(MAX_VALUE+1) for j in xrange(len(grid[0])): new_dp = [INF]*(MAX_VALUE+1) cnt = [0]*(MAX_VALUE+1) for i in xrange(len(grid)): cnt[grid[i][j]] += 1 k1 = min(xrange(MAX_VALUE+1), key=lambda x: dp[x]) k2 = min((i for i in xrange(MAX_VALUE+1) if i != k1), key=lambda x: dp[x]) for i in xrange(MAX_VALUE+1): new_dp[i] = min(new_dp[i], (dp[k1] if i != k1 else dp[k2])+(len(grid)-cnt[i])) dp = new_dp return min(dp) ", "class Solution def minimumOperations(self, grid): INF = float(\"inf\") MAX_VALUE = 9 dp = [0]*(MAX_VALUE+1) for j in xrange(len(grid[0])): new_dp = [INF]*(MAX_VALUE+1) cnt = [0]*(MAX_VALUE+1) for i in xrange(len(grid)): cnt[grid[i][j]] += 1 for i in xrange(MAX_VALUE+1): new_dp[i] = min(new_dp[i], min(dp[k] for k in xrange(MAX_VALUE+1) if k != i)+(len(grid)-cnt[i])) dp = new_dp return min(dp) ", "class Solution def canThreePartsEqualSum(self, A): total = sum(A) if total % 3 != 0: return False parts, curr = 0, 0 for x in A: curr += x if curr == total//3: parts += 1 curr = 0 return parts >= 3 ", "class Solution def wiggleSort(self, nums): nums.sort() mid = (len(nums) - 1) / 2 nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1] from random import randint ", "class Solution def wiggleSort(self, nums): def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 def reversedTriPartitionWithVI(nums, val): def idx(i, N): return (1 + 2 * (i)) % N N = len(nums) / 2 * 2 + 1 i, j, n = 0, 0, len(nums) - 1 while j <= n: if nums[idx(j, N)] > val: nums[idx(i, N)], nums[idx(j, N)] = nums[idx(j, N)], nums[idx(i, N)] i += 1 j += 1 elif nums[idx(j, N)] < val: nums[idx(j, N)], nums[idx(n, N)] = nums[idx(n, N)], nums[idx(j, N)] n -= 1 else: j += 1 mid = (len(nums)-1)//2 nth_element(nums, mid) reversedTriPartitionWithVI(nums, nums[mid]) ", "class Solution def maximumRequests(self, n, requests): for k in reversed(xrange(1, len(requests)+1)): for c in itertools.combinations(xrange(len(requests)), k): change = [0]*n for i in c: change[requests[i][0]] -= 1 change[requests[i][1]] += 1 if all(c == 0 for c in change): return k return 0 ", "class Solution def maximumRequests(self, n, requests): def evaluate(n, requests, mask): change = [0]*n base, count = 1, 0 for i in xrange(len(requests)): if base & mask: change[requests[i][0]] -= 1 change[requests[i][1]] += 1 count += 1 base <<= 1 return count if all(c == 0 for c in change) else 0 return max(evaluate(n, requests, i) for i in xrange(1 << len(requests))) ", "class Solution def minimumRounds(self, tasks): cnt = collections.Counter(tasks) return sum((x+2)//3 for x in cnt.itervalues()) if 1 not in cnt.itervalues() else -1 ", "class Solution def doesValidArrayExist(self, derived): return reduce(lambda total, x: total^x, derived, 0) == 0 ", "class Solution def printLinkedListInReverse(self, head): def print_nodes(head, count): nodes = [] while head and len(nodes) != count: nodes.append(head) head = head.getNext() for node in reversed(nodes): node.printValue() count = 0 curr = head while curr: curr = curr.getNext() count += 1 bucket_count = int(math.ceil(count**0.5)) buckets = [] count = 0 curr = head while curr: if count % bucket_count == 0: buckets.append(curr) curr = curr.getNext() count += 1 for node in reversed(buckets): print_nodes(node, bucket_count) ", "class Solution def printLinkedListInReverse(self, head): nodes = [] while head: nodes.append(head) head = head.getNext() for node in reversed(nodes): node.printValue() ", "class Solution def printLinkedListInReverse(self, head): tail = None while head != tail: curr = head while curr.getNext() != tail: curr = curr.getNext() curr.printValue() tail = curr ", "class Solution def minWindow(self, s, t): count, remain = collections.Counter(t), len(t) i, left, right = 0, -1, -1 for j, c in enumerate(s): remain -= count[c] > 0 count[c] -= 1 if remain: continue while count[s[i]] < 0: count[s[i]] += 1 i += 1 if right == -1 or j-i+1 < right-left+1: left, right = i, j return s[left:right+1] ", "class Solution def minWindow(self, s, t): current_count = [0 for i in xrange(52)] expected_count = [0 for i in xrange(52)] for char in t: expected_count[ord(char) - ord('a')] += 1 i, count, start, min_width, min_start = 0, 0, 0, float(\"inf\"), 0 while i < len(s): current_count[ord(s[i]) - ord('a')] += 1 if current_count[ord(s[i]) - ord('a')] <= expected_count[ord(s[i]) - ord('a')]: count += 1 if count == len(t): while expected_count[ord(s[start]) - ord('a')] == 0 or current_count[ord(s[start]) - ord('a')] > expected_count[ord(s[start]) - ord('a')]: current_count[ord(s[start]) - ord('a')] -= 1 start += 1 if min_width > i - start + 1: min_width = i - start + 1 min_start = start i += 1 if min_width == float(\"inf\"): return \"\" return s[min_start:min_start + min_width] ", "class Solution def numWaterBottles(self, numBottles, numExchange): result = numBottles while numBottles >= numExchange: numBottles, remainder = divmod(numBottles, numExchange) result += numBottles numBottles += remainder return result ", "class Solution def getSumAbsoluteDifferences(self, nums): prefix, suffix = 0, sum(nums) result = [] for i, num in enumerate(nums): suffix -= num result.append((i*num-prefix) + (suffix-((len(nums)-1)-i)*num)) prefix += num return result ", "class Solution def minDeletion(self, nums): result = 0 for i in xrange(len(nums)-1): result += int(i%2 == result%2 and nums[i] == nums[i+1]) return result+(len(nums)-result)%2 ", "class Solution def moveSubTree(self, root, p, q): def iter_find_parents(node, parent, p, q, is_ancestor, lookup): stk = [(1, [node, None, False])] while stk: step, params = stk.pop() if step == 1: node, parent, is_ancestor = params if node in (p, q): lookup[node] = parent if len(lookup) == 2: return is_ancestor stk.append((2, [node, is_ancestor, reversed(node.children)])) else: node, is_ancestor, it = params child = next(it, None) if not child: continue stk.append((2, [node, is_ancestor, it])) stk.append((1, [child, node, is_ancestor or node == p])) assert(False) return False lookup = {} is_ancestor = iter_find_parents(root, None, p, q, False, lookup) if p in lookup and lookup[p] == q: return root q.children.append(p) if not is_ancestor: lookup[p].children.remove(p) else: lookup[q].children.remove(q) if p == root: root = q else: lookup[p].children[lookup[p].children.index(p)] = q return root class Solution_Recu(object): def moveSubTree(self, root, p, q): def find_parents(node, parent, p, q, is_ancestor, lookup): if node in (p, q): lookup[node] = parent if len(lookup) == 2: return True, is_ancestor for child in node.children: found, new_is_ancestor = find_parents(child, node, p, q, is_ancestor or node == p, lookup) if found: return True, new_is_ancestor return False, False lookup = {} is_ancestor = find_parents(root, None, p, q, False, lookup)[1] if p in lookup and lookup[p] == q: return root q.children.append(p) if not is_ancestor: lookup[p].children.remove(p) else: lookup[q].children.remove(q) if p == root: root = q else: lookup[p].children[lookup[p].children.index(p)] = q return root ", "class Solution def moveSubTree(self, root, p, q): def iter_find_parents(node, parent, p, q, lookup): stk = [(1, [node, None])] while stk: step, params = stk.pop() if step == 1: node, parent = params if node in (p, q): lookup[node] = parent if len(lookup) == 2: return stk.append((2, [node, reversed(node.children)])) else: node, it = params child = next(it, None) if not child: continue stk.append((2, [node, it])) stk.append((1, [child, node])) def iter_is_ancestor(node, q): stk = [(1, [node])] while stk: step, params = stk.pop() if step == 1: node = params[0] stk.append((2, [reversed(node.children)])) else: it = params[0] child = next(it, None) if not child: continue if child == q: return True stk.append((2, [it])) stk.append((1, [child])) return False lookup = {} iter_find_parents(root, None, p, q, lookup) if p in lookup and lookup[p] == q: return root q.children.append(p) if not iter_is_ancestor(p, q): lookup[p].children.remove(p) else: lookup[q].children.remove(q) if p == root: root = q else: lookup[p].children[lookup[p].children.index(p)] = q return root class Solution2_Recu(object): def moveSubTree(self, root, p, q): def find_parents(node, parent, p, q, lookup): if node in (p, q): lookup[node] = parent if len(lookup) == 2: return True for child in node.children: if find_parents(child, node, p, q, lookup): return True return False def is_ancestor(node, q): for child in node.children: if node == q or is_ancestor(child, q): return True return False lookup = {} find_parents(root, None, p, q, lookup) if p in lookup and lookup[p] == q: return root q.children.append(p) if not is_ancestor(p, q): lookup[p].children.remove(p) else: lookup[q].children.remove(q) if p == root: root = q else: lookup[p].children[lookup[p].children.index(p)] = q return root ", "class Solution def distanceTraveled(self, mainTank, additionalTank): USE, REFILL, DIST = 5, 1, 10 cnt = min((mainTank-REFILL)//(USE-REFILL), additionalTank) return (mainTank+cnt*REFILL)*DIST ", "class Solution def minimumDistance(self, word): def distance(a, b): return abs(a//6 - b//6) + abs(a%6 - b%6) dp = [0]*26 for i in xrange(len(word)-1): b, c = ord(word[i])-ord('A'), ord(word[i+1])-ord('A') dp[b] = max(dp[a] - distance(a, c) + distance(b, c) for a in xrange(26)) return sum(distance(ord(word[i])-ord('A'), ord(word[i+1])-ord('A')) for i in xrange(len(word)-1)) - max(dp) ", "class Solution def minimumDistance(self, word): def distance(a, b): if -1 in [a, b]: return 0 return abs(a//6 - b//6) + abs(a%6 - b%6) dp = {(-1, -1): 0} for c in word: c = ord(c)-ord('A') new_dp = {} for a, b in dp: new_dp[c, b] = min(new_dp.get((c, b), float(\"inf\")), dp[a, b] + distance(a, c)) new_dp[a, c] = min(new_dp.get((a, c), float(\"inf\")), dp[a, b] + distance(b, c)) dp = new_dp return min(dp.itervalues()) ", "class Solution def strongPasswordCheckerII(self, password): SPECIAL = set(\"!@#$%^&*()-+\") return (len(password) >= 8 and any(c.islower() for c in password) and any(c.isupper() for c in password) and any(c.isdigit() for c in password) and any(c in SPECIAL for c in password) and all(password[i] != password[i+1] for i in xrange(len(password)-1))) ", "class Solution def isPowerOfFour(self, num): return num > 0 and (num & (num - 1)) == 0 and ((num & 0b01010101010101010101010101010101) == num) ", "class Solution def isPowerOfFour(self, num): while num and not (num & 0b11): num >>= 2 return (num == 1) ", "class Solution def isPowerOfFour(self, num): num = bin(num) return True if num[2:].startswith('1') and len(num[2:]) == num.count('0') and num.count('0') % 2 and '-' not in num else False ", "class Solution def mostFrequent(self, nums, key): return collections.Counter(nums[i+1] for i in xrange(len(nums)-1) if nums[i] == key).most_common(1)[0][0] ", "class Solution def maxMoves(self, grid): dp = [True]*len(grid) result = 0 for c in xrange(len(grid[0])-1): new_dp = [False]*len(grid) for r in xrange(len(grid)): if not dp[r]: continue if grid[r][c] < grid[r][c+1]: new_dp[r] = True if r-1 >= 0 and grid[r][c] < grid[r-1][c+1]: new_dp[r-1] = True if r+1 < len(grid) and grid[r][c] < grid[r+1][c+1]: new_dp[r+1] = True dp = new_dp if not sum(dp): break else: c = len(grid[0])-1 return c ", "class Solution def maxMoves(self, grid): dp = [0]*len(grid) for c in reversed(xrange(len(grid[0])-1)): new_dp = [0]*len(grid) for r in xrange(len(grid)): if grid[r][c] < grid[r][c+1]: new_dp[r] = max(new_dp[r], dp[r]+1) if r-1 >= 0 and grid[r][c] < grid[r-1][c+1]: new_dp[r] = max(new_dp[r], dp[r-1]+1) if r+1 < len(grid) and grid[r][c] < grid[r+1][c+1]: new_dp[r] = max(new_dp[r], dp[r+1]+1) dp = new_dp return max(dp) ", "class Solution def maxMoves(self, grid): q = set(xrange(len(grid))) for c in xrange(len(grid[0])-1): new_q = set() for r in q: if grid[r][c] < grid[r][c+1]: new_q.add(r) if r-1 >= 0 and grid[r][c] < grid[r-1][c+1]: new_q.add(r-1) if r+1 < len(grid) and grid[r][c] < grid[r+1][c+1]: new_q.add(r+1) q = new_q if not q: break else: c = len(grid[0])-1 return c ", "class Solution def parseBoolExpr(self, expression): def parse(expression, i): if expression[i[0]] not in \"&|!\": result = expression[i[0]] == 't' i[0] += 1 return result op = expression[i[0]] i[0] += 2 stk = [] while expression[i[0]] != ')': if expression[i[0]] == ',': i[0] += 1 continue stk.append(parse(expression, i)) i[0] += 1 if op == '&': return all(stk) if op == '|': return any(stk) return not stk[0] return parse(expression, [0]) ", "class Solution def uniquePathsIII(self, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def index(grid, r, c): return 1 << (r*len(grid[0])+c) def dp(grid, src, dst, todo, lookup): if src == dst: return int(todo == 0) key = (src, todo) if key in lookup: return lookup[key] result = 0 for d in directions: r, c = src[0]+d[0], src[1]+d[1] if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] % 2 == 0 and todo & index(grid, r, c): result += dp(grid, (r, c), dst, todo ^ index(grid, r, c), lookup) lookup[key] = result return lookup[key] todo = 0 src, dst = None, None for r, row in enumerate(grid): for c, val in enumerate(row): if val % 2 == 0: todo |= index(grid, r, c) if val == 1: src = (r, c) elif val == 2: dst = (r, c) return dp(grid, src, dst, todo, {}) ", "class Solution def maximumANDSum(self, nums, numSlots): def hungarian(a): if not a: return 0, [] n, m = len(a)+1, len(a[0])+1 u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1) for i in xrange(1, n): p[0] = i j0 = 0 dist, pre = [float(\"inf\")]*m, [-1]*m done = [False]*(m+1) while True: done[j0] = True i0, j1, delta = p[j0], None, float(\"inf\") for j in xrange(1, m): if done[j]: continue cur = a[i0-1][j-1]-u[i0]-v[j] if cur < dist[j]: dist[j], pre[j] = cur, j0 if dist[j] < delta: delta, j1 = dist[j], j for j in xrange(m): if done[j]: u[p[j]] += delta v[j] -= delta else: dist[j] -= delta j0 = j1 if not p[j0]: break while j0: j1 = pre[j0] p[j0], j0 = p[j1], j1 for j in xrange(1, m): if p[j]: ans[p[j]-1] = j-1 return -v[0], ans return -hungarian([[-((nums[i] if i < len(nums) else 0) & (1+x//2)) for x in xrange(2*numSlots)] for i in xrange(2*numSlots)])[0] from scipy.optimize import linear_sum_assignment as hungarian import itertools ", "class Solution def maximumANDSum(self, nums, numSlots): adj = [[-((nums[i] if i < len(nums) else 0) & (1+x//2)) for x in xrange(2*numSlots)] for i in xrange(2*numSlots)] return -sum(adj[i][j] for i, j in itertools.izip(*hungarian(adj))) ", "class Solution def maximumANDSum(self, nums, numSlots): def count(x): result = 0 while x: result += x%3 x //= 3 return result dp = [0]*(3**numSlots) for mask in xrange(1, len(dp)): i = count(mask)-1 x = nums[i] if i < len(nums) else 0 base = 1 for slot in xrange(1, numSlots+1): if mask//base%3: dp[mask] = max(dp[mask], (x&slot)+dp[mask-base]) base *= 3 return dp[-1] ", "class Solution def maximumANDSum(self, nums, numSlots): def memoiztion(i, mask): if lookup[mask] != -1: return lookup[mask] x = nums[i] if i < len(nums) else 0 base = 1 for slot in xrange(1, numSlots+1): if mask//base%3: lookup[mask] = max(lookup[mask], (x&slot)+memoiztion(i-1, mask-base)) base *= 3 return lookup[mask] lookup = [-1]*(3**numSlots) lookup[0] = 0 return memoiztion(2*numSlots-1, 3**numSlots-1) ", "class Solution def sumCounts(self, nums): MOD = 10**9+7 class BIT(object): def __init__(self, n): self.__bit = [0]*(n+1) def add(self, i, val): i += 1 while i < len(self.__bit): self.__bit[i] = (self.__bit[i]+val) % MOD i += (i & -i) def query(self, i): i += 1 ret = 0 while i > 0: ret = (ret+self.__bit[i]) % MOD i -= (i & -i) return ret def update(accu, d): i = sl.bisect_left(idxs[x][-1]) accu = (accu + d*(len(nums)*(2*len(sl)-1) - (2*i+1)*idxs[x][-1] - 2*(bit.query(len(nums)-1)-bit.query(idxs[x][-1])))) % MOD bit.add(idxs[x][-1], d*idxs[x][-1]) return accu idxs = collections.defaultdict(list) for i in reversed(xrange(len(nums))): idxs[nums[i]].append(i) result = 0 sl = SortedList(idxs[x][-1] for x in idxs) accu = (len(nums)*len(sl)**2) % MOD for i, x in enumerate(sl): accu = (accu-(2*i+1)*x) % MOD bit = BIT(len(nums)) for x in sl: bit.add(x, x) for x in nums: result = (result+accu) % MOD accu = update(accu, -1) del sl[0] idxs[x].pop() if not idxs[x]: continue sl.add(idxs[x][-1]) accu = update(accu, +1) assert(accu == 0) return result ", "class Solution def sumCounts(self, nums): MOD = 10**9+7 class SegmentTree(object): def __init__(self, N, build_fn=None, query_fn=lambda x, y: y if x is None else x if y is None else (x+y)%MOD, update_fn=lambda x, y: y if x is None else (x+y)%MOD): self.tree = [None]*(1<<((N-1).bit_length()+1)) self.base = len(self.tree)>>1 self.lazy = [None]*self.base self.query_fn = query_fn self.update_fn = update_fn if build_fn is not None: for i in xrange(self.base, self.base+N): self.tree[i] = build_fn(i-self.base) for i in reversed(xrange(1, self.base)): self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1]) self.count = [1]*len(self.tree) for i in reversed(xrange(1, self.base)): self.count[i] = self.count[i<<1] + self.count[(i<<1)+1] def __apply(self, x, val): self.tree[x] = self.update_fn(self.tree[x], val*self.count[x]) if x < self.base: self.lazy[x] = self.update_fn(self.lazy[x], val) def __push(self, x): for h in reversed(xrange(1, x.bit_length())): y = x>>h if self.lazy[y] is not None: self.__apply(y<<1, self.lazy[y]) self.__apply((y<<1)+1, self.lazy[y]) self.lazy[y] = None def update(self, L, R, h): def pull(x): while x > 1: x >>= 1 self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1]) if self.lazy[x] is not None: self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x]) L += self.base R += self.base L0, R0 = L, R while L <= R: if L & 1: self.__apply(L, h) L += 1 if R & 1 == 0: self.__apply(R, h) R -= 1 L >>= 1 R >>= 1 pull(L0) pull(R0) def query(self, L, R): if L > R: return None L += self.base R += self.base self.__push(L) self.__push(R) left = right = None while L <= R: if L & 1: left = self.query_fn(left, self.tree[L]) L += 1 if R & 1 == 0: right = self.query_fn(self.tree[R], right) R -= 1 L >>= 1 R >>= 1 return self.query_fn(left, right) result = accu = 0 sl = {} st = SegmentTree(len(nums)) for i in xrange(len(nums)): j = sl[nums[i]] if nums[i] in sl else -1 accu = (accu+((i-j)+2*max(st.query(j+1, i), 0)))%MOD result = (result+accu)%MOD st.update(j+1, i, 1) sl[nums[i]] = i return result ", "class Solution def sumCounts(self, nums): MOD = 10**9+7 result = 0 for i in xrange(len(nums)): lookup = set() for j in reversed(xrange(i+1)): lookup.add(nums[j]) result = (result+len(lookup)**2) % MOD return result ", "class Solution def isRobotBounded(self, instructions): directions = [[ 1, 0], [0, -1], [-1, 0], [0, 1]] x, y, i = 0, 0, 0 for instruction in instructions: if instruction == 'R': i = (i+1) % 4; elif instruction == 'L': i = (i-1) % 4; else: x += directions[i][0] y += directions[i][1] return (x == 0 and y == 0) or i > 0 ", "class Solution def minBuildTime(self, blocks, split): heapq.heapify(blocks) while len(blocks) != 1: x, y = heapq.heappop(blocks), heapq.heappop(blocks) heapq.heappush(blocks, y+split) return heapq.heappop(blocks) ", "class Solution def numDifferentIntegers(self, word): result, num = set(), None for i in xrange(len(word)+1): c = word[i] if i < len(word) else ' ' if c.isdigit(): num = 10*num+int(c) if num is not None else int(c) elif num is not None: result.add(num) num = None return len(result) ", "class Solution def minimumDifference(self, nums, k): nums.sort() return min(nums[i]-nums[i-k+1] for i in xrange(k-1, len(nums))) ", "class Solution def sumOfUnique(self, nums): return sum(x for x, c in collections.Counter(nums).iteritems() if c == 1) ", "class Solution def minimumOperationsToMakeEqual(self, x, y): def memoization(x): if y >= x: return y-x if x not in lookup: lookup[x] = min(x-y, min(min(x%d, d-x%d)+memoization(x//d+int(d-x%d < x%d))+1 for d in (5, 11))) return lookup[x] lookup = {} return memoization(x) ", "class Solution def minimumOperationsToMakeEqual(self, x, y): if y >= x: return y-x upper_bound = x+(x-y) result = 0 lookup = {x} q = [x] while q: new_q = [] for x in q: if x == y: return result candidates = [x+1, x-1] for d in (5, 11): if x%d == 0: candidates.append(x//d) for new_x in candidates: if not (0 <= new_x <= upper_bound and new_x not in lookup): continue lookup.add(new_x) new_q.append(new_x) q = new_q result += 1 return -1 ", "class Solution def smallestEqual(self, nums): return next((i for i, x in enumerate(nums) if i%10 == x), -1) ", "class Solution def maxCoins(self, piles): piles.sort() return sum(itertools.islice(piles, len(piles)//3, len(piles), 2)) ", "class Solution def numDupDigitsAtMostN(self, N): def P(m, n): result = 1 for _ in xrange(n): result *= m m -= 1 return result digits = map(int, str(N+1)) result = 0 for i in xrange(1, len(digits)): result += P(9, 1)*P(9, i-1) prefix_set = set() for i, x in enumerate(digits): for y in xrange(1 if i == 0 else 0, x): if y in prefix_set: continue result += P(9-i, len(digits)-i-1) if x in prefix_set: break prefix_set.add(x) return N-result ", "class Solution def minAreaRect(self, points): nx = len(set(x for x, y in points)) ny = len(set(y for x, y in points)) p = collections.defaultdict(list) if nx > ny: for x, y in points: p[x].append(y) else: for x, y in points: p[y].append(x) lookup = {} result = float(\"inf\") for x in sorted(p): p[x].sort() for j in xrange(len(p[x])): for i in xrange(j): y1, y2 = p[x][i], p[x][j] if (y1, y2) in lookup: result = min(result, (x-lookup[y1, y2]) * (y2-y1)) lookup[y1, y2] = x return result if result != float(\"inf\") else 0 ", "class Solution def minAreaRect(self, points): lookup = set() result = float(\"inf\") for x1, y1 in points: for x2, y2 in lookup: if (x1, y2) in lookup and (x2, y1) in lookup: result = min(result, abs(x1-x2) * abs(y1-y2)) lookup.add((x1, y1)) return result if result != float(\"inf\") else 0 ", "class Solution def soupServings(self, N): def dp(a, b, lookup): if (a, b) in lookup: return lookup[a, b] if a <= 0 and b <= 0: return 0.5 if a <= 0: return 1.0 if b <= 0: return 0.0 lookup[a, b] = 0.25 * (dp(a-4, b, lookup) + dp(a-3, b-1, lookup) + dp(a-2, b-2, lookup) + dp(a-1, b-3, lookup)) return lookup[a, b] if N >= 4800: return 1.0 lookup = {} N = (N+24)//25 return dp(N, N, lookup) ", "class Solution def ways(self, pizza, k): MOD = 10**9+7 prefix = [[0]*len(pizza[0]) for _ in xrange(len(pizza))] for j in reversed(xrange(len(pizza[0]))): accu = 0 for i in reversed(xrange(len(pizza))): accu += int(pizza[i][j] == 'A') prefix[i][j] = (prefix[i][j+1] if (j+1 < len(pizza[0])) else 0) + accu dp = [[[0]*k for _ in xrange(len(pizza[0]))] for _ in xrange(len(pizza))] for i in reversed(xrange(len(pizza))): for j in reversed(xrange(len(pizza[0]))): dp[i][j][0] = 1 for m in xrange(1, k): for n in xrange(i+1, len(pizza)): if prefix[i][j] == prefix[n][j]: continue if prefix[n][j] == 0: break dp[i][j][m] = (dp[i][j][m] + dp[n][j][m-1]) % MOD for n in xrange(j+1, len(pizza[0])): if prefix[i][j] == prefix[i][n]: continue if prefix[i][n] == 0: break dp[i][j][m] = (dp[i][j][m] + dp[i][n][m-1]) % MOD return dp[0][0][k-1] ", "class Solution def minimumRefill(self, plants, capacityA, capacityB): result = 0 left, right = 0, len(plants)-1 canA, canB = capacityA, capacityB while left < right: if canA < plants[left]: result += 1 canA = capacityA canA -= plants[left] if canB < plants[right]: result += 1 canB = capacityB canB -= plants[right] left, right = left+1, right-1 if left == right: if max(canA, canB) < plants[left]: result += 1 return result ", "class Solution def specialPerm(self, nums): MOD = 10**9+7 def backtracking(i, mask): if mask == (1<<len(nums))-1: return 1 if lookup[i+1][mask] == -1: total = 0 for j in xrange(len(nums)): if mask&(1<<j): continue if not (i == -1 or nums[i]%nums[j] == 0 or nums[j]%nums[i] == 0): continue total = (total+backtracking(j, mask|(1<<j)))%MOD lookup[i+1][mask] = total return lookup[i+1][mask] lookup = [[-1]*(1<<len(nums)) for _ in xrange(len(nums)+1)] return backtracking(-1, 0) ", "class Solution def deleteDuplicates(self, head): cur = head while cur: runner = cur.next while runner and runner.val == cur.val: runner = runner.next cur.next = runner cur = runner return head def deleteDuplicates2(self, head): if not head: return head if head.next: if head.val == head.next.val: head = self.deleteDuplicates2(head.next) else: head.next = self.deleteDuplicates2(head.next) return head ", "class Solution def hasPathSum(self, root, sum): if root is None: return False if root.left is None and root.right is None and root.val == sum: return True return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val) ", "class Solution def countGoodSubsequences(self, s): MOD = 10**9+7 fact, inv, inv_fact = [[1]*2 for _ in xrange(3)] def nCr(n, k): if not (0 <= k <= n): return 0 while len(inv) <= n: fact.append(fact[-1]*len(inv) % MOD) inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) inv_fact.append(inv_fact[-1]*inv[-1] % MOD) return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD cnt = collections.Counter(s) return reduce(lambda total, k: (total+reduce(lambda total, x: total*(1+nCr(x, k))%MOD, cnt.itervalues(), 1)-1)%MOD, xrange(1, max(cnt.itervalues())+1), 0) ", "class Solution def amountPainted(self, paint): points = collections.defaultdict(list) for i, (s, e) in enumerate(paint): points[s].append((True, i)) points[e].append((False, i)) min_heap = [] lookup = [False]*len(paint) result = [0]*len(paint) prev = -1 for pos in sorted(points.iterkeys()): while min_heap and lookup[min_heap[0]]: heapq.heappop(min_heap) if min_heap: result[min_heap[0]] += pos-prev prev = pos for t, i in points[pos]: if t: heapq.heappush(min_heap, i) else: lookup[i] = True return result from sortedcontainers import SortedList ", "class Solution def amountPainted(self, paint): points = collections.defaultdict(list) for i, (s, e) in enumerate(paint): points[s].append((True, i)) points[e].append((False, i)) sl = SortedList() result = [0]*len(paint) prev = -1 for pos in sorted(points.iterkeys()): if sl: result[sl[0]] += pos-prev prev = pos for t, i in points[pos]: if t: sl.add(i) else: sl.remove(i) return result class SegmentTree(object): def __init__(self, N, build_fn=lambda x: 0, query_fn=lambda x, y: y if x is None else x+y, update_fn=lambda x, y: y): self.tree = [None]*(2*N) self.lazy = [None]*len(self.tree) self.base = len(self.tree)//2 self.H = (self.base-1).bit_length() self.query_fn = query_fn self.update_fn = update_fn for i in xrange(self.base, self.base+N): self.tree[i] = build_fn(i-self.base) for i in reversed(xrange(1, self.base)): self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1]) self.count = [1]*(2*N) for i in reversed(xrange(1, N)): self.count[i] = self.count[2*i] + self.count[2*i+1] def __apply(self, x, val): self.tree[x] = self.update_fn(self.tree[x], val*self.count[x]) if x < self.base: self.lazy[x] = self.update_fn(self.lazy[x], val) def __push(self, x): n = 2**self.H while n != 1: y = x // n if self.lazy[y] is not None: self.__apply(y*2, self.lazy[y]) self.__apply(y*2 + 1, self.lazy[y]) self.lazy[y] = None n //= 2 def update(self, L, R, h): def pull(x): while x > 1: x //= 2 self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1]) if self.lazy[x] is not None: self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x]) if L > R: return L += self.base R += self.base self.__push(L) self.__push(R) L0, R0 = L, R while L <= R: if L & 1: self.__apply(L, h) L += 1 if R & 1 == 0: self.__apply(R, h) R -= 1 L //= 2 R //= 2 pull(L0) pull(R0) def query(self, L, R): result = None if L > R: return result L += self.base R += self.base self.__push(L) self.__push(R) while L <= R: if L & 1: result = self.query_fn(result, self.tree[L]) L += 1 if R & 1 == 0: result = self.query_fn(result, self.tree[R]) R -= 1 L //= 2 R //= 2 return result class SolutionTLE(object): def amountPainted(self, paint): result = [] st = SegmentTree(max(e for _, e in paint)) for s, e in paint: cnt = st.query(s, e-1) st.update(s, e-1, 1) result.append(st.query(s, e-1)-cnt) return result ", "class Solution def allCellsDistOrder(self, R, C, r0, c0): def append(R, C, r, c, result): if 0 <= r < R and 0 <= c < C: result.append([r, c]) result = [[r0, c0]] for d in xrange(1, R+C): append(R, C, r0-d, c0, result) for x in xrange(-d+1, d): append(R, C, r0+x, c0+abs(x)-d, result) append(R, C, r0+x, c0+d-abs(x), result) append(R, C, r0+d, c0, result) return result ", "class Solution def gridIllumination(self, N, lamps, queries): lookup = set() row = collections.defaultdict(int) col = collections.defaultdict(int) diag = collections.defaultdict(int) anti = collections.defaultdict(int) for r, c in lamps: if (r, c) in lookup: continue lookup.add((r, c)) row[r] += 1 col[c] += 1 diag[r-c] += 1 anti[r+c] += 1 result = [] for r, c in queries: if not (row[r] or col[c] or diag[r-c] or anti[r+c]): result.append(0) continue result.append(1) for nr in xrange(max(r-1, 0), min(r+1, N-1)+1): for nc in xrange(max(c-1, 0), min(c+1, N-1)+1): if (nr, nc) not in lookup: continue lookup.remove((nr, nc)) row[nr] -= 1 col[nc] -= 1 diag[nr-nc] -= 1 anti[nr+nc] -= 1 return result ", "class Solution def longestSubarray(self, nums): count, left = 0, 0 for right in xrange(len(nums)): count += (nums[right] == 0) if count >= 2: count -= (nums[left] == 0) left += 1 return (right-left+1)-1 ", "class Solution def longestSubarray(self, nums): result, count, left = 0, 0, 0 for right in xrange(len(nums)): count += (nums[right] == 0) while count >= 2: count -= (nums[left] == 0) left += 1 result = max(result, right-left+1) return result-1 ", "class Solution def equalToDescendants(self, root): def iter_dfs(node): result = 0 stk = [(1, [node, [0]])] while stk: step, args = stk.pop() if step == 1: node, ret = args if not node: continue ret1, ret2 = [0], [0] stk.append((2, [node, ret1, ret2, ret])) stk.append((1, [node.right, ret2])) stk.append((1, [node.left, ret1])) elif step == 2: node, ret1, ret2, ret = args if node.val == ret1[0]+ret2[0]: result += 1 ret[0] = ret1[0]+ret2[0]+node.val return result return iter_dfs(root) ", "class Solution def equalToDescendants(self, root): def dfs(node, result): if not node: return 0 total = dfs(node.left, result) + dfs(node.right, result) if node.val == total: result[0] += 1 return total+node.val result = [0] dfs(root, result) return result[0] ", "class Solution def baseNeg2(self, N): result = [] while N: result.append(str(-N & 1)) N = -(N >> 1) result.reverse() return \"\".join(result) if result else \"0\" ", "class Solution def baseNeg2(self, N): BASE = -2 result = [] while N: N, r = divmod(N, BASE) if r < 0: r -= BASE N += 1 result.append(str(r)) result.reverse() return \"\".join(result) if result else \"0\" ", "class Solution def badSensor(self, sensor1, sensor2): for i in xrange(len(sensor1)-1): if sensor1[i] == sensor2[i]: continue while i+1 < len(sensor2) and sensor2[i+1] == sensor1[i]: i += 1 return 1 if i+1 == len(sensor2) else 2 return -1 ", "class Solution def treeToDoublyList(self, root): if not root: return None left_head, left_tail, right_head, right_tail = root, root, root, root if root.left: left_head = self.treeToDoublyList(root.left) left_tail = left_head.left if root.right: right_head = self.treeToDoublyList(root.right) right_tail = right_head.left left_tail.right, right_head.left = root, root root.left, root.right = left_tail, right_head left_head.left, right_tail.right = right_tail, left_head return left_head ", "class Solution def findBuildings(self, heights): result = [] for i, h in enumerate(heights): while result and heights[result[-1]] <= h: result.pop() result.append(i) return result ", "class Solution def findBuildings(self, heights): result = [] for i in reversed(xrange(len(heights))): if not result or heights[result[-1]] < heights[i]: result.append(i) result.reverse() return result ", "class Solution def idealArrays(self, n, maxValue): MOD = 10**9+7 fact, inv, inv_fact = [[1]*2 for _ in xrange(3)] def nCr(n, k): while len(inv) <= n: fact.append(fact[-1]*len(inv) % MOD) inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) inv_fact.append(inv_fact[-1]*inv[-1] % MOD) return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD def linear_sieve_of_eratosthenes(n): primes = [] spf = [-1]*(n+1) for i in xrange(2, n+1): if spf[i] == -1: spf[i] = i primes.append(i) for p in primes: if i*p > n or p > spf[i]: break spf[i*p] = p return primes def prime_factors(x): factors = collections.Counter() for p in primes: if p*p > x: break while x%p == 0: factors[p] += 1 x //= p if x != 1: factors[x] += 1 return factors primes = linear_sieve_of_eratosthenes(int(maxValue**0.5)) result = 0 for k in xrange(1, maxValue+1): total = 1 for c in prime_factors(k).itervalues(): total = (total*nCr(n+c-1, c))%MOD result = (result+total)%MOD return result import collections ", "class Solution def idealArrays(self, n, maxValue): MOD = 10**9+7 fact, inv, inv_fact = [[1]*2 for _ in xrange(3)] def nCr(n, k): while len(inv) <= n: fact.append(fact[-1]*len(inv) % MOD) inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) inv_fact.append(inv_fact[-1]*inv[-1] % MOD) return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD result = 0 dp = collections.Counter(xrange(1, maxValue+1)) for i in xrange(n): new_dp = collections.Counter() total = 0 for x, c in dp.iteritems(): total = (total+c)%MOD for y in xrange(x+x, maxValue+1, x): new_dp[y] += c result = (result+total*nCr(n-1, i))%MOD dp = new_dp return result ", "class Solution def divideString(self, s, k, fill): return [s[i:i+k] + fill*(i+k-len(s)) for i in xrange(0, len(s), k)] ", "class Solution def kItemsWithMaximumSum(self, numOnes, numZeros, numNegOnes, k): return min(numOnes, k)-max(k-numOnes-numZeros, 0) ", "class Solution def maximumSafenessFactor(self, grid): DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1)) def bfs(): dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))] q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]] d = 0 while q: new_q = [] for r, c in q: for dr, dc in DIRECTIONS: nr, nc = r+dr, c+dc if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] == -1): continue dist[nr][nc] = d+1 new_q.append((nr, nc)) q = new_q d += 1 return dist dist = bfs() buckets = [[] for _ in xrange((len(grid)-1)+(len(grid[0])-1)+1)] for r in xrange(len(grid)): for c in xrange(len(grid[0])): buckets[dist[r][c]].append((r, c)) lookup = [[False]*len(grid[0]) for _ in xrange(len(grid))] uf = UnionFind(len(grid)*len(grid[0])) for d in reversed(xrange(len(buckets))): for r, c in buckets[d]: for dr, dc in DIRECTIONS: nr, nc = r+dr, c+dc if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and lookup[nr][nc] == True): continue uf.union_set(nr*len(grid[0])+nc, r*len(grid[0])+c) lookup[r][c] = True if uf.find_set(0*len(grid[0])+0) == uf.find_set((len(grid)-1)*len(grid[0])+(len(grid[0])-1)): break return d import heapq ", "class Solution def maximumSafenessFactor(self, grid): DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1)) def bfs(): dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))] q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]] d = 0 while q: new_q = [] for r, c in q: for dr, dc in DIRECTIONS: nr, nc = r+dr, c+dc if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] == -1): continue dist[nr][nc] = d+1 new_q.append((nr, nc)) q = new_q d += 1 return dist def dijkstra(start, target): max_heap = [(-dist[start[0]][start[1]], start)] dist[start[0]][start[1]] = -1 while max_heap: curr, u = heapq.heappop(max_heap) curr = -curr if u == target: return curr for dr, dc in DIRECTIONS: nr, nc = u[0]+dr, u[1]+dc if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] != -1): continue heapq.heappush(max_heap, (-min(curr, dist[nr][nc]), (nr, nc))) dist[nr][nc] = -1 return -1 dist = bfs() return dijkstra(dist, (0, 0), (len(grid)-1, len(grid[0])-1)) import heapq ", "class Solution def maximumSafenessFactor(self, grid): DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1)) def bfs(): dist = [[0 if grid[r][c] == 1 else -1 for c in xrange(len(grid[0]))] for r in xrange(len(grid))] q = [(r, c) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c]] d = 0 while q: new_q = [] for r, c in q: for dr, dc in DIRECTIONS: nr, nc = r+dr, c+dc if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] == -1): continue dist[nr][nc] = d+1 new_q.append((nr, nc)) q = new_q d += 1 return dist def check(x): lookup = [[False]*len(dist[0]) for _ in xrange(len(dist))] q = [(0, 0)] lookup[0][0] = True while q: new_q = [] for r, c in q: for dr, dc in DIRECTIONS: nr, nc = r+dr, c+dc if not (0 <= nr < len(dist) and 0 <= nc < len(dist[0]) and dist[nr][nc] >= x and not lookup[nr][nc]): continue lookup[nr][nc] = True new_q.append((nr, nc)) q = new_q return lookup[-1][-1] dist = bfs() left, right = 0, dist[0][0] while left <= right: mid = left + (right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right ", "class Solution def alphabetBoardPath(self, target): x, y = 0, 0 result = [] for c in target: y1, x1 = divmod(ord(c)-ord('a'), 5) result.append('U' * max(y-y1, 0)) result.append('L' * max(x-x1, 0)) result.append('R' * max(x1-x, 0)) result.append('D' * max(y1-y, 0)) result.append('!') x, y = x1, y1 return \"\".join(result) ", "class Solution def satisfiesConditions(self, grid): return (all(grid[i][j] == grid[i+1][j] for j in xrange(len(grid[0])) for i in xrange(len(grid)-1)) and all(grid[0][j] != grid[0][j+1] for j in xrange(len(grid[0])-1))) ", "class Solution def minIncrements(self, n, cost): result = 0 for i in reversed(xrange(n//2)): result += abs(cost[2*i+1]-cost[2*i+2]) cost[i] += max(cost[2*i+1], cost[2*i+2]) return result ", "class Solution def addBinary(self, a, b): result, carry, val = \"\", 0, 0 for i in xrange(max(len(a), len(b))): val = carry if i < len(a): val += int(a[-(i + 1)]) if i < len(b): val += int(b[-(i + 1)]) carry, val = divmod(val, 2) result += str(val) if carry: result += str(carry) return result[::-1] from itertools import izip_longest ", "class Solution def addBinary(self, a, b): result = \"\" carry = 0 for x, y in izip_longest(reversed(a), reversed(b), fillvalue=\"0\"): carry, remainder = divmod(int(x)+int(y)+carry, 2) result += str(remainder) if carry: result += str(carry) return result[::-1] ", "class Solution def getFolderNames(self, names): count = collections.Counter() result, lookup = [], set() for name in names: while True: name_with_suffix = \"{}({})\".format(name, count[name]) if count[name] else name count[name] += 1 if name_with_suffix not in lookup: break result.append(name_with_suffix) lookup.add(name_with_suffix) return result ", "class Solution def firstCompleteIndex(self, arr, mat): lookup = {mat[i][j]: (i, j) for i in xrange(len(mat)) for j in xrange(len(mat[0]))} row = [0]*len(mat) col = [0]*len(mat[0]) for idx, x in enumerate(arr): i, j = lookup[x] row[i] += 1 col[j] += 1 if row[i] == len(mat[0]) or col[j] == len(mat): return idx return -1 ", "class Solution def grayCode(self, n): result = [0] for i in xrange(n): for n in reversed(result): result.append(1 << i | n) return result ", "class Solution def grayCode(self, n): return [i >> 1 ^ i for i in xrange(1 << n)] ", "class Solution def findLexSmallestString(self, s, a, b): def less(s, i, j): for k in xrange(len(s)): if s[(k+i)%len(s)] != s[(k+j)%len(s)]: return s[(k+i)%len(s)] < s[(k+j)%len(s)] return False s = list(s) result = s[:] even = [False]*10 while not even[int(s[0])]: even[int(s[0])] = True odd = [False]*10 while not odd[int(s[1])]: odd[int(s[1])] = True best_rotate = 0 lookup = [False]*len(s) i = b while not lookup[i]: lookup[i] = True if less(s, i, best_rotate): best_rotate = i i = (i+b)%len(s) result = min(result, s[best_rotate:] + s[:best_rotate]) for k in xrange(1, len(s), 2): s[k] = str((int(s[k])+a) % 10) if b%2: for k in xrange(0, len(s), 2): s[k] = str((int(s[k])+a) % 10) return \"\".join(result) import collections ", "class Solution def findLexSmallestString(self, s, a, b): q, lookup, result = collections.deque([s]), {s}, s while q: curr = q.popleft() if curr < result: result = curr add_a = list(curr) for i, c in enumerate(add_a): if i%2: add_a[i] = str((int(c)+a) % 10) add_a = \"\".join(add_a) if add_a not in lookup: lookup.add(add_a); q.append(add_a) rotate_b = curr[b:] + curr[:b] if rotate_b not in lookup: lookup.add(rotate_b) q.append(rotate_b) return result ", "class Solution def decodeCiphertext(self, encodedText, rows): cols = len(encodedText)//rows k = len(encodedText) for i in reversed(xrange(cols)): for j in reversed(xrange(i, len(encodedText), cols+1)): if encodedText[j] != ' ': k = j break else: continue break result = [] for i in xrange(cols): for j in xrange(i, len(encodedText), cols+1): result.append(encodedText[j]) if j == k: break else: continue break return \"\".join(result) ", "class Solution def decodeCiphertext(self, encodedText, rows): cols = len(encodedText)//rows result = [] for i in xrange(cols): for j in xrange(i, len(encodedText), cols+1): result.append(encodedText[j]) while result and result[-1] == ' ': result.pop() return \"\".join(result) ", "class Solution def minDistance(self, houses, k): def cost(prefix, i, j): return (prefix[j+1]-prefix[(i+j+1)//2])-(prefix[(i+j)//2+1]-prefix[i]) houses.sort() prefix = [0]*(len(houses)+1) for i, h in enumerate(houses): prefix[i+1] = prefix[i]+h dp = [cost(prefix, 0, j) for j in xrange(len(houses))] for m in xrange(1, k): for j in reversed(xrange(m, len(houses))): for i in xrange(m, j+1): dp[j] = min(dp[j], dp[i-1]+cost(prefix, i, j)) return dp[-1] ", "class Solution def findFinalValue(self, nums, original): lookup = set(nums) while original in lookup: original *= 2 return original ", "class Solution def preorderTraversal(self, root): result, curr = [], root while curr: if curr.left is None: result.append(curr.val) curr = curr.right else: node = curr.left while node.right and node.right != curr: node = node.right if node.right is None: result.append(curr.val) node.right = curr curr = curr.left else: node.right = None curr = curr.right return result ", "class Solution def preorderTraversal(self, root): result, stack = [], [(root, False)] while stack: root, is_visited = stack.pop() if root is None: continue if is_visited: result.append(root.val) else: stack.append((root.right, False)) stack.append((root.left, False)) stack.append((root, True)) return result ", "class Solution def findProductsOfElements(self, queries): def binary_search(left, right, check): while left <= right: mid = left + ((right-left)>>1) if check(mid): right = mid-1 else: left = mid+1 return left def f(x): def count1(x): result = i = 0 while 1<<i <= x: mask = (1<<(i+1))-1 result += ((x&~mask)>>1)+max((x&mask)-(1<<i)+1, 0) i += 1 return result def count2(x): result = i = 0 while 1<<i <= x: mask = (1<<(i+1))-1 result += (((x&~mask)>>1)+max((x&mask)-(1<<i)+1, 0))*i i += 1 return result y = binary_search(1, x-1, lambda i: count1(i) >= x) result = count2(y-1) x -= count1(y-1) i = 0 while 1<<i <= y: if y&(1<<i): result += i x -= 1 if x == 0: break i += 1 return result return [pow(2, f(right+1)-f(left), mod) for left, right, mod in queries] ", "class Solution def longestPath(self, parent, s): def topological_sort(s, adj, in_degree): result = 1 top2 = collections.defaultdict(lambda:[0]*2) q = [(i, 1) for i, d in enumerate(in_degree) if not d] while q: new_q = [] for (u, l) in q: for v in adj[u]: if s[v] != s[u]: if l > top2[v][0]: top2[v][0], top2[v][1] = l, top2[v][0] elif l > top2[v][1]: top2[v][1] = l in_degree[v] -= 1 if in_degree[v]: continue new_q.append((v, top2[v][0]+1)) result = max(result, top2[v][0]+top2[v][1]+1) del top2[v] q = new_q return result adj = [[] for _ in xrange(len(s))] in_degree = [0]*len(s) for i in xrange(1, len(parent)): adj[i].append(parent[i]) in_degree[parent[i]] += 1 return topological_sort(s, adj, in_degree) ", "class Solution def longestPath(self, parent, s): def iter_dfs(s, adj): result = 0 stk = [(1, (0, [0]))] while stk: step, args = stk.pop() if step == 1: u, ret = args top2 = [0]*2 stk.append((4, (top2, ret))) stk.append((2, (u, 0, top2, ret))) elif step == 2: u, i, top2, ret = args if i == len(adj[u]): continue ret2 = [0] stk.append((3, (u, i, top2, ret2))) stk.append((1, (adj[u][i], ret2))) elif step == 3: u, i, top2, ret2 = args if s[adj[u][i]] != s[u]: if ret2[0] > top2[0]: top2[0], top2[1] = ret2[0], top2[0] elif ret2[0] > top2[1]: top2[1] = ret2[0] stk.append((2, (u, i+1, top2, ret))) elif step == 4: top2, ret = args result = max(result, top2[0]+top2[1]+1) ret[0] = top2[0]+1 return result adj = [[] for _ in xrange(len(s))] for i in xrange(1, len(parent)): adj[parent[i]].append(i) return iter_dfs(s, adj) ", "class Solution def longestPath(self, parent, s): def dfs(s, adj, u, result): top2 = [0]*2 for v in adj[u]: l = dfs(s, adj, v, result) if s[v] == s[u]: continue if l > top2[0]: top2[0], top2[1] = l, top2[0] elif l > top2[1]: top2[1] = l result[0] = max(result[0], top2[0]+top2[1]+1) return top2[0]+1 adj = [[] for _ in xrange(len(s))] for i in xrange(1, len(parent)): adj[parent[i]].append(i) result = [0] dfs(s, adj, 0, result) return result[0] ", "class Solution def consecutiveNumbersSum(self, N): result = 1 while N % 2 == 0: N /= 2 i = 3 while i*i <= N: count = 0 while N % i == 0: N /= i count += 1 result *= count+1 i += 2 if N != 1: result *= 1+1 return result ", "class Solution def str2tree(self, s): def str2treeHelper(s, i): start = i if s[i] == '-': i += 1 while i < len(s) and s[i].isdigit(): i += 1 node = TreeNode(int(s[start:i])) if i < len(s) and s[i] == '(': i += 1 node.left, i = str2treeHelper(s, i) i += 1 if i < len(s) and s[i] == '(': i += 1 node.right, i = str2treeHelper(s, i) i += 1 return node, i return str2treeHelper(s, 0)[0] if s else None ", "class Solution def lengthOfLIS(self, nums): LIS = [] def insert(target): left = bisect.bisect_left(LIS, target) if left == len(LIS): LIS.append(target) else: LIS[left] = target for num in nums: insert(num) return len(LIS) ", "class Solution def lengthOfLIS(self, nums): LIS = [] def insert(target): left, right = 0, len(LIS) - 1 while left <= right: mid = left + (right - left) // 2 if LIS[mid] >= target: right = mid - 1 else: left = mid + 1 if left == len(LIS): LIS.append(target) else: LIS[left] = target for num in nums: insert(num) return len(LIS) class SegmentTree(object): def __init__(self, N, build_fn=lambda x, y: [y]*(2*x), query_fn=lambda x, y: y if x is None else max(x, y), update_fn=lambda x, y: y, default_val=0): self.N = N self.H = (N-1).bit_length() self.query_fn = query_fn self.update_fn = update_fn self.default_val = default_val self.tree = build_fn(N, default_val) self.lazy = [None]*N def __apply(self, x, val): self.tree[x] = self.update_fn(self.tree[x], val) if x < self.N: self.lazy[x] = self.update_fn(self.lazy[x], val) def update(self, L, R, h): def pull(x): while x > 1: x //= 2 self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1]) if self.lazy[x] is not None: self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]) L += self.N R += self.N L0, R0 = L, R while L <= R: if L & 1: self.__apply(L, h) L += 1 if R & 1 == 0: self.__apply(R, h) R -= 1 L //= 2 R //= 2 pull(L0) pull(R0) def query(self, L, R): def push(x): n = 2**self.H while n != 1: y = x // n if self.lazy[y] is not None: self.__apply(y*2, self.lazy[y]) self.__apply(y*2 + 1, self.lazy[y]) self.lazy[y] = None n //= 2 result = None if L > R: return result L += self.N R += self.N push(L) push(R) while L <= R: if L & 1: result = self.query_fn(result, self.tree[L]) L += 1 if R & 1 == 0: result = self.query_fn(result, self.tree[R]) R -= 1 L //= 2 R //= 2 return result def __str__(self): showList = [] for i in xrange(self.N): showList.append(self.query(i, i)) return \",\".join(map(str, showList)) ", "class Solution def lengthOfLIS(self, nums): sorted_nums = sorted(set(nums)) lookup = {num:i for i, num in enumerate(sorted_nums)} segment_tree = SegmentTree(len(lookup)) for num in nums: segment_tree.update(lookup[num], lookup[num], segment_tree.query(0, lookup[num]-1)+1 if lookup[num] >= 1 else 1) return segment_tree.query(0, len(lookup)-1) if len(lookup) >= 1 else 0 ", "class Solution def lengthOfLIS(self, nums): dp = [] for i in xrange(len(nums)): dp.append(1) for j in xrange(i): if nums[j] < nums[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) if dp else 0 ", "class Solution def toHex(self, num): if not num: return \"0\" result = [] while num and len(result) != 8: h = num & 15 if h < 10: result.append(str(chr(ord('0') + h))) else: result.append(str(chr(ord('a') + h-10))) num >>= 4 result.reverse() return \"\".join(result) ", "class Solution def countPalindromes(self, s): MOD = 10**9+7 cnt = [0]*10 left = [[[0]*10 for _ in xrange(10)] for _ in xrange(len(s)+1)] for k in xrange(len(s)): left[k+1] = [[left[k][i][j] for j in xrange(10)] for i in xrange(10)] for i in xrange(10): left[k+1][int(s[k])][i] += cnt[i] cnt[int(s[k])] += 1 cnt = [0]*10 right = [[0]*10 for _ in xrange(10)] result = 0 for k in reversed(xrange(len(s))): for i in xrange(10): for j in xrange(10): result = (result+left[k][i][j]*right[i][j])%MOD for i in xrange(10): right[int(s[k])][i] += cnt[i] cnt[int(s[k])] += 1 return result ", "class Solution def countPalindromes(self, s): MOD = 10**9+7 result = 0 for i in xrange(10): for j in xrange(10): pattern = \"%s%s*%s%s\" % (i, j, j, i) dp = [0]*(5+1) dp[0] = 1 for k in xrange(len(s)): for l in reversed(xrange(5)): if pattern[l] == '*' or pattern[l] == s[k]: dp[l+1] = (dp[l+1]+dp[l])%MOD result = (result+dp[5])%MOD return result ", "class Solution def maxPoints(self, points): max_points = 0 for i, start in enumerate(points): slope_count, same = collections.defaultdict(int), 1 for j in xrange(i + 1, len(points)): end = points[j] if start.x == end.x and start.y == end.y: same += 1 else: slope = float(\"inf\") if start.x - end.x != 0: slope = (start.y - end.y) * 1.0 / (start.x - end.x) slope_count[slope] += 1 current_max = same for slope in slope_count: current_max = max(current_max, slope_count[slope] + same) max_points = max(max_points, current_max) return max_points ", "class Solution def generatePossibleNextMoves(self, s): res = [] i, n = 0, len(s) - 1 while i < n: if s[i] == '+': while i < n and s[i+1] == '+': res.append(s[:i] + '--' + s[i+2:]) i += 1 i += 1 return res ", "class Solution def generatePossibleNextMoves(self, s): return [s[:i] + \"--\" + s[i+2:] for i in xrange(len(s) - 1) if s[i:i+2] == \"++\"] ", "class Solution def minSumOfLengths(self, arr, target): prefix, dp = {0: -1}, [0]*len(arr) result = min_len = float(\"inf\") accu = 0 for right in xrange(len(arr)): accu += arr[right] prefix[accu] = right if accu-target in prefix: left = prefix[accu-target] min_len = min(min_len, right-left) if left != -1: result = min(result, dp[left] + (right-left)) dp[right] = min_len return result if result != float(\"inf\") else -1 ", "class Solution def longestNiceSubarray(self, nums): result = left = curr = 0 for right in xrange(len(nums)): while curr&nums[right]: curr ^= nums[left] left += 1 curr |= nums[right] result = max(result, right-left+1) return result ", "class Solution def checkOnesSegment(self, s): return \"01\" not in s ", "class Solution def combinationSum3(self, k, n): result = [] self.combinationSumRecu(result, [], 1, k, n) return result def combinationSumRecu(self, result, intermediate, start, k, target): if k == 0 and target == 0: result.append(list(intermediate)) elif k < 0: return while start < 10 and start * k + k * (k - 1) / 2 <= target: intermediate.append(start) self.combinationSumRecu(result, intermediate, start + 1, k - 1, target - start) intermediate.pop() start += 1 ", "class Solution def shortestSuperstring(self, A): n = len(A) overlaps = [[0]*n for _ in xrange(n)] for i, x in enumerate(A): for j, y in enumerate(A): for l in reversed(xrange(min(len(x), len(y)))): if y[:l].startswith(x[len(x)-l:]): overlaps[i][j] = l break dp = [[0]*n for _ in xrange(1<<n)] prev = [[None]*n for _ in xrange(1<<n)] for mask in xrange(1, 1<<n): for bit in xrange(n): if ((mask>>bit) & 1) == 0: continue prev_mask = mask^(1<<bit) for i in xrange(n): if ((prev_mask>>i) & 1) == 0: continue value = dp[prev_mask][i] + overlaps[i][bit] if value > dp[mask][bit]: dp[mask][bit] = value prev[mask][bit] = i bit = max(xrange(n), key = dp[-1].__getitem__) words = [] mask = (1<<n)-1 while bit is not None: words.append(bit) mask, bit = mask^(1<<bit), prev[mask][bit] words.reverse() lookup = set(words) words.extend([i for i in xrange(n) if i not in lookup]) result = [A[words[0]]] for i in xrange(1, len(words)): overlap = overlaps[words[i-1]][words[i]] result.append(A[words[i]][overlap:]) return \"\".join(result) ", "class Solution def countInterestingSubarrays(self, nums, modulo, k): cnt = collections.Counter([0]) result = prefix = 0 for x in nums: if x%modulo == k: prefix = (prefix+1)%modulo result += cnt[(prefix-k)%modulo] cnt[prefix] += 1 return result ", "class Solution def longestWord(self, words): def iter_dfs(words, node): result = -1 stk = [node] while stk: node = stk.pop() if result == -1 or len(words[node[\"_end\"]]) > len(words[result]): result = node[\"_end\"] for c in reversed(string.ascii_lowercase): if c not in node or \"_end\" not in node[c]: continue stk.append(node[c]) return result _trie = lambda: collections.defaultdict(_trie) trie = _trie() trie[\"_end\"] = -1 for i, word in enumerate(words): reduce(dict.__getitem__, word, trie)[\"_end\"] = i result = iter_dfs(words, trie) return words[result] if result != -1 else \"\" import collections import string ", "class Solution def longestWord(self, words): def dfs(words, node, result): if result[0] == -1 or len(words[node[\"_end\"]]) > len(words[result[0]]): result[0] = node[\"_end\"] for c in string.ascii_lowercase: if c not in node or \"_end\" not in node[c]: continue dfs(words, node[c], result) _trie = lambda: collections.defaultdict(_trie) trie = _trie() trie[\"_end\"] = -1 for i, word in enumerate(words): reduce(dict.__getitem__, word, trie)[\"_end\"] = i result = [-1] dfs(words, trie, result) return words[result[0]] if result[0] != -1 else \"\" ", "class Solution def numberCount(self, a, b): def popcount(x): return bin(x).count('1') def count2(n): if n == 0: return 0 result = cnt = 1 for i in xrange(n-1): cnt *= 9-i result += cnt return 9*result def count(x): n = base = 1 while x//(base*10): base *= 10 n += 1 result = count2(n-1) lookup = 0 cnt = reduce(lambda accu, i: accu*(9-i), xrange(n-1), 1) for i in xrange(n): d = (x//base)%10 base //= 10 mask = lookup&(((1<<d)-1)-int(i == 0)) result += ((d-int(i == 0))-popcount(mask))*cnt cnt //= 9-i if lookup&(1<<d): break lookup |= 1<<d return result return count(b+1)-count(a) ", "class Solution def numberCount(self, a, b): fact = [1]*2 def nPr(n, k): while len(fact) <= n: fact.append(fact[-1]*len(fact)) return fact[n]//fact[n-k] def popcount(x): return bin(x).count('1') def count(x): digits = map(int, str(x)) result = 9*sum(nPr(9, i) for i in xrange(len(digits)-1)) lookup = 0 for i, d in enumerate(digits): mask = lookup&(((1<<d)-1)-int(i == 0)) result += ((d-int(i == 0))-popcount(mask))*nPr(10-(i+1), len(digits)-(i+1)) if lookup&(1<<d): break lookup |= 1<<d return result return count(b+1)-count(a) ", "class Solution def numberCount(self, a, b): def check(x): lookup = 0 while x: if lookup&(1<<(x%10)): return False lookup |= (1<<(x%10)) x //= 10 return True return sum(check(x) for x in xrange(a, b+1)) ", "class Solution def numberCount(self, a, b): return sum(len(set(str(x))) == len(str(x)) for x in xrange(a, b+1)) ", "class Solution def asteroidCollision(self, asteroids): result = [] for x in asteroids: if x > 0: result.append(x) continue while result and 0 < result[-1] < -x: result.pop() if result and 0 < result[-1]: if result[-1] == -x: result.pop() continue result.append(x) return result ", "class Solution def asteroidCollision(self, asteroids): result = [] for x in asteroids: while result and x < 0 < result[-1]: if result[-1] < -x: result.pop() continue elif result[-1] == -x: result.pop() break else: result.append(x) return result ", "class Solution def construct(self, grid): def dfs(grid, x, y, l): if l == 1: return Node(grid[x][y] == 1, True, None, None, None, None) half = l // 2 topLeftNode = dfs(grid, x, y, half) topRightNode = dfs(grid, x, y+half, half) bottomLeftNode = dfs(grid, x+half, y, half) bottomRightNode = dfs(grid, x+half, y+half, half) if topLeftNode.isLeaf and topRightNode.isLeaf and bottomLeftNode.isLeaf and bottomRightNode.isLeaf and topLeftNode.val == topRightNode.val == bottomLeftNode.val == bottomRightNode.val: return Node(topLeftNode.val, True, None, None, None, None) return Node(True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode) if not grid: return None return dfs(grid, 0, 0, len(grid)) ", "class Solution def maxProfit(self, k, prices): def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 profits = [] v_p_stk = [] v, p = -1, -1 while p+1 < len(prices): for v in xrange(p+1, len(prices)-1): if prices[v] < prices[v+1]: break else: v = len(prices)-1 for p in xrange(v, len(prices)-1): if prices[p] > prices[p+1]: break else: p = len(prices)-1 while v_p_stk and prices[v_p_stk[-1][0]] > prices[v]: last_v, last_p = v_p_stk.pop() profits.append(prices[last_p]-prices[last_v]) while v_p_stk and prices[v_p_stk[-1][1]] <= prices[p]: last_v, last_p = v_p_stk.pop() profits.append(prices[last_p]-prices[v]) v = last_v v_p_stk.append((v, p)) while v_p_stk: last_v, last_p = v_p_stk.pop() profits.append(prices[last_p]-prices[last_v]) if k > len(profits): k = len(profits) else: nth_element(profits, k-1, compare=lambda a, b: a > b) return sum(profits[i] for i in xrange(k)) ", "class Solution def maxProfit(self, k, prices): def maxAtMostNPairsProfit(sprices): profit = 0 for i in xrange(len(prices) - 1): profit += max(0, prices[i + 1] - prices[i]) return profit def maxAtMostKPairsProfit(prices, k): max_buy = [float(\"-inf\") for _ in xrange(k + 1)] max_sell = [0 for _ in xrange(k + 1)] for i in xrange(len(prices)): for j in xrange(1, k + 1): max_buy[j] = max(max_buy[j], max_sell[j-1] - prices[i]) max_sell[j] = max(max_sell[j], max_buy[j] + prices[i]) return max_sell[k] if k >= len(prices) // 2: return maxAtMostNPairsProfit(prices) return maxAtMostKPairsProfit(prices, k) ", "class Solution def lenLongestFibSubseq(self, A): lookup = set(A) result = 2 for i in xrange(len(A)): for j in xrange(i+1, len(A)): x, y, l = A[i], A[j], 2 while x+y in lookup: x, y, l = y, x+y, l+1 result = max(result, l) return result if result > 2 else 0 ", "class Solution def breakPalindrome(self, palindrome): for i in xrange(len(palindrome)//2): if palindrome[i] != 'a': return palindrome[:i] + 'a' + palindrome[i+1:] return palindrome[:-1] + 'b' if len(palindrome) >= 2 else \"\" ", "class Solution def findLongestWord(self, s, d): d.sort(key = lambda x: (-len(x), x)) for word in d: i = 0 for c in s: if i < len(word) and word[i] == c: i += 1 if i == len(word): return word return \"\" ", "class Solution def largestTriangleArea(self, points): result = 0 for i in xrange(len(points)-2): for j in xrange(i+1, len(points)-1): for k in xrange(j+1, len(points)): result = max(result, 0.5 * abs(points[i][0] * points[j][1] + points[j][0] * points[k][1] + points[k][0] * points[i][1] - points[j][0] * points[i][1] - points[k][0] * points[j][1] - points[i][0] * points[k][1])) return result ", "class Solution def firstDayBeenInAllRooms(self, nextVisit): MOD = 10**9+7 dp = [0]*len(nextVisit) for i in xrange(1, len(dp)): dp[i] = (dp[i-1]+1+(dp[i-1]-dp[nextVisit[i-1]])+1)%MOD return dp[-1] ", "class Solution def findFarmland(self, land): result = [] for i in xrange(len(land)): for j in xrange(len(land[0])): if land[i][j] != 1: continue ni, nj = i, j while ni+1 < len(land) and land[ni+1][j] == 1: ni += 1 while nj+1 < len(land[0]) and land[i][nj+1] == 1: nj += 1 for r in xrange(i, ni+1): for c in xrange(j, nj+1): land[r][c] = -1 result.append([i, j, ni, nj]) return result ", "class Solution def combine(self, n, k): if k > n: return [] nums, idxs = range(1, n+1), range(k) result = [[nums[i] for i in idxs]] while True: for i in reversed(xrange(k)): if idxs[i] != i+n-k: break else: break idxs[i] += 1 for j in xrange(i+1, k): idxs[j] = idxs[j-1]+1 result.append([nums[i] for i in idxs]) return result ", "class Solution def combine(self, n, k): result, combination = [], [] i = 1 while True: if len(combination) == k: result.append(combination[:]) if len(combination) == k or len(combination)+(n-i+1) < k: if not combination: break i = combination.pop()+1 else: combination.append(i) i += 1 return result ", "class Solution def combine(self, n, k): def combineDFS(n, start, intermediate, k, result): if k == 0: result.append(intermediate[:]) return for i in xrange(start, n): intermediate.append(i+1) combineDFS(n, i+1, intermediate, k-1, result) intermediate.pop() result = [] combineDFS(n, 0, [], k, result) return result ", "class Solution def kthSmallestPrimeFraction(self, A, K): def check(mid, A, K, result): tmp = [0]*2 count = 0 j = 0 for i in xrange(len(A)): while j < len(A): if i < j and A[i] < A[j]*mid: if tmp[0] == 0 or tmp[0]*A[j] < tmp[1]*A[i]: tmp[0] = A[i] tmp[1] = A[j] break j += 1 count += len(A)-j if count == K: result[:] = tmp return count >= K result = [] left, right = 0.0, 1.0 while right-left > 1e-8: mid = left + (right-left) / 2.0 if check(mid, A, K, result): right = mid else: left = mid if result: break return result ", "class Solution def cycleLengthQueries(self, n, queries): result = [] for x, y in queries: cnt = 1 while x != y: if x > y: x, y = y, x y //= 2 cnt += 1 result.append(cnt) return result ", "class Solution def canChoose(self, groups, nums): def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j+1 > 0 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix def KMP(text, pattern, start): prefix = getPrefix(pattern) j = -1 for i in xrange(start, len(text)): while j+1 > 0 and pattern[j+1] != text[i]: j = prefix[j] if pattern[j+1] == text[i]: j += 1 if j+1 == len(pattern): return i-j return -1 pos = 0 for group in groups: pos = KMP(nums, group, pos) if pos == -1: return False pos += len(group) return True ", "class Solution def combinationSum2(self, candidates, target): result = [] self.combinationSumRecu(sorted(candidates), result, 0, [], target) return result def combinationSumRecu(self, candidates, result, start, intermediate, target): if target == 0: result.append(list(intermediate)) prev = 0 while start < len(candidates) and candidates[start] <= target: if prev != candidates[start]: intermediate.append(candidates[start]) self.combinationSumRecu(candidates, result, start + 1, intermediate, target - candidates[start]) intermediate.pop() prev = candidates[start] start += 1 ", "class Solution def findMinFibonacciNumbers(self, k): result, a, b = 0, 1, 1 while b <= k: b, a = a+b, b while k: if a <= k: k -= a result += 1 a, b = b-a, a return result ", "class Solution def numberOfWays(self, num_people): MOD = 10**9+7 def inv(x, m): return pow(x, m-2, m) def nCr(n, k, m): if n-k < k: return nCr(n, n-k, m) result = 1 for i in xrange(1, k+1): result = result*(n-k+i)*inv(i, m)%m return result n = num_people//2 return nCr(2*n, n, MOD)*inv(n+1, MOD) % MOD ", "class Solution def numberOfWays(self, num_people): MOD = 10**9+7 dp = [0]*(num_people//2+1) dp[0] = 1 for k in xrange(1, num_people//2+1): for i in xrange(k): dp[k] = (dp[k] + dp[i]*dp[k-1-i]) % MOD return dp[num_people//2] ", "class Solution def countElements(self, arr): lookup = set(arr) return sum(1 for x in arr if x+1 in lookup) ", "class Solution def countElements(self, arr): arr.sort() result, l = 0, 1 for i in xrange(len(arr)-1): if arr[i] == arr[i+1]: l += 1 continue if arr[i]+1 == arr[i+1]: result += l l = 1 return result ", "class Solution def numDecodings(self, s): M, W = 1000000007, 3 dp = [0] * W dp[0] = 1 dp[1] = 9 if s[0] == '*' else dp[0] if s[0] != '0' else 0 for i in xrange(1, len(s)): if s[i] == '*': dp[(i + 1) % W] = 9 * dp[i % W] if s[i - 1] == '1': dp[(i + 1) % W] = (dp[(i + 1) % W] + 9 * dp[(i - 1) % W]) % M elif s[i - 1] == '2': dp[(i + 1) % W] = (dp[(i + 1) % W] + 6 * dp[(i - 1) % W]) % M elif s[i - 1] == '*': dp[(i + 1) % W] = (dp[(i + 1) % W] + 15 * dp[(i - 1) % W]) % M else: dp[(i + 1) % W] = dp[i % W] if s[i] != '0' else 0 if s[i - 1] == '1': dp[(i + 1) % W] = (dp[(i + 1) % W] + dp[(i - 1) % W]) % M elif s[i - 1] == '2' and s[i] <= '6': dp[(i + 1) % W] = (dp[(i + 1) % W] + dp[(i - 1) % W]) % M elif s[i - 1] == '*': dp[(i + 1) % W] = (dp[(i + 1) % W] + (2 if s[i] <= '6' else 1) * dp[(i - 1) % W]) % M return dp[len(s) % W] ", "class Solution def canMouseWin(self, grid, catJump, mouseJump): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] DRAW, MOUSE, CAT = range(3) def parents(m, c, t): if t == CAT: for nm in graph[m, MOUSE^CAT^t]: yield nm, c, MOUSE^CAT^t else: for nc in graph[c, MOUSE^CAT^t]: yield m, nc, MOUSE^CAT^t R, C = len(grid), len(grid[0]) N = R*C WALLS = set() FOOD, MOUSE_START, CAT_START = [-1]*3 for r in xrange(R): for c in xrange(C): if grid[r][c] == 'M': MOUSE_START = r*C + c elif grid[r][c] == 'C': CAT_START = r*C + c elif grid[r][c] == 'F': FOOD = r*C + c elif grid[r][c] == '#': WALLS.add(r*C + c) graph = collections.defaultdict(set) jump = {MOUSE:mouseJump, CAT:catJump} for r in xrange(R): for c in xrange(C): if grid[r][c] == '#': continue pos = r*C + c for t in [MOUSE, CAT]: for dr, dc in directions: for d in xrange(jump[t]+1): nr, nc = r+dr*d, c+dc*d if not (0 <= nr < R and 0 <= nc < C and grid[nr][nc] != '#'): break graph[pos, t].add(nr*C + nc) degree = {} for m in xrange(N): for c in xrange(N): degree[m, c, MOUSE] = len(graph[m, MOUSE]) degree[m, c, CAT] = len(graph[c, CAT]) color = collections.defaultdict(int) q = collections.deque() for i in xrange(N): if i in WALLS or i == FOOD: continue color[FOOD, i, CAT] = MOUSE q.append((FOOD, i, CAT, MOUSE)) color[i, FOOD, MOUSE] = CAT q.append((i, FOOD, MOUSE, CAT)) for t in [MOUSE, CAT]: color[i, i, t] = CAT q.append((i, i, t, CAT)) while q: i, j, t, c = q.popleft() for ni, nj, nt in parents(i, j, t): if color[ni, nj, nt] != DRAW: continue if nt == c: color[ni, nj, nt] = c q.append((ni, nj, nt, c)) continue degree[ni, nj, nt] -= 1 if not degree[ni, nj, nt]: color[ni, nj, nt] = c q.append((ni, nj, nt, c)) return color[MOUSE_START, CAT_START, MOUSE] == MOUSE import collections ", "class Solution def canMouseWin(self, grid, catJump, mouseJump): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] DRAW, MOUSE, CAT = range(3) def parents(m, c, t): if t == CAT: for nm in graph[m, MOUSE^CAT^t]: yield nm, c, MOUSE^CAT^t else: for nc in graph[c, MOUSE^CAT^t]: yield m, nc, MOUSE^CAT^t R, C = len(grid), len(grid[0]) N = R*C WALLS = set() FOOD, MOUSE_START, CAT_START = [-1]*3 for r in xrange(R): for c in xrange(C): if grid[r][c] == 'M': MOUSE_START = r*C + c elif grid[r][c] == 'C': CAT_START = r*C + c elif grid[r][c] == 'F': FOOD = r*C + c elif grid[r][c] == '#': WALLS.add(r*C + c) graph = collections.defaultdict(set) jump = {MOUSE:mouseJump, CAT:catJump} for r in xrange(R): for c in xrange(C): if grid[r][c] == '#': continue pos = r*C + c for t in [MOUSE, CAT]: for dr, dc in directions: for d in xrange(jump[t]+1): nr, nc = r+dr*d, c+dc*d if not (0 <= nr < R and 0 <= nc < C and grid[nr][nc] != '#'): break graph[pos, t].add(nr*C + nc) degree = {} for m in xrange(N): for c in xrange(N): degree[m, c, CAT] = len(graph[c, CAT]) color = collections.defaultdict(int) q1 = collections.deque() for i in xrange(N): if i in WALLS or i == FOOD: continue color[FOOD, i, CAT] = MOUSE q1.append((FOOD, i, CAT)) color[i, FOOD, MOUSE] = CAT for t in [MOUSE, CAT]: color[i, i, t] = CAT while q1: i, j, t = q1.popleft() for ni, nj, nt in parents(i, j, t): if color[ni, nj, nt] != DRAW: continue if t == CAT: color[ni, nj, nt] = MOUSE q1.append((ni, nj, nt)) continue degree[ni, nj, nt] -= 1 if not degree[ni, nj, nt]: color[ni, nj, nt] = MOUSE q1.append((ni, nj, nt)) return color[MOUSE_START, CAT_START, MOUSE] == MOUSE ", "class Solution def addTwoNumbers(self, l1, l2): dummy = ListNode(0) current, carry = dummy, 0 while l1 or l2: val = carry if l1: val += l1.val l1 = l1.next if l2: val += l2.val l2 = l2.next carry, val = divmod(val, 10) current.next = ListNode(val) current = current.next if carry == 1: current.next = ListNode(1) return dummy.next ", "class Solution def makeStringsEqual(self, s, target): return ('1' in s) == ('1' in target) ", "class Solution def brokenCalc(self, X, Y): result = 0 while X < Y: if Y%2: Y += 1 else: Y /= 2 result += 1 return result + X-Y ", "class Solution def __init__(self): def dayOfMonth(M): return (28 if (M == 2) else 31-(M-1)%7%2) self.__lookup = [0]*12 for M in xrange(1, len(self.__lookup)): self.__lookup[M] += self.__lookup[M-1]+dayOfMonth(M) def dayOfYear(self, date): Y, M, D = map(int, date.split(\"-\")) leap = 1 if M > 2 and (((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0)) else 0 return self.__lookup[M-1]+D+leap ", "class Solution def dayOfYear(self, date): def numberOfDays(Y, M): leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0 return (28+leap if (M == 2) else 31-(M-1)%7%2) Y, M, result = map(int, date.split(\"-\")) for i in xrange(1, M): result += numberOfDays(Y, i) return result ", "class Solution def concatenatedBinary(self, n): MOD = 10**9+7 result = l = 0 for i in xrange(1, n+1): if i&(i-1) == 0: l += 1 result = ((result<<l)%MOD+i)%MOD return result ", "class Solution def longestMonotonicSubarray(self, nums): result = cnt = 1 curr = prev = 0 for i in xrange(1, len(nums)): curr = cmp(nums[i-1], nums[i]) if curr == 0: cnt = 1 continue else: cnt = (cnt if curr == prev else 1)+1 result = max(result, cnt) prev = curr return result ", "class Solution def longestMonotonicSubarray(self, nums): result = cnt1 = cnt2 = 1 for i in xrange(1, len(nums)): if nums[i-1] < nums[i]: cnt1 += 1 cnt2 = 1 elif nums[i-1] > nums[i]: cnt2 += 1 cnt1 = 1 else: cnt1 = cnt2 = 1 result = max(result, cnt1, cnt2) return result ", "class Solution def longestMonotonicSubarray(self, nums): def f(compare): result = l = 0 for i in xrange(len(nums)): l += 1 if i+1 == len(nums) or not compare(nums[i], nums[i+1]): result = max(result, l) l = 0 return result return max(f(lambda x, y: x < y), f(lambda x, y: x > y)) ", "class Solution def beautifulIndices(self, s, a, b, k): def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j+1 > 0 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix def KMP(text, pattern): prefix = getPrefix(pattern) j = -1 for i in xrange(len(text)): while j+1 > 0 and pattern[j+1] != text[i]: j = prefix[j] if pattern[j+1] == text[i]: j += 1 if j+1 == len(pattern): yield i-j j = prefix[j] result = [] if not (len(a) <= len(s) and len(b) <= len(s)): return result lookup = list(KMP(s, b)) j = 0 for i in KMP(s, a): while j < len(lookup) and lookup[j] < i-k: j += 1 if j < len(lookup) and lookup[j] <= i+k: result.append(i) return result import bisect ", "class Solution def beautifulIndices(self, s, a, b, k): def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j+1 > 0 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix def KMP(text, pattern): prefix = getPrefix(pattern+'#'+text) return ((i-(len(pattern)+1))-(len(pattern)-1) for i in xrange((len(pattern)+1)+(len(pattern)-1) , len(prefix)) if prefix[i]+1 == len(pattern)) result = [] if not (len(a) <= len(s) and len(b) <= len(s)): return result lookup = list(KMP(s, b)) j = 0 for i in KMP(s, a): j = bisect.bisect_left(lookup, i-k) if j < len(lookup) and lookup[j] <= i+k: result.append(i) return result ", "class Solution def longestWPI(self, hours): result, accu = 0, 0 lookup = {} for i, h in enumerate(hours): accu = accu+1 if h > 8 else accu-1 if accu > 0: result = i+1 elif accu-1 in lookup: result = max(result, i-lookup[accu-1]) lookup.setdefault(accu, i) return result ", "class Solution def goodNodes(self, root): result = 0 stk = [(root, root.val)] while stk: node, curr_max = stk.pop() if not node: continue curr_max = max(curr_max, node.val) result += int(curr_max <= node.val) stk.append((node.right, curr_max)) stk.append((node.left, curr_max)) return result ", "class Solution def goodNodes(self, root): def dfs(node, curr_max): if not node: return 0 curr_max = max(curr_max, node.val) return (int(curr_max <= node.val) + dfs(node.left, curr_max) + dfs(node.right, curr_max)) return dfs(root, root.val) ", "class Solution def generateParenthesis(self, n): result, curr = [], [] stk = [(1, (n, n))] while stk: step, args = stk.pop() if step == 1: left, right = args if left == 0 and right == 0: result.append(\"\".join(curr)) if left < right: stk.append((3, tuple())) stk.append((1, (left, right-1))) stk.append((2, (')'))) if left > 0: stk.append((3, tuple())) stk.append((1, (left-1, right))) stk.append((2, ('('))) elif step == 2: curr.append(args[0]) elif step == 3: curr.pop() return result ", "class Solution def generateParenthesis(self, n): def generateParenthesisRecu(left, right, curr, result): if left == 0 and right == 0: result.append(\"\".join(curr)) if left > 0: curr.append('(') generateParenthesisRecu(left-1, right, curr, result) curr.pop() if left < right: curr.append(')') generateParenthesisRecu(left, right-1, curr, result) curr.pop() result = [] generateParenthesisRecu(n, n, [], result) return result ", "class Solution def lengthOfLongestSubstringKDistinct(self, s, k): longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in xrange(256)] for i, char in enumerate(s): if visited[ord(char)] == 0: distinct_count += 1 visited[ord(char)] += 1 while distinct_count > k: visited[ord(s[start])] -= 1 if visited[ord(s[start])] == 0: distinct_count -= 1 start += 1 longest = max(longest, i - start + 1) return longest from collections import Counter ", "class Solution def lengthOfLongestSubstringKDistinct(self, s, k): counter = Counter() left, max_length = 0, 0 for right, char in enumerate(s): counter[char] += 1 while len(counter) > k: counter[s[left]] -= 1 if counter[s[left]] == 0: del counter[s[left]] left += 1 max_length = max(max_length, right-left+1) return max_length ", "class Solution def maxSumDivThree(self, nums): dp = [0, 0, 0] for num in nums: for i in [num+x for x in dp]: dp[i%3] = max(dp[i%3], i) return dp[0] ", "class Solution def hasCycle(self, head): fast, slow = head, head while fast and fast.next: fast, slow = fast.next.next, slow.next if fast is slow: return True return False ", "class Solution def find132pattern(self, nums): ak = float(\"-inf\") stk = [] for i in reversed(xrange(len(nums))): if nums[i] < ak: return True while stk and stk[-1] < nums[i]: ak = stk.pop() stk.append(nums[i]) return False class Solution_TLE(object): def find132pattern(self, nums): for k in xrange(len(nums)): valid = False for j in xrange(k): if nums[j] < nums[k]: valid = True elif nums[j] > nums[k]: if valid: return True return False ", "class Solution def checkIfPrerequisite(self, n, prerequisites, queries): def floydWarshall(n, graph): reachable = set(map(lambda x: x[0]*n+x[1], graph)) for k in xrange(n): for i in xrange(n): for j in xrange(n): if i*n+j not in reachable and (i*n+k in reachable and k*n+j in reachable): reachable.add(i*n+j) return reachable reachable = floydWarshall(n, prerequisites) return [i*n+j in reachable for i, j in queries] import collections ", "class Solution def checkIfPrerequisite(self, n, prerequisites, queries): graph = collections.defaultdict(list) for u, v in prerequisites: graph[u].append(v) result = [] for i, j in queries: stk, lookup = [i], set([i]) while stk: node = stk.pop() for nei in graph[node]: if nei in lookup: continue stk.append(nei) lookup.add(nei) result.append(j in lookup) return result ", "class Solution def rightSideView(self, root): result = [] self.rightSideViewDFS(root, 1, result) return result def rightSideViewDFS(self, node, depth, result): if not node: return if depth > len(result): result.append(node.val) self.rightSideViewDFS(node.right, depth+1, result) self.rightSideViewDFS(node.left, depth+1, result) ", "class Solution def rightSideView(self, root): if root is None: return [] result, current = [], [root] while current: next_level = [] for node in current: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) result.append(node.val) current = next_level return result ", "class Solution def isBipartite(self, graph): color = {} for node in xrange(len(graph)): if node in color: continue stack = [node] color[node] = 0 while stack: curr = stack.pop() for neighbor in graph[curr]: if neighbor not in color: stack.append(neighbor) color[neighbor] = color[curr] ^ 1 elif color[neighbor] == color[curr]: return False return True ", "class Solution def crackSafe(self, n, k): M = k**(n-1) P = [q*k+i for i in xrange(k) for q in xrange(M)] result = [str(k-1)]*(n-1) for i in xrange(k**n): j = i while P[j] >= 0: result.append(str(j//M)) P[j], j = -1, P[j] return \"\".join(result) ", "class Solution def crackSafe(self, n, k): total = k**n M = total//k unique_rolling_hash = 0 result = [str(0)]*(n-1) lookup = set() while len(lookup) < total: for i in reversed(xrange(k)): new_unique_rolling_hash = unique_rolling_hash*k + i if new_unique_rolling_hash not in lookup: lookup.add(new_unique_rolling_hash) result.append(str(i)) unique_rolling_hash = new_unique_rolling_hash%M break return \"\".join(result) ", "class Solution def crackSafe(self, n, k): M = k**(n-1) def dfs(k, unique_rolling_hash, lookup, result): for i in reversed(xrange(k)): new_unique_rolling_hash = unique_rolling_hash*k + i if new_unique_rolling_hash not in lookup: lookup.add(new_unique_rolling_hash) result.append(str(i)) dfs(k, new_unique_rolling_hash%M, lookup, result) break unique_rolling_hash = 0 result = [str(0)]*(n-1) lookup = set() dfs(k, unique_rolling_hash, lookup, result) return \"\".join(result) ", "class Solution def crackSafe(self, n, k): result = [str(k-1)]*(n-1) lookup = set() total = k**n while len(lookup) < total: node = result[len(result)-n+1:] for i in xrange(k): neighbor = \"\".join(node) + str(i) if neighbor not in lookup: lookup.add(neighbor) result.append(str(i)) break return \"\".join(result) ", "class Solution def crackSafe(self, n, k): def dfs(k, node, lookup, result): for i in xrange(k): neighbor = node + str(i) if neighbor not in lookup: lookup.add(neighbor) result.append(str(i)) dfs(k, neighbor[1:], lookup, result) break result = [str(k-1)]*(n-1) lookup = set() dfs(k, \"\".join(result), lookup, result) return \"\".join(result) ", "class Solution def waysToBuildRooms(self, prevRoom): MOD = 10**9+7 fact = [1, 1] inv = [0, 1] inv_fact = [1, 1] def nCr(n, k): while len(inv) <= n: fact.append(fact[-1]*len(inv) % MOD) inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) inv_fact.append(inv_fact[-1]*inv[-1] % MOD) return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD def dfs(adj, curr): total_ways, total_cnt = 1, 0 for child in adj[curr]: ways, cnt = dfs(adj, child) total_cnt += cnt total_ways = (((total_ways*ways) % MOD)*nCr(total_cnt, cnt)) % MOD return total_ways, total_cnt+1 adj = [[] for _ in xrange(len(prevRoom))] for i in xrange(1, len(prevRoom)): adj[prevRoom[i]].append(i) return dfs(adj, 0)[0] ", "class Solution def maskPII(self, S): if '@' in S: first, after = S.split('@') return \"{}*****{}@{}\".format(first[0], first[-1], after).lower() digits = filter(lambda x: x.isdigit(), S) local = \"***-***-{}\".format(digits[-4:]) if len(digits) == 10: return local return \"+{}-{}\".format('*' * (len(digits) - 10), local) ", "class Solution def longestValidSubstring(self, word, forbidden): _trie = lambda: collections.defaultdict(_trie) trie = _trie() for w in forbidden: reduce(dict.__getitem__, w, trie)[\"_end\"] result = 0 right = len(word)-1 for left in reversed(xrange(len(word))): node = trie for i in xrange(left, right+1): if word[i] not in node: break node = node[word[i]] if \"_end\" in node: right = i-1 break result = max(result, right-left+1) return result ", "class Solution def minimumBoxes(self, apple, capacity): capacity.sort(reverse=True) total = sum(apple) for i in xrange(len(capacity)): total -= capacity[i] if total <= 0: return i+1 return -1 ", "class Solution def findTheCity(self, n, edges, distanceThreshold): dist = [[float(\"inf\")]*n for _ in xrange(n)] for i, j, w in edges: dist[i][j] = dist[j][i] = w for i in xrange(n): dist[i][i] = 0 for k in xrange(n): for i in xrange(n): for j in xrange(n): dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) result = {sum(d <= distanceThreshold for d in dist[i]): i for i in xrange(n)} return result[min(result.iterkeys())] ", "class Solution def insertIntoBST(self, root, val): curr, parent = root, None while curr: parent = curr if val <= curr.val: curr = curr.left else: curr = curr.right if not parent: root = TreeNode(val) elif val <= parent.val: parent.left = TreeNode(val) else: parent.right = TreeNode(val) return root ", "class Solution def insertIntoBST(self, root, val): if not root: root = TreeNode(val) else: if val <= root.val: root.left = self.insertIntoBST(root.left, val) else: root.right = self.insertIntoBST(root.right, val) return root ", "class Solution def sumOfPower(self, nums, k): MOD = 10**9+7 dp = [0]*(k+1) dp[0] = 1 for x in nums: for i in reversed(xrange(k+1)): dp[i] = (dp[i]+(dp[i]+(dp[i-x] if i-x >= 0 else 0)))%MOD return dp[k] ", "class Solution def kthLuckyNumber(self, k): result = [] k += 1 while k != 1: result.append('7' if k&1 else '4') k >>= 1 result.reverse() return \"\".join(result) ", "class Solution def kthLuckyNumber(self, k): return bin(k+1)[3:].replace('1', '7').replace('0', '4') ", "class Solution def kClosest(self, points, K): def dist(point): return point[0]**2 + point[1]**2 def kthElement(nums, k, compare): def PartitionAroundPivot(left, right, pivot_idx, nums, compare): new_pivot_idx = left nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx] for i in xrange(left, right): if compare(nums[i], nums[right]): nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i] new_pivot_idx += 1 nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right] return new_pivot_idx left, right = 0, len(nums) - 1 while left <= right: pivot_idx = randint(left, right) new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare) if new_pivot_idx == k: return elif new_pivot_idx > k: right = new_pivot_idx - 1 else: left = new_pivot_idx + 1 kthElement(points, K-1, lambda a, b: dist(a) < dist(b)) return points[:K] import heapq ", "class Solution def kClosest(self, points, K): def dist(point): return point[0]**2 + point[1]**2 max_heap = [] for point in points: heapq.heappush(max_heap, (-dist(point), point)) if len(max_heap) > K: heapq.heappop(max_heap) return [heapq.heappop(max_heap)[1] for _ in xrange(len(max_heap))] ", "class Solution def tictactoe(self, moves): row, col = [[0]*3 for _ in xrange(2)], [[0]*3 for _ in xrange(2)] diag, anti_diag = [0]*2, [0]*2 p = 0 for r, c in moves: row[p][r] += 1 col[p][c] += 1 diag[p] += r == c anti_diag[p] += r+c == 2 if 3 in (row[p][r], col[p][c], diag[p], anti_diag[p]): return \"AB\"[p] p ^= 1 return \"Draw\" if len(moves) == 9 else \"Pending\" ", "class Solution def longestIncreasingPath(self, matrix): directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] if not matrix: return 0 in_degree = [[0]*len(matrix[0]) for _ in xrange(len(matrix))] for i in xrange(len(matrix)): for j in xrange(len(matrix[0])): for di, dj in directions: ni, nj = i+di, j+dj if not (0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and matrix[ni][nj] > matrix[i][j]): continue in_degree[i][j] += 1 q = [] for i in xrange(len(matrix)): for j in xrange(len(matrix[0])): if not in_degree[i][j]: q.append((i, j)) result = 0 while q: new_q = [] for i, j in q: for di, dj in directions: ni, nj = i+di, j+dj if not (0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and matrix[i][j] > matrix[ni][nj]): continue in_degree[ni][nj] -= 1 if not in_degree[ni][nj]: new_q.append((ni, nj)) q = new_q result += 1 return result ", "class Solution def longestIncreasingPath(self, matrix): directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] def longestpath(matrix, i, j, max_lengths): if max_lengths[i][j]: return max_lengths[i][j] max_depth = 0 for di, dj in directions: x, y = i+di, j+dj if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and matrix[x][y] < matrix[i][j]: max_depth = max(max_depth, longestpath(matrix, x, y, max_lengths)) max_lengths[i][j] = max_depth + 1 return max_lengths[i][j] if not matrix: return 0 result = 0 max_lengths = [[0 for _ in xrange(len(matrix[0]))] for _ in xrange(len(matrix))] for i in xrange(len(matrix)): for j in xrange(len(matrix[0])): result = max(result, longestpath(matrix, i, j, max_lengths)) return result ", "class Solution def furthestDistanceFromOrigin(self, moves): curr = cnt = 0 for x in moves: if x == 'L': curr -= 1 elif x == 'R': curr += 1 else: cnt += 1 return abs(curr)+cnt ", "class Solution def addedInteger(self, nums1, nums2): return max(nums2)-max(nums1) ", "class Solution def maxCoins(self, nums): coins = [1] + [i for i in nums if i > 0] + [1] n = len(coins) max_coins = [[0 for _ in xrange(n)] for _ in xrange(n)] for k in xrange(2, n): for left in xrange(n - k): right = left + k for i in xrange(left + 1, right): max_coins[left][right] = max(max_coins[left][right], coins[left] * coins[i] * coins[right] + max_coins[left][i] + max_coins[i][right]) return max_coins[0][-1] ", "class Solution def makeAntiPalindrome(self, s): cnt = [0]*26 for x in s: cnt[ord(x)-ord('a')] += 1 if max(cnt) > len(s)//2: return \"-1\" result = [i for i, x in enumerate(cnt) for _ in xrange(x)] l = next(l for l in xrange((len(s)//2)//2+1) if result[len(s)//2+l] != result[len(s)//2-1]) if l: for i in xrange(cnt[result[len(s)//2-1]]-l): result[len(s)//2+i], result[len(s)//2+i+l] = result[len(s)//2+i+l], result[len(s)//2+i] return \"\".join(map(lambda x: chr(ord('a')+x), result)) ", "class Solution def makeAntiPalindrome(self, s): cnt = [0]*26 for x in s: cnt[ord(x)-ord('a')] += 1 if max(cnt) > len(s)//2: return \"-1\" result = [i for i, x in enumerate(cnt) for _ in xrange(x)] left = len(s)//2 right = left+1 while right < len(s) and result[right] == result[left]: right += 1 while result[left] == result[len(s)-1-left]: result[left] , result[right] = result[right], result[left] left += 1 right += 1 return \"\".join(map(lambda x: chr(ord('a')+x), result)) ", "class Solution def makeAntiPalindrome(self, s): cnt = [0]*26 for x in s: cnt[ord(x)-ord('a')] += 1 if max(cnt) > len(s)//2: return \"-1\" result = [-1]*len(s) for i in xrange(len(s)//2): j = next(j for j in xrange(len(cnt)) if cnt[j]) cnt[j] -= 1 result[i] = j for i in xrange(len(s)//2, len(s)): j = next(j for j in xrange(len(cnt)) if cnt[j] and result[(len(s)-1)-i] != j) cnt[j] -= 1 result[i] = j return \"\".join(map(lambda x: chr(ord('a')+x), result)) ", "class Solution def flipEquiv(self, root1, root2): dq1, dq2 = collections.deque([root1]), collections.deque([root2]) while dq1 and dq2: node1, node2 = dq1.pop(), dq2.pop() if not node1 and not node2: continue if not node1 or not node2 or node1.val != node2.val: return False if (not node1.left and not node2.right) or (node1.left and node2.right and node1.left.val == node2.right.val): dq1.extend([node1.right, node1.left]) else: dq1.extend([node1.left, node1.right]) dq2.extend([node2.left, node2.right]) return not dq1 and not dq2 ", "class Solution def flipEquiv(self, root1, root2): stk1, stk2 = [root1], [root2] while stk1 and stk2: node1, node2 = stk1.pop(), stk2.pop() if not node1 and not node2: continue if not node1 or not node2 or node1.val != node2.val: return False if (not node1.left and not node2.right) or (node1.left and node2.right and node1.left.val == node2.right.val): stk1.extend([node1.right, node1.left]) else: stk1.extend([node1.left, node1.right]) stk2.extend([node2.left, node2.right]) return not stk1 and not stk2 ", "class Solution def flipEquiv(self, root1, root2): if not root1 and not root2: return True if not root1 or not root2 or root1.val != root2.val: return False return (self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right) or self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left)) ", "class Solution def checkStraightLine(self, coordinates): i, j = coordinates[:2] return all(i[0] * j[1] - j[0] * i[1] + j[0] * k[1] - k[0] * j[1] + k[0] * i[1] - i[0] * k[1] == 0 for k in coordinates) ", "class Solution def arrangeCoins(self, n): return int((math.sqrt(8*n+1)-1) / 2) ", "class Solution def arrangeCoins(self, n): def check(mid, n): return mid*(mid+1) <= 2*n left, right = 1, n while left <= right: mid = left + (right-left)//2 if not check(mid, n): right = mid-1 else: left = mid+1 return right ", "class Solution def countCompleteComponents(self, n, edges): def bfs(u): if lookup[u]: return False v_cnt = e_cnt = 0 lookup[u] = True q = [u] while q: new_q = [] v_cnt += len(q) for u in q: e_cnt += len(adj[u]) for v in adj[u]: if lookup[v]: continue lookup[v] = True new_q.append(v) q = new_q return v_cnt*(v_cnt-1) == e_cnt adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) lookup = [False]*n return sum(bfs(u) for u in xrange(n) if not lookup[u]) ", "class Solution def longestPalindromeSubseq(self, s): dp = [[[0]*26 for _ in xrange(len(s))] for _ in xrange(2)] for i in reversed(xrange(len(s))): for j in xrange(i+1, len(s)): if i == j-1: if s[j] == s[i]: dp[i%2][j][ord(s[i])-ord('a')] = 2 else: for k in xrange(26): if s[j] == s[i] and ord(s[j])-ord('a') != k: dp[i%2][j][ord(s[j])-ord('a')] = max(dp[i%2][j][ord(s[j])-ord('a')], dp[(i+1)%2][j-1][k]+2); dp[i%2][j][k] = max(dp[i%2][j][k], dp[i%2][j-1][k], dp[(i+1)%2][j][k], dp[(i+1)%2][j-1][k]) return max(dp[0][-1]) ", "class Solution def beforeAndAfterPuzzles(self, phrases): lookup = collections.defaultdict(list) for i, phrase in enumerate(phrases): right = phrase.rfind(' ') word = phrase if right == -1 else phrase[right+1:] lookup[word].append(i) result_set = set() for i, phrase in enumerate(phrases): left = phrase.find(' ') word = phrase if left == -1 else phrase[:left] if word not in lookup: continue for j in lookup[word]: if j == i: continue result_set.add(phrases[j] + phrase[len(word):]) return sorted(result_set) ", "class Solution def countPairs(self, nums, k): def gcd(x, y): while y: x, y = y, x%y return x cnt = collections.Counter() for x in nums: cnt[gcd(x, k)] += 1 result = 0 for x in cnt.iterkeys(): for y in cnt.iterkeys(): if x > y or x*y%k: continue result += cnt[x]*cnt[y] if x != y else cnt[x]*(cnt[x]-1)//2 return result import collections ", "class Solution def countPairs(self, nums, k): def gcd(x, y): while y: x, y = y, x%y return x result = 0 gcds = collections.Counter() for x in nums: gcd_i = gcd(x, k) result += sum(cnt for gcd_j, cnt in gcds.iteritems() if gcd_i*gcd_j%k == 0) gcds[gcd_i] += 1 return result ", "class Solution def buyChoco(self, prices, money): i = min(xrange(len(prices)), key=lambda x: prices[x]) j = min((j for j in xrange(len(prices)) if j != i), key=lambda x: prices[x]) return money-(prices[i]+prices[j]) if prices[i]+prices[j] <= money else money ", "class Solution def findClosestLeaf(self, root, k): def traverse(node, neighbors, leaves): if not node: return if not node.left and not node.right: leaves.add(node.val) return if node.left: neighbors[node.val].append(node.left.val) neighbors[node.left.val].append(node.val) traverse(node.left, neighbors, leaves) if node.right: neighbors[node.val].append(node.right.val) neighbors[node.right.val].append(node.val) traverse(node.right, neighbors, leaves) neighbors, leaves = collections.defaultdict(list), set() traverse(root, neighbors, leaves) q, lookup = [k], set([k]) while q: next_q = [] for u in q: if u in leaves: return u for v in neighbors[u]: if v in lookup: continue lookup.add(v) next_q.append(v) q = next_q return 0 ", "class Solution def areOccurrencesEqual(self, s): return len(set(collections.Counter(s).itervalues())) == 1 ", "class Solution def distributeCandies(self, n, limit): def nCr(n, r): if not 0 <= r <= n: return 0 if n-r < r: r = n-r c = 1 for k in xrange(1, r+1): c *= n-k+1 c //= k return c def nHr(n, r): return nCr(n+(r-1), r-1) R = 3 return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R)for r in xrange(R+1)) ", "class Solution def distributeCandies(self, n, limit): return sum(min(limit, n-i)-max((n-i)-limit, 0)+1 for i in xrange(max(n-2*limit, 0), min(limit, n)+1)) ", "class Solution def distributeCandies(self, n, limit): return sum(n-i-j <= limit for i in xrange(min(limit, n)+1) for j in xrange(min(limit, n-i)+1)) ", "class Solution def constrainedSubsetSum(self, nums, k): result, dq = float(\"-inf\"), collections.deque() for i in xrange(len(nums)): if dq and i-dq[0][0] == k+1: dq.popleft() curr = nums[i] + (dq[0][1] if dq else 0) while dq and dq[-1][1] <= curr: dq.pop() if curr > 0: dq.append((i, curr)) result = max(result, curr) return result ", "class Solution def findMaximizedCapital(self, k, W, Profits, Capital): curr = [] future = sorted(zip(Capital, Profits), reverse=True) for _ in xrange(k): while future and future[-1][0] <= W: heapq.heappush(curr, -future.pop()[1]) if curr: W -= heapq.heappop(curr) return W ", "class Solution def average(self, salary): total, mi, ma = 0, float(\"inf\"), float(\"-inf\") for s in salary: total += s mi, ma = min(mi, s), max(ma, s) return 1.0*(total-mi-ma)/(len(salary)-2) ", "class Solution def average(self, salary): return 1.0*(sum(salary)-min(salary)-max(salary))/(len(salary)-2) ", "class Solution def distributeCandies(self, n, limit): def nCr(n, r): if not 0 <= r <= n: return 0 if n-r < r: r = n-r c = 1 for k in xrange(1, r+1): c *= n-k+1 c //= k return c def nHr(n, r): return nCr(n+(r-1), r-1) R = 3 return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R)for r in xrange(R+1)) ", "class Solution def distributeCandies(self, n, limit): return sum(min(limit, n-i)-max((n-i)-limit, 0)+1 for i in xrange(max(n-2*limit, 0), min(limit, n)+1)) ", "class Solution def convertArray(self, nums): def f(nums): result = 0 max_heap = [] for x in nums: if max_heap and x < -max_heap[0]: result += -heapq.heappop(max_heap)-x heapq.heappush(max_heap, -x) heapq.heappush(max_heap, -x) return result return min(f(nums), f((x for x in reversed(nums)))) import collections ", "class Solution def convertArray(self, nums): vals = sorted(set(nums)) def f(nums): dp = collections.defaultdict(int) for x in nums: prev = -1 for i in vals: dp[i] = min(dp[i]+abs(i-x), dp[prev]) if prev != -1 else dp[i]+abs(i-x) prev = i return dp[vals[-1]] return min(f(nums), f((x for x in reversed(nums)))) ", "class Solution def buildTree(self, preorder, inorder): lookup = {} for i, num in enumerate(inorder): lookup[num] = i return self.buildTreeRecu(lookup, preorder, inorder, 0, 0, len(inorder)) def buildTreeRecu(self, lookup, preorder, inorder, pre_start, in_start, in_end): if in_start == in_end: return None node = TreeNode(preorder[pre_start]) i = lookup[preorder[pre_start]] node.left = self.buildTreeRecu(lookup, preorder, inorder, pre_start + 1, in_start, i) node.right = self.buildTreeRecu(lookup, preorder, inorder, pre_start + 1 + i - in_start, i + 1, in_end) return node ", "class Solution def buildTree(self, preorder, inorder): preorder_iterator = iter(preorder) inorder_lookup = {n: i for i, n in enumerate(inorder)} def helper(start, end): if start > end: return None root_val = next(preorder_iterator) root = TreeNode(root_val) idx = inorder_lookup[root_val] root.left = helper(start, idx-1) root.right = helper(idx+1, end) return root return helper(0, len(inorder)-1) ", "class Solution def findKthBit(self, n, k): flip, l = 0, 2**n-1 while k > 1: if k == l//2+1: flip ^= 1 break if k > l//2: k = l+1-k flip ^= 1 l //= 2 return str(flip) ", "class Solution def guessMajority(self, reader): count_a, count_b, idx_b = 1, 0, None value_0_1_2_3 = reader.query(0, 1, 2, 3) for i in reversed(xrange(4, reader.length())): value_0_1_2_i = reader.query(0, 1, 2, i) if value_0_1_2_i == value_0_1_2_3: count_a = count_a+1 else: count_b, idx_b = count_b+1, i value_0_1_2_4 = value_0_1_2_i for i in xrange(3): value_a_b_3_4 = reader.query(*[v for v in [0, 1, 2, 3, 4] if v != i]) if value_a_b_3_4 == value_0_1_2_4: count_a = count_a+1 else: count_b, idx_b = count_b+1, i if count_a == count_b: return -1 return 3 if count_a > count_b else idx_b ", "class Solution def diStringMatch(self, S): result = [] left, right = 0, len(S) for c in S: if c == 'I': result.append(left) left += 1 else: result.append(right) right -= 1 result.append(left) return result ", "class Solution def findDuplicates(self, nums): result = [] for i in nums: if nums[abs(i)-1] < 0: result.append(abs(i)) else: nums[abs(i)-1] *= -1 return result ", "class Solution def findDuplicates(self, nums): result = [] i = 0 while i < len(nums): if nums[i] != nums[nums[i]-1]: nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1] else: i += 1 for i in xrange(len(nums)): if i != nums[i]-1: result.append(nums[i]) return result from collections import Counter ", "class Solution def findDuplicates(self, nums): return [elem for elem, count in Counter(nums).items() if count == 2] ", "class Solution def binarySearchableNumbers(self, nums): right = [float(\"inf\")]*(len(nums)+1) for i in reversed(xrange(1, len(nums)+1)): right[i-1] = min(right[i], nums[i-1]) result, left = set(), float(\"-inf\") for i in xrange(len(nums)): if left <= nums[i] <= right[i+1]: result.add(nums[i]) left = max(left, nums[i]) return len(result) ", "class Solution def escapeGhosts(self, ghosts, target): total = abs(target[0])+abs(target[1]) return all(total < abs(target[0]-i)+abs(target[1]-j) for i, j in ghosts) ", "class Solution def countUnivalSubtrees(self, root): [is_uni, count] = self.isUnivalSubtrees(root, 0) return count def isUnivalSubtrees(self, root, count): if not root: return [True, count] [left, count] = self.isUnivalSubtrees(root.left, count) [right, count] = self.isUnivalSubtrees(root.right, count) if self.isSame(root, root.left, left) and self.isSame(root, root.right, right): count += 1 return [True, count] return [False, count] def isSame(self, root, child, is_uni): return not child or (is_uni and root.val == child.val) ", "class Solution def getPermutationIndex(self, perm): MOD = 10**9+7 class BIT(object): def __init__(self, n): self.__bit = [0]*(n+1) def add(self, i, val): i += 1 while i < len(self.__bit): self.__bit[i] = (self.__bit[i]+val) % MOD i += (i & -i) def query(self, i): i += 1 ret = 0 while i > 0: ret = (ret+self.__bit[i]) % MOD i -= (i & -i) return ret fact = [0]*len(perm) fact[0] = 1 for i in xrange(len(fact)-1): fact[i+1] = ((i+1)*fact[i])%MOD result = 0 bit = BIT(len(perm)) for i, x in enumerate(perm): result = (result+(((((x-1)-bit.query((x-1)-1))%MOD)*fact[(len(perm)-1)-i])%MOD))%MOD bit.add(x-1, +1) return result ", "class Solution def getPermutationIndex(self, perm): MOD = 10**9+7 fact = [1]*2 def factorial(n): while len(fact) <= n: fact.append(fact[-1]*len(fact) % MOD) return fact[n] class BIT(object): def __init__(self, n): self.__bit = [0]*(n+1) def add(self, i, val): i += 1 while i < len(self.__bit): self.__bit[i] = (self.__bit[i]+val) % MOD i += (i & -i) def query(self, i): i += 1 ret = 0 while i > 0: ret = (ret+self.__bit[i]) % MOD i -= (i & -i) return ret result = 0 bit = BIT(len(perm)) for i, x in enumerate(perm): result = (result+(((((x-1)-bit.query((x-1)-1))%MOD)*factorial((len(perm)-1)-i))%MOD))%MOD bit.add(x-1, +1) return result ", "class Solution def countDays(self, days, meetings): meetings.sort() result = curr = 0 for s, e in meetings: result += max((s-1)-curr, 0) curr = max(curr, e) result += days-curr return result ", "class Solution def longestMountain(self, A): result, up_len, down_len = 0, 0, 0 for i in xrange(1, len(A)): if (down_len and A[i-1] < A[i]) or A[i-1] == A[i]: up_len, down_len = 0, 0 up_len += A[i-1] < A[i] down_len += A[i-1] > A[i] if up_len and down_len: result = max(result, up_len+down_len+1) return result ", "class Solution def convertTemperature(self, celsius): return [celsius+273.15, celsius*1.80+32.00] ", "class Solution def maximalNetworkRank(self, n, roads): MAX_N = 100 MAX_NUM = MAX_N-1 def counting_sort(arr, key=lambda x:x, reverse=False): count = [0]*(MAX_NUM+1) for x in arr: count[key(x)] += 1 for i in xrange(1, len(count)): count[i] += count[i-1] result = [0]*len(arr) if not reverse: for x in reversed(arr): count[key(x)] -= 1 result[count[key(x)]] = x else: for x in arr: count[key(x)] -= 1 result[count[key(x)]] = x result.reverse() return result degree = [0]*n adj = collections.defaultdict(set) for a, b in roads: degree[a] += 1 degree[b] += 1 adj[a].add(b) adj[b].add(a) sorted_idx = counting_sort(xrange(n), key=lambda x:degree[x], reverse=True) m = 2 while m < n: if degree[sorted_idx[m]] != degree[sorted_idx[1]]: break m += 1 result = degree[sorted_idx[0]] + degree[sorted_idx[1]] - 1 for i in xrange(m-1): for j in xrange(i+1, m): if degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]]) > result: return degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]]) return result import collections ", "class Solution def maximalNetworkRank(self, n, roads): degree = [0]*n adj = collections.defaultdict(set) for a, b in roads: degree[a] += 1 degree[b] += 1 adj[a].add(b) adj[b].add(a) sorted_idx = range(n) sorted_idx.sort(key=lambda x:-degree[x]) m = 2 while m < n: if degree[sorted_idx[m]] != degree[sorted_idx[1]]: break m += 1 result = degree[sorted_idx[0]] + degree[sorted_idx[1]] - 1 for i in xrange(m-1): for j in xrange(i+1, m): if degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]]) > result: return degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]]) return result import collections ", "class Solution def maximalNetworkRank(self, n, roads): degree = [0]*n adj = collections.defaultdict(set) for a, b in roads: degree[a] += 1 degree[b] += 1 adj[a].add(b) adj[b].add(a) result = 0 for i in xrange(n-1): for j in xrange(i+1, n): result = max(result, degree[i]+degree[j]-int(i in adj and j in adj[i])) return result ", "class Solution def placeWordInCrossword(self, board, word): def get_val(mat, i, j, transposed): return mat[i][j] if not transposed else mat[j][i] def get_vecs(mat, transposed): for i in xrange(len(mat) if not transposed else len(mat[0])): yield (get_val(mat, i, j, transposed) for j in xrange(len(mat[0]) if not transposed else len(mat))) for direction in (lambda x: iter(x), reversed): for transposed in xrange(2): for row in get_vecs(board, transposed): it, matched = direction(word), True for c in row: if c == '#': if next(it, None) is None and matched: return True it, matched = direction(word), True continue if not matched: continue nc = next(it, None) matched = (nc is not None) and c in (nc, ' ') if (next(it, None) is None) and matched: return True return False ", "class Solution def placeWordInCrossword(self, board, word): words = [word, word[::-1]] for mat in (board, zip(*board)): for row in mat: blocks = ''.join(row).split('#') for s in blocks: if len(s) != len(word): continue for w in words: if all(s[i] in (w[i], ' ') for i in xrange(len(s))): return True return False ", "class Solution def isDecomposable(self, s): if len(s)%3 != 2: return False for left in xrange(0, len(s), 3): if any(s[i] != s[i-1] for i in xrange(left+1, min(left+3, len(s)))): break for right in reversed(xrange(left+1, len(s), 3)): if any(s[i] != s[i+1] for i in reversed(xrange(max(right-2, left), right))): break return right-left == 1 ", "class Solution def isDecomposable(self, s): found, i = False, 0 while i < len(s): l = 1 for j in xrange(i+1, min(i+3, len(s))): if s[j] != s[i]: break l += 1 if l < 2: return False if l == 2: if found: return False found = True i += l return found ", "class Solution def isDecomposable(self, s): found, l = False, 0 for i, c in enumerate(s): if not l or c != s[i-1]: if l: return False l = 1 continue l += 1 if l == 2: if i == len(s)-1 or s[i] != s[i+1]: if found: return False found, l = True, 0 elif l == 3: l = 0 return found ", "class Solution def longestValidParentheses(self, s): def length(it, start, c): depth, longest = 0, 0 for i in it: if s[i] == c: depth += 1 else: depth -= 1 if depth < 0: start, depth = i, 0 elif depth == 0: longest = max(longest, abs(i - start)) return longest return max(length(xrange(len(s)), -1, '('), length(reversed(xrange(len(s))), len(s), ')')) ", "class Solution def longestValidParentheses(self, s): longest, last, indices = 0, -1, [] for i in xrange(len(s)): if s[i] == '(': indices.append(i) elif not indices: last = i else: indices.pop() if not indices: longest = max(longest, i - last) else: longest = max(longest, i - indices[-1]) return longest ", "class Solution def lowestCommonAncestor(self, root, p, q): s, b = sorted([p.val, q.val]) while not s <= root.val <= b: root = root.left if s <= root.val else root.right return root ", "class Solution def findWordsContaining(self, words, x): return [i for i, w in enumerate(words) if x in w] ", "class Solution def colorBorder(self, grid, r0, c0, color): directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] lookup, q, borders = set([(r0, c0)]), collections.deque([(r0, c0)]), [] while q: r, c = q.popleft() is_border = False for direction in directions: nr, nc = r+direction[0], c+direction[1] if not ((0 <= nr < len(grid)) and (0 <= nc < len(grid[0])) and grid[nr][nc] == grid[r][c]): is_border = True continue if (nr, nc) in lookup: continue lookup.add((nr, nc)) q.append((nr, nc)) if is_border: borders.append((r, c)) for r, c in borders: grid[r][c] = color return grid ", "class Solution def numberOfStableArrays(self, zero, one, limit): MOD = 10**9+7 dp = [[[0]*2 for _ in xrange(one+1)] for _ in xrange(zero+1)] for i in xrange(zero+1): dp[i][0][0] = 1 if i <= limit else 0 for j in xrange(one+1): dp[0][j][1] = 1 if j <= limit else 0 for i in xrange(1, zero+1): for j in xrange(1, one+1): dp[i][j][0] = (dp[i-1][j][0]+dp[i-1][j][1])%MOD dp[i][j][1] = (dp[i][j-1][0]+dp[i][j-1][1])%MOD if i-limit-1 >= 0: dp[i][j][0] = (dp[i][j][0]-dp[i-limit-1][j][1])%MOD if j-limit-1 >= 0: dp[i][j][1] = (dp[i][j][1]-dp[i][j-limit-1][0])%MOD return (dp[-1][-1][0]+dp[-1][-1][1])%MOD ", "class Solution def medianOfUniquenessArray(self, nums): def binary_search(left, right, check): while left <= right: mid = left + (right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left def check(k): result = 0 cnt = collections.Counter() left = 0 for right in xrange(len(nums)): cnt[nums[right]] += 1 while len(cnt) == k+1: cnt[nums[left]] -= 1 if cnt[nums[left]] == 0: del cnt[nums[left]] left += 1 result += right-left+1 return result >= total-result total = (len(nums)+1)*len(nums)//2 return binary_search(1, len(set(nums)), check) ", "class Solution def numberOfPowerfulInt(self, start, finish, limit, s): def count(x): def length(x): result = 0 while x: x //= 10 result += 1 return result result = 0 n = length(x) base = 10**n l = n-len(s) cnt = (limit+1)**l for i in xrange(l): base //= 10 curr = x//base%10 cnt //= limit+1 result += (min(curr-1, limit)-0+1)*cnt if curr > limit: break else: if x%base >= int(s): result += 1 return result return count(finish)-count(start-1) ", "class Solution def numberOfPowerfulInt(self, start, finish, limit, s): def count(x): result = 0 str_x = str(x) l = len(str_x)-len(s) cnt = (limit+1)**l for i in xrange(l): cnt //= limit+1 result += (min(int(str_x[i])-1, limit)-0+1)*cnt if int(str_x[i]) > limit: break else: if int(str_x[-len(s):]) >= int(s): result += 1 return result return count(finish)-count(start-1) ", "class Solution def canArrange(self, arr, k): count = collections.Counter(i%k for i in arr) return (0 not in count or not count[0]%2) and all(k-i in count and count[i] == count[k-i] for i in xrange(1, k) if i in count) ", "class Solution def calculate(self, s): def compute(operands, operators): right, left = operands.pop(), operands.pop() operands.append(ops[operators.pop()](left, right)) ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div} precedence = {'+':0, '-':0, '*':1, '/':1} operands, operators, operand = [], [], 0 for i in xrange(len(s)): if s[i].isdigit(): operand = operand*10 + int(s[i]) if i == len(s)-1 or not s[i+1].isdigit(): operands.append(operand) operand = 0 elif s[i] == '(': operators.append(s[i]) elif s[i] == ')': while operators[-1] != '(': compute(operands, operators) operators.pop() elif s[i] in precedence: while operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[s[i]]: compute(operands, operators) operators.append(s[i]) while operators: compute(operands, operators) return operands[-1] ", "class Solution def calculate(self, s): operands, operators = [], [] operand = \"\" for i in reversed(xrange(len(s))): if s[i].isdigit(): operand += s[i] if i == 0 or not s[i-1].isdigit(): operands.append(int(operand[::-1])) operand = \"\" elif s[i] == ')' or s[i] == '+' or s[i] == '-': operators.append(s[i]) elif s[i] == '(': while operators[-1] != ')': self.compute(operands, operators) operators.pop() while operators: self.compute(operands, operators) return operands[-1] def compute(self, operands, operators): left, right = operands.pop(), operands.pop() op = operators.pop() if op == '+': operands.append(left + right) elif op == '-': operands.append(left - right) ", "class Solution def longestCommonPrefix(self, strs): if not strs: return \"\" for i in xrange(len(strs[0])): for string in strs[1:]: if i >= len(string) or string[i] != strs[0][i]: return strs[0][:i] return strs[0] ", "class Solution def longestCommonPrefix(self, strs): prefix = \"\" for chars in zip(*strs): if all(c == chars[0] for c in chars): prefix += chars[0] else: return prefix return prefix ", "class Solution def maximizeSweetness(self, sweetness, K): def check(sweetness, K, x): curr, cuts = 0, 0 for s in sweetness: curr += s if curr >= x: cuts += 1 curr = 0 return cuts >= K+1 left, right = min(sweetness), sum(sweetness)//(K+1) while left <= right: mid = left + (right-left)//2 if not check(sweetness, K, mid): right = mid-1 else: left = mid+1 return right ", "class Solution def minOperations(self, k): def isqrt(n): a, b = n, (n+1)//2 while b < a: a, b = b, (b+n//b)//2 return a def ceil_divide(a, b): return (a+b-1)//b x = isqrt(k) return (x-1)+(ceil_divide(k, x)-1) ", "class Solution def __init__(self): M = 10**5 self.__lookup = [0] i = 10 while i < M: self.__lookup.append(i) i *= 10 self.__lookup.append(i) def findNumbers(self, nums): def digit_count(n): return bisect.bisect_right(self.__lookup, n) return sum(digit_count(n) % 2 == 0 for n in nums) ", "class Solution def findNumbers(self, nums): def digit_count(n): result = 0 while n: n //= 10 result += 1 return result return sum(digit_count(n) % 2 == 0 for n in nums) ", "class Solution def findNumbers(self, nums): return sum(len(str(n)) % 2 == 0 for n in nums) ", "class Solution def averageWaitingTime(self, customers): avai = wait = 0.0 for a, t in customers: avai = max(avai, a)+t wait += avai-a return wait/len(customers) ", "class Solution def largestSubarray(self, nums, k): left, right, l = 0, 1, 0 while right+k-1 < len(nums) and right+l < len(nums): if nums[left+l] == nums[right+l]: l += 1 continue if nums[left+l] > nums[right+l]: right += l+1 else: left = max(right, min(left+l+1, len(nums)-k)) right = left+1 l = 0 return nums[left:left+k] ", "class Solution def confusingNumber(self, N): lookup = {\"0\":\"0\", \"1\":\"1\", \"6\":\"9\", \"8\":\"8\", \"9\":\"6\"} S = str(N) result = [] for i in xrange(len(S)): if S[i] not in lookup: return False for i in xrange((len(S)+1)//2): if S[i] != lookup[S[-(i+1)]]: return True return False ", "class Solution def getNoZeroIntegers(self, n): a, curr, base = 0, n, 1 while curr: if curr % 10 == 0 or (curr % 10 == 1 and curr != 1): a += base curr -= 10 a += base base *= 10 curr //= 10 return [a, n-a] ", "class Solution def getNoZeroIntegers(self, n): return next([a, n-a] for a in xrange(1, n) if '0' not in '{}{}'.format(a, n-a)) ", "class Solution def transformArray(self, arr): def is_changable(arr): return any(arr[i-1] > arr[i] < arr[i+1] or arr[i-1] < arr[i] > arr[i+1] for i in xrange(1, len(arr)-1)) while is_changable(arr): new_arr = arr[:] for i in xrange(1, len(arr)-1): new_arr[i] += arr[i-1] > arr[i] < arr[i+1] new_arr[i] -= arr[i-1] < arr[i] > arr[i+1] arr = new_arr return arr ", "class Solution def indexPairs(self, text, words): result = [] reversed_words = [w[::-1] for w in words] trie = AhoTrie(reversed_words) for i in reversed(xrange(len(text))): for j in trie.step(text[i]): result.append([i, i+len(reversed_words[j])-1]) result.reverse() return result ", "class Solution def letterCombinations(self, digits): if not digits: return [] lookup = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] total = 1 for digit in digits: total *= len(lookup[int(digit)]) result = [] for i in xrange(total): base, curr = total, [] for digit in digits: choices = lookup[int(digit)] base //= len(choices) curr.append(choices[(i//base)%len(choices)]) result.append(\"\".join(curr)) return result ", "class Solution def letterCombinations(self, digits): if not digits: return [] result = [\"\"] lookup = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] for digit in reversed(digits): choices = lookup[int(digit)] m, n = len(choices), len(result) result.extend([result[i % n] for i in xrange(n, m*n)]) for i in xrange(m*n): result[i] = choices[i//n] + result[i] return result ", "class Solution def letterCombinations(self, digits): lookup = [\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"] def letterCombinationsRecu(result, digits, curr, n): if n == len(digits): result.append(\"\".join(curr)) return for choice in lookup[int(digits[n])]: curr.append(choice) letterCombinationsRecu(result, digits, curr, n+1) curr.pop() if not digits: return [] result = [] letterCombinationsRecu(result, digits, [], 0) return result ", "class Solution def digitsCount(self, d, low, high): def digitsCount(n, k): pivot, result = 1, 0 while n >= pivot: result += (n//(10*pivot))*pivot + min(pivot, max(n%(10*pivot) - k*pivot + 1, 0)) if k == 0: result -= pivot pivot *= 10 return result+1 return digitsCount(high, d) - digitsCount(low-1, d) ", "class Solution def houseCount(self, street, k): while not street.isDoorOpen(): street.moveRight() result = 0 for i in xrange(k+1): if i and street.isDoorOpen(): street.closeDoor() result = i street.moveRight() return result ", "class Solution def getMaximumGenerated(self, n): if n+1 > len(dp): for i in xrange(len(nums), n+1): if i%2 == 0: nums.append(nums[i//2]) else: nums.append(nums[i//2] + nums[i//2+1]) dp.append(max(dp[-1], nums[-1])) return dp[n] ", "class Solution def getMaximumGenerated(self, n): if n == 0: return 0 nums = [0]*(n+1) nums[1] = 1 result = 1 for i in xrange(2, n+1): if i%2 == 0: nums[i] = nums[i//2] else: nums[i] = nums[i//2] + nums[i//2+1] result = max(result, nums[i]) return result ", "class Solution def canReach(self, arr, start): q, lookup = collections.deque([start]), set([start]) while q: i = q.popleft() if not arr[i]: return True for j in [i-arr[i], i+arr[i]]: if 0 <= j < len(arr) and j not in lookup: lookup.add(j) q.append(j) return False ", "class Solution def movesToMakeZigzag(self, nums): result = [0, 0] for i in xrange(len(nums)): left = nums[i-1] if i-1 >= 0 else float(\"inf\") right = nums[i+1] if i+1 < len(nums) else float(\"inf\") result[i%2] += max(nums[i] - min(left, right) + 1, 0) return min(result) ", "class Solution def findThePrefixCommonArray(self, A, B): result = [0]*len(A) cnt = collections.Counter() curr = 0 for i, (a, b) in enumerate(itertools.izip(A, B)): cnt[a] += 1 if cnt[a] == 2: curr += 1 cnt[b] += 1 if cnt[b] == 2: curr += 1 result[i] = curr return result ", "class Solution def longestRepeating(self, s, queryCharacters, queryIndices): LEFT, RIGHT, LEFT_LEN, RIGHT_LEN, LEN, MAX_LEN, SIZE = xrange(7) def build(i): return update(s[i]) def update(y): result = [0]*SIZE result[LEFT] = result[RIGHT] = y result[LEN] = result[LEFT_LEN] = result[RIGHT_LEN] = result[MAX_LEN] = 1 return result def query(x, y): return x if y is None else [x[LEFT], y[RIGHT], x[LEFT_LEN]+(y[LEFT_LEN] if x[LEFT_LEN] == x[LEN] and x[RIGHT] == y[LEFT] else 0), y[RIGHT_LEN]+(x[RIGHT_LEN] if y[RIGHT_LEN] == y[LEN] and y[LEFT] == x[RIGHT] else 0), x[LEN]+y[LEN], max(x[MAX_LEN], y[MAX_LEN], x[RIGHT_LEN]+y[LEFT_LEN] if x[RIGHT] == y[LEFT] else 0)] result = [] st = SegmentTree(len(s), build_fn=build, query_fn=query, update_fn=update) for c, i in itertools.izip(queryCharacters, queryIndices): st.update(i, c) result.append(st.tree[1][MAX_LEN]) return result import itertools class SegmentTree2(object): def __init__(self, N, build_fn=lambda _: float(\"inf\"), query_fn=lambda x, y: y if x is None else x if y is None else min(x, y), update_fn=lambda x: x): self.tree = [None]*(2*2**((N-1).bit_length())) self.base = len(self.tree)//2 self.query_fn = query_fn self.update_fn = update_fn for i in xrange(self.base, self.base+N): self.tree[i] = build_fn(i-self.base) for i in reversed(xrange(1, self.base)): self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1]) def update(self, i, h): x = self.base+i self.tree[x] = self.update_fn(h) while x > 1: x //= 2 self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1]) def query(self, L, R): if L > R: return None L += self.base R += self.base left = right = None while L <= R: if L & 1: left = self.query_fn(left, self.tree[L]) L += 1 if R & 1 == 0: right = self.query_fn(self.tree[R], right) R -= 1 L //= 2 R //= 2 return self.query_fn(left, right) ", "class Solution def longestRepeating(self, s, queryCharacters, queryIndices): LEFT, RIGHT, LEFT_LEN, RIGHT_LEN, LEN, MAX_LEN, SIZE = xrange(7) def build(i): return update(s[i]) def update(y): result = [0]*SIZE result[LEN] = result[LEFT_LEN] = result[RIGHT_LEN] = result[MAX_LEN] = 1 result[LEFT] = result[RIGHT] = y return result def query(x, y): return y if x is None else x if y is None else [x[LEFT], y[RIGHT], x[LEFT_LEN]+(y[LEFT_LEN] if x[LEFT_LEN] == x[LEN] and x[RIGHT] == y[LEFT] else 0), y[RIGHT_LEN]+(x[RIGHT_LEN] if y[RIGHT_LEN] == y[LEN] and y[LEFT] == x[RIGHT] else 0), x[LEN]+y[LEN], max(x[MAX_LEN], y[MAX_LEN], x[RIGHT_LEN]+y[LEFT_LEN] if x[RIGHT] == y[LEFT] else 0)] result = [] st = SegmentTree2(len(s), build_fn=build, query_fn=query, update_fn=update) for c, i in itertools.izip(queryCharacters, queryIndices): st.update(i, c) result.append(st.query(0, len(s)-1)[MAX_LEN]) return result ", "class Solution def postorderTraversal(self, root): dummy = TreeNode(0) dummy.left = root result, cur = [], dummy while cur: if cur.left is None: cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: node.right = cur cur = cur.left else: result += self.traceBack(cur.left, node) node.right = None cur = cur.right return result def traceBack(self, frm, to): result, cur = [], frm while cur is not to: result.append(cur.val) cur = cur.right result.append(to.val) result.reverse() return result ", "class Solution def postorderTraversal(self, root): result, stack = [], [(root, False)] while stack: root, is_visited = stack.pop() if root is None: continue if is_visited: result.append(root.val) else: stack.append((root, True)) stack.append((root.right, False)) stack.append((root.left, False)) return result ", "class Solution def countHillValley(self, nums): result, inc = 0, -1 for i in xrange(len(nums)-1): if nums[i] < nums[i+1]: result += int(inc == 0) inc = 1 elif nums[i] > nums[i+1]: result += int(inc == 1) inc = 0 return result ", "class Solution def findTheLongestSubstring(self, s): VOWELS = \"aeiou\" result, mask, lookup = 0, 0, [-2]*(2**len(VOWELS)) lookup[0] = -1 for i, c in enumerate(s): index = VOWELS.find(c) mask ^= (1 << index) if index >= 0 else 0 if lookup[mask] == -2: lookup[mask] = i result = max(result, i-lookup[mask]) return result ", "class Solution def distanceK(self, root, target, K): def dfs(parent, child, neighbors): if not child: return if parent: neighbors[parent.val].append(child.val) neighbors[child.val].append(parent.val) dfs(child, child.left, neighbors) dfs(child, child.right, neighbors) neighbors = collections.defaultdict(list) dfs(None, root, neighbors) bfs = [target.val] lookup = set(bfs) for _ in xrange(K): bfs = [nei for node in bfs for nei in neighbors[node] if nei not in lookup] lookup |= set(bfs) return bfs ", "class Solution def sortString(self, s): result, count = [], [0]*26 for c in s: count[ord(c)-ord('a')] += 1 while len(result) != len(s): for c in xrange(len(count)): if not count[c]: continue result.append(chr(ord('a')+c)) count[c] -= 1 for c in reversed(xrange(len(count))): if not count[c]: continue result.append(chr(ord('a')+c)) count[c] -= 1 return \"\".join(result) import collections ", "class Solution def sortString(self, s): result, count, desc = [], collections.Counter(s), False while count: for c in sorted(count.keys(), reverse=desc): result.append(c) count[c] -= 1 if not count[c]: del count[c] desc = not desc return \"\".join(result) ", "class Solution def isSubstringPresent(self, s): lookup = [[False]*26 for _ in xrange(26)] for i in xrange(len(s)-1): lookup[ord(s[i])-ord('a')][ord(s[i+1])-ord('a')] = True return any(lookup[ord(s[i+1])-ord('a')][ord(s[i])-ord('a')] for i in xrange(len(s)-1)) import collections ", "class Solution def isSubstringPresent(self, s): lookup = collections.defaultdict(set) for i in xrange(len(s)-1): lookup[s[i]].add(s[i+1]) return any(s[i] in lookup[s[i+1]] for i in xrange(len(s)-1)) ", "class Solution def findRadius(self, houses, heaters): heaters.sort() min_radius = 0 for house in houses: equal_or_larger = bisect.bisect_left(heaters, house) curr_radius = float(\"inf\") if equal_or_larger != len(heaters): curr_radius = heaters[equal_or_larger] - house if equal_or_larger != 0: smaller = equal_or_larger-1 curr_radius = min(curr_radius, house - heaters[smaller]) min_radius = max(min_radius, curr_radius) return min_radius ", "class Solution def matchReplacement(self, s, sub, mappings): def transform(x): return ord(x)-ord('0') if x.isdigit() else ord(x)-ord('a')+10 if x.islower() else ord(x)-ord('A')+36 def check(i): return all(sub[j] == s[i+j] or lookup[sub[j]][s[i+j]] for j in xrange(len(sub))) lookup = [[0]*62 for _ in xrange(62)] for a, b in mappings: lookup[transform(a)][transform(b)] = 1 s = map(transform, s) sub = map(transform, sub) return any(check(i) for i in xrange(len(s)-len(sub)+1)) import collections ", "class Solution def matchReplacement(self, s, sub, mappings): def check(i): return all(sub[j] == s[i+j] or (sub[j], s[i+j]) in lookup for j in xrange(len(sub))) lookup = set() for a, b in mappings: lookup.add((a, b)) return any(check(i) for i in xrange(len(s)-len(sub)+1)) ", "class Solution def beautifulArray(self, N): result = [1] while len(result) < N: result = [i*2 - 1 for i in result] + [i*2 for i in result] return [i for i in result if i <= N] ", "class Solution def numDecodings(self, s): if len(s) == 0 or s[0] == '0': return 0 prev, prev_prev = 1, 0 for i in xrange(len(s)): cur = 0 if s[i] != '0': cur = prev if i > 0 and (s[i - 1] == '1' or (s[i - 1] == '2' and s[i] <= '6')): cur += prev_prev prev, prev_prev = cur, prev return prev ", "class Solution def isGoodArray(self, nums): def gcd(a, b): while b: a, b = b, a%b return a result = nums[0] for num in nums: result = gcd(result, num) if result == 1: break return result == 1 ", "class Solution def lengthOfLongestSubstringTwoDistinct(self, s): longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in xrange(256)] for i, char in enumerate(s): if visited[ord(char)] == 0: distinct_count += 1 visited[ord(char)] += 1 while distinct_count > 2: visited[ord(s[start])] -= 1 if visited[ord(s[start])] == 0: distinct_count -= 1 start += 1 longest = max(longest, i - start + 1) return longest from collections import Counter ", "class Solution def lengthOfLongestSubstringTwoDistinct(self, s): counter = Counter() left, max_length = 0, 0 for right, char in enumerate(s): counter[char] += 1 while len(counter) > 2: counter[s[left]] -= 1 if counter[s[left]] == 0: del counter[s[left]] left += 1 max_length = max(max_length, right-left+1) return max_length ", "class Solution def maxPower(self, s): result, count = 1, 1 for i in xrange(1, len(s)): if s[i] == s[i-1]: count += 1 else: count = 1 result = max(result, count) return result import itertools ", "class Solution def maxPower(self, s): return max(len(list(v)) for _, v in itertools.groupby(s)) ", "class Solution def validPath(self, n, edges, start, end): def bi_bfs(adj, start, target): left, right = {start}, {target} lookup = set() steps = 0 while left: for pos in left: lookup.add(pos) new_left = set() for pos in left: if pos in right: return steps for nei in adj[pos]: if nei in lookup: continue new_left.add(nei) left = new_left steps += 1 if len(left) > len(right): left, right = right, left return -1 adj = collections.defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) return bi_bfs(adj, start, end) >= 0 ", "class Solution def validPath(self, n, edges, start, end): def bfs(adj, start, target): q = [start] lookup = set(q) steps = 0 while q: new_q = [] for pos in q: if pos == target: return steps for nei in adj[pos]: if nei in lookup: continue lookup.add(nei) new_q.append(nei) q = new_q steps += 1 return -1 adj = collections.defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) return bfs(adj, start, end) >= 0 ", "class Solution def validPath(self, n, edges, start, end): def dfs(adj, start, target): stk = [start] lookup = set(stk) while stk: pos = stk.pop() if pos == target: return True for nei in reversed(adj[pos]): if nei in lookup: continue lookup.add(nei) stk.append(nei) return False adj = collections.defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) return dfs(adj, start, end) ", "class Solution def diffWaysToCompute(self, input): tokens = re.split('(\\D)', input) nums = map(int, tokens[::2]) ops = map({'+': operator.add, '-': operator.sub, '*': operator.mul}.get, tokens[1::2]) lookup = [[None for _ in xrange(len(nums))] for _ in xrange(len(nums))] def diffWaysToComputeRecu(left, right): if left == right: return [nums[left]] if lookup[left][right]: return lookup[left][right] lookup[left][right] = [ops[i](x, y) for i in xrange(left, right) for x in diffWaysToComputeRecu(left, i) for y in diffWaysToComputeRecu(i + 1, right)] return lookup[left][right] return diffWaysToComputeRecu(0, len(nums) - 1) ", "class Solution def diffWaysToCompute(self, input): lookup = [[None for _ in xrange(len(input) + 1)] for _ in xrange(len(input) + 1)] ops = {'+': operator.add, '-': operator.sub, '*': operator.mul} def diffWaysToComputeRecu(left, right): if lookup[left][right]: return lookup[left][right] result = [] for i in xrange(left, right): if input[i] in ops: for x in diffWaysToComputeRecu(left, i): for y in diffWaysToComputeRecu(i + 1, right): result.append(ops[input[i]](x, y)) if not result: result = [int(input[left:right])] lookup[left][right] = result return lookup[left][right] return diffWaysToComputeRecu(0, len(input)) ", "class Solution def findPattern(self, stream, pattern): def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j+1 > 0 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix prefix = getPrefix(pattern) i = j = -1 while True: d = stream.next() i += 1 while j+1 > 0 and pattern[j+1] != d: j = prefix[j] if pattern[j+1] == d: j += 1 if j+1 == len(pattern): return i-j return -1 ", "class Solution def countDaysTogether(self, arriveAlice, leaveAlice, arriveBob, leaveBob): NUMS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] prefix = [0]*(len(NUMS)+1) for i in xrange(len(NUMS)): prefix[i+1] += prefix[i]+NUMS[i] def day(date): return prefix[int(date[:2])-1]+int(date[3:]) return max(day(min(leaveAlice, leaveBob))-day(max(arriveAlice, arriveBob))+1, 0) ", "class Solution def canCross(self, stones): if stones[1] != 1: return False last_jump_units = {s: set() for s in stones} last_jump_units[1].add(1) for s in stones[:-1]: for j in last_jump_units[s]: for k in (j-1, j, j+1): if k > 0 and s+k in last_jump_units: last_jump_units[s+k].add(k) return bool(last_jump_units[stones[-1]]) ", "class Solution def canMakeSubsequence(self, str1, str2): i = 0 for c in str1: if (ord(str2[i])-ord(c))%26 > 1: continue i += 1 if i == len(str2): return True return False ", "class Solution def kBigIndices(self, nums, k): right = [False]*len(nums) max_heap1 = [] for i in reversed(xrange(len(nums))): if len(max_heap1) == k and nums[i] > -max_heap1[0]: right[i] = True heapq.heappush(max_heap1, -nums[i]) if len(max_heap1) == k+1: heapq.heappop(max_heap1) result = 0 max_heap2 = [] for i in xrange(len(nums)): if len(max_heap2) == k and nums[i] > -max_heap2[0] and right[i]: result += 1 heapq.heappush(max_heap2, -nums[i]) if len(max_heap2) == k+1: heapq.heappop(max_heap2) return result from sortedcontainers import SortedList ", "class Solution def kBigIndices(self, nums, k): sl1, sl2 = SortedList(), SortedList(nums) result = 0 for x in nums: sl2.remove(x) if sl1.bisect_left(x) >= k and sl2.bisect_left(x) >= k: result += 1 sl1.add(x) return result ", "class Solution def countPairsOfConnectableServers(self, edges, signalSpeed): def iter_dfs(u, p, dist): result = 0 stk = [(u, p, dist)] while stk: u, p, dist = stk.pop() if dist%signalSpeed == 0: result += 1 for v, w in reversed(adj[u]): if v == p: continue stk.append((v, u, dist+w)) return result adj = [[] for _ in xrange(len(edges)+1)] for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) result = [0]*(len(edges)+1) for u in xrange(len(result)): curr = 0 for v, w in adj[u]: cnt = iter_dfs(v, u, w) result[u] += curr*cnt curr += cnt return result ", "class Solution def countPairsOfConnectableServers(self, edges, signalSpeed): def dfs(u, p, dist): cnt = 1 if dist%signalSpeed == 0 else 0 for v, w in adj[u]: if v == p: continue cnt += dfs(v, u, dist+w) return cnt adj = [[] for _ in xrange(len(edges)+1)] for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) result = [0]*(len(edges)+1) for u in xrange(len(result)): curr = 0 for v, w in adj[u]: cnt = dfs(v, u, w) result[u] += curr*cnt curr += cnt return result ", "class Solution def countPairsOfConnectableServers(self, edges, signalSpeed): def bfs(u, p, dist): result = 0 q = [(u, p, dist)] while q: new_q = [] for u, p, dist in q: if dist%signalSpeed == 0: result += 1 for v, w in adj[u]: if v == p: continue new_q.append((v, u, dist+w)) q = new_q return result adj = [[] for _ in xrange(len(edges)+1)] for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) result = [0]*(len(edges)+1) for u in xrange(len(result)): curr = 0 for v, w in adj[u]: cnt = bfs(v, u, w) result[u] += curr*cnt curr += cnt return result ", "class Solution def diagonalSum(self, mat): return sum(mat[i][i]+mat[~i][i] for i in xrange(len(mat))) - (mat[len(mat)//2][len(mat)//2] if len(mat)%2 == 1 else 0) ", "class Solution def longestString(self, x, y, z): return ((min(x, y)*2+int(x != y))+z)*2 ", "class Solution def waysToReachStair(self, k): def ceil_log2_x(x): return (x-1).bit_length() l = ceil_log2_x(k) while (1<<l)-k <= l+1: l += 1 fact = [1]*(l+1) for i in xrange(len(fact)-1): fact[i+1] = fact[i]*(i+1) def nCr(n, r): if not (0 <= r <= n): return 0 return fact[n]//fact[r]//fact[n-r] return sum(nCr(i+1, (1<<i)-k) for i in xrange(l)) ", "class Solution def countGoodNumbers(self, n): def powmod(a, b, mod): a %= mod result = 1 while b: if b&1: result = (result*a)%mod a = (a*a)%mod b >>= 1 return result MOD = 10**9 + 7 return powmod(5, (n+1)//2%(MOD-1), MOD)*powmod(4, n//2%(MOD-1), MOD) % MOD ", "class Solution def countGoodNumbers(self, n): MOD = 10**9 + 7 return pow(5, (n+1)//2%(MOD-1), MOD)*pow(4, n//2%(MOD-1), MOD) % MOD ", "class Solution def circularPermutation(self, n, start): return [start ^ (i>>1) ^ i for i in xrange(1<<n)] ", "class Solution def coloredCells(self, n): return n**2+(n-1)**2 ", "class Solution def coloredCells(self, n): return (1+(1+2*(n-1)))*n//2*2-(2*n-1) ", "class Solution def findAnswer(self, n, edges): INF = float(\"inf\") def dijkstra(start): best = [INF]*len(adj) best[start] = 0 min_heap = [(0, start)] while min_heap: curr, u = heapq.heappop(min_heap) if curr > best[u]: continue for v, w in adj[u]: if best[v] <= curr+w: continue best[v] = curr+w heapq.heappush(min_heap, (best[v], v)) return best adj = [[] for _ in xrange(n)] for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) dist1 = dijkstra(0) dist2 = dijkstra(n-1) return [(dist1[u] != INF != dist2[v] and dist1[u]+w+dist2[v] == dist1[n-1]) or (dist2[u] != INF != dist1[v] and dist2[u]+w+dist1[v] == dist2[0]) for i, (u, v, w) in enumerate(edges)] ", "class Solution def maximumScore(self, nums, k): MOD = 10**9+7 def linear_sieve_of_eratosthenes(n): primes = [] spf = [-1]*(n+1) for i in xrange(2, n+1): if spf[i] == -1: spf[i] = i primes.append(i) for p in primes: if i*p > n or p > spf[i]: break spf[i*p] = p return primes lookup = {} def count_of_distinct_prime_factors(x): y = x if y not in lookup: cnt = 0 for p in primes: if p*p > x: break if x%p != 0: continue cnt += 1 while x%p == 0: x //= p if x != 1: cnt += 1 lookup[y] = cnt return lookup[y] primes = linear_sieve_of_eratosthenes(int(max(nums)**0.5)) scores = [count_of_distinct_prime_factors(x) for x in nums] left = [-1]*len(scores) stk = [-1] for i in xrange(len(scores)): while stk[-1] != -1 and scores[stk[-1]] < scores[i]: stk.pop() left[i] = stk[-1] stk.append(i) right = [-1]*len(scores) stk = [len(scores)] for i in reversed(xrange(len(scores))): while stk[-1] != len(scores) and scores[stk[-1]] <= scores[i]: stk.pop() right[i] = stk[-1] stk.append(i) result = 1 max_heap = [(-x, i) for i, x in enumerate(nums)] heapq.heapify(max_heap) while max_heap: _, i = heapq.heappop(max_heap) c = min((i-left[i])*(right[i]-i), k) result = (result*pow(nums[i], c, MOD))%MOD k -= c if not k: break return result ", "class Solution def halvesAreAlike(self, s): vowels = set(\"aeiouAEIOU\") cnt1 = cnt2 = 0 left, right = 0, len(s)-1 while left < right: cnt1 += s[left] in vowels cnt2 += s[right] in vowels left += 1 right -= 1 return cnt1 == cnt2 ", "class Solution def getFactors(self, n): result = [] factors = [] self.getResult(n, result, factors) return result def getResult(self, n, result, factors): i = 2 if not factors else factors[-1] while i <= n / i: if n % i == 0: factors.append(i) factors.append(n / i) result.append(list(factors)) factors.pop() self.getResult(n / i, result, factors) factors.pop() i += 1 ", "class Solution def canEat(self, candiesCount, queries): prefix = [0]*(len(candiesCount)+1) for i, c in enumerate(candiesCount): prefix[i+1] = prefix[i]+c return [prefix[t]//c < d+1 <= prefix[t+1]//1 for t, d, c in queries] ", "class Solution def numJewelsInStones(self, J, S): lookup = set(J) return sum(s in lookup for s in S) ", "class Solution def findMiddleIndex(self, nums): total = sum(nums) accu = 0 for i, x in enumerate(nums): if accu*2 == total-x: return i accu += x return -1 ", "class Solution def getLonelyNodes(self, root): result = [] stk = [root] while stk: node = stk.pop() if not node: continue if node.left and not node.right: result.append(node.left.val) elif node.right and not node.left: result.append(node.right.val) stk.append(node.right) stk.append(node.left) return result ", "class Solution def getLonelyNodes(self, root): def dfs(node, result): if not node: return if node.left and not node.right: result.append(node.left.val) elif node.right and not node.left: result.append(node.right.val) dfs(node.left, result) dfs(node.right, result) result = [] dfs(root, result) return result ", "class Solution def countHousePlacements(self, n): MOD = 10**9+7 def matrix_mult(A, B): ZB = zip(*B) return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A] def matrix_expo(A, K): result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))] while K: if K % 2: result = matrix_mult(result, A) A = matrix_mult(A, A) K /= 2 return result T = [[1, 1], [1, 0]] return pow(matrix_mult([[1, 0]], matrix_expo(T, n+1))[0][0], 2, MOD) ", "class Solution def countHousePlacements(self, n): MOD = 10**9+7 prev, curr = 0, 1 for _ in xrange(n+1): prev, curr = curr, (prev+curr)%MOD return pow(curr, 2, MOD) ", "class Solution head = None def sortedListToBST(self, head): current, length = head, 0 while current is not None: current, length = current.next, length + 1 self.head = head return self.sortedListToBSTRecu(0, length) def sortedListToBSTRecu(self, start, end): if start == end: return None mid = start + (end - start) / 2 left = self.sortedListToBSTRecu(start, mid) current = TreeNode(self.head.val) current.left = left self.head = self.head.next current.right = self.sortedListToBSTRecu(mid + 1, end) return current ", "class Solution def beautifulPair(self, nums1, nums2): INF = float(\"inf\") def dist(a, b): if a[2] > b[2]: a, b = b, a return [abs(a[0]-b[0])+abs(a[1]-b[1]), a[2], b[2]] def cell(point, size): x, y, _ = point return math.floor(x/size), math.floor(y/size) def improve(): lookup = {} for p in points: i, j = map(int, cell(p, result[0]/2.0)) for ni in xrange(i-2, (i+2)+1): for nj in xrange(j-2, (j+2)+1): if (ni, nj) not in lookup: continue d = dist(p, lookup[ni, nj]) if d < result: result[:] = d return True lookup[i, j] = p return False points = [(i, j, idx) for idx, (i, j) in enumerate(itertools.izip(nums1, nums2))] result = [INF]*3 lookup = {} for i in reversed(xrange(len(points))): if points[i][:2] in lookup: result = [0, i, lookup[points[i][:2]]] lookup[points[i][:2]] = i if result[0] == 0: return result[1:] random.shuffle(points) result = dist(points[0], points[1]) while improve(): pass return result[1:] import itertools ", "class Solution def beautifulPair(self, nums1, nums2): INF = float(\"inf\") MAX_NEIGHBOR_COUNT = (8+2)//2 def dist(a, b): if a > b: a, b = b, a return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b] def merge_sort(left, right): def update(arr, i): for j in reversed(xrange(len(arr))): if points[i][1]-points[arr[j]][1] > result[0]: break result[:] = min(result, dist(i, arr[j])) else: j = -1 assert((len(arr)-1)-j <= MAX_NEIGHBOR_COUNT) if left == right: return mid = left+(right-left)//2 x = points[order[mid]][0] merge_sort(left, mid) merge_sort(mid+1, right) tmp, tmp_l, tmp_r = [], [], [] l, r = left, mid+1 while l <= mid or r <= right: if r == right+1 or (l <= mid and points[order[l]][1] <= points[order[r]][1]): update(tmp_r, order[l]) if x-points[order[l]][0] <= result[0]: tmp_l.append(order[l]) tmp.append(order[l]) l += 1 else: update(tmp_l, order[r]) if points[order[r]][0]-x <= result[0]: tmp_r.append(order[r]) tmp.append(order[r]) r += 1 order[left:right+1] = tmp points = [(i, j) for i, j in itertools.izip(nums1, nums2)] result = [INF]*3 lookup = {} for i in reversed(xrange(len(points))): if points[i] in lookup: result = [0, (i, lookup[points[i]])] lookup[points[i]] = i if result[0] == 0: return result[1] order = range(len(points)) order.sort(key=lambda x: points[x][0]) merge_sort(0, len(points)-1) return result[1:] import itertools ", "class Solution def beautifulPair(self, nums1, nums2): INF = float(\"inf\") MAX_NEIGHBOR_COUNT = 8 def dist(a, b): if a > b: a, b = b, a return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b] def merge_sort(left, right): if left == right: return mid = left + (right-left)//2 x = points[order[mid]][0] merge_sort(left, mid) merge_sort(mid+1, right) r = mid+1 tmp = [] for l in xrange(left, mid+1): while r <= right and points[order[r]][1] < points[order[l]][1]: tmp.append(order[r]) r += 1 tmp.append(order[l]) order[left:left+len(tmp)] = tmp stripe = [order[i] for i in xrange(left, right+1) if abs(points[order[i]][0]-x) <= result[0]] for i in xrange(len(stripe)-1): for j in xrange(i+1, len(stripe)): x, y = stripe[i], stripe[j] if points[y][1]-points[x][1] > result[0]: break result[:] = min(result, dist(x, y)) else: j = len(stripe) assert(j-(i+1) <= MAX_NEIGHBOR_COUNT) points = [(i, j) for i, j in itertools.izip(nums1, nums2)] result = [INF]*3 lookup = {} for i in reversed(xrange(len(points))): if points[i] in lookup: result = [0, (i, lookup[points[i]])] lookup[points[i]] = i if result[0] == 0: return result[1] order = range(len(points)) order.sort(key=lambda x: points[x][0]) merge_sort(0, len(points)-1) return result[1:] import itertools ", "class Solution def beautifulPair(self, nums1, nums2): INF = float(\"inf\") class SegmentTree(object): def __init__(self, N, build_fn=lambda _: [-INF, -INF], query_fn=lambda x, y: y if x is None else x if y is None else max(x, y), update_fn=lambda x: x): self.tree = [None]*(2*2**((N-1).bit_length())) self.base = len(self.tree)//2 self.query_fn = query_fn self.update_fn = update_fn for i in xrange(self.base, self.base+N): self.tree[i] = build_fn(i-self.base) for i in reversed(xrange(1, self.base)): self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1]) def update(self, i, h): x = self.base+i self.tree[x] = self.update_fn(h) while x > 1: x //= 2 self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1]) def query(self, L, R): if L > R: return [-INF, -INF] L += self.base R += self.base left = right = None while L <= R: if L & 1: left = self.query_fn(left, self.tree[L]) L += 1 if R & 1 == 0: right = self.query_fn(self.tree[R], right) R -= 1 L //= 2 R //= 2 return self.query_fn(left, right) def dist(a, b): if a > b: a, b = b, a return [abs(points[a][0]-points[b][0])+abs(points[a][1]-points[b][1]), a, b] points = [(i, j) for i, j in itertools.izip(nums1, nums2)] result = [INF]*3 lookup = {} for i in reversed(xrange(len(points))): if points[i] in lookup: result = [0, (i, lookup[points[i]])] lookup[points[i]] = i if result[0] == 0: return result[1] order = range(len(points)) order.sort(key=lambda x: points[x][0]) y_set = set(y for _, y in points) y_to_idx = {y:i for i, y in enumerate(sorted(y_set))} st1, st2 = SegmentTree(len(y_to_idx)), SegmentTree(len(y_to_idx)) for i in order: j = -st1.query(0, y_to_idx[points[i][1]]-1)[1] if j != INF: assert(points[j][1] < points[i][1]) result = min(result, dist(i, j)) st1.update(y_to_idx[points[i][1]], [points[i][0]+points[i][1], -i]) j = -st2.query(y_to_idx[points[i][1]], len(y_to_idx)-1)[1] if j != INF: assert(points[j][1] >= points[i][1]) result = min(result, dist(i, j)) st2.update(y_to_idx[points[i][1]], [points[i][0]-points[i][1], -i]) return result[1:] ", "class Solution def destroyTargets(self, nums, space): cnt = collections.Counter(x%space for x in nums) mx = max(cnt.itervalues()) return min(x for x in nums if cnt[x%space] == mx) ", "class Solution def titleToNumber(self, s): result = 0 for i in xrange(len(s)): result *= 26 result += ord(s[i]) - ord('A') + 1 return result ", "class Solution def visibleMountains(self, peaks): peaks.sort(key=lambda x: (x[0]-x[1], -(x[0]+x[1]))) result = mx = 0 for i in xrange(len(peaks)): if peaks[i][0]+peaks[i][1] <= mx: continue mx = peaks[i][0]+peaks[i][1] if i+1 == len(peaks) or peaks[i+1] != peaks[i]: result += 1 return result ", "class Solution def visibleMountains(self, peaks): def is_covered(a, b): x1, y1 = a x2, y2 = b return x2-y2 <= x1-y1 and x1+y1 <= x2+y2 peaks.sort() stk = [] for i in xrange(len(peaks)): while stk and is_covered(peaks[stk[-1]], peaks[i]): stk.pop() if (i-1 == -1 or peaks[i-1] != peaks[i]) and (not stk or not is_covered(peaks[i], peaks[stk[-1]])): stk.append(i) return len(stk) ", "class Solution def maxChunksToSorted(self, arr): result, max_i = 0, 0 for i, v in enumerate(arr): max_i = max(max_i, v) if max_i == i: result += 1 return result ", "class Solution def maxChunksToSorted(self, arr): result, increasing_stk = 0, [] for num in arr: max_num = num if not increasing_stk else max(increasing_stk[-1], num) while increasing_stk and increasing_stk[-1] > num: increasing_stk.pop() increasing_stk.append(max_num) return len(increasing_stk) ", "class Solution def minChanges(self, nums, k): def one_are_not_from_nums(nums, cnts): mxs = [cnts[i].most_common(1)[0][1] for i in xrange(k)] return len(nums) - (sum(mxs)-min(mxs)) def all_are_from_nums(nums, cnts): dp = {0:0} for cnt in cnts: new_dp = collections.defaultdict(int) for x in dp.iterkeys(): for y in cnt.iterkeys(): new_dp[x^y] = max(new_dp[x^y], dp[x]+cnt[y]) dp = new_dp return len(nums)-dp[0] cnts = [collections.Counter(nums[j] for j in xrange(i, len(nums), k)) for i in xrange(k)] return min(one_are_not_from_nums(nums, cnts), all_are_from_nums(nums, cnts)) ", "class Solution def countQuadruplets(self, nums): dp = [0]*len(nums) result = 0 for l in xrange(len(nums)): cnt = 0 for j in xrange(l): if nums[j] < nums[l]: cnt += 1 result += dp[j] elif nums[j] > nums[l]: dp[j] += cnt return result ", "class Solution def countQuadruplets(self, nums): right = [[0]*(len(nums)+1) for _ in xrange(len(nums))] for j in xrange(len(nums)): for i in reversed(xrange(j+1, len(nums))): right[j][i] = right[j][i+1] + int(nums[i] > nums[j]) result = 0 for k in xrange(len(nums)): left = 0 for j in xrange(k): if nums[k] < nums[j]: result += left*right[j][k+1] left += int(nums[k] > nums[j]) return result ", "class Solution def countQuadruplets(self, nums): left = [[0]*(len(nums)+1) for _ in xrange(len(nums))] for j in xrange(len(nums)): for i in xrange(j): left[j][i+1] = left[j][i] + int(nums[i] < nums[j]) right = [[0]*(len(nums)+1) for _ in xrange(len(nums))] for j in xrange(len(nums)): for i in reversed(xrange(j+1, len(nums))): right[j][i] = right[j][i+1] + int(nums[i] > nums[j]) result = 0 for k in xrange(len(nums)): for j in xrange(k): if nums[k] < nums[j]: result += left[k][j]*right[j][k+1] return result ", "class Solution def findPeakGrid(self, mat): def get_vec(mat, i): return mat[i] if len(mat) > len(mat[0]) else (mat[j][i] for j in xrange(len(mat))) def check(mat, x): return max(get_vec(mat, x)) > max(get_vec(mat, x+1)) left, right = 0, (max(len(mat), len(mat[0]))-1)-1 while left <= right: mid = left + (right-left)//2 if check(mat, mid): right = mid-1 else: left = mid+1 mav_val = max(get_vec(mat, left)) result = [left, next(i for i, x in enumerate(get_vec(mat, left)) if x == mav_val)] return result if len(mat) > len(mat[0]) else result[::-1] ", "class Solution def kEmptySlots(self, flowers, k): days = [0] * len(flowers) for i in xrange(len(flowers)): days[flowers[i]-1] = i result = float(\"inf\") i, left, right = 0, 0, k+1 while right < len(days): if days[i] < days[left] or days[i] <= days[right]: if i == right: result = min(result, max(days[left], days[right])) left, right = i, k+1+i i += 1 return -1 if result == float(\"inf\") else result+1 ", "class Solution def hasAllCodes(self, s, k): return 2**k <= len(s) and len({s[i:i+k] for i in xrange(len(s)-k+1)}) == 2**k ", "class Solution def hasAllCodes(self, s, k): lookup = set() base = 2**k if base > len(s): return False num = 0 for i in xrange(len(s)): num = (num << 1) + (s[i] == '1') if i >= k-1: lookup.add(num) num -= (s[i-k+1] == '1') * (base//2) return len(lookup) == base ", "class Solution def maxSumSubmatrix(self, matrix, k): if not matrix: return 0 m = min(len(matrix), len(matrix[0])) n = max(len(matrix), len(matrix[0])) result = float(\"-inf\") for i in xrange(m): sums = [0] * n for j in xrange(i, m): for l in xrange(n): sums[l] += matrix[j][l] if m == len(matrix) else matrix[l][j] accu_sum_set, accu_sum = [0], 0 for sum in sums: accu_sum += sum it = bisect_left(accu_sum_set, accu_sum - k) if it != len(accu_sum_set): result = max(result, accu_sum - accu_sum_set[it]) insort(accu_sum_set, accu_sum) return result class Solution_TLE(object): def maxSumSubmatrix(self, matrix, k): class BST(object): def __init__(self, val): self.val = val self.left = None self.right = None def insert(self, val): curr = self while curr: if curr.val >= val: if curr.left: curr = curr.left else: curr.left = BST(val) return else: if curr.right: curr = curr.right else: curr.right = BST(val) return def lower_bound(self, val): result, curr = None, self while curr: if curr.val >= val: result, curr = curr, curr.left else: curr = curr.right return result if not matrix: return 0 m = min(len(matrix), len(matrix[0])) n = max(len(matrix), len(matrix[0])) result = float(\"-inf\") for i in xrange(m): sums = [0] * n for j in xrange(i, m): for l in xrange(n): sums[l] += matrix[j][l] if m == len(matrix) else matrix[l][j] accu_sum_set = BST(0) accu_sum = 0 for sum in sums: accu_sum += sum node = accu_sum_set.lower_bound(accu_sum - k) if node: result = max(result, accu_sum - node.val) accu_sum_set.insert(accu_sum) return result ", "class Solution def sumOfTheDigitsOfHarshadNumber(self, x): result = 0 y = x while y: y, r = divmod(y, 10) result += r return result if x%result == 0 else -1 ", "class Solution def minJumps(self, arr): groups = collections.defaultdict(list) for i, x in enumerate(arr): groups[x].append(i) q = collections.deque([(0, 0)]) lookup = set([0]) while q: pos, step = q.popleft() if pos == len(arr)-1: break neighbors = set(groups[arr[pos]] + [pos-1, pos+1]) groups[arr[pos]] = [] for p in neighbors: if p in lookup or not 0 <= p < len(arr): continue lookup.add(p) q.append((p, step+1)) return step ", "class Solution def toGoatLatin(self, S): def convert(S): vowel = set('aeiouAEIOU') for i, word in enumerate(S.split(), 1): if word[0] not in vowel: word = word[1:] + word[:1] yield word + 'ma' + 'a'*i return \" \".join(convert(S)) ", "class Solution def getResults(self, queries): class BIT(object): def __init__(self, n, default=0, fn=lambda x, y: x+y): self.__bit = [default]*(n+1) self.__default = default self.__fn = fn def update(self, i, val): i += 1 while i < len(self.__bit): self.__bit[i] = self.__fn(self.__bit[i], val) i += (i & -i) def query(self, i): i += 1 ret = self.__default while i > 0: ret = self.__fn(ret, self.__bit[i]) i -= (i & -i) return ret sl = SortedList(q[1] for q in queries if q[0] == 1) val_to_idx = {x:i for i, x in enumerate(sl)} bit = BIT(len(val_to_idx), fn=max) for i in xrange(len(sl)): bit.update(val_to_idx[sl[i]], sl[i]-(sl[i-1] if i-1 >= 0 else 0)) result = [] for q in reversed(queries): i = sl.bisect_left(q[1]) if q[0] == 1: if i+1 < len(sl): bit.update(val_to_idx[sl[i+1]], sl[i+1]-(sl[i-1] if i-1 >= 0 else 0)) del sl[i] else: result.append(q[1]-(sl[i-1] if i-1 >= 0 else 0) >= q[2] or (i-1 >= 0 and bit.query(val_to_idx[sl[i-1]]) >= q[2])) result.reverse() return result from sortedcontainers import SortedList ", "class Solution def getResults(self, queries): class SegmentTree(object): def __init__(self, N, build_fn=lambda _: None, query_fn=lambda x, y: y if x is None else x if y is None else max(x, y), update_fn=lambda x: x): self.tree = [None]*(1<<((N-1).bit_length()+1)) self.base = len(self.tree)>>1 self.query_fn = query_fn self.update_fn = update_fn for i in xrange(self.base, self.base+N): self.tree[i] = build_fn(i-self.base) for i in reversed(xrange(1, self.base)): self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1]) def update(self, i, h): x = self.base+i self.tree[x] = self.update_fn(h) while x > 1: x >>= 1 self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1]) def query(self, L, R): L += self.base R += self.base left = right = None while L <= R: if L & 1: left = self.query_fn(left, self.tree[L]) L += 1 if R & 1 == 0: right = self.query_fn(self.tree[R], right) R -= 1 L >>= 1 R >>= 1 return self.query_fn(left, right) def update(x): sl.add(x) i = sl.bisect_left(x) st.update(val_to_idx[x], x-(sl[i-1] if i-1 >= 0 else 0)) if i+1 < len(sl): st.update(val_to_idx[sl[i+1]], sl[i+1]-x) val_to_idx = {x:i for i, x in enumerate(sorted(q[1] for q in queries if q[0] == 1))} st = SegmentTree(len(val_to_idx)) sl = SortedList() result = [] for q in queries: if q[0] == 1: update(q[1]) else: i = sl.bisect_left(q[1]) result.append(q[1]-(sl[i-1] if i-1 >= 0 else 0) >= q[2] or (i-1 >= 0 and st.query(0, val_to_idx[sl[i-1]]) >= q[2])) return result ", "class Solution def longestWord(self, words): _trie = lambda: defaultdict(_trie) trie = _trie() for i, word in enumerate(words): reduce(getitem, word, trie)[\"_end\"] = i stack = trie.values() result = \"\" while stack: curr = stack.pop() if \"_end\" in curr: word = words[curr[\"_end\"]] if len(word) > len(result) or (len(word) == len(result) and word < result): result = word stack += [curr[letter] for letter in curr if letter != \"_end\"] return result ", "class Solution def backspaceCompare(self, S, T): def findNextChar(S): skip = 0 for i in reversed(xrange(len(S))): if S[i] == '#': skip += 1 elif skip: skip -= 1 else: yield S[i] return all(x == y for x, y in itertools.izip_longest(findNextChar(S), findNextChar(T))) ", "class Solution def sortedArrayToBST(self, nums): return self.sortedArrayToBSTRecu(nums, 0, len(nums)) def sortedArrayToBSTRecu(self, nums, start, end): if start == end: return None mid = start + self.perfect_tree_pivot(end - start) node = TreeNode(nums[mid]) node.left = self.sortedArrayToBSTRecu(nums, start, mid) node.right = self.sortedArrayToBSTRecu(nums, mid + 1, end) return node def perfect_tree_pivot(self, n): x = 1 x = 1 << (n.bit_length() - 1) if x // 2 - 1 <= (n - x): return x - 1 else: return n - x // 2 ", "class Solution def sortedArrayToBST(self, nums): self.iterator = iter(nums) return self.helper(0, len(nums)) def helper(self, start, end): if start == end: return None mid = (start + end) // 2 left = self.helper(start, mid) current = TreeNode(next(self.iterator)) current.left = left current.right = self.helper(mid+1, end) return current ", "class Solution def flowerGame(self, n, m): return (n*m)//2 ", "class Solution def isNStraightHand(self, hand, W): if len(hand) % W: return False counts = Counter(hand) min_heap = list(hand) heapify(min_heap) for _ in xrange(len(min_heap)//W): while counts[min_heap[0]] == 0: heappop(min_heap) start = heappop(min_heap) for _ in xrange(W): counts[start] -= 1 if counts[start] < 0: return False start += 1 return True ", "class Solution def hasValidPath(self, grid): E, S, W, N = [(0, 1), (1, 0), (0, -1), (-1, 0)] directions = [ [W, E], [N, S], [W, S], [S, E], [W, N], [N, E] ] for r, c in directions[grid[0][0]-1]: if not (0 <= r < len(grid) and 0 <= c < len(grid[0])): continue pr, pc = 0, 0 while r != len(grid)-1 or c != len(grid[0])-1: for dx, dy in directions[grid[r][c]-1]: nr, nc = r+dx, c+dy if (nr == pr and nc == pc) or not(0 <= nr < len(grid) and 0 <= nc < len(grid[0])) or (-dx, -dy) not in directions[grid[nr][nc]-1]: continue pr, pc, r, c = r, c, nr, nc break else: return False return True return len(grid) == len(grid[0]) == 1 ", "class Solution def countNegatives(self, grid): result, c = 0, len(grid[0])-1 for row in grid: while c >= 0 and row[c] < 0: c -= 1 result += len(grid[0])-1-c return result ", "class Solution def anagramMappings(self, A, B): lookup = collections.defaultdict(collections.deque) for i, n in enumerate(B): lookup[n].append(i) result = [] for n in A: result.append(lookup[n].popleft()) return result ", "class Solution def maximumLength(self, nums, k): lookup = {x:i for i, x in enumerate(set(nums))} dp = [[0]*len(lookup) for _ in xrange(k+1)] result = [0]*(k+1) for x in nums: x = lookup[x] for i in reversed(xrange(k+1)): dp[i][x] = max(dp[i][x], result[i-1] if i-1 >= 0 else 0)+1 result[i] = max(result[i], dp[i][x]) return result[k] import collections ", "class Solution def maximumLength(self, nums, k): dp = [collections.defaultdict(int) for _ in xrange(k+1)] result = [0]*(k+1) for x in nums: for i in reversed(xrange(k+1)): dp[i][x] = max(dp[i][x], result[i-1] if i-1 >= 0 else 0)+1 result[i] = max(result[i], dp[i][x]) return result[k] ", "class Solution def maximumLength(self, nums, k): dp = [[0]*(k+1) for _ in xrange(len(nums))] result = 0 for i in xrange(len(nums)): dp[i][0] = 1 for l in xrange(k+1): for j in xrange(i): dp[i][l] = max(dp[i][l], dp[j][l]+1 if nums[j] == nums[i] else 1, dp[j][l-1]+1 if l-1 >= 0 else 1) result = max(result, dp[i][l]) return result ", "class Solution def isEscapePossible(self, blocked, source, target): R, C = 10**6, 10**6 directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] def bfs(blocks, source, target): max_area_surrounded_by_blocks = len(blocks)*(len(blocks)-1)//2 lookup = set([source]) if len(lookup) > max_area_surrounded_by_blocks: return True q = collections.deque([source]) while q: source = q.popleft() if source == target: return True for direction in directions: nr, nc = source[0]+direction[0], source[1]+direction[1] if not ((0 <= nr < R) and (0 <= nc < C) and (nr, nc) not in lookup and (nr, nc) not in blocks): continue lookup.add((nr, nc)) if len(lookup) > max_area_surrounded_by_blocks: return True q.append((nr, nc)) return False return bfs(set(map(tuple, blocked)), tuple(source), tuple(target)) and bfs(set(map(tuple, blocked)), tuple(target), tuple(source)) ", "class Solution def doubleIt(self, head): if head.val >= 5: head = ListNode(0, head) curr = head while curr: curr.val = (curr.val*2)%10 if curr.next and curr.next.val >= 5: curr.val += 1 curr = curr.next return head ", "class Solution def search(self, nums, target): left, right = 0, len(nums)-1 while left <= right: mid = left + (right-left)//2 if nums[mid] > target: right = mid-1 elif nums[mid] < target: left = mid+1 else: return mid return -1 ", "class Solution def numMagicSquaresInside(self, grid): def magic(grid, r, c): expect = k * (k**2+1) // 2 nums = set() min_num = float(\"inf\") sum_diag, sum_anti = 0, 0 for i in xrange(k): sum_diag += grid[r+i][c+i] sum_anti += grid[r+i][c+k-1-i] sum_r, sum_c = 0, 0 for j in xrange(k): min_num = min(min_num, grid[r+i][c+j]) nums.add(grid[r+i][c+j]) sum_r += grid[r+i][c+j] sum_c += grid[r+j][c+i] if not (sum_r == sum_c == expect): return False return sum_diag == sum_anti == expect and len(nums) == k**2 and min_num == 1 k = 3 result = 0 for r in xrange(len(grid)-k+1): for c in xrange(len(grid[r])-k+1): if magic(grid, r, c): result += 1 return result ", "class Solution def inorderSuccessor(self, root, p): if p and p.right: p = p.right while p.left: p = p.left return p successor = None while root and root != p: if root.val > p.val: successor = root root = root.left else: root = root.right return successor ", "class Solution def flipAndInvertImage(self, A): for row in A: for i in xrange((len(row)+1) // 2): row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1 return A ", "class Solution def longestBeautifulSubstring(self, word): result = 0 l = cnt = 1 for i in xrange(len(word)-1): if word[i] > word[i+1]: l = cnt = 1 else: l += 1 cnt += int(word[i] < word[i+1]) if cnt == 5: result = max(result, l) return result ", "class Solution def countPairs(self, nums1, nums2): for i in xrange(len(nums1)): nums1[i] -= nums2[i] nums1.sort() result = 0 left, right = 0, len(nums1)-1 while left < right: if nums1[left] > 0 or -nums1[left] < nums1[right]: result += right-left right -= 1 else: left += 1 return result ", "class Solution def countOfPairs(self, n, x, y): x, y = x-1, y-1 if x > y: x, y = y, x diff = [0]*n for i in xrange(n): diff[0] += 1+1 diff[min(abs(i-x), abs(i-y)+1)] += 1 diff[min(abs(i-y), abs(i-x)+1)] += 1 diff[min(abs(i-0), abs(i-y)+1+abs(x-0))] -= 1 diff[min(abs(i-(n-1)), abs(i-x)+1+abs(y-(n-1)))] -= 1 diff[max(x-i, 0)+max(i-y, 0)+((y-x)+0)//2] -= 1 diff[max(x-i, 0)+max(i-y, 0)+((y-x)+1)//2] -= 1 for i in xrange(n-1): diff[i+1] += diff[i] return diff ", "class Solution def countCompleteSubarrays(self, nums): nums_set = set(nums) result = left = 0 cnt = collections.Counter() for right in xrange(len(nums)): cnt[nums[right]] += 1 while len(cnt) == len(nums_set): cnt[nums[left]] -= 1 if cnt[nums[left]] == 0: del cnt[nums[left]] left += 1 result += left return result ", "class Solution def numberOfPatterns(self, m, n): def merge(used, i): return used | (1 << i) def number_of_keys(i): number = 0 while i > 0: i &= i - 1 number += 1 return number def contain(used, i): return bool(used & (1 << i)) def convert(i, j): return 3 * i + j dp = [[0] * 9 for _ in xrange(1 << 9)] for i in xrange(9): dp[merge(0, i)][i] = 1 res = 0 for used in xrange(len(dp)): number = number_of_keys(used) if number > n: continue for i in xrange(9): if not contain(used, i): continue if m <= number <= n: res += dp[used][i] x1, y1 = divmod(i, 3) for j in xrange(9): if contain(used, j): continue x2, y2 = divmod(j, 3) if ((x1 == x2 and abs(y1 - y2) == 2) or (y1 == y2 and abs(x1 - x2) == 2) or (abs(x1 - x2) == 2 and abs(y1 - y2) == 2)) and not contain(used, convert((x1 + x2) // 2, (y1 + y2) // 2)): continue dp[merge(used, j)][j] += dp[used][i] return res ", "class Solution def numberOfPatterns(self, m, n): def merge(used, i): return used | (1 << i) def number_of_keys(i): number = 0 while i > 0: i &= i - 1 number += 1 return number def exclude(used, i): return used & ~(1 << i) def contain(used, i): return bool(used & (1 << i)) def convert(i, j): return 3 * i + j dp = [[0] * 9 for _ in xrange(1 << 9)] for i in xrange(9): dp[merge(0, i)][i] = 1 res = 0 for used in xrange(len(dp)): number = number_of_keys(used) if number > n: continue for i in xrange(9): if not contain(used, i): continue x1, y1 = divmod(i, 3) for j in xrange(9): if i == j or not contain(used, j): continue x2, y2 = divmod(j, 3) if ((x1 == x2 and abs(y1 - y2) == 2) or (y1 == y2 and abs(x1 - x2) == 2) or (abs(x1 - x2) == 2 and abs(y1 - y2) == 2)) and not contain(used, convert((x1 + x2) // 2, (y1 + y2) // 2)): continue dp[used][i] += dp[exclude(used, i)][j] if m <= number <= n: res += dp[used][i] return res class Solution_TLE(object): def numberOfPatterns(self, m, n): def merge(used, i): return used | (1 << i) def contain(used, i): return bool(used & (1 << i)) def convert(i, j): return 3 * i + j def numberOfPatternsHelper(m, n, level, used, i): number = 0 if level > n: return number if m <= level <= n: number += 1 x1, y1 = divmod(i, 3) for j in xrange(9): if contain(used, j): continue x2, y2 = divmod(j, 3) if ((x1 == x2 and abs(y1 - y2) == 2) or (y1 == y2 and abs(x1 - x2) == 2) or (abs(x1 - x2) == 2 and abs(y1 - y2) == 2)) and not contain(used, convert((x1 + x2) // 2, (y1 + y2) // 2)): continue number += numberOfPatternsHelper(m, n, level + 1, merge(used, j), j) return number number = 0 number += 4 * numberOfPatternsHelper(m, n, 1, merge(0, 0), 0) number += 4 * numberOfPatternsHelper(m, n, 1, merge(0, 1), 1) number += numberOfPatternsHelper(m, n, 1, merge(0, 4), 4) return number ", "class Solution def countLatticePoints(self, circles): lookup = set() for x, y, r in circles: for i in xrange(-r, r+1): for j in xrange(-r, r+1): if i**2+j**2 <= r**2: lookup.add(((x+i), (y+j))) return len(lookup) ", "class Solution def countLatticePoints(self, circles): max_x = max(x+r for x, _, r in circles) max_y = max(y+r for _, y, r in circles) result = 0 for i in xrange(max_x+1): for j in xrange(max_y+1): if any((i-x)**2+(j-y)**2 <= r**2 for x, y, r in circles): result += 1 return result ", "class Solution def findOrder(self, numCourses, prerequisites): adj = collections.defaultdict(list) in_degree = collections.Counter() for u, v in prerequisites: in_degree[u] += 1 adj[v].append(u) result = [] q = [u for u in xrange(numCourses) if u not in in_degree] while q: new_q = [] for u in q: result.append(u) for v in adj[u]: in_degree[v] -= 1 if in_degree[v] == 0: new_q.append(v) q = new_q return result if len(result) == numCourses else [] import collections ", "class Solution def findOrder(self, numCourses, prerequisites): adj = collections.defaultdict(list) in_degree = collections.Counter() for u, v in prerequisites: in_degree[u] += 1 adj[v].append(u) result = [] stk = [u for u in xrange(numCourses) if u not in in_degree] while stk: u = stk.pop() result.append(u) for v in adj[u]: in_degree[v] -= 1 if in_degree[v] == 0: stk.append(v) return result if len(result) == numCourses else [] import collections ", "class Solution def findOrder(self, numCourses, prerequisites): WHITE, GRAY, BLACK = range(3) def dfs(u): if lookup[u] != WHITE: return lookup[u] == BLACK lookup[u] = GRAY if any(not dfs(v) for v in adj[u]): return False lookup[u] = BLACK result.append(u) return True result = [] adj = collections.defaultdict(list) for u, v in prerequisites: adj[u].append(v) lookup = collections.defaultdict(lambda:WHITE) for u in xrange(numCourses): if not dfs(u): return [] return result import collections ", "class Solution def findOrder(self, numCourses, prerequisites): WHITE, GRAY, BLACK = range(3) def dfs(u): if lookup[u] != WHITE: return lookup[u] == BLACK lookup[u] = GRAY if any(not dfs(v) for v in adj[u]): return False lookup[u] = BLACK result.append(u) return True result = [] adj = collections.defaultdict(list) for u, v in prerequisites: adj[v].append(u) lookup = collections.defaultdict(lambda:WHITE) for u in xrange(numCourses): if not dfs(u): return [] result.reverse() return result ", "class Solution def countPairs(self, coordinates, k): result = 0 cnt = collections.Counter() for x, y in coordinates: for i in xrange(k+1): result += cnt.get((x^i, y^(k-i)), 0) cnt[(x, y)] += 1 return result ", "class Solution def findAndReplacePattern(self, words, pattern): def match(word): lookup = {} for x, y in itertools.izip(pattern, word): if lookup.setdefault(x, y) != y: return False return len(set(lookup.values())) == len(lookup.values()) return filter(match, words) ", "class Solution def closestDivisors(self, num): def divisors(n): for d in reversed(xrange(1, int(n**0.5)+1)): if n % d == 0: return d, n//d return 1, n return min([divisors(num+1), divisors(num+2)], key=lambda x: x[1]-x[0]) ", "class Solution def closestDivisors(self, num): result, d = [1, num+1], 1 while d*d <= num+2: if (num+2) % d == 0: result = [d, (num+2)//d] if (num+1) % d == 0: result = [d, (num+1)//d] d += 1 return result ", "class Solution def combinationSum(self, candidates, target): result = [] self.combinationSumRecu(sorted(candidates), result, 0, [], target) return result def combinationSumRecu(self, candidates, result, start, intermediate, target): if target == 0: result.append(list(intermediate)) while start < len(candidates) and candidates[start] <= target: intermediate.append(candidates[start]) self.combinationSumRecu(candidates, result, start, intermediate, target - candidates[start]) intermediate.pop() start += 1 ", "class Solution def finalString(self, s): dq = collections.deque() parity = 0 for x in s: if x == 'i': parity ^= 1 else: dq.appendleft(x) if parity else dq.append(x) if parity: dq.reverse() return \"\".join(dq) ", "class Solution def countSubmatrices(self, grid, k): result = 0 for i in xrange(len(grid)): for j in xrange(len(grid[0])): if i-1 >= 0: grid[i][j] += grid[i-1][j] if j-1 >= 0: grid[i][j] += grid[i][j-1] if i-1 >= 0 and j-1 >= 0: grid[i][j] -= grid[i-1][j-1] if grid[i][j] <= k: result += 1 return result ", "class Solution def getIndex(self, reader): left, right = 0, reader.length()-1 while left < right: mid = left + (right-left)//2 if reader.compareSub(left, mid, mid if (right-left+1)%2 else mid+1, right) >= 0: right = mid else: left = mid+1 return left ", "class Solution def discountPrices(self, sentence, discount): result = [] i = 0 while i < len(sentence): j = sentence.find(' ', i) if j == -1: j = len(sentence) if sentence[i] == '$' and j-(i+1) > 0 and all(sentence[k].isdigit() for k in xrange(i+1, j)): cnt = reduce(lambda x, y: x*10+int(y), (sentence[k] for k in xrange(i+1, j)), 0) result.append(\"${:d}.{:02d}\".format(*divmod(cnt*(100-discount), 100))) else: for k in xrange(i, j): result.append(sentence[k]) if j != len(sentence): result.append(' ') i = j+1 return \"\".join(result) ", "class Solution def discountPrices(self, sentence, discount): def format(discount, x): return \"${:d}.{:02d}\".format(*divmod(int(x[1:])*(100-discount), 100)) if x[0] == '$' and x[1:].isdigit() else x return \" \".join(format(discount, x) for x in sentence.split()) ", "class Solution def calPoints(self, ops): history = [] for op in ops: if op == '+': history.append(history[-1] + history[-2]) elif op == 'D': history.append(history[-1] * 2) elif op == 'C': history.pop() else: history.append(int(op)) return sum(history) ", "class Solution def maxArrayValue(self, nums): result = curr = 0 for i in reversed(xrange(len(nums))): if nums[i] > curr: curr = 0 curr += nums[i] result = max(result, curr) return result ", "class Solution def exclusiveTime(self, n, logs): result = [0] * n stk, prev = [], 0 for log in logs: tokens = log.split(\":\") if tokens[1] == \"start\": if stk: result[stk[-1]] += int(tokens[2]) - prev stk.append(int(tokens[0])) prev = int(tokens[2]) else: result[stk.pop()] += int(tokens[2]) - prev + 1 prev = int(tokens[2]) + 1 return result ", "class Solution def findTheArrayConcVal(self, nums): return sum((nums[i]*10**(int(math.log10(nums[~i]))+1) for i in xrange(len(nums)//2)))+sum(nums[i] for i in xrange(len(nums)//2, len(nums))) ", "class Solution def minimumTimeRequired(self, jobs, k): def backtracking(jobs, i, cap, counts): if i == len(jobs): return True for j in xrange(len(counts)): if counts[j]+jobs[i] <= cap: counts[j] += jobs[i] if backtracking(jobs, i+1, cap, counts): return True counts[j] -= jobs[i] if counts[j] == 0: break return False jobs.sort(reverse=True) left, right = max(jobs), sum(jobs) while left <= right: mid = left + (right-left)//2 if backtracking(jobs, 0, mid, [0]*k): right = mid-1 else: left = mid+1 return left ", "class Solution def minimumTimeRequired(self, jobs, k): def backtracking(jobs, i, counts, result): if i == len(jobs): result[0] = min(result[0], max(counts)) return for j in xrange(len(counts)): if counts[j]+jobs[i] <= result[0]: counts[j] += jobs[i] backtracking(jobs, i+1, counts, result) counts[j] -= jobs[i] if counts[j] == 0: break jobs.sort(reverse=False) result = [sum(jobs)] backtracking(jobs, 0, [0]*k, result) return result[0] ", "class Solution def majorityElement(self, nums): k, n, cnts = 3, len(nums), collections.defaultdict(int) for i in nums: cnts[i] += 1 if len(cnts) == k: for j in cnts.keys(): cnts[j] -= 1 if cnts[j] == 0: del cnts[j] for i in cnts.keys(): cnts[i] = 0 for i in nums: if i in cnts: cnts[i] += 1 result = [] for i in cnts.keys(): if cnts[i] > n / k: result.append(i) return result def majorityElement2(self, nums): return [i[0] for i in collections.Counter(nums).items() if i[1] > len(nums) / 3] ", "class Solution def largestBSTSubtree(self, root): if root is None: return 0 max_size = [1] def largestBSTSubtreeHelper(root): if root.left is None and root.right is None: return 1, root.val, root.val left_size, left_min, left_max = 0, root.val, root.val if root.left is not None: left_size, left_min, left_max = largestBSTSubtreeHelper(root.left) right_size, right_min, right_max = 0, root.val, root.val if root.right is not None: right_size, right_min, right_max = largestBSTSubtreeHelper(root.right) size = 0 if (root.left is None or left_size > 0) and (root.right is None or right_size > 0) and left_max <= root.val <= right_min: size = 1 + left_size + right_size max_size[0] = max(max_size[0], size) return size, left_min, right_max largestBSTSubtreeHelper(root) return max_size[0] ", "class Solution def findValueOfPartition(self, nums): nums.sort() return min(nums[i+1]-nums[i] for i in xrange(len(nums)-1)) ", "class Solution def insertGreatestCommonDivisors(self, head): def gcd(a, b): while b: a, b = b, a%b return a curr = head while curr.next: curr.next = ListNode(gcd(curr.val, curr.next.val), curr.next) curr = curr.next.next return head ", "class Solution def squareFreeSubsets(self, nums): def linear_sieve_of_eratosthenes(n): primes = [] spf = [-1]*(n+1) for i in xrange(2, n+1): if spf[i] == -1: spf[i] = i primes.append(i) for p in primes: if i*p > n or p > spf[i]: break spf[i*p] = p return primes MAX_NUM = max(nums) PRIMES = linear_sieve_of_eratosthenes(MAX_NUM) MASKS = [0]*(MAX_NUM+1) for x in xrange(MAX_NUM+1): y = x for i, p in enumerate(PRIMES): if y%p: continue if y%p**2 == 0: MASKS[x] = 0 break MASKS[x] |= (1<<i) y //= p MOD = 10**9+7 cnt = collections.Counter(nums) arr = [x for x in cnt.iterkeys() if x != 1] dp = [1]*(1<<len(PRIMES)) for x in arr: if not MASKS[x]: continue for mask in reversed(xrange(len(dp))): if MASKS[x]&mask == 0: dp[mask|MASKS[x]] = (dp[mask|MASKS[x]]+cnt[x]*dp[mask])%MOD return (dp[-1]*pow(2, cnt[1], MOD)-1)%MOD if 1 in cnt else (dp[-1]-1)%MOD import collections ", "class Solution def squareFreeSubsets(self, nums): def linear_sieve_of_eratosthenes(n): primes = [] spf = [-1]*(n+1) for i in xrange(2, n+1): if spf[i] == -1: spf[i] = i primes.append(i) for p in primes: if i*p > n or p > spf[i]: break spf[i*p] = p return primes MAX_NUM = max(nums) PRIMES = linear_sieve_of_eratosthenes(MAX_NUM) MASKS = [0]*(MAX_NUM+1) for x in xrange(MAX_NUM+1): y = x for i, p in enumerate(PRIMES): if y%p: continue if y%p**2 == 0: MASKS[x] = 0 break MASKS[x] |= (1<<i) y //= p MOD = 10**9+7 cnt = collections.Counter(nums) arr = [x for x in cnt.iterkeys() if x != 1] dp = [[-1]*(1<<len(PRIMES)) for i in xrange(len(arr))] def memoization(i, mask): if i == len(arr): return 1 if dp[i][mask] == -1: dp[i][mask] = memoization(i+1, mask) if MASKS[arr[i]] and (MASKS[arr[i]]&mask) == MASKS[arr[i]]: dp[i][mask] = (dp[i][mask]+cnt[arr[i]]*memoization(i+1, mask^MASKS[arr[i]]))%MOD return dp[i][mask] return (memoization(0, (1<<len(PRIMES))-1)*pow(2, cnt[1], MOD)-1)%MOD if 1 in cnt else (memoization(0, (1<<len(PRIMES))-1)-1)%MOD ", "class Solution def expand(self, S): def form_words(options): words = map(\"\".join, itertools.product(*options)) words.sort() return words def generate_option(expr, i): option_set = set() while i[0] != len(expr) and expr[i[0]] != \"}\": i[0] += 1 for option in generate_words(expr, i): option_set.add(option) i[0] += 1 option = list(option_set) option.sort() return option def generate_words(expr, i): options = [] while i[0] != len(expr) and expr[i[0]] not in \",}\": tmp = [] if expr[i[0]] not in \"{,}\": tmp.append(expr[i[0]]) i[0] += 1 elif expr[i[0]] == \"{\": tmp = generate_option(expr, i) options.append(tmp) return form_words(options) return generate_words(S, [0]) ", "class Solution def expand(self, S): def form_words(options): words = [] total = 1 for opt in options: total *= len(opt) for i in xrange(total): tmp = [] for opt in reversed(options): i, c = divmod(i, len(opt)) tmp.append(opt[c]) tmp.reverse() words.append(\"\".join(tmp)) words.sort() return words def generate_option(expr, i): option_set = set() while i[0] != len(expr) and expr[i[0]] != \"}\": i[0] += 1 for option in generate_words(expr, i): option_set.add(option) i[0] += 1 option = list(option_set) option.sort() return option def generate_words(expr, i): options = [] while i[0] != len(expr) and expr[i[0]] not in \",}\": tmp = [] if expr[i[0]] not in \"{,}\": tmp.append(expr[i[0]]) i[0] += 1 elif expr[i[0]] == \"{\": tmp = generate_option(expr, i) options.append(tmp) return form_words(options) return generate_words(S, [0]) ", "class Solution def addNegabinary(self, arr1, arr2): result = [] carry = 0 while arr1 or arr2 or carry: if arr1: carry += arr1.pop() if arr2: carry += arr2.pop() result.append(carry & 1) carry = -(carry >> 1) while len(result) > 1 and result[-1] == 0: result.pop() result.reverse() return result ", "class Solution def dieSimulator(self, n, rollMax): MOD = 10**9+7 def sum_mod(array): return reduce(lambda x, y: (x+y)%MOD, array) dp = [[1] + [0]*(rollMax[i]-1) for i in xrange(6)] for _ in xrange(n-1): new_dp = [[0]*rollMax[i] for i in xrange(6)] for i in xrange(6): for k in xrange(rollMax[i]): for j in xrange(6): if i == j: if k < rollMax[i]-1: new_dp[j][k+1] = (new_dp[j][k+1]+dp[i][k])%MOD else: new_dp[j][0] = (new_dp[j][0]+dp[i][k])%MOD dp = new_dp return sum_mod(sum_mod(row) for row in dp) ", "class Solution def braceExpansionII(self, expression): def form_words(options): words = map(\"\".join, itertools.product(*options)) words.sort() return words def generate_option(expr, i): option_set = set() while i[0] != len(expr) and expr[i[0]] != \"}\": i[0] += 1 for option in generate_words(expr, i): option_set.add(option) i[0] += 1 option = list(option_set) option.sort() return option def generate_words(expr, i): options = [] while i[0] != len(expr) and expr[i[0]] not in \",}\": tmp = [] if expr[i[0]] not in \"{,}\": tmp.append(expr[i[0]]) i[0] += 1 elif expr[i[0]] == \"{\": tmp = generate_option(expr, i) options.append(tmp) return form_words(options) return generate_words(expression, [0]) ", "class Solution def braceExpansionII(self, expression): def form_words(options): words = [] total = 1 for opt in options: total *= len(opt) for i in xrange(total): tmp = [] for opt in reversed(options): i, c = divmod(i, len(opt)) tmp.append(opt[c]) tmp.reverse() words.append(\"\".join(tmp)) words.sort() return words def generate_option(expr, i): option_set = set() while i[0] != len(expr) and expr[i[0]] != \"}\": i[0] += 1 for option in generate_words(expr, i): option_set.add(option) i[0] += 1 option = list(option_set) option.sort() return option def generate_words(expr, i): options = [] while i[0] != len(expr) and expr[i[0]] not in \",}\": tmp = [] if expr[i[0]] not in \"{,}\": tmp.append(expr[i[0]]) i[0] += 1 elif expr[i[0]] == \"{\": tmp = generate_option(expr, i) options.append(tmp) return form_words(options) return generate_words(expression, [0]) ", "class Solution def count(self, num1, num2, min_sum, max_sum): MOD = 10**9+7 def f(x): dp = [[0]*(max_sum+1) for _ in xrange(2)] dp[0][0] = dp[1][0] = 1 for i in reversed(xrange(len(x))): new_dp = [[0]*(max_sum+1) for _ in xrange(2)] for t in xrange(2): for total in xrange(max_sum+1): for d in xrange(min((int(x[i]) if t else 9), total)+1): new_dp[t][total] = (new_dp[t][total]+dp[int(t and d == int(x[i]))][total-d])%MOD dp = new_dp return reduce(lambda x, y: (x+y)%MOD, (dp[1][total] for total in xrange(min_sum, max_sum+1))) return (f(num2)-f(str(int(num1)-1)))%MOD ", "class Solution def sumOfEncryptedInt(self, nums): def f(x): mx = base = 0 while x: mx = max(mx, x%10) x //= 10 base = 10*base+1 return mx*base return sum(f(x) for x in nums) ", "class Solution def countMaxOrSubsets(self, nums): dp = collections.Counter([0]) for x in nums: for k, v in dp.items(): dp[k|x] += v return dp[reduce(lambda x, y: x|y, nums)] ", "class Solution def findNeartestRightNode(self, root, u): q = [root] while q: new_q = [] for i, node in enumerate(q): if node == u: return q[i+1] if i+1 < len(q) else None if node.left: new_q.append(node.left) if node.right: new_q.append(node.right) q = new_q return None ", "class Solution def longestOnes(self, A, K): result, i = 0, 0 for j in xrange(len(A)): K -= int(A[j] == 0) while K < 0: K += int(A[i] == 0) i += 1 result = max(result, j-i+1) return result ", "class Solution def insert(self, intervals, newInterval): result = [] i = 0 while i < len(intervals) and newInterval[0] > intervals[i][1]: result += intervals[i], i += 1 while i < len(intervals) and newInterval[1] >= intervals[i][0]: newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])] i += 1 result.append(newInterval) result.extend(intervals[i:]) return result ", "class Solution def imageSmoother(self, M): def getGray(M, i, j): total, count = 0, 0.0 for r in xrange(-1, 2): for c in xrange(-1, 2): ii, jj = i + r, j + c if 0 <= ii < len(M) and 0 <= jj < len(M[0]): total += M[ii][jj] count += 1.0 return int(total / count) result = [[0 for _ in xrange(len(M[0]))] for _ in xrange(len(M))] for i in xrange(len(M)): for j in xrange(len(M[0])): result[i][j] = getGray(M, i, j) return result ", "class Solution def closestToTarget(self, arr, target): count = BitCount(max(arr).bit_length()) result, left = float(\"inf\"), 0 for right in xrange(len(arr)): count += arr[right] while left <= right: f = count.bit_and() result = min(result, abs(f-target)) if f >= target: break count -= arr[left] left += 1 return result ", "class Solution def closestToTarget(self, arr, target): result, dp = float(\"inf\"), set() for x in arr: dp = {x}|{f&x for f in dp} for f in dp: result = min(result, abs(f-target)) return result ", "class Solution def fractionAddition(self, expression): def gcd(a, b): while b: a, b = b, a%b return a ints = map(int, re.findall('[+-]?\\d+', expression)) A, B = 0, 1 for i in xrange(0, len(ints), 2): a, b = ints[i], ints[i+1] A = A * b + a * B B *= b g = gcd(A, B) A //= g B //= g return '%d/%d' % (A, B) ", "class Solution def findLonely(self, nums): cnt = collections.Counter(nums) return [x for x in nums if cnt[x] == 1 and x-1 not in cnt and x+1 not in cnt] ", "class Solution def employeeFreeTime(self, schedule): result = [] min_heap = [(emp[0].start, eid, 0) for eid, emp in enumerate(schedule)] heapq.heapify(min_heap) last_end = -1 while min_heap: t, eid, i = heapq.heappop(min_heap) if 0 <= last_end < t: result.append(Interval(last_end, t)) last_end = max(last_end, schedule[eid][i].end) if i+1 < len(schedule[eid]): heapq.heappush(min_heap, (schedule[eid][i+1].start, eid, i+1)) return result ", "class Solution def destCity(self, paths): A, B = map(set, itertools.izip(*paths)) return (B-A).pop() ", "class Solution def bestTeamScore(self, scores, ages): players = sorted(zip(scores, ages)) sorted_ages = sorted(set(ages)) lookup = {age:i for i, age in enumerate(sorted_ages)} segment_tree = SegmentTree(len(lookup)) result = 0 for score, age in players: segment_tree.update(lookup[age], lookup[age], segment_tree.query(0, lookup[age])+score) return segment_tree.query(0, len(lookup)-1) ", "class Solution def bestTeamScore(self, scores, ages): players = sorted(zip(ages, scores)) sorted_scores = sorted(set(scores)) lookup = {score:i for i, score in enumerate(sorted_scores)} segment_tree = SegmentTree(len(lookup)) result = 0 for age, score in players: segment_tree.update(lookup[score], lookup[score], segment_tree.query(0, lookup[score])+score) return segment_tree.query(0, len(lookup)-1) import collections ", "class Solution def bestTeamScore(self, scores, ages): players = sorted(zip(scores, ages)) sorted_ages = sorted(set(ages)) dp = collections.defaultdict(int) result = 0 for score, age in players: dp[age] = max(dp[a] for a in sorted_ages if a <= age) + score return max(dp.itervalues()) import collections ", "class Solution def bestTeamScore(self, scores, ages): players = sorted(zip(ages, scores)) sorted_scores = sorted(set(scores)) dp = collections.defaultdict(int) result = 0 for age, score in players: dp[score] = max(dp[s] for s in sorted_scores if s <= score) + score return max(dp.itervalues()) ", "class Solution def bestTeamScore(self, scores, ages): players = sorted(zip(scores, ages)) dp = [0]*len(players) result = 0 for i in xrange(len(players)): dp[i] = players[i][0] for j in xrange(i): if players[j][1] <= players[i][1]: dp[i] = max(dp[i], dp[j] + players[i][0]) result = max(result, dp[i]) return result ", "class Solution def bestTeamScore(self, scores, ages): players = sorted(zip(ages, scores)) dp = [0]*len(players) result = 0 for i in xrange(len(players)): dp[i] = players[i][1] for j in xrange(i): if players[j][1] <= players[i][1]: dp[i] = max(dp[i], dp[j] + players[i][1]) result = max(result, dp[i]) return result ", "class Solution def goodTriplets(self, nums1, nums2): lookup = [0]*len(nums1) for i, x in enumerate(nums1): lookup[x] = i result = 0 bit = BIT(len(nums1)) for i, x in enumerate(nums2): smaller = bit.query(lookup[x]-1) larger = (len(nums1)-(lookup[x]+1))-(i-smaller) result += smaller*larger bit.add(lookup[x], 1) return result ", "class Solution def addBoldTag(self, s, dict): lookup = [0] * len(s) for d in dict: pos = s.find(d) while pos != -1: lookup[pos:pos+len(d)] = [1] * len(d) pos = s.find(d, pos + 1) result = [] for i in xrange(len(s)): if lookup[i] and (i == 0 or not lookup[i-1]): result.append(\"<b>\") result.append(s[i]) if lookup[i] and (i == len(s)-1 or not lookup[i+1]): result.append(\"</b>\") return \"\".join(result) ", "class Solution def addBoldTag(self, s, words): _trie = lambda: collections.defaultdict(_trie) trie = _trie() for i, word in enumerate(words): functools.reduce(dict.__getitem__, word, trie).setdefault(\"_end\") lookup = [False] * len(s) for i in xrange(len(s)): curr = trie k = -1 for j in xrange(i, len(s)): if s[j] not in curr: break curr = curr[s[j]] if \"_end\" in curr: k = j for j in xrange(i, k+1): lookup[j] = True result = [] for i in xrange(len(s)): if lookup[i] and (i == 0 or not lookup[i-1]): result.append(\"<b>\") result.append(s[i]) if lookup[i] and (i == len(s)-1 or not lookup[i+1]): result.append(\"</b>\") return \"\".join(result) ", "class Solution def findClosestNumber(self, nums): return max(nums, key=lambda x:(-abs(x), x)) ", "class Solution def makeGood(self, s): stk = [] for ch in s: counter_ch = ch.upper() if ch.islower() else ch.lower() if stk and stk[-1] == counter_ch: stk.pop() else: stk.append(ch) return \"\".join(stk) ", "class Solution def numberToWords(self, num): if num == 0: return \"Zero\" lookup = {0: \"Zero\", 1:\"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\", 10: \"Ten\", 11: \"Eleven\", 12: \"Twelve\", 13: \"Thirteen\", 14: \"Fourteen\", 15: \"Fifteen\", 16: \"Sixteen\", 17: \"Seventeen\", 18: \"Eighteen\", 19: \"Nineteen\", 20: \"Twenty\", 30: \"Thirty\", 40: \"Forty\", 50: \"Fifty\", 60: \"Sixty\", 70: \"Seventy\", 80: \"Eighty\", 90: \"Ninety\"} unit = [\"\", \"Thousand\", \"Million\", \"Billion\"] res, i = [], 0 while num: cur = num % 1000 if num % 1000: res.append(self.threeDigits(cur, lookup, unit[i])) num //= 1000 i += 1 return \" \".join(res[::-1]) def threeDigits(self, num, lookup, unit): res = [] if num / 100: res = [lookup[num / 100] + \" \" + \"Hundred\"] if num % 100: res.append(self.twoDigits(num % 100, lookup)) if unit != \"\": res.append(unit) return \" \".join(res) def twoDigits(self, num, lookup): if num in lookup: return lookup[num] return lookup[(num / 10) * 10] + \" \" + lookup[num % 10] ", "class Solution def numSmallerByFrequency(self, queries, words): words_freq = sorted(word.count(min(word)) for word in words) return [len(words)-bisect.bisect_right(words_freq, query.count(min(query))) for query in queries] ", "class Solution def pruneTree(self, root): if not root: return None root.left = self.pruneTree(root.left) root.right = self.pruneTree(root.right) if not root.left and not root.right and root.val == 0: return None return root ", "class Solution def countPalindromicSubsequences(self, S): def dp(i, j, prv, nxt, lookup): if lookup[i][j] is not None: return lookup[i][j] result = 1 if i <= j: for x in xrange(4): i0 = nxt[i][x] j0 = prv[j][x] if i <= i0 <= j: result = (result + 1) % P if None < i0 < j0: result = (result + dp(i0+1, j0-1, prv, nxt, lookup)) % P result %= P lookup[i][j] = result return result prv = [None] * len(S) nxt = [None] * len(S) last = [None] * 4 for i in xrange(len(S)): last[ord(S[i])-ord('a')] = i prv[i] = tuple(last) last = [None] * 4 for i in reversed(xrange(len(S))): last[ord(S[i])-ord('a')] = i nxt[i] = tuple(last) P = 10**9 + 7 lookup = [[None] * len(S) for _ in xrange(len(S))] return dp(0, len(S)-1, prv, nxt, lookup) - 1 ", "class Solution def xorGame(self, nums): return reduce(xor, nums) == 0 or len(nums) % 2 == 0 ", "class Solution def maxScoreIndices(self, nums): result = [] mx = zeros = 0 total = sum(nums) for i in xrange(len(nums)+1): zeros += ((nums[i-1] if i else 0) == 0) if zeros+(total-(i-zeros)) > mx: mx = zeros+(total-(i-zeros)) result = [] if zeros+(total-(i-zeros)) == mx: result.append(i) return result ", "class Solution def constructFromPrePost(self, pre, post): stack = [TreeNode(pre[0])] j = 0 for i in xrange(1, len(pre)): node = TreeNode(pre[i]) while stack[-1].val == post[j]: stack.pop() j += 1 if not stack[-1].left: stack[-1].left = node else: stack[-1].right = node stack.append(node) return stack[0] ", "class Solution def constructFromPrePost(self, pre, post): def constructFromPrePostHelper(pre, pre_s, pre_e, post, post_s, post_e, post_entry_idx_map): if pre_s >= pre_e or post_s >= post_e: return None node = TreeNode(pre[pre_s]) if pre_e-pre_s > 1: left_tree_size = post_entry_idx_map[pre[pre_s+1]]-post_s+1 node.left = constructFromPrePostHelper(pre, pre_s+1, pre_s+1+left_tree_size, post, post_s, post_s+left_tree_size, post_entry_idx_map) node.right = constructFromPrePostHelper(pre, pre_s+1+left_tree_size, pre_e, post, post_s+left_tree_size, post_e-1, post_entry_idx_map) return node post_entry_idx_map = {} for i, val in enumerate(post): post_entry_idx_map[val] = i return constructFromPrePostHelper(pre, 0, len(pre), post, 0, len(post), post_entry_idx_map) ", "class Solution def findWinners(self, matches): lose = collections.defaultdict(int) players_set = set() for x, y in matches: lose[y] += 1 players_set.add(x) players_set.add(y) return [[x for x in sorted(players_set) if lose[x] == i] for i in xrange(2)] ", "class Solution def numComponents(self, head, G): lookup = set(G) dummy = ListNode(-1) dummy.next = head curr = dummy result = 0 while curr and curr.next: if curr.val not in lookup and curr.next.val in lookup: result += 1 curr = curr.next return result ", "class Solution def constructDistancedSequence(self, n): def backtracking(n, i, result, lookup): if i == len(result): return True if result[i]: return backtracking(n, i+1, result, lookup) for x in reversed(xrange(1, n+1)): j = i if x == 1 else i+x if lookup[x] or j >= len(result) or result[j]: continue result[i], result[j], lookup[x] = x, x, True if backtracking(n, i+1, result, lookup): return True result[i], result[j], lookup[x] = 0, 0, False return False result, lookup = [0]*(2*n-1), [False]*(n+1) backtracking(n, 0, result, lookup) return result ", "class Solution def coinChange(self, coins, amount): INF = 0x7fffffff dp = [INF] * (amount + 1) dp[0] = 0 for i in xrange(amount + 1): if dp[i] != INF: for coin in coins: if i + coin <= amount: dp[i + coin] = min(dp[i + coin], dp[i] + 1) return dp[amount] if dp[amount] != INF else -1 ", "class Solution def nthPersonGetsNthSeat(self, n): return 0.5 if n != 1 else 1.0 ", "class Solution def nthPersonGetsNthSeat(self, n): dp = [0.0]*2 dp[0] = 1.0 for i in xrange(2, n+1): dp[(i-1)%2] = 1.0/i+dp[(i-2)%2]*(i-2)/i return dp[(n-1)%2] ", "class Solution def checkArray(self, nums, k): curr = 0 for i, x in enumerate(nums): if x-curr < 0: return False nums[i] -= curr curr += nums[i] if i-(k-1) >= 0: curr -= nums[i-(k-1)] return curr == 0 ", "class Solution def beautifulSubstrings(self, s, k): VOWELS = set(\"aeiou\") prefix = [0]*(len(s)+1) for i in xrange(len(s)): prefix[i+1] = prefix[i]+(+1 if s[i] in VOWELS else -1) new_k = 1 x = k for i in xrange(2, k+1): if i*i > k: break cnt = 0 while x%i == 0: x //= i cnt += 1 if cnt: new_k *= i**((cnt+1)//2+int(i == 2)) if x != 1: new_k *= x**((1+1)//2+int(x == 2)) cnt = collections.Counter() result = 0 for i, p in enumerate(prefix): result += cnt[p, i%new_k] cnt[p, i%new_k] += 1 return result ", "class Solution def btreeGameWinningMove(self, root, n, x): def count(node, x, left_right): if not node: return 0 left, right = count(node.left, x, left_right), count(node.right, x, left_right) if node.val == x: left_right[0], left_right[1] = left, right return left + right + 1 left_right = [0, 0] count(root, x, left_right) blue = max(max(left_right), n-(sum(left_right)+1)) return blue > n-blue ", "class Solution def countDistinctIntegers(self, nums): def reverse(n): result = 0 while n: result = result*10 + n%10 n //= 10 return result return len({y for x in nums for y in (x, reverse(x))}) ", "class Solution def countDistinctIntegers(self, nums): return len({y for x in nums for y in (x, int(str(x)[::-1]))}) ", "class Solution def kthSmallestSubarraySum(self, nums, k): def check(nums, k, x): cnt = curr = left = 0 for right in xrange(len(nums)): curr += nums[right] while curr > x: curr -= nums[left] left += 1 cnt += right-left+1 return cnt >= k left, right = min(nums), sum(nums) while left <= right: mid = left + (right-left)//2 if check(nums, k, mid): right = mid-1 else: left = mid+1 return left ", "class Solution def countSubstrings(self, s, t): def count(i, j): result = left_cnt = right_cnt = 0 for k in xrange(min(len(s)-i, len(t)-j)): right_cnt += 1 if s[i+k] != t[j+k]: left_cnt, right_cnt = right_cnt, 0 result += left_cnt return result return sum(count(i, 0) for i in xrange(len(s))) + sum(count(0, j) for j in xrange(1, len(t))) ", "class Solution def countAnagrams(self, s): MOD = 10**9+7 fact, inv, inv_fact = [[1]*2 for _ in xrange(3)] def lazy_init(n): while len(inv) <= n: fact.append(fact[-1]*len(inv) % MOD) inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) inv_fact.append(inv_fact[-1]*inv[-1] % MOD) def factorial(n): lazy_init(n) return fact[n] def inv_factorial(n): lazy_init(n) return inv_fact[n] def count(j, i): result = 1 cnt = collections.Counter() for k in xrange(j, i+1): cnt[s[k]] += 1 result = factorial(sum(cnt.itervalues())) for c in cnt.itervalues(): result = (result*inv_factorial(c))%MOD return result result = 1 j = 0 for i in xrange(len(s)): if i+1 != len(s) and s[i+1] != ' ': continue result = (result*count(j, i))%MOD j = i+2 return result ", "class Solution def countVisitedNodes(self, edges): def find_cycles(adj): result = [0]*len(adj) lookup = [0]*len(adj) stk = [] idx = 0 for u in xrange(len(adj)): prev = idx while not lookup[u]: idx += 1 lookup[u] = idx stk.append(u) u = adj[u] if lookup[u] > prev: l = idx-lookup[u]+1 for _ in xrange(l): result[stk.pop()] = l while stk: result[stk[-1]] = result[adj[stk[-1]]]+1 stk.pop() return result return find_cycles(edges) ", "class Solution def nextGreatestLetter(self, letters, target): i = bisect.bisect_right(letters, target) return letters[0] if i == len(letters) else letters[i] ", "class Solution def verticalOrder(self, root): cols = collections.defaultdict(list) queue = [(root, 0)] for node, i in queue: if node: cols[i].append(node.val) queue += (node.left, i - 1), (node.right, i + 1) return [cols[i] for i in xrange(min(cols.keys()), max(cols.keys()) + 1)] if cols else [] ", "class Solution def betterCompression(self, compressed): cnt = [0]*26 x, curr = -1, 0 for i in xrange(len(compressed)): if not compressed[i].isdigit(): x = ord(compressed[i])-ord('a') continue curr = curr*10+int(compressed[i]) if i+1 == len(compressed) or not compressed[i+1].isdigit(): cnt[x] += curr curr = 0 return \"\".join(\"%s%s\" % (chr(ord('a')+i), x) for i, x in enumerate(cnt) if x) ", "class Solution def beautifulIndices(self, s, a, b, k): def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j+1 > 0 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix def KMP(text, pattern): prefix = getPrefix(pattern) j = -1 for i in xrange(len(text)): while j+1 > 0 and pattern[j+1] != text[i]: j = prefix[j] if pattern[j+1] == text[i]: j += 1 if j+1 == len(pattern): yield i-j j = prefix[j] result = [] if not (len(a) <= len(s) and len(b) <= len(s)): return result lookup = list(KMP(s, b)) j = 0 for i in KMP(s, a): while j < len(lookup) and lookup[j] < i-k: j += 1 if j < len(lookup) and lookup[j] <= i+k: result.append(i) return result import bisect ", "class Solution def beautifulIndices(self, s, a, b, k): def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j+1 > 0 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix def KMP(text, pattern): prefix = getPrefix(pattern+'#'+text) return ((i-(len(pattern)+1))-(len(pattern)-1) for i in xrange((len(pattern)+1)+(len(pattern)-1) , len(prefix)) if prefix[i]+1 == len(pattern)) result = [] if not (len(a) <= len(s) and len(b) <= len(s)): return result lookup = list(KMP(s, b)) j = 0 for i in KMP(s, a): j = bisect.bisect_left(lookup, i-k) if j < len(lookup) and lookup[j] <= i+k: result.append(i) return result ", "class Solution def equalSubstring(self, s, t, maxCost): left = 0 for right in xrange(len(s)): maxCost -= abs(ord(s[right])-ord(t[right])) if maxCost < 0: maxCost += abs(ord(s[left])-ord(t[left])) left += 1 return (right+1)-left ", "class Solution def decode(self, encoded, first): result = [first] for x in encoded: result.append(result[-1]^x) return result ", "class Solution def kSimilarity(self, A, B): def neighbors(s, B): for i, c in enumerate(s): if c != B[i]: break t = list(s) for j in xrange(i+1, len(s)): if t[j] == B[i]: t[i], t[j] = t[j], t[i] yield \"\".join(t) t[j], t[i] = t[i], t[j] q = collections.deque([A]) lookup = set() result = 0 while q: for _ in xrange(len(q)): s = q.popleft() if s == B: return result for t in neighbors(s, B): if t not in lookup: lookup.add(t) q.append(t) result += 1 ", "class Solution def addToArrayForm(self, A, K): A.reverse() carry, i = K, 0 A[i] += carry carry, A[i] = divmod(A[i], 10) while carry: i += 1 if i < len(A): A[i] += carry else: A.append(carry) carry, A[i] = divmod(A[i], 10) A.reverse() return A ", "class Solution def unmarkedSumArray(self, nums, queries): total = sum(nums) lookup = [False]*len(nums) min_heap = [(x, i) for i, x in enumerate(nums)] heapq.heapify(min_heap) result = [] for i, k in queries: if not lookup[i]: lookup[i] = True total -= nums[i] for _ in xrange(k): while min_heap: x, i = heapq.heappop(min_heap) if lookup[i]: continue lookup[i] = True total -= x break if not min_heap: break result.append(total) return result ", "class Solution def deleteNode(self, node): if node and node.next: node_to_delete = node.next node.val = node_to_delete.val node.next = node_to_delete.next del node_to_delete ", "class Solution def clearDigits(self, s): s = list(s) j = 0 for i, x in enumerate(s): if x.isdigit(): j -= 1 continue s[j] = x j += 1 while len(s) > j: s.pop() return \"\".join(s) ", "class Solution def clearDigits(self, s): result = [] for x in s: if x.isdigit(): result.pop() continue result.append(x) return \"\".join(result) ", "class Solution def numberOfPairs(self, points): points.sort(key=lambda x: (x[0], -x[1])) result = 0 for i in xrange(len(points)): y = float(\"-inf\") for j in xrange(i+1, len(points)): if points[i][1] < points[j][1]: continue if points[j][1] > y: y = points[j][1] result += 1 return result ", "class Solution def numberOfPairs(self, points): points.sort(key=lambda x: (x[0], -x[1])) return sum(all(not points[i][1] >= points[k][1] >= points[j][1] for k in xrange(i+1, j)) for i in xrange(len(points)) for j in xrange(i+1, len(points)) if points[i][1] >= points[j][1]) ", "class Solution def largestIsland(self, grid): directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] def dfs(r, c, index, grid): if not (0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == 1): return 0 result = 1 grid[r][c] = index for d in directions: result += dfs(r+d[0], c+d[1], index, grid) return result area = {} index = 2 for r in xrange(len(grid)): for c in xrange(len(grid[r])): if grid[r][c] == 1: area[index] = dfs(r, c, index, grid) index += 1 result = max(area.values() or [0]) for r in xrange(len(grid)): for c in xrange(len(grid[r])): if grid[r][c] == 0: seen = set() for d in directions: nr, nc = r+d[0], c+d[1] if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] > 1): continue seen.add(grid[nr][nc]) result = max(result, 1 + sum(area[i] for i in seen)) return result ", "class Solution def rootCount(self, edges, guesses, k): def iter_dfs(): result = 0 stk = [(0, -1)] while stk: u, p = stk.pop() result += int((p, u) in lookup) for v in adj[u]: if v == p: continue stk.append((v, u)) return result def iter_dfs2(curr): result = 0 stk = [(0, -1, curr)] while stk: u, p, curr = stk.pop() if (p, u) in lookup: curr -= 1 if (u, p) in lookup: curr += 1 result += int(curr >= k) for v in adj[u]: if v == p: continue stk.append((v, u, curr)) return result adj = collections.defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) lookup = {(u, v) for u, v in guesses} curr = iter_dfs() return iter_dfs2(curr) import collections ", "class Solution def rootCount(self, edges, guesses, k): def dfs(u, p): cnt = int((p, u) in lookup) for v in adj[u]: if v == p: continue cnt += dfs(v, u) return cnt def dfs2(u, p, curr): if (p, u) in lookup: curr -= 1 if (u, p) in lookup: curr += 1 cnt = int(curr >= k) for v in adj[u]: if v == p: continue cnt += dfs2(v, u, curr) return cnt adj = collections.defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) lookup = {(u, v) for u, v in guesses} curr = dfs(0, -1) return dfs2(0, -1, curr) import collections ", "class Solution def rootCount(self, edges, guesses, k): cnt = [0] def memoization(u, p): if (u, p) not in memo: memo[u, p] = int((p, u) in lookup) for v in adj[u]: if v == p: continue cnt[0] += 1 memo[u, p] += memoization(v, u) return memo[u, p] adj = collections.defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) lookup = {(u, v) for u, v in guesses} memo = {} return sum(memoization(i, -1) >= k for i in adj.iterkeys()) ", "class Solution def isPossibleToCutPath(self, grid): for i in xrange(len(grid)): for j in xrange(len(grid[0])): if (i, j) == (0, 0) or grid[i][j] == 0: continue if (i-1 < 0 or grid[i-1][j] == 0) and (j-1 < 0 or grid[i][j-1] == 0): grid[i][j] = 0 for i in reversed(xrange(len(grid))): for j in reversed(xrange(len(grid[0]))): if (i, j) == (len(grid)-1, len(grid[0])-1) or grid[i][j] == 0: continue if (i+1 >= len(grid) or grid[i+1][j] == 0) and (j+1 >= len(grid[0]) or grid[i][j+1] == 0): grid[i][j] = 0 cnt = [0]*(len(grid)+len(grid[0])-1) for i in xrange(len(grid)): for j in xrange(len(grid[0])): cnt[i+j] += grid[i][j] return any(cnt[i] <= 1 for i in xrange(1, len(grid)+len(grid[0])-2)) ", "class Solution def isPossibleToCutPath(self, grid): def iter_dfs(): stk = [(0, 0)] while stk: i, j = stk.pop() if not (i < len(grid) and j < len(grid[0]) and grid[i][j]): continue if (i, j) == (len(grid)-1, len(grid[0])-1): return True if (i, j) != (0, 0): grid[i][j] = 0 stk.append((i, j+1)) stk.append((i+1, j)) return False return not iter_dfs() or not iter_dfs() ", "class Solution def isPossibleToCutPath(self, grid): def dfs(i, j): if not (i < len(grid) and j < len(grid[0]) and grid[i][j]): return False if (i, j) == (len(grid)-1, len(grid[0])-1): return True if (i, j) != (0, 0): grid[i][j] = 0 return dfs(i+1, j) or dfs(i, j+1) return not dfs(0, 0) or not dfs(0, 0) ", "class Solution def __init__(self): self.__memo = {1: [TreeNode(0)]} def allPossibleFBT(self, N): if N % 2 == 0: return [] if N not in self.__memo: result = [] for i in xrange(N): for left in self.allPossibleFBT(i): for right in self.allPossibleFBT(N-1-i): node = TreeNode(0) node.left = left node.right = right result.append(node) self.__memo[N] = result return self.__memo[N] ", "class Solution def findScore(self, nums): idxs = range(len(nums)) idxs.sort(key=lambda x: (nums[x], x)) lookup = [False]*len(nums) result = 0 for i in idxs: if lookup[i]: continue lookup[i] = True if i-1 >= 0: lookup[i-1] = True if i+1 < len(lookup): lookup[i+1] = True result += nums[i] return result ", "class Solution def closestNodes(self, root, queries): def iter_dfs(): inorder = [] stk = [(1, root)] while stk: step, node = stk.pop() if step == 1: if not node: continue stk.append((1, node.right)) stk.append((2, node)) stk.append((1, node.left)) elif step == 2: inorder.append(node.val) return inorder inorder = iter_dfs() result = [] for q in queries: i = bisect.bisect_left(inorder, q) if i == len(inorder): result.append([inorder[i-1], -1]) elif inorder[i] == q: result.append([inorder[i], inorder[i]]) elif i-1 >= 0: result.append([inorder[i-1], inorder[i]]) else: result.append([-1, inorder[i]]) return result import bisect ", "class Solution def closestNodes(self, root, queries): def dfs(node): if not node: return dfs(node.left) inorder.append(node.val) dfs(node.right) inorder = [] dfs(root) result = [] for q in queries: i = bisect.bisect_left(inorder, q) if i == len(inorder): result.append([inorder[i-1], -1]) elif inorder[i] == q: result.append([inorder[i], inorder[i]]) elif i-1 >= 0: result.append([inorder[i-1], inorder[i]]) else: result.append([-1, inorder[i]]) return result ", "class Solution def bestHand(self, ranks, suits): LOOKUP = [\"\", \"High Card\", \"Pair\", \"Three of a Kind\", \"Three of a Kind\", \"Three of a Kind\"] if all(suits[i] == suits[0] for i in xrange(1, len(suits))): return \"Flush\" cnt = [0]*13 for x in ranks: cnt[x-1] += 1 return LOOKUP[max(cnt)] ", "class Solution def candyCrush(self, board): R, C = len(board), len(board[0]) changed = True while changed: changed = False for r in xrange(R): for c in xrange(C-2): if abs(board[r][c]) == abs(board[r][c+1]) == abs(board[r][c+2]) != 0: board[r][c] = board[r][c+1] = board[r][c+2] = -abs(board[r][c]) changed = True for r in xrange(R-2): for c in xrange(C): if abs(board[r][c]) == abs(board[r+1][c]) == abs(board[r+2][c]) != 0: board[r][c] = board[r+1][c] = board[r+2][c] = -abs(board[r][c]) changed = True for c in xrange(C): i = R-1 for r in reversed(xrange(R)): if board[r][c] > 0: board[i][c] = board[r][c] i -= 1 for r in reversed(xrange(i+1)): board[r][c] = 0 return board ", "class Solution def smallerNumbersThanCurrent(self, nums): count = collections.Counter(nums) for i in xrange(max(nums)+1): count[i] += count[i-1] return [count[i-1] for i in nums] import bisect ", "class Solution def smallerNumbersThanCurrent(self, nums): sorted_nums = sorted(nums) return [bisect.bisect_left(sorted_nums, i) for i in nums] ", "class Solution def containsNearbyDuplicate(self, nums, k): lookup = {} for i, num in enumerate(nums): if num not in lookup: lookup[num] = i else: if i - lookup[num] <= k: return True lookup[num] = i return False ", "class Solution def isCovered(self, ranges, left, right): RANGE_SIZE = 50 interval = [0]*(RANGE_SIZE+1) for l, r in ranges: interval[l-1] += 1 interval[(r-1)+1] -= 1 cnt = 0 for i in xrange((right-1)+1): cnt += interval[i] if i >= left-1 and not cnt: return False return True ", "class Solution def isCovered(self, ranges, left, right): ranges.sort() for l, r in ranges: if l <= left <= r: left = r+1 return left > right ", "class Solution def isCovered(self, ranges, left, right): return all(any(l <= i <= r for l, r in ranges) for i in xrange(left, right+1)) ", "class Solution def alternatingSubarray(self, nums): result = l = -1 for i in xrange(len(nums)-1): if l != -1 and nums[i-1] == nums[i+1]: l += 1 else: l = 2 if nums[i+1]-nums[i] == 1 else -1 result = max(result, l) return result ", "class Solution def largestPathValue(self, colors, edges): adj = [[] for _ in xrange(len(colors))] in_degree = [0]*len(colors) for u, v in edges: adj[u].append(v) in_degree[v] += 1 q = [] for u in xrange(len(colors)): if not in_degree[u]: q.append(u) dp = [[0]*26 for _ in xrange(len(colors))] result, cnt = -1, 0 while q: new_q = [] for u in q: cnt += 1 dp[u][ord(colors[u])-ord('a')] += 1 result = max(result, dp[u][ord(colors[u])-ord('a')]) for v in adj[u]: for c in xrange(26): dp[v][c] = max(dp[v][c], dp[u][c]) in_degree[v] -= 1 if not in_degree[v]: new_q.append(v) q = new_q return result if cnt == len(colors) else -1 ", "class Solution def minOperations(self, nums1, nums2): if len(nums1)*6 < len(nums2) or len(nums1) > len(nums2)*6: return -1 diff = sum(nums2)-sum(nums1) if diff < 0: nums1, nums2 = nums2, nums1 diff = -diff count = collections.Counter(6-num for num in nums1) count += collections.Counter(num-1 for num in nums2) result = 0 for i in reversed(xrange(1, 6)): if not count[i]: continue cnt = min(count[i], (diff+i-1)//i) result += cnt diff -= i*cnt if diff <= 0: break return result ", "class Solution def findIntersectionValues(self, nums1, nums2): lookup1, lookup2 = set(nums1), set(nums2) return [sum(x in lookup2 for x in nums1), sum(x in lookup1 for x in nums2)] ", "class Solution def isValid(self, S): stack = [] for i in S: if i == 'c': if stack[-2:] == ['a', 'b']: stack.pop() stack.pop() else: return False else: stack.append(i) return not stack ", "class Solution def isReachable(self, targetX, targetY): def gcd(a, b): while b: a, b = b, a%b return a g = gcd(targetX, targetY) return g == (g&~(g-1)) ", "class Solution def largestGoodInteger(self, num): result = '' cnt = 0 for i, x in enumerate(num): cnt += 1 if i+1 < len(num) and num[i] == num[i+1]: continue if cnt >= 3: result = max(result, num[i]) cnt = 0 return result*3 ", "class Solution def largestGoodInteger(self, num): return max(num[i] if num[i] == num[i+1] == num[i+2] else '' for i in xrange(len(num)-2))*3 ", "class Solution def firstPalindrome(self, words): def is_palindrome(s): i, j = 0, len(s)-1 while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True for w in words: if is_palindrome(w): return w return \"\" ", "class Solution def firstPalindrome(self, words): return next((x for x in words if x == x[::-1]), \"\") ", "class Solution def incremovableSubarrayCount(self, nums): for j in reversed(xrange(1, len(nums))): if not nums[j-1] < nums[j]: break else: return (len(nums)+1)*len(nums)//2 result = len(nums)-j+1 for i in xrange(len(nums)-1): while j < len(nums) and not (nums[i] < nums[j]): j += 1 result += len(nums)-j+1 if not (nums[i] < nums[i+1]): break return result ", "class Solution def incremovableSubarrayCount(self, nums): return sum((left == 0 or right == len(nums)-1 or nums[left-1] < nums[right+1]) and all(nums[i] < nums[i+1] for i in xrange(left-1)) and all(nums[i] < nums[i+1] for i in xrange(right+1, len(nums)-1)) for left in xrange(len(nums)) for right in xrange(left, len(nums))) ", "class Solution def magnificentSets(self, n, edges): def iter_dfs(u): group = [] stk = [u] lookup[u] = 0 while stk: u = stk.pop() group.append(u) for v in adj[u]: if lookup[v] != -1: if lookup[v] == lookup[u]: return [] continue lookup[v] = lookup[u]^1 stk.append(v) return group def bfs(u): result = 0 lookup = [False]*n q = [u] lookup[u] = True while q: new_q = [] for u in q: for v in adj[u]: if lookup[v]: continue lookup[v] = True new_q.append(v) q = new_q result += 1 return result adj = [[] for _ in xrange(n)] for u, v in edges: adj[u-1].append(v-1) adj[v-1].append(u-1) result = 0 lookup = [-1]*n for u in xrange(n): if lookup[u] != -1: continue group = iter_dfs(u) if not group: return -1 result += max(bfs(u) for u in group) return result ", "class Solution def magnificentSets(self, n, edges): def bfs(u): group = [] q = {u} lookup[u] = True while q: new_q = set() for u in q: group.append(u) for v in adj[u]: if lookup[v]: continue lookup[v] = True new_q.add(v) q = new_q return group def bfs2(u): result = 0 lookup = [False]*n q = {u} lookup[u] = True while q: new_q = set() for u in q: for v in adj[u]: if v in q: return 0 if lookup[v]: continue lookup[v] = True new_q.add(v) q = new_q result += 1 return result adj = [[] for _ in xrange(n)] for u, v in edges: adj[u-1].append(v-1) adj[v-1].append(u-1) result = 0 lookup = [0]*n for u in xrange(n): if lookup[u]: continue group = bfs(u) mx = 0 for u in group: d = bfs2(u) if d == 0: return -1 mx = max(mx, d) result += mx return result ", "class Solution def chalkReplacer(self, chalk, k): k %= sum(chalk) for i, x in enumerate(chalk): if k < x: return i k -= x return -1 ", "class Solution def findSubsequences(self, nums): def findSubsequencesHelper(nums, pos, seq, result): if len(seq) >= 2: result.append(list(seq)) lookup = set() for i in xrange(pos, len(nums)): if (not seq or nums[i] >= seq[-1]) and nums[i] not in lookup: lookup.add(nums[i]) seq.append(nums[i]) findSubsequencesHelper(nums, i+1, seq, result) seq.pop() result, seq = [], [] findSubsequencesHelper(nums, 0, seq, result) return result ", "class Solution def firstBadVersion(self, n): left, right = 1, n while left <= right: mid = left + (right - left) / 2 if isBadVersion(mid): right = mid - 1 else: left = mid + 1 return left ", "class Solution def diameter(self, root): def iter_dfs(root): result = [0]*2 stk = [(1, (root, result))] while stk: step, params = stk.pop() if step == 1: node, ret = params for child in reversed(node.children): ret2 = [0]*2 stk.append((2, (ret2, ret))) stk.append((1, (child, ret2))) else: ret2, ret = params ret[0] = max(ret[0], ret2[0], ret[1]+ret2[1]+1) ret[1] = max(ret[1], ret2[1]+1) return result return iter_dfs(root)[0] ", "class Solution def diameter(self, root): def dfs(node): max_dia, max_depth = 0, 0 for child in node.children: child_max_dia, child_max_depth = dfs(child) max_dia = max(max_dia, child_max_dia, max_depth+child_max_depth+1) max_depth = max(max_depth, child_max_depth+1) return max_dia, max_depth return dfs(root)[0] ", "class Solution def closestValue(self, root, target): gap = float(\"inf\") closest = float(\"inf\") while root: if abs(root.val - target) < gap: gap = abs(root.val - target) closest = root.val if target == root.val: break elif target < root.val: root = root.left else: root = root.right return closest ", "class Solution def countOfPairs(self, n, x, y): x, y = x-1, y-1 if x > y: x, y = y, x diff = [0]*n for i in xrange(n): diff[0] += 1+1 diff[min(abs(i-x), abs(i-y)+1)] += 1 diff[min(abs(i-y), abs(i-x)+1)] += 1 diff[min(abs(i-0), abs(i-y)+1+abs(x-0))] -= 1 diff[min(abs(i-(n-1)), abs(i-x)+1+abs(y-(n-1)))] -= 1 diff[max(x-i, 0)+max(i-y, 0)+((y-x)+0)//2] -= 1 diff[max(x-i, 0)+max(i-y, 0)+((y-x)+1)//2] -= 1 for i in xrange(n-1): diff[i+1] += diff[i] return diff ", "class Solution def countOfPairs(self, n, x, y): x, y = x-1, y-1 result = [0]*n for i in xrange(n): for j in xrange(i+1, n): result[min(abs(i-j), abs(i-x)+1+abs(y-j), abs(i-y)+1+abs(x-j))-1] += 2 return result ", "class Solution def findIndices(self, nums, indexDifference, valueDifference): mx_i = mn_i = 0 for i in xrange(len(nums)-indexDifference): if nums[i] > nums[mx_i]: mx_i = i elif nums[i] < nums[mn_i]: mn_i = i if nums[mx_i]-nums[i+indexDifference] >= valueDifference: return [mx_i, i+indexDifference] if nums[i+indexDifference]-nums[mn_i] >= valueDifference: return [mn_i, i+indexDifference] return [-1]*2 ", "class Solution def numSubmat(self, mat): def count(heights): dp, stk = [0]*len(heights), [] for i in xrange(len(heights)): while stk and heights[stk[-1]] >= heights[i]: stk.pop() dp[i] = dp[stk[-1]] + heights[i]*(i-stk[-1]) if stk else heights[i]*(i-(-1)) stk.append(i) return sum(dp) result = 0 heights = [0]*len(mat[0]) for i in xrange(len(mat)): for j in xrange(len(mat[0])): heights[j] = heights[j]+1 if mat[i][j] == 1 else 0 result += count(heights) return result ", "class Solution def getKthCharacter(self, root, k): while root.len: l = max(root.left.len, len(root.left.val)) if root.left else 0 if k <= l: root = root.left else: k -= l root = root.right return root.val[k-1] ", "class Solution def binaryGap(self, N): result = 0 last = None for i in xrange(32): if (N >> i) & 1: if last is not None: result = max(result, i-last) last = i return result ", "class Solution def maxArea(self, height): max_area, i, j = 0, 0, len(height) - 1 while i < j: max_area = max(max_area, min(height[i], height[j]) * (j - i)) if height[i] < height[j]: i += 1 else: j -= 1 return max_area ", "class Solution def findLeastNumOfUniqueInts(self, arr, k): count = collections.Counter(arr) result, count_count = len(count), collections.Counter(count.itervalues()) for c in xrange(1, len(arr)+1): if k < c*count_count[c]: result -= k//c break k -= c*count_count[c] result -= count_count[c] return result ", "class Solution def numberOfArithmeticSlices(self, A): result = 0 dp = [collections.defaultdict(int) for i in xrange(len(A))] for i in xrange(1, len(A)): for j in xrange(i): diff = A[i]-A[j] dp[i][diff] += 1 if diff in dp[j]: dp[i][diff] += dp[j][diff] result += dp[j][diff] return result ", "class Solution def containsNearbyAlmostDuplicate(self, nums, k, t): if k < 0 or t < 0: return False window = collections.OrderedDict() for n in nums: if len(window) > k: window.popitem(False) bucket = n if not t else n // t for m in (window.get(bucket - 1), window.get(bucket), window.get(bucket + 1)): if m is not None and abs(n - m) <= t: return True window[bucket] = n return False ", "class Solution def expTree(self, s): def compute(operands, operators): right, left = operands.pop(), operands.pop() operands.append(Node(val=operators.pop(), left=left, right=right)) precedence = {'+':0, '-':0, '*':1, '/':1} operands, operators, operand = [], [], 0 for i in xrange(len(s)): if s[i].isdigit(): operand = operand*10 + int(s[i]) if i == len(s)-1 or not s[i+1].isdigit(): operands.append(Node(val=str(operand))) operand = 0 elif s[i] == '(': operators.append(s[i]) elif s[i] == ')': while operators[-1] != '(': compute(operands, operators) operators.pop() elif s[i] in precedence: while operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[s[i]]: compute(operands, operators) operators.append(s[i]) while operators: compute(operands, operators) return operands[-1] ", "class Solution def isIsomorphic(self, s, t): if len(s) != len(t): return False s2t, t2s = {}, {} for p, w in izip(s, t): if w not in s2t and p not in t2s: s2t[w] = p t2s[p] = w elif w not in s2t or s2t[w] != p: return False return True ", "class Solution def isIsomorphic(self, s, t): if len(s) != len(t): return False return self.halfIsom(s, t) and self.halfIsom(t, s) def halfIsom(self, s, t): lookup = {} for i in xrange(len(s)): if s[i] not in lookup: lookup[s[i]] = t[i] elif lookup[s[i]] != t[i]: return False return True ", "class Solution def rob(self, nums): if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] return max(self.robRange(nums, 0, len(nums) - 1), self.robRange(nums, 1, len(nums))) def robRange(self, nums, start, end): num_i, num_i_1 = nums[start], 0 for i in xrange(start + 1, end): num_i_1, num_i_2 = num_i, num_i_1 num_i = max(nums[i] + num_i_2, num_i_1) return num_i ", "class Solution def trailingZeroes(self, n): result = 0 while n > 0: result += n / 5 n /= 5 return result ", "class Solution def catMouseGame(self, graph): HOLE, MOUSE_START, CAT_START = range(3) DRAW, MOUSE, CAT = range(3) def parents(m, c, t): if t == CAT: for nm in graph[m]: yield nm, c, MOUSE^CAT^t else: for nc in graph[c]: if nc != HOLE: yield m, nc, MOUSE^CAT^t degree = {} ignore = set(graph[HOLE]) for m in xrange(len(graph)): for c in xrange(len(graph)): degree[m, c, MOUSE] = len(graph[m]) degree[m, c, CAT] = len(graph[c])-(c in ignore) color = collections.defaultdict(int) q = collections.deque() for i in xrange(len(graph)): if i == HOLE: continue color[HOLE, i, CAT] = MOUSE q.append((HOLE, i, CAT, MOUSE)) for t in [MOUSE, CAT]: color[i, i, t] = CAT q.append((i, i, t, CAT)) while q: i, j, t, c = q.popleft() for ni, nj, nt in parents(i, j, t): if color[ni, nj, nt] != DRAW: continue if nt == c: color[ni, nj, nt] = c q.append((ni, nj, nt, c)) continue degree[ni, nj, nt] -= 1 if not degree[ni, nj, nt]: color[ni, nj, nt] = c q.append((ni, nj, nt, c)) return color[MOUSE_START, CAT_START, MOUSE] import collections ", "class Solution def catMouseGame(self, graph): HOLE, MOUSE_START, CAT_START = range(3) DRAW, MOUSE, CAT = range(3) def parents(m, c, t): if t == CAT: for nm in graph[m]: yield nm, c, MOUSE^CAT^t else: for nc in graph[c]: if nc != HOLE: yield m, nc, MOUSE^CAT^t color = collections.defaultdict(int) degree = {} ignore = set(graph[HOLE]) for m in xrange(len(graph)): for c in xrange(len(graph)): degree[m, c, MOUSE] = len(graph[m]) degree[m, c, CAT] = len(graph[c])-(c in ignore) q1 = collections.deque() q2 = collections.deque() for i in xrange(len(graph)): if i == HOLE: continue color[HOLE, i, CAT] = MOUSE q1.append((HOLE, i, CAT)) for t in [MOUSE, CAT]: color[i, i, t] = CAT q2.append((i, i, t)) while q1: i, j, t = q1.popleft() for ni, nj, nt in parents(i, j, t): if color[ni, nj, nt] != DRAW: continue if t == CAT: color[ni, nj, nt] = MOUSE q1.append((ni, nj, nt)) continue degree[ni, nj, nt] -= 1 if not degree[ni, nj, nt]: color[ni, nj, nt] = MOUSE q1.append((ni, nj, nt)) while q2: i, j, t = q2.popleft() for ni, nj, nt in parents(i, j, t): if color[ni, nj, nt] != DRAW: continue if t == MOUSE: color[ni, nj, nt] = CAT q2.append((ni, nj, nt)) continue degree[ni, nj, nt] -= 1 if not degree[ni, nj, nt]: color[ni, nj, nt] = CAT q2.append((ni, nj, nt)) return color[MOUSE_START, CAT_START, MOUSE] ", "class Solution def findAnagrams(self, s, p): result = [] cnts = [0] * 26 for c in p: cnts[ord(c) - ord('a')] += 1 left, right = 0, 0 while right < len(s): cnts[ord(s[right]) - ord('a')] -= 1 while left <= right and cnts[ord(s[right]) - ord('a')] < 0: cnts[ord(s[left]) - ord('a')] += 1 left += 1 if right - left + 1 == len(p): result.append(left) right += 1 return result ", "class Solution def closestCost(self, baseCosts, toppingCosts, target): max_count = 2 max_base, max_topping = max(baseCosts), max(toppingCosts) dp = [False]*(max(max_base, target+max_topping//2)+1) for b in baseCosts: dp[b] = True for t in toppingCosts: for _ in xrange(max_count): for i in reversed(xrange(len(dp)-t)): if dp[i]: dp[i+t] = True result = float(\"inf\") for i in xrange(1, len(dp)): if not dp[i]: continue if abs(i-target) < abs(result-target): result = i if i >= target: break return result ", "class Solution def closestCost(self, baseCosts, toppingCosts, target): max_count = 2 def backtracking(toppingCosts, i, cost, target, lookup, result): if (i, cost) in lookup: return lookup.add((i, cost)) if cost >= target or i == len(toppingCosts): if (abs(cost-target), cost) < (abs(result[0]-target), result[0]): result[0] = cost return for j in xrange(max_count+1): backtracking(toppingCosts, i+1, cost+j*toppingCosts[i], target, lookup, result) result = [float(\"inf\")] lookup = set() for b in baseCosts: backtracking(toppingCosts, 0, b, target, lookup, result) return result[0] import bisect ", "class Solution def closestCost(self, baseCosts, toppingCosts, target): max_count = 2 combs = set([0]) for t in toppingCosts: combs = set([c+i*t for c in combs for i in xrange(max_count+1)]) result, combs = float(\"inf\"), sorted(combs) for b in baseCosts: idx = bisect.bisect_left(combs, target-b) if idx < len(combs): result = min(result, b+combs[idx], key=lambda x: (abs(x-target), x)) if idx > 0: result = min(result, b+combs[idx-1], key=lambda x: (abs(x-target), x)) return result ", "class Solution def closestCost(self, baseCosts, toppingCosts, target): max_count = 2 combs = set([0]) for t in toppingCosts: combs = set([c+i*t for c in combs for i in xrange(max_count+1)]) result = float(\"inf\") for b in baseCosts: for c in combs: result = min(result, b+c, key=lambda x: (abs(x-target), x)) return result ", "class Solution def countDigits(self, num): result = 0 curr = num while curr: result += int(num%(curr%10) == 0) curr //= 10 return result ", "class Solution def boxDelivering(self, boxes, portsCount, maxBoxes, maxWeight): dp = [0]*(len(boxes)+1) left, cost, curr = 0, 1, 0 for right in xrange(len(boxes)): if right == 0 or boxes[right][0] != boxes[right-1][0]: cost += 1 curr += boxes[right][1] while right-left+1 > maxBoxes or curr > maxWeight or (left+1 < right+1 and dp[left+1] == dp[left]): curr -= boxes[left][1] if boxes[left+1][0] != boxes[left][0]: cost -= 1 left += 1 dp[right+1] = dp[(left-1)+1] + cost return dp[len(boxes)] ", "class Solution def findPermutation(self, s): result = [] for i in xrange(len(s)+1): if i == len(s) or s[i] == 'I': result += range(i+1, len(result), -1) return result ", "class Solution def findTheWinner(self, n, k): return reduce(lambda idx, n:(idx+k)%(n+1), xrange(1, n), 0)+1 ", "class Solution def findTheWinner(self, n, k): def f(idx, n, k): if n == 1: return 0 return (k+f((idx+k)%n, n-1, k))%n return f(0, n, k)+1 ", "class Solution def countHomogenous(self, s): MOD = 10**9+7 result = cnt = 0 for i in xrange(len(s)): if i and s[i-1] == s[i]: cnt += 1 else: cnt = 1 result = (result+cnt)%MOD return result ", "class Solution def distinctEchoSubstrings(self, text): def KMP(text, l, result): prefix = [-1]*(len(text)-l) j = -1 for i in xrange(1, len(prefix)): while j > -1 and text[l+j+1] != text[l+i]: j = prefix[j] if text[l+j+1] == text[l+i]: j += 1 prefix[i] = j if (j+1) and (i+1) % ((i+1) - (j+1)) == 0 and (i+1) // ((i+1) - (j+1)) % 2 == 0: result.add(text[l:l+i+1]) return len(prefix)-(prefix[-1]+1) if prefix[-1]+1 and len(prefix) % (len(prefix)-(prefix[-1]+1)) == 0 else float(\"inf\") result = set() i, l = 0, len(text)-1 while i < l: l = min(l, i + KMP(text, i, result)); i += 1 return len(result) ", "class Solution def distinctEchoSubstrings(self, text): result = set() for l in xrange(1, len(text)//2+1): count = sum(text[i] == text[i+l] for i in xrange(l)) for i in xrange(len(text)-2*l): if count == l: result.add(text[i:i+l]) count += (text[i+l] == text[i+l+l]) - (text[i] == text[i+l]) if count == l: result.add(text[len(text)-2*l:len(text)-2*l+l]) return len(result) ", "class Solution def distinctEchoSubstrings(self, text): MOD = 10**9+7 D = 27 result = set() for i in xrange(len(text)-1): left, right, pow_D = 0, 0, 1 for l in xrange(1, min(i+2, len(text)-i)): left = (D*left + (ord(text[i-l+1])-ord('a')+1)) % MOD right = (pow_D*(ord(text[i+l])-ord('a')+1) + right) % MOD if left == right: result.add(left) pow_D = (pow_D*D) % MOD return len(result) class Solution_TLE(object): def distinctEchoSubstrings(self, text): def compare(text, l, s1, s2): for i in xrange(l): if text[s1+i] != text[s2+i]: return False return True MOD = 10**9+7 D = 27 result = set() for i in xrange(len(text)): left, right, pow_D = 0, 0, 1 for l in xrange(1, min(i+2, len(text)-i)): left = (D*left + (ord(text[i-l+1])-ord('a')+1)) % MOD right = (pow_D*(ord(text[i+l])-ord('a')+1) + right) % MOD if left == right and compare(text, l, i-l+1, i+1): result.add(text[i+1:i+1+l]) pow_D = (pow_D*D) % MOD return len(result) ", "class Solution def numOfArrays(self, n, m, k): MOD = 10**9 + 7 dp = [[[0]*(k+1) for _ in xrange(m+1)] for _ in xrange(2)] prefix_dp = [[[0]*(k+1) for _ in xrange(m+1)] for _ in xrange(2)] for i in xrange(1, m+1): dp[1][i][1] = 1 prefix_dp[1][i][1] = (prefix_dp[1][i-1][1] + dp[1][i][1])%MOD for l in xrange(2, n+1): for i in xrange(1, m+1): for j in xrange(1, k+1): dp[l%2][i][j] = (i*dp[(l-1)%2][i][j]%MOD + prefix_dp[(l-1)%2][i-1][j-1])%MOD prefix_dp[l%2][i][j] = (prefix_dp[l%2][i-1][j] + dp[l%2][i][j])%MOD return prefix_dp[n%2][m][k] ", "class Solution def minAbsDifference(self, nums, goal): mx, mn = sum(x for x in nums if x > 0), sum(x for x in nums if x < 0) if goal > mx: return goal-mx if goal < mn: return mn-goal result = abs(goal) sums1 = set([0]) for i in xrange(len(nums)//2): for x in list(sums1): if x+nums[i] in sums1: continue sums1.add(x+nums[i]) result = min(result, abs(goal-x-nums[i])) sorted_sums1 = sorted(sums1) sums2 = set([0]) for i in xrange(len(nums)//2, len(nums)): for x in list(sums2): if x+nums[i] in sums2: continue sums2.add(x+nums[i]) ni = bisect.bisect_left(sorted_sums1, goal-x-nums[i]) if ni < len(sorted_sums1): result = min(result, abs(goal-x-nums[i]-sorted_sums1[ni])) if ni > 0: result = min(result, abs(goal-x-nums[i]-sorted_sums1[ni-1])) if result == 0: return result return result ", "class Solution def lowestCommonAncestor(self, p, q): a, b = p, q while a != b: a = a.parent if a else q b = b.parent if b else p return a ", "class Solution def lowestCommonAncestor(self, p, q): def depth(node): d = 0 while node: node = node.parent d += 1 return d p_d, q_d = depth(p), depth(q) while p_d > q_d: p = p.parent p_d -= 1 while p_d < q_d: q = q.parent q_d -= 1 while p != q: p = p.parent q = q.parent return p ", "class Solution def maximumLength(self, nums, k): lookup = {x:i for i, x in enumerate(set(nums))} dp = [[0]*len(lookup) for _ in xrange(k+1)] result = [0]*(k+1) for x in nums: x = lookup[x] for i in reversed(xrange(k+1)): dp[i][x] = max(dp[i][x], result[i-1] if i-1 >= 0 else 0)+1 result[i] = max(result[i], dp[i][x]) return result[k] import collections ", "class Solution def maximumLength(self, nums, k): dp = [collections.defaultdict(int) for _ in xrange(k+1)] result = [0]*(k+1) for x in nums: for i in reversed(xrange(k+1)): dp[i][x] = max(dp[i][x], result[i-1] if i-1 >= 0 else 0)+1 result[i] = max(result[i], dp[i][x]) return result[k] ", "class Solution def countOrders(self, n): MOD = 10**9+7 result = 1 for i in reversed(xrange(2, 2*n+1, 2)): result = result * i*(i-1)//2 % MOD return result ", "class Solution def canMakePaliQueries(self, s, queries): CHARSET_SIZE = 26 curr, count = [0]*CHARSET_SIZE, [[0]*CHARSET_SIZE] for c in s: curr[ord(c)-ord('a')] += 1 count.append(curr[:]) return [sum((b-a)%2 for a, b in itertools.izip(count[left], count[right+1]))//2 <= k for left, right, k in queries] ", "class Solution def matrixBlockSum(self, mat, K): m, n = len(mat), len(mat[0]) accu = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)] for i in xrange(m): for j in xrange(n): accu[i+1][j+1] = accu[i+1][j]+accu[i][j+1]-accu[i][j]+mat[i][j] result = [[0 for _ in xrange(n)] for _ in xrange(m)] for i in xrange(m): for j in xrange(n): r1, c1, r2, c2 = max(i-K, 0), max(j-K, 0), min(i+K+1, m), min(j+K+1, n) result[i][j] = accu[r2][c2]-accu[r1][c2]-accu[r2][c1]+accu[r1][c1] return result ", "class Solution def findKDistantIndices(self, nums, key, k): result = [] prev = -1 for i, x in enumerate(nums): if x != key: continue for j in xrange(max(i-k, prev+1), min(i+k+1, len(nums))): result.append(j) prev = min(i+k, len(nums)-1) return result ", "class Solution def intToRoman(self, num): numeral_map = {1: \"I\", 4: \"IV\", 5: \"V\", 9: \"IX\", 10: \"X\", 40: \"XL\", 50: \"L\", 90: \"XC\", 100: \"C\", 400: \"CD\", 500: \"D\", 900: \"CM\", 1000: \"M\"} keyset, result = sorted(numeral_map.keys()), [] while num > 0: for key in reversed(keyset): while num / key > 0: num -= key result += numeral_map[key] return \"\".join(result) ", "class Solution def findBlackPixel(self, picture, N): rows, cols = [0] * len(picture), [0] * len(picture[0]) lookup = collections.defaultdict(int) for i in xrange(len(picture)): for j in xrange(len(picture[0])): if picture[i][j] == 'B': rows[i] += 1 cols[j] += 1 lookup[tuple(picture[i])] += 1 result = 0 for i in xrange(len(picture)): if rows[i] == N and lookup[tuple(picture[i])] == N: for j in xrange(len(picture[0])): result += picture[i][j] == 'B' and cols[j] == N return result ", "class Solution def findBlackPixel(self, picture, N): lookup = collections.Counter(map(tuple, picture)) cols = [col.count('B') for col in zip(*picture)] return sum(N * zip(row, cols).count(('B', N)) for row, cnt in lookup.iteritems() if cnt == N == row.count('B')) ", "class Solution def lastNonEmptyString(self, s): cnt = [0]*26 for x in s: cnt[ord(x)-ord('a')] += 1 mx = max(cnt) result = [] for x in reversed(s): if cnt[ord(x)-ord('a')] != mx: continue cnt[ord(x)-ord('a')] -= 1 result.append(x) return \"\".join(reversed(result)) ", "class Solution def isWinner(self, player1, player2): k = 2 def f(arr): result = cnt = 0 for i in xrange(len(arr)): result += 2*arr[i] if cnt else arr[i] cnt += (arr[i] == 10) if i-k >= 0: cnt -= (arr[i-k] == 10) return result a, b = f(player1), f(player2) return 1 if a > b else 2 if a < b else 0 ", "class Solution def getWinner(self, arr, k): result = arr[0] count = 0 for i in xrange(1, len(arr)): if arr[i] > result: result = arr[i] count = 0 count += 1 if (count == k): break return result ", "class Solution def fixedPoint(self, A): left, right = 0, len(A)-1 while left <= right: mid = left + (right-left)//2 if A[mid] >= mid: right = mid-1 else: left = mid+1 return left if A[left] == left else -1 ", "class Solution def outerTrees(self, trees): def dist(a, b): return ((a[0]-b[0])**2 + (a[1]-b[1])**2)**0.5 def inside(c, p): return dist(c[0], p) < c[1]+EPS def circle_center(bx, by, cx, cy): B = bx*bx + by*by C = cx*cx + cy*cy D = bx*cy - by*cx return [float(cy*B - by*C)/(2*D), float(bx*C - cx*B)/(2*D)] def circle_from_2_points(A, B): C = [(A[0]+B[0])/2.0, (A[1]+B[1])/2.0] return [C, dist(A, B)/2.0] def circle_from_3_points(A, B, C): I = circle_center(B[0]-A[0], B[1]-A[1], C[0]-A[0], C[1]-A[1]) I[0] += A[0] I[1] += A[1] return [I, dist(I, A)] def trivial(boundaries): if not boundaries: return None if len(boundaries) == 1: return [boundaries[0], 0.0] if len(boundaries) == 2: return circle_from_2_points(boundaries[0], boundaries[1]) return circle_from_3_points(boundaries[0], boundaries[1], boundaries[2]) def Welzl(points, boundaries, curr): if curr == len(points) or len(boundaries) == 3: return trivial(boundaries) result = Welzl(points, boundaries, curr+1) if result is not None and inside(result, points[curr]): return result boundaries.append(points[curr]) result = Welzl(points, boundaries, curr+1) boundaries.pop() return result EPS = 1e-5 random.seed(0) random.shuffle(trees) result = Welzl(trees, [], 0) return result[0][0], result[0][1], result[1] ", "class Solution def findPattern(self, stream, pattern): def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j+1 > 0 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix prefix = getPrefix(pattern) i = j = -1 while True: d = stream.next() i += 1 while j+1 > 0 and pattern[j+1] != d: j = prefix[j] if pattern[j+1] == d: j += 1 if j+1 == len(pattern): return i-j return -1 ", "class Solution def cloneGraph(self, node): if node is None: return None cloned_node = UndirectedGraphNode(node.label) cloned, queue = {node:cloned_node}, [node] while queue: current = queue.pop() for neighbor in current.neighbors: if neighbor not in cloned: queue.append(neighbor) cloned_neighbor = UndirectedGraphNode(neighbor.label) cloned[neighbor] = cloned_neighbor cloned[current].neighbors.append(cloned[neighbor]) return cloned[node] ", "class Solution def isCompleteTree(self, root): end = False current = [root] while current: next_level = [] for node in current: if not node: end = True continue if end: return False next_level.append(node.left) next_level.append(node.right) current = next_level return True ", "class Solution def isCompleteTree(self, root): prev_level, current = [], [(root, 1)] count = 0 while current: count += len(current) next_level = [] for node, v in current: if not node: continue next_level.append((node.left, 2*v)) next_level.append((node.right, 2*v+1)) prev_level, current = current, next_level return prev_level[-1][1] == count ", "class Solution def containVirus(self, grid): directions = [(0, 1), (0, -1), (-1, 0), (1, 0)] def dfs(grid, r, c, lookup, regions, frontiers, perimeters): if (r, c) in lookup: return lookup.add((r, c)) regions[-1].add((r, c)) for d in directions: nr, nc = r+d[0], c+d[1] if not (0 <= nr < len(grid) and 0 <= nc < len(grid[r])): continue if grid[nr][nc] == 1: dfs(grid, nr, nc, lookup, regions, frontiers, perimeters) elif grid[nr][nc] == 0: frontiers[-1].add((nr, nc)) perimeters[-1] += 1 result = 0 while True: lookup, regions, frontiers, perimeters = set(), [], [], [] for r, row in enumerate(grid): for c, val in enumerate(row): if val == 1 and (r, c) not in lookup: regions.append(set()) frontiers.append(set()) perimeters.append(0) dfs(grid, r, c, lookup, regions, frontiers, perimeters) if not regions: break triage_idx = frontiers.index(max(frontiers, key = len)) for i, region in enumerate(regions): if i == triage_idx: result += perimeters[i] for r, c in region: grid[r][c] = -1 continue for r, c in region: for d in directions: nr, nc = r+d[0], c+d[1] if not (0 <= nr < len(grid) and 0 <= nc < len(grid[r])): continue if grid[nr][nc] == 0: grid[nr][nc] = 1 return result ", "class Solution def isPrefixOfWord(self, sentence, searchWord): def KMP(text, pattern): def getPrefix(pattern): prefix = [-1] * len(pattern) j = -1 for i in xrange(1, len(pattern)): while j > -1 and pattern[j + 1] != pattern[i]: j = prefix[j] if pattern[j + 1] == pattern[i]: j += 1 prefix[i] = j return prefix prefix = getPrefix(pattern) j = -1 for i in xrange(len(text)): while j != -1 and pattern[j+1] != text[i]: j = prefix[j] if pattern[j+1] == text[i]: j += 1 if j+1 == len(pattern): return i-j return -1 if sentence.startswith(searchWord): return 1 p = KMP(sentence, ' ' + searchWord) if p == -1: return -1 return 1+sum(sentence[i] == ' ' for i in xrange(p+1)) ", "class Solution def findGoodStrings(self, n, s1, s2, evil): MOD = 10**9+7 def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j != -1 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix prefix = getPrefix(evil) dp = [[[[0]*len(evil) for _ in xrange(2)] for _ in xrange(2)] for _ in xrange(2)] dp[0][0][0][0] = 1 for i in xrange(n): dp[(i+1)%2] = [[[0]*len(evil) for _ in xrange(2)] for _ in xrange(2)] for j in xrange(2): for k in xrange(2): min_c = 'a' if j else s1[i] max_c = 'z' if k else s2[i] for l in xrange(len(evil)): if not dp[i%2][j][k][l]: continue for c in xrange(ord(min_c)-ord('a'), ord(max_c)-ord('a')+1): c = chr(c+ord('a')) m = l-1 while m != -1 and evil[m+1] != c: m = prefix[m] if evil[m+1] == c: m += 1 if m+1 == len(evil): continue dp[(i+1)%2][j or (s1[i] != c)][k or (s2[i] != c)][m+1] = (dp[(i+1)%2][j or (s1[i] != c)][k or (s2[i] != c)][m+1] + dp[i%2][j][k][l]) % MOD result = 0 for j in xrange(2): for k in xrange(2): for l in xrange(len(evil)): result = (result + dp[n%2][j][k][l]) % MOD return result ", "class Solution def closestFair(self, n): digits = map(int, str(n)) result = [] if len(digits)%2 == 0: left = [0]*2 for d in digits: left[d%2] += 1 if left[0] == len(digits)//2: return n for i in reversed(xrange(len(digits)//2, len(digits))): left[digits[i]%2] -= 1 right = [len(digits)//2-left[0], len(digits)//2-left[1]] if any(x < 0 for x in right): continue d = digits[i]+1 if right[(digits[i]+1)%2]-1 >= 0 else digits[i]+2 if d > 9: continue right[d%2] -= 1 result = digits[:i]+[d]+[0]*right[0]+[1]*right[1] break if not result: l = len(digits)//2+1 result = [1]+[0]*l+[1]*(l-1) return int(\"\".join(map(str, result))) ", "class Solution def maximumCostSubstring(self, s, chars, vals): def kadane(s): result = curr = 0 for c in s: curr = max(curr+(lookup[c] if c in lookup else ord(c)-ord('a')+1), 0) result = max(result, curr) return result lookup = {} for c, v in itertools.izip(chars, vals): lookup[c] = v return kadane(s) ", "class Solution def countOperations(self, num1, num2): result = 0 while num2: result += num1//num2 num1, num2 = num2, num1%num2 return result ", "class Solution def longestRepeatingSubstring(self, S): M = 10**9+7 D = 26 def check(S, L): p = pow(D, L, M) curr = reduce(lambda x, y: (D*x+ord(y)-ord('a')) % M, S[:L], 0) lookup = collections.defaultdict(list) lookup[curr].append(L-1) result = 0 for i in xrange(L, len(S)): curr = ((D*curr) % M + ord(S[i])-ord('a') - ((ord(S[i-L])-ord('a'))*p) % M) % M if curr in lookup: for j in lookup[curr]: if S[j-L+1:j+1] == S[i-L+1:i+1]: if result == 0: result = i return result-L+1 lookup[curr].append(i) return result left, right = 0, len(S)-1 while left <= right: mid = left + (right-left)//2 if not check(S, mid): right = mid-1 else: left = mid+1 return right ", "class Solution def countVowelSubstrings(self, word): VOWELS = set(\"aeiou\") k = 5 def atLeastK(word, k): cnt = collections.Counter() result = left = right = 0 for i, c in enumerate(word): if c not in VOWELS: cnt = collections.Counter() left = right = i+1 continue cnt[c] += 1 while len(cnt) > k-1: cnt[word[right]] -= 1 if not cnt[word[right]]: del cnt[word[right]] right += 1 result += right-left return result return atLeastK(word, k) import collections ", "class Solution def countVowelSubstrings(self, word): VOWELS = set(\"aeiou\") k = 5 def atMostK(word, k): cnt = collections.Counter() result = left = 0 for right, c in enumerate(word): if c not in VOWELS: cnt = collections.Counter() left = right+1 continue cnt[c] += 1 while len(cnt) > k: cnt[word[left]] -=1 if not cnt[word[left]]: del cnt[word[left]] left += 1 result += right-left+1 return result return atMostK(word, k) - atMostK(word, k-1) ", "class Solution def findAllConcatenatedWordsInADict(self, words): lookup = set(words) result = [] for word in words: dp = [False] * (len(word)+1) dp[0] = True for i in xrange(len(word)): if not dp[i]: continue for j in xrange(i+1, len(word)+1): if j - i < len(word) and word[i:j] in lookup: dp[j] = True if dp[len(word)]: result.append(word) break return result ", "class Solution def maximumValueSum(self, nums, k, edges): result = parity = 0 diff = float(\"inf\") for x in nums: y = x^k result += max(x, y) parity ^= int(x < y) diff = min(diff, abs(x-y)) return result-parity*diff ", "class Solution def findEvenNumbers(self, digits): k = 3 def backtracking(curr, cnt, result): if len(curr) == k: result.append(reduce(lambda x, y: x*10+y, curr)) return for i, c in enumerate(cnt): if c == 0 or (not curr and i == 0) or (len(curr) == k-1 and i%2 != 0): continue cnt[i] -= 1 curr.append(i) backtracking(curr, cnt, result) curr.pop() cnt[i] += 1 cnt = [0]*10 for d in digits: cnt[d] += 1 result = [] backtracking([], cnt, result) return result import collections ", "class Solution def findEvenNumbers(self, digits): result, cnt = [], collections.Counter(digits) for i in xrange(1, 10): for j in xrange(10): for k in xrange(0, 10, 2): if cnt[i] > 0 and cnt[j] > (j == i) and cnt[k] > (k == i) + (k == j): result.append(i*100 + j*10 + k) return result import collections class Node(object): def __init__(self, val=None, left=None, right=None): self.val = val self.left = left self.right = right ", "class Solution def findEvenNumbers(self, digits): k = 3 def backtracking(curr, dummy, result): if len(curr) == k: result.append(reduce(lambda x, y: x*10+y, curr)) return node = dummy.right while node: if (not curr and node.val[0] == 0) or (len(curr) == k-1 and node.val[0]%2 != 0): node = node.right continue node.val[1] -= 1 if node.val[1] == 0: if node.left: node.left.right = node.right if node.right: node.right.left = node.left curr.append(node.val[0]) backtracking(curr, dummy, result) curr.pop() if node.val[1] == 0: if node.left: node.left.right = node if node.right: node.right.left = node node.val[1] += 1 node = node.right prev = dummy = Node() for digit, cnt in sorted(map(list, collections.Counter(digits).iteritems())): prev.right = Node(val=[digit, cnt], left=prev) prev = prev.right result = [] backtracking([], dummy, result) return result import collections ", "class Solution def findEvenNumbers(self, digits): k = 3 def backtracking(curr, digit_cnt, result): if len(curr) == k: result.append(reduce(lambda x, y: x*10+y, curr)) return for i, (digit, cnt) in enumerate(digit_cnt): if (not curr and digit == 0) or (len(curr) == k-1 and digit%2 != 0): continue digit_cnt[i][1] -= 1 digit_cnt[i], digit_cnt[-1] = digit_cnt[-1], digit_cnt[i] removed = [] if digit_cnt[-1][1] == 0: removed = digit_cnt.pop() curr.append(digit) backtracking(curr, digit_cnt, result) curr.pop() if removed: digit_cnt.append(removed) digit_cnt[i], digit_cnt[-1] = digit_cnt[-1], digit_cnt[i] digit_cnt[i][1] += 1 cnt = collections.Counter(digits) digit_cnt = map(list, cnt.iteritems()) result = [] backtracking([], digit_cnt, result) result.sort() return result ", "class Solution def findingUsersActiveMinutes(self, logs, k): lookup = collections.defaultdict(set) for u, t in logs: lookup[u].add(t) result = [0]*k for _, ts in lookup.iteritems(): result[len(ts)-1] += 1 return result ", "class Solution def findDuplicateSubtrees(self, root): def getid(root, lookup, trees): if not root: return -1 node_id = lookup[root.val, getid(root.left, lookup, trees), getid(root.right, lookup, trees)] trees[node_id].append(root) return node_id trees = collections.defaultdict(list) lookup = collections.defaultdict() lookup.default_factory = lookup.__len__ getid(root, lookup, trees) return [roots[0] for roots in trees.itervalues() if len(roots) > 1] ", "class Solution def findDuplicateSubtrees(self, root): def postOrderTraversal(node, lookup, result): if not node: return \"\" s = \"(\" + postOrderTraversal(node.left, lookup, result) + str(node.val) + postOrderTraversal(node.right, lookup, result) + \")\" if lookup[s] == 1: result.append(node) lookup[s] += 1 return s lookup = collections.defaultdict(int) result = [] postOrderTraversal(root, lookup, result) return result ", "class Solution def maximumLength(self, nums): cnt = collections.Counter(nums) dp = {} result = 0 for x in cnt.iterkeys(): if x == 1: result = max(result, cnt[x]-(1 if cnt[x]%2 == 0 else 0)) continue stk = [] while x not in dp and x in cnt and cnt[x] >= 2: stk.append(x) x *= x if x not in dp: if x not in cnt: x = stk.pop() dp[x] = 1 l = dp[x] while stk: l += 2 dp[stk.pop()] = l result = max(result, l) return result import collections ", "class Solution def maximumLength(self, nums): cnt = collections.Counter(nums) result = 0 for x in cnt.iterkeys(): if x == 1: result = max(result, cnt[x]-(1 if cnt[x]%2 == 0 else 0)) continue l = 0 while x in cnt and cnt[x] >= 2: l += 2 x *= x l += 1 if x in cnt else -1 result = max(result, l) return result ", "class Solution def buildArray(self, nums): for i in xrange(len(nums)): prev, curr = i, nums[i] while curr >= 0 and curr != i: nums[prev], nums[curr] = ~nums[curr], ~nums[prev] if prev == i else nums[prev] prev, curr = curr, ~nums[prev] for i in xrange(len(nums)): if nums[i] < 0: nums[i] = ~nums[i] return nums ", "class Solution def buildArray(self, nums): return [nums[x] for x in nums] ", "class Solution def kidsWithCandies(self, candies, extraCandies): max_num = max(candies) return [x + extraCandies >= max_num for x in candies] ", "class Solution def rearrangeBarcodes(self, barcodes): k = 2 cnts = collections.Counter(barcodes) bucket_cnt = max(cnts.itervalues()) result = [0]*len(barcodes) i = (len(barcodes)-1)%k for c in itertools.chain((c for c, v in cnts.iteritems() if v == bucket_cnt), (c for c, v in cnts.iteritems() if v != bucket_cnt)): for _ in xrange(cnts[c]): result[i] = c i += k if i >= len(result): i = (i-1)%k return result import collections ", "class Solution def rearrangeBarcodes(self, barcodes): cnts = collections.Counter(barcodes) sorted_cnts = [[v, k] for k, v in cnts.iteritems()] sorted_cnts.sort(reverse=True) i = 0 for v, k in sorted_cnts: for _ in xrange(v): barcodes[i] = k i += 2 if i >= len(barcodes): i = 1 return barcodes ", "class Solution def checkAlmostEquivalent(self, word1, word2): k = 3 cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2) return all(abs(cnt1[c]-cnt2[c]) <= k for c in set(cnt1.keys()+cnt2.keys())) ", "class Solution def getDistances(self, arr): lookup = collections.defaultdict(list) for i, x in enumerate(arr): lookup[x].append(i) result = [0]*len(arr) for idxs in lookup.itervalues(): prefix = [0] for i in idxs: prefix.append(prefix[-1]+i) for i, idx in enumerate(idxs): result[idx] = (idx*(i+1)-prefix[i+1]) + ((prefix[len(idxs)]-prefix[i])-idx*(len(idxs)-i)) return result ", "class Solution def maxProfit(self, prices): if not prices: return 0 buy, sell, coolDown = [0] * 2, [0] * 2, [0] * 2 buy[0] = -prices[0] for i in xrange(1, len(prices)): buy[i % 2] = max(buy[(i - 1) % 2], coolDown[(i - 1) % 2] - prices[i]) sell[i % 2] = buy[(i - 1) % 2] + prices[i] coolDown[i % 2] = max(coolDown[(i - 1) % 2], sell[(i - 1) % 2]) return max(coolDown[(len(prices) - 1) % 2], sell[(len(prices) - 1) % 2]) ", "class Solution def updateMatrix(self, matrix): for i in xrange(len(matrix)): for j in xrange(len(matrix[i])): if not matrix[i][j]: continue matrix[i][j] = float(\"inf\") if i > 0: matrix[i][j] = min(matrix[i][j], matrix[i-1][j]+1) if j > 0: matrix[i][j] = min(matrix[i][j], matrix[i][j-1]+1) for i in reversed(xrange(len(matrix))): for j in reversed(xrange(len(matrix[i]))): if not matrix[i][j]: continue if i < len(matrix)-1: matrix[i][j] = min(matrix[i][j], matrix[i+1][j]+1) if j < len(matrix[i])-1: matrix[i][j] = min(matrix[i][j], matrix[i][j+1]+1) return matrix ", "class Solution def updateMatrix(self, matrix): dp = [[float(\"inf\")]*len(matrix[0]) for _ in xrange(len(matrix))] for i in xrange(len(matrix)): for j in xrange(len(matrix[i])): if matrix[i][j] == 0: dp[i][j] = 0 else: if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j]+1) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1]+1) for i in reversed(xrange(len(matrix))): for j in reversed(xrange(len(matrix[i]))): if matrix[i][j] == 0: dp[i][j] = 0 else: if i < len(matrix)-1: dp[i][j] = min(dp[i][j], dp[i+1][j]+1) if j < len(matrix[i])-1: dp[i][j] = min(dp[i][j], dp[i][j+1]+1) return dp import collections ", "class Solution def updateMatrix(self, matrix): queue = collections.deque() for i in xrange(len(matrix)): for j in xrange(len(matrix[0])): if matrix[i][j] == 0: queue.append((i, j)) else: matrix[i][j] = float(\"inf\") dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: cell = queue.popleft() for dir in dirs: i, j = cell[0]+dir[0], cell[1]+dir[1] if not (0 <= i < len(matrix) and 0 <= j < len(matrix[0]) and matrix[i][j] > matrix[cell[0]][cell[1]]+1): continue queue.append((i, j)) matrix[i][j] = matrix[cell[0]][cell[1]]+1 return matrix ", "class Solution def isArmstrong(self, N): n_str = str(N) return sum(int(i)**len(n_str) for i in n_str) == N ", "class Solution def heightChecker(self, heights): return sum(i != j for i, j in itertools.izip(heights, sorted(heights))) ", "class Solution def countNicePairs(self, nums): MOD = 10**9 + 7 def rev(x): result = 0 while x: x, r = divmod(x, 10) result = result*10+r return result result = 0 lookup = collections.defaultdict(int) for num in nums: result = (result + lookup[num-rev(num)])%MOD lookup[num-rev(num)] += 1 return result ", "class Solution def countSpecialSubsequences(self, nums): MOD = 10**9+7 dp = [0]*3 for x in nums: dp[x] = ((dp[x]+dp[x])%MOD+(dp[x-1] if x-1 >= 0 else 1))%MOD return dp[-1] ", "class Solution def findCriticalAndPseudoCriticalEdges(self, n, edges): def MST(n, edges, unused=None, used=None): union_find = UnionFind(n) weight = 0 if used is not None: u, v, w, _ = edges[used] if union_find.union_set(u, v): weight += w for i, (u, v, w, _) in enumerate(edges): if i == unused: continue if union_find.union_set(u, v): weight += w return weight if union_find.count == 1 else float(\"inf\") for i, edge in enumerate(edges): edge.append(i) edges.sort(key=lambda x: x[2]) mst = MST(n, edges) result = [[], []] for i, edge in enumerate(edges): if mst < MST(n, edges, unused=i): result[0].append(edge[3]) elif mst == MST(n, edges, used=i): result[1].append(edge[3]) return result ", "class Solution def smallestEquivalentString(self, A, B, S): union_find = UnionFind(26) for i in xrange(len(A)): union_find.union_set(ord(A[i])-ord('a'), ord(B[i])-ord('a')) result = [] for i in xrange(len(S)): parent = union_find.find_set(ord(S[i])-ord('a')) result.append(chr(parent+ord('a'))) return \"\".join(result) ", "class Solution def lastStoneWeightII(self, stones): dp = {0} for stone in stones: dp |= {stone+i for i in dp} S = sum(stones) return min(abs(i-(S-i)) for i in dp) ", "class Solution def executeInstructions(self, n, startPos, s): directions = {'U':(-1, 0), 'R':(0, 1), 'D':(1, 0), 'L':(0, -1)} (x0, y0), (x, y) = startPos, (0, 0) result = range(len(s), 0, -1) lookup_x = collections.defaultdict(list) lookup_y = collections.defaultdict(list) lookup_x[x0-x].append(0) lookup_y[y0-y].append(0) for i, d in enumerate(s): dx, dy = directions[d] x, y = x+dx, y+dy for k in n-x, -x-1: if k not in lookup_x: continue for j in lookup_x[k]: result[j] = min(result[j], i-j) lookup_x[k] = [] for k in n-y, -y-1: if k not in lookup_y: continue for j in lookup_y[k]: result[j] = min(result[j], i-j) lookup_y[k] = [] lookup_x[x0-x].append(i+1) lookup_y[y0-y].append(i+1) return result ", "class Solution def decodeMessage(self, key, message): f = lambda x: ord(x)-ord('a') lookup = [-1]*26 i = 0 for x in itertools.imap(f, key): if x < 0 or lookup[x] != -1: continue lookup[x] = i i += 1 return \"\".join(itertools.imap(lambda x: chr(ord('a')+x), (lookup[x] if x >= 0 else x for x in itertools.imap(f, message)))) ", "class Solution def vowelStrings(self, words, left, right): VOWELS = {'a', 'e', 'i', 'o', 'u'} return sum(words[i][0] in VOWELS and words[i][-1] in VOWELS for i in xrange(left, right+1)) ", "class Solution def rob(self, root): def robHelper(root): if not root: return (0, 0) left, right = robHelper(root.left), robHelper(root.right) return (root.val + left[1] + right[1], max(left) + max(right)) return max(robHelper(root)) ", "class Solution def minimumDistance(self, n, edges, s, marked): def dijkstra(start): best = [float(\"inf\")]*len(adj) best[start] = 0 min_heap = [(0, start)] while min_heap: curr, u = heapq.heappop(min_heap) if curr > best[u]: continue if u in target: return curr for v, w in adj[u]: if curr+w >= best[v]: continue best[v] = curr+w heapq.heappush(min_heap, (best[v], v)) return -1 target = set(marked) adj = [[] for _ in xrange(n)] for u, v, w in edges: adj[u].append((v, w)) return dijkstra(s) ", "class Solution def addStrings(self, num1, num2): result = [] i, j, carry = len(num1) - 1, len(num2) - 1, 0 while i >= 0 or j >= 0 or carry: if i >= 0: carry += ord(num1[i]) - ord('0') i -= 1 if j >= 0: carry += ord(num2[j]) - ord('0') j -= 1 result.append(str(carry % 10)) carry /= 10 result.reverse() return \"\".join(result) def addStrings2(self, num1, num2): length = max(len(num1), len(num2)) num1 = num1.zfill(length)[::-1] num2 = num2.zfill(length)[::-1] res, plus = '', 0 for index, num in enumerate(num1): tmp = str(int(num) + int(num2[index]) + plus) res += tmp[-1] if int(tmp) > 9: plus = 1 else: plus = 0 if plus: res += '1' return res[::-1] ", "class Solution def oddCells(self, n, m, indices): row, col = [0]*n, [0]*m for r, c in indices: row[r] ^= 1 col[c] ^= 1 row_sum, col_sum = sum(row), sum(col) return row_sum*m+col_sum*n-2*row_sum*col_sum import collections import itertools ", "class Solution def oddCells(self, n, m, indices): fn = lambda x: sum(count&1 for count in collections.Counter(x).itervalues()) row_sum, col_sum = map(fn, itertools.izip(*indices)) return row_sum*m+col_sum*n-2*row_sum*col_sum ", "class Solution def countSpecialNumbers(self, n): def P(m, n): result = 1 for _ in xrange(n): result *= m m -= 1 return result digits = map(int, str(n+1)) result = sum(P(9, 1)*P(9, i-1) for i in xrange(1, len(digits))) lookup = set() for i, x in enumerate(digits): for y in xrange(int(i == 0), x): if y in lookup: continue result += P(9-i, len(digits)-i-1) if x in lookup: break lookup.add(x) return result ", "class Solution def maxAreaOfIsland(self, grid): directions = [[-1, 0], [ 1, 0], [ 0, 1], [ 0, -1]] def dfs(i, j, grid, area): if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] > 0): return False grid[i][j] *= -1 area[0] += 1 for d in directions: dfs(i+d[0], j+d[1], grid, area) return True result = 0 for i in xrange(len(grid)): for j in xrange(len(grid[0])): area = [0] if dfs(i, j, grid, area): result = max(result, area[0]) return result ", "class Solution def dailyTemperatures(self, temperatures): result = [0] * len(temperatures) stk = [] for i in xrange(len(temperatures)): while stk and temperatures[stk[-1]] < temperatures[i]: idx = stk.pop() result[idx] = i-idx stk.append(i) return result ", "class Solution def minEatingSpeed(self, piles, H): def possible(piles, H, K): return sum((pile-1)//K+1 for pile in piles) <= H left, right = 1, max(piles) while left <= right: mid = left + (right-left)//2 if possible(piles, H, mid): right = mid-1 else: left = mid+1 return left ", "class Solution def findMaxLength(self, nums): result, count = 0, 0 lookup = {0: -1} for i, num in enumerate(nums): count += 1 if num == 1 else -1 if count in lookup: result = max(result, i - lookup[count]) else: lookup[count] = i return result ", "class Solution def boldWords(self, words, S): _trie = lambda: collections.defaultdict(_trie) trie = _trie() for i, word in enumerate(words): functools.reduce(dict.__getitem__, word, trie).setdefault(\"_end\") lookup = [False] * len(S) for i in xrange(len(S)): curr = trie k = -1 for j in xrange(i, len(S)): if S[j] not in curr: break curr = curr[S[j]] if \"_end\" in curr: k = j for j in xrange(i, k+1): lookup[j] = True result = [] for i in xrange(len(S)): if lookup[i] and (i == 0 or not lookup[i-1]): result.append(\"<b>\") result.append(S[i]) if lookup[i] and (i == len(S)-1 or not lookup[i+1]): result.append(\"</b>\") return \"\".join(result) ", "class Solution def boldWords(self, words, S): lookup = [0] * len(S) for d in words: pos = S.find(d) while pos != -1: lookup[pos:pos+len(d)] = [1] * len(d) pos = S.find(d, pos+1) result = [] for i in xrange(len(S)): if lookup[i] and (i == 0 or not lookup[i-1]): result.append(\"<b>\") result.append(S[i]) if lookup[i] and (i == len(S)-1 or not lookup[i+1]): result.append(\"</b>\") return \"\".join(result) ", "class Solution def alienOrder(self, words): result, in_degree, out_degree = [], {}, {} zero_in_degree_queue = collections.deque() nodes = set() for word in words: for c in word: nodes.add(c) for i in xrange(1, len(words)): if (len(words[i-1]) > len(words[i]) and words[i-1][:len(words[i])] == words[i]): return \"\" self.findEdges(words[i - 1], words[i], in_degree, out_degree) for node in nodes: if node not in in_degree: zero_in_degree_queue.append(node) while zero_in_degree_queue: precedence = zero_in_degree_queue.popleft() result.append(precedence) if precedence in out_degree: for c in out_degree[precedence]: in_degree[c].discard(precedence) if not in_degree[c]: zero_in_degree_queue.append(c) del out_degree[precedence] if out_degree: return \"\" return \"\".join(result) def findEdges(self, word1, word2, in_degree, out_degree): str_len = min(len(word1), len(word2)) for i in xrange(str_len): if word1[i] != word2[i]: if word2[i] not in in_degree: in_degree[word2[i]] = set() if word1[i] not in out_degree: out_degree[word1[i]] = set() in_degree[word2[i]].add(word1[i]) out_degree[word1[i]].add(word2[i]) break ", "class Solution def alienOrder(self, words): nodes, ancestors = set(), {} for i in xrange(len(words)): for c in words[i]: nodes.add(c) for node in nodes: ancestors[node] = [] for i in xrange(1, len(words)): if (len(words[i-1]) > len(words[i]) and words[i-1][:len(words[i])] == words[i]): return \"\" self.findEdges(words[i - 1], words[i], ancestors) result = [] visited = {} for node in nodes: if self.topSortDFS(node, node, ancestors, visited, result): return \"\" return \"\".join(result) def findEdges(self, word1, word2, ancestors): min_len = min(len(word1), len(word2)) for i in xrange(min_len): if word1[i] != word2[i]: ancestors[word2[i]].append(word1[i]) break def topSortDFS(self, root, node, ancestors, visited, result): if node not in visited: visited[node] = root for ancestor in ancestors[node]: if self.topSortDFS(root, ancestor, ancestors, visited, result): return True result.append(node) elif visited[node] == root: return True return False ", "class Solution def ipToCIDR(self, ip, n): def ipToInt(ip): result = 0 for i in ip.split('.'): result = 256 * result + int(i) return result def intToIP(n): return \".\".join(str((n >> i) % 256) for i in (24, 16, 8, 0)) start = ipToInt(ip) result = [] while n: mask = max(33-(start & ~(start-1)).bit_length(), 33-n.bit_length()) result.append(intToIP(start) + '/' + str(mask)) start += 1 << (32-mask) n -= 1 << (32-mask) return result ", "class Solution def validPartition(self, nums): dp = [False]*4 dp[0] = True for i in xrange(len(nums)): dp[(i+1)%4] = False if i-1 >= 0 and nums[i] == nums[i-1]: dp[(i+1)%4] |= dp[((i+1)-2)%4] if i-2 >= 0 and (nums[i] == nums[i-1] == nums[i-2] or nums[i] == nums[i-1]+1 == nums[i-2]+2): dp[(i+1)%4] |= dp[((i+1)-3)%4] return dp[len(nums)%4] ", "class Solution def islandPerimeter(self, grid): count, repeat = 0, 0 for i in xrange(len(grid)): for j in xrange(len(grid[i])): if grid[i][j] == 1: count += 1 if i != 0 and grid[i - 1][j] == 1: repeat += 1 if j != 0 and grid[i][j - 1] == 1: repeat += 1 return 4*count - 2*repeat def islandPerimeter2(self, grid): return sum(sum(map(operator.ne, [0] + row, row + [0])) for row in grid + map(list, zip(*grid))) ", "class Solution def orderOfLargestPlusSign(self, N, mines): lookup = {tuple(mine) for mine in mines} dp = [[0] * N for _ in xrange(N)] result = 0 for i in xrange(N): l = 0 for j in xrange(N): l = 0 if (i, j) in lookup else l+1 dp[i][j] = l l = 0 for j in reversed(xrange(N)): l = 0 if (i, j) in lookup else l+1 dp[i][j] = min(dp[i][j], l) for j in xrange(N): l = 0 for i in xrange(N): l = 0 if (i, j) in lookup else l+1 dp[i][j] = min(dp[i][j], l) l = 0 for i in reversed(xrange(N)): l = 0 if (i, j) in lookup else l+1 dp[i][j] = min(dp[i][j], l) result = max(result, dp[i][j]) return result ", "class Solution def minimumCost(self, N, connections): connections.sort(key = lambda x: x[2]) union_find = UnionFind(N) result = 0 for u, v, val in connections: if union_find.union_set(u-1, v-1): result += val return result if union_find.count == 1 else -1 ", "class Solution def groupStrings(self, strings): groups = collections.defaultdict(list) for s in strings: groups[self.hashStr(s)].append(s) result = [] for key, val in groups.iteritems(): result.append(sorted(val)) return result def hashStr(self, s): base = ord(s[0]) hashcode = \"\" for i in xrange(len(s)): if ord(s[i]) - base >= 0: hashcode += unichr(ord('a') + ord(s[i]) - base) else: hashcode += unichr(ord('a') + ord(s[i]) - base + 26) return hashcode ", "class Solution def allPathsSourceTarget(self, graph): def dfs(graph, curr, path, result): if curr == len(graph)-1: result.append(path[:]) return for node in graph[curr]: path.append(node) dfs(graph, node, path, result) path.pop() result = [] dfs(graph, 0, [0], result) return result ", "class Solution def numberOfArrays(self, differences, lower, upper): total = mn = mx = 0 for x in differences: total += x mn = min(mn, total) mx = max(mx, total) return max((upper-lower)-(mx-mn)+1, 0) ", "class Solution def findDiagonalOrder(self, nums): result, dq, col = [], collections.deque(), 0 for i in xrange(len(nums)+max(itertools.imap(len, nums))-1): new_dq = collections.deque() if i < len(nums): dq.appendleft((i, 0)) for r, c in dq: result.append(nums[r][c]) if c+1 < len(nums[r]): new_dq.append((r, c+1)) dq = new_dq return result ", "class Solution def findDiagonalOrder(self, nums): result = [] for r, row in enumerate(nums): for c, num in enumerate(row): if len(result) <= r+c: result.append([]) result[r+c].append(num) return [num for row in result for num in reversed(row)] ", "class Solution def countSubarrays(self, nums, k): result = total = left = 0 for right in xrange(len(nums)): total += nums[right] while total*(right-left+1) >= k: total -= nums[left] left += 1 result += right-left+1 return result ", "class Solution def closestMeetingNode(self, edges, node1, node2): def dfs(node): lookup = {} i = 0 while node != -1: if node in lookup: break lookup[node] = i i += 1 node = edges[node] return lookup lookup1, lookup2 = dfs(node1), dfs(node2) intersect = set(lookup1.iterkeys())&set(lookup2.iterkeys()) return min(intersect, key=lambda x: (max(lookup1[x], lookup2[x]), x)) if intersect else -1 ", "class Solution def kthSmallest(self, root, k): s, cur, rank = [], root, 0 while s or cur: if cur: s.append(cur) cur = cur.left else: cur = s.pop() rank += 1 if rank == k: return cur.val cur = cur.right return float(\"-inf\") from itertools import islice ", "class Solution def kthSmallest(self, root, k): def gen_inorder(root): if root: for n in gen_inorder(root.left): yield n yield root.val for n in gen_inorder(root.right): yield n return next(islice(gen_inorder(root), k-1, k)) ", "class Solution def wordCount(self, startWords, targetWords): def bitmask(w): return reduce(lambda x, y: x|y, (1 << (ord(c)-ord('a')) for i, c in enumerate(w))) lookup = set(bitmask(w) for w in startWords) result = 0 for w in targetWords: mask = bitmask(w) result += any(mask ^ (1 << ord(c)-ord('a')) in lookup for c in w) return result ", "class Solution def numberOfPairs(self, nums1, nums2, k): cnt = [0]*(max(nums1)+1) for x, c in collections.Counter(k*x for x in nums2).iteritems(): for i in xrange(1, (len(cnt)-1)//x+1): cnt[i*x] += c return sum(cnt[x] for x in nums1) ", "class Solution def dietPlanPerformance(self, calories, k, lower, upper): total = sum(itertools.islice(calories, 0, k)) result = int(total > upper)-int(total < lower) for i in xrange(k, len(calories)): total += calories[i]-calories[i-k] result += int(total > upper)-int(total < lower) return result ", "class Solution def findNumber(self): BIT_COUNT = 30 result = 0 prev = commonBits(0) for i in xrange(BIT_COUNT): curr = commonBits(1<<i) if curr-prev == 1: result |= 1<<i prev = curr return result ", "class Solution def findNumber(self): BIT_COUNT = 30 return reduce(lambda accu, i: accu|(1<<i if commonBits(1<<i)-commonBits(1<<i) == 1 else 0), xrange(BIT_COUNT), 0) ", "class Solution def divisorGame(self, N): return N % 2 == 0 ", "class Solution def divisorGame(self, N): def memoization(N, dp): if N == 1: return False if N not in dp: result = False for i in xrange(1, N+1): if i*i > N: break if N % i == 0: if not memoization(N-i, dp): result = True break dp[N] = result return dp[N] return memoization(N, {}) ", "class Solution def containsCycle(self, grid): def index(n, i, j): return i*n + j union_find = UnionFind(len(grid)*len(grid[0])) for i in xrange(len(grid)): for j in xrange(len(grid[0])): if i and j and grid[i][j] == grid[i-1][j] == grid[i][j-1] and union_find.find_set(index(len(grid[0]), i-1, j)) == union_find.find_set(index(len(grid[0]), i, j-1)): return True if i and grid[i][j] == grid[i-1][j]: union_find.union_set(index(len(grid[0]), i-1, j), index(len(grid[0]),i, j)) if j and grid[i][j] == grid[i][j-1]: union_find.union_set(index(len(grid[0]), i, j-1), index(len(grid[0]), i, j)) return False ", "class Solution def containsCycle(self, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for i in xrange(len(grid)): for j in xrange(len(grid[0])): if not grid[i][j]: continue val = grid[i][j] q = [(i, j)] while q: new_q = [] for r, c in q: if not grid[r][c]: return True grid[r][c] = 0 for dr, dc in directions: nr, nc = r+dr, c+dc if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == val): continue new_q.append((nr, nc)) q = new_q return False ", "class Solution def detectCapitalUse(self, word): return word.isupper() or word.islower() or word.istitle() ", "class Solution def canDivideIntoSubsequences(self, nums, K): curr, max_count = 1, 1 for i in xrange(1, len(nums)): curr = 1 if nums[i-1] < nums[i] else curr+1 max_count = max(max_count, curr) return K*max_count <= len(nums) ", "class Solution def findMatrix(self, nums): result = [] cnt = collections.Counter() for x in nums: if cnt[x] == len(result): result.append([]) result[cnt[x]].append(x) cnt[x] += 1 return result import collections ", "class Solution def findMatrix(self, nums): result = [] cnt = collections.Counter(nums) while cnt: result.append(cnt.keys()) cnt = {k:v-1 for k, v in cnt.iteritems() if v-1} return result ", "class Solution def longestPalindrome(self, s): odds = 0 for k, v in collections.Counter(s).iteritems(): odds += v & 1 return len(s) - odds + int(odds > 0) def longestPalindrome2(self, s): odd = sum(map(lambda x: x & 1, collections.Counter(s).values())) return len(s) - odd + int(odd > 0) ", "class Solution def checkIfExist(self, arr): lookup = set() for x in arr: if 2*x in lookup or (x%2 == 0 and x//2 in lookup): return True lookup.add(x) return False ", "class Solution def generateTheString(self, n): result = ['a']*(n-1) result.append('a' if n%2 else 'b') return \"\".join(result) ", "class Solution def isPossibleDivide(self, nums, k): count = collections.Counter(nums) for num in sorted(count.keys()): c = count[num] if not c: continue for i in xrange(num, num+k): if count[i] < c: return False count[i] -= c return True ", "class Solution def kthLargestNumber(self, nums, k): def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 nth_element(nums, k-1, compare=lambda a, b: a > b if len(a) == len(b) else len(a) > len(b)) return nums[k-1] ", "class Solution def nearestPalindromic(self, n): l = len(n) candidates = set((str(10**l + 1), str(10**(l - 1) - 1))) prefix = int(n[:(l + 1)/2]) for i in map(str, (prefix-1, prefix, prefix+1)): candidates.add(i + [i, i[:-1]][l%2][::-1]) candidates.discard(n) return min(candidates, key=lambda x: (abs(int(x) - int(n)), int(x))) ", "class Solution def addRungs(self, rungs, dist): def ceil_divide(a, b): return (a+(b-1))//b result = prev = 0 for curr in rungs: result += ceil_divide(curr-prev, dist)-1 prev = curr return result ", "class Solution def beautifulSubarrays(self, nums): cnt = collections.Counter() cnt[0] = 1 result = curr = 0 for x in nums: curr ^= x result += cnt[curr] cnt[curr] += 1 return result ", "class Solution def checkPowersOfThree(self, n): while n > 0: if n%3 == 2: return False n //= 3 return True ", "class Solution def findJudge(self, N, trust): degrees = [0]*N for i, j in trust: degrees[i-1] -= 1 degrees[j-1] += 1 for i in xrange(len(degrees)): if degrees[i] == N-1: return i+1 return -1 ", "class Solution def addOneRow(self, root, v, d): if d in (0, 1): node = TreeNode(v) if d == 1: node.left = root else: node.right = root return node if root and d >= 2: root.left = self.addOneRow(root.left, v, d-1 if d > 2 else 1) root.right = self.addOneRow(root.right, v, d-1 if d > 2 else 0) return root ", "class Solution def getMoneyAmount(self, n): dp = [[0]*(n+1) for _ in xrange(n+1)] for j in xrange(n+1): for i in reversed(xrange(j-1)): dp[i][j] = min((k+1) + max(dp[i][k], dp[k+1][j]) for k in xrange(i, j)) return dp[0][n] ", "class Solution def getMoneyAmount(self, n): dp = [[0]*(n+1) for _ in xrange(n+1)] for i in reversed(xrange(n)): for j in xrange(i+2, n+1): dp[i][j] = min((k+1) + max(dp[i][k], dp[k+1][j]) for k in xrange(i, j)) return dp[0][n] ", "class Solution def pivotInteger(self, n): x = int(((n+1)*n//2)**0.5+0.5) return x if x**2 == (n+1)*n//2 else -1 ", "class Solution def distributeCandies(self, candies, num_people): p = int((2*candies + 0.25)**0.5 - 0.5) remaining = candies - (p+1)*p//2 rows, cols = divmod(p, num_people) result = [0]*num_people for i in xrange(num_people): result[i] = (i+1)*(rows+1) + (rows*(rows+1)//2)*num_people if i < cols else (i+1)*rows + ((rows-1)*rows//2)*num_people result[cols] += remaining return result ", "class Solution def distributeCandies(self, candies, num_people): left, right = 1, candies while left <= right: mid = left + (right-left)//2 if not ((mid <= candies*2 // (mid+1))): right = mid-1 else: left = mid+1 p = right remaining = candies - (p+1)*p//2 rows, cols = divmod(p, num_people) result = [0]*num_people for i in xrange(num_people): result[i] = (i+1)*(rows+1) + (rows*(rows+1)//2)*num_people if i < cols else (i+1)*rows + ((rows-1)*rows//2)*num_people result[cols] += remaining return result ", "class Solution def distributeCandies(self, candies, num_people): result = [0]*num_people i = 0 while candies != 0: result[i % num_people] += min(candies, i+1) candies -= min(candies, i+1) i += 1 return result ", "class Solution def maximumSumOfHeights(self, maxHeights): left = [0]*len(maxHeights) stk = [-1] curr = 0 for i in xrange(len(maxHeights)): while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]: j = stk.pop() curr -= (j-stk[-1])*maxHeights[j] curr += (i-stk[-1])*maxHeights[i] stk.append(i) left[i] = curr stk = [len(maxHeights)] result = right = curr = 0 for i in reversed(xrange(len(maxHeights))): while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]: j = stk.pop() curr -= (stk[-1]-j)*maxHeights[j] curr += (stk[-1]-i)*maxHeights[i] stk.append(i) right = curr result = max(result, left[i]+right-maxHeights[i]) return result ", "class Solution def memLeak(self, memory1, memory2): def s(a, d, n): return (2*a + (n-1)*d)*n//2 def f(a, d, x): r = int((-(2*a-d)+((2*a-d)**2+8*d*x)**0.5)/(2*d)) if s(a, d, r) > x: r -= 1 return r is_swapped = False if memory1 < memory2: memory1, memory2 = memory2, memory1 is_swapped = True n = f(1, 1, memory1-memory2) memory1 -= s(1, 1, n) if memory1 == memory2: is_swapped = False l = f(n+1, 2, memory1) r = f(n+2, 2, memory2) memory1 -= s(n+1, 2, l) memory2 -= s(n+2, 2, r) if is_swapped: memory1, memory2 = memory2, memory1 return [n+l+r+1, memory1, memory2] ", "class Solution def maxNumOfMarkedIndices(self, nums): nums.sort() left = 0 for right in xrange((len(nums)+1)//2, len(nums)): if nums[right] >= 2*nums[left]: left += 1 return left*2 ", "class Solution def maxNumOfMarkedIndices(self, nums): nums.sort() left = 0 for right in xrange(len(nums)): if nums[right] >= 2*nums[left]: left += 1 return min(left, len(nums)//2)*2 ", "class Solution def countTriplets(self, arr): count_sum = collections.defaultdict(lambda: [0, 0]) count_sum[0] = [1, 0] result, prefix = 0, 0 for i, x in enumerate(arr): prefix ^= x c, t = count_sum[prefix] result += c*i - t count_sum[prefix] = [c+1, t+i+1] return result ", "class Solution def loudAndRich(self, richer, quiet): def dfs(graph, quiet, node, result): if result[node] is None: result[node] = node for nei in graph[node]: smallest_person = dfs(graph, quiet, nei, result) if quiet[smallest_person] < quiet[result[node]]: result[node] = smallest_person return result[node] graph = [[] for _ in xrange(len(quiet))] for u, v in richer: graph[v].append(u) result = [None]*len(quiet) return map(lambda x: dfs(graph, quiet, x, result), xrange(len(quiet))) ", "class Solution def createSortedArray(self, instructions): MOD = 10**9 + 7 bit = BIT(max(instructions)) result = 0 for i, inst in enumerate(instructions): inst -= 1 result += min(bit.query(inst-1), i-bit.query(inst)) bit.add(inst, 1) return result % MOD import itertools class Solution_TLE(object): def createSortedArray(self, instructions): MOD = 10**9 + 7 def smallerMergeSort(idxs, start, end, counts): if end - start <= 0: return 0 mid = start + (end - start) // 2 smallerMergeSort(idxs, start, mid, counts) smallerMergeSort(idxs, mid + 1, end, counts) r = start tmp = [] for i in xrange(mid+1, end + 1): while r <= mid and idxs[r][0] < idxs[i][0]: tmp.append(idxs[r]) r += 1 tmp.append(idxs[i]) counts[idxs[i][1]] += r - start while r <= mid: tmp.append(idxs[r]) r += 1 idxs[start:start+len(tmp)] = tmp def largerMergeSort(idxs, start, end, counts): if end - start <= 0: return 0 mid = start + (end - start) // 2 largerMergeSort(idxs, start, mid, counts) largerMergeSort(idxs, mid + 1, end, counts) r = start tmp = [] for i in xrange(mid+1, end + 1): while r <= mid and idxs[r][0] <= idxs[i][0]: tmp.append(idxs[r]) r += 1 if r <= mid: tmp.append(idxs[i]) counts[idxs[i][1]] += mid - r + 1 while r <= mid: tmp.append(idxs[r]) r += 1 idxs[start:start+len(tmp)] = tmp idxs = [] smaller_counts, larger_counts = [[0] * len(instructions) for _ in xrange(2)] for i, inst in enumerate(instructions): idxs.append((inst, i)) smallerMergeSort(idxs[:], 0, len(idxs)-1, smaller_counts) largerMergeSort(idxs, 0, len(idxs)-1, larger_counts) return sum(min(s, l) for s, l in itertools.izip(smaller_counts, larger_counts)) % MOD ", "class Solution def isValidSequence(self, root, arr): q = [root] for depth in xrange(len(arr)): new_q = [] while q: node = q.pop() if not node or node.val != arr[depth]: continue if depth+1 == len(arr) and node.left == node.right: return True new_q.extend(child for child in (node.left, node.right)) q = new_q return False ", "class Solution def isValidSequence(self, root, arr): s = [(root, 0)] while s: node, depth = s.pop() if not node or depth == len(arr) or node.val != arr[depth]: continue if depth+1 == len(arr) and node.left == node.right: return True s.append((node.right, depth+1)) s.append((node.left, depth+1)) return False ", "class Solution def isValidSequence(self, root, arr): def dfs(node, arr, depth): if not node or depth == len(arr) or node.val != arr[depth]: return False if depth+1 == len(arr) and node.left == node.right: return True return dfs(node.left, arr, depth+1) or dfs(node.right, arr, depth+1) return dfs(root, arr, 0) ", "class Solution def arraysIntersection(self, arr1, arr2, arr3): result = [] i, j, k = 0, 0, 0 while i != len(arr1) and j != len(arr2) and k != len(arr3): if arr1[i] == arr2[j] == arr3[k]: result.append(arr1[i]) i += 1 j += 1 k += 1 else: curr = max(arr1[i], arr2[j], arr3[k]) while i != len(arr1) and arr1[i] < curr: i += 1 while j != len(arr2) and arr2[j] < curr: j += 1 while k != len(arr3) and arr3[k] < curr: k += 1 return result ", "class Solution def arraysIntersection(self, arr1, arr2, arr3): intersect = reduce(set.intersection, map(set, [arr2, arr3])) return [x for x in arr1 if x in intersect] ", "class Solution def maxKilledEnemies(self, grid): result = 0 if not grid or not grid[0]: return result down = [[0 for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))] right = [[0 for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))] for i in reversed(xrange(len(grid))): for j in reversed(xrange(len(grid[0]))): if grid[i][j] != 'W': if i + 1 < len(grid): down[i][j] = down[i + 1][j] if j + 1 < len(grid[0]): right[i][j] = right[i][j + 1] if grid[i][j] == 'E': down[i][j] += 1 right[i][j] += 1 up = [0 for _ in xrange(len(grid[0]))] for i in xrange(len(grid)): left = 0 for j in xrange(len(grid[0])): if grid[i][j] == 'W': up[j], left = 0, 0 elif grid[i][j] == 'E': up[j] += 1 left += 1 else: result = max(result, left + up[j] + right[i][j] + down[i][j]) return result ", "class Solution def checkIfPangram(self, sentence): return len(set(sentence)) == 26 ", "class Solution def countCharacters(self, words, chars): def check(word, chars, count): if len(word) > len(chars): return False curr_count = collections.Counter() for c in word: curr_count[c] += 1 if c not in count or count[c] < curr_count[c]: return False return True count = collections.Counter(chars) return sum(len(word) for word in words if check(word, chars, count)) ", "class Solution def furthestBuilding(self, heights, bricks, ladders): min_heap = [] for i in xrange(len(heights)-1): diff = heights[i+1]-heights[i] if diff > 0: heapq.heappush(min_heap, diff) if len(min_heap) <= ladders: continue bricks -= heapq.heappop(min_heap) if bricks < 0: return i return len(heights)-1 ", "class Solution def minDeletionSize(self, A): dp = [1] * len(A[0]) for j in xrange(1, len(A[0])): for i in xrange(j): if all(A[k][i] <= A[k][j] for k in xrange(len(A))): dp[j] = max(dp[j], dp[i]+1) return len(A[0]) - max(dp) ", "class Solution def countTexts(self, pressedKeys): MOD = 10**9+7 dp = [1]*5 for i in xrange(1, len(pressedKeys)+1): dp[i%5] = 0 for j in reversed(xrange(max(i-(4 if pressedKeys[i-1] in \"79\" else 3), 0), i)): if pressedKeys[j] != pressedKeys[i-1]: break dp[i%5] = (dp[i%5]+dp[j%5])%MOD return dp[len(pressedKeys)%5] ", "class Solution def findMissingAndRepeatedValues(self, grid): n = len(grid) a_xor_b = 0 for i in xrange(n**2): r, c = divmod(i, n) a_xor_b ^= grid[r][c]^(i+1) base = a_xor_b&-a_xor_b result = [0]*2 for i in xrange(n**2): r, c = divmod(i, len(grid[0])) result[1 if (i+1)&base != 0 else 0] ^= i+1 result[1 if grid[r][c]&base != 0 else 0] ^= grid[r][c] if any(x == result[1] for row in grid for x in row): result[0], result[1] = result[1], result[0] return result import collections ", "class Solution def findMissingAndRepeatedValues(self, grid): cnt = collections.Counter(x for row in grid for x in row) return [next(k for k, v in cnt.iteritems() if v == 2), next(x for x in xrange(1, len(grid)**2+1) if x not in cnt)] ", "class Solution def missingRolls(self, rolls, mean, n): MAX_V = 6 MIN_V = 1 total = sum(rolls) missing = mean*(n+len(rolls))-total if missing < MIN_V*n or missing > MAX_V*n: return [] q, r = divmod(missing, n) return [q+int(i < r) for i in xrange(n)] ", "class Solution def missingRolls(self, rolls, mean, n): MAX_V = 6 MIN_V = 1 total = sum(rolls) missing = mean*(n+len(rolls))-total if missing < MIN_V*n or missing > MAX_V*n: return [] q, r = divmod(missing-MIN_V*n, (MAX_V-MIN_V)) return [MAX_V if i < q else MIN_V+r if i == q else MIN_V for i in xrange(n)] ", "class Solution def countPrefixes(self, words, s): return sum(itertools.imap(s.startswith, words)) ", "class Solution def leftmostBuildingQueries(self, heights, queries): class SegmentTree(object): def __init__(self, N, build_fn=lambda _: None, query_fn=lambda x, y: max(x, y)): self.tree = [None]*(2*2**((N-1).bit_length())) self.build_fn = build_fn self.query_fn = query_fn self.build(0, N-1, 1) def build(self, left, right, idx): if left == right: self.tree[idx] = self.build_fn(left) return mid = left + (right-left)//2 self.build(left, mid, idx*2) self.build(mid+1, right, idx*2+1) self.tree[idx] = self.query_fn(self.tree[idx*2], self.tree[idx*2+1]) def binary_search(self, L, R, left, right, idx, h): if right < L or left > R: return -1 if L <= left and right <= R: if not self.tree[idx] > h: return -1 if left == right: return left mid = left + (right-left)//2 i = self.binary_search(L, R, left, mid, idx*2, h) return i if i != -1 else self.binary_search(L, R, mid+1, right, idx*2+1, h) def build(i): return heights[i] result = [-1]*len(queries) st = SegmentTree(len(heights), build_fn=build) for i, (a, b) in enumerate(queries): if a > b: a, b = b, a if a == b or heights[a] < heights[b]: result[i] = b continue result[i] = st.binary_search(b+1, len(heights)-1, 0, len(heights)-1, 1, heights[a]) return result import heapq ", "class Solution def leftmostBuildingQueries(self, heights, queries): result = [-1]*len(queries) qs = [[] for _ in xrange(len(heights))] for i, (a, b) in enumerate(queries): if a > b: a, b = b, a if a == b or heights[a] < heights[b]: result[i] = b else: qs[b].append((heights[a], i)) min_heap = [] for i, h in enumerate(heights): for q in qs[i]: heapq.heappush(min_heap, q) while min_heap and min_heap[0][0] < h: _, j = heapq.heappop(min_heap) result[j] = i return result ", "class Solution def leftmostBuildingQueries(self, heights, queries): def binary_search_right(left, right, check): while left <= right: mid = left + (right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right result = [-1]*len(queries) qs = [[] for _ in xrange(len(heights))] for i, (a, b) in enumerate(queries): if a > b: a, b = b, a if a == b or heights[a] < heights[b]: result[i] = b else: qs[b].append((heights[a], i)) stk = [] for b in reversed(xrange(len(heights))): while stk and stk[-1][0] <= heights[b]: stk.pop() stk.append((heights[b], b)) for ha, i in qs[b]: j = binary_search_right(0, len(stk)-1, lambda x: stk[x][0] > ha) if j >= 0: result[i] = stk[j][1] return result ", "class Solution def largestAltitude(self, gain): result = curr = 0 for g in gain: curr += g result = max(result, curr) return result ", "class Solution def divideArray(self, nums, k): nums.sort() return [nums[i:i+3] for i in xrange(0, len(nums), 3)] if all(nums[i+2]-nums[i] <= k for i in xrange(0, len(nums), 3)) else [] ", "class Solution def findPeaks(self, mountain): return [i for i in xrange(1, len(mountain)-1) if mountain[i-1] < mountain[i] > mountain[i+1]] ", "class Solution def cheapestJump(self, A, B): result = [] if not A or A[-1] == -1: return result n = len(A) dp, next_pos = [float(\"inf\")] * n, [-1] * n dp[n-1] = A[n-1] for i in reversed(xrange(n-1)): if A[i] == -1: continue for j in xrange(i+1, min(i+B+1,n)): if A[i] + dp[j] < dp[i]: dp[i] = A[i] + dp[j] next_pos[i] = j if dp[0] == float(\"inf\"): return result k = 0 while k != -1: result.append(k+1) k = next_pos[k] return result ", "class Solution def isSymmetric(self, root): if root is None: return True stack = [] stack.append(root.left) stack.append(root.right) while stack: p, q = stack.pop(), stack.pop() if p is None and q is None: continue if p is None or q is None or p.val != q.val: return False stack.append(p.left) stack.append(q.right) stack.append(p.right) stack.append(q.left) return True ", "class Solution def isSymmetric(self, root): if root is None: return True return self.isSymmetricRecu(root.left, root.right) def isSymmetricRecu(self, left, right): if left is None and right is None: return True if left is None or right is None or left.val != right.val: return False return self.isSymmetricRecu(left.left, right.right) and self.isSymmetricRecu(left.right, right.left) ", "class Solution def isScramble(self, s1, s2): if not s1 or not s2 or len(s1) != len(s2): return False if s1 == s2: return True result = [[[False for j in xrange(len(s2))] for i in xrange(len(s1))] for n in xrange(len(s1) + 1)] for i in xrange(len(s1)): for j in xrange(len(s2)): if s1[i] == s2[j]: result[1][i][j] = True for n in xrange(2, len(s1) + 1): for i in xrange(len(s1) - n + 1): for j in xrange(len(s2) - n + 1): for k in xrange(1, n): if result[k][i][j] and result[n - k][i + k][j + k] or result[k][i][j + n - k] and result[n - k][i + k][j]: result[n][i][j] = True break return result[n][0][0] ", "class Solution def pseudoPalindromicPaths (self, root): result = 0 stk = [(root, 0)] while stk: node, count = stk.pop() if not node: continue count ^= 1 << (node.val-1) result += int(node.left == node.right and count&(count-1) == 0) stk.append((node.right, count)) stk.append((node.left, count)) return result ", "class Solution def pseudoPalindromicPaths (self, root): def dfs(node, count): if not root: return 0 count ^= 1 << (node.val-1) return int(node.left == node.right and count&(count-1) == 0) + dfs(node.left, count) + dfs(node.right, count) return dfs(root, 0) ", "class Solution def relocateMarbles(self, nums, moveFrom, moveTo): lookup = set(nums) for a, b in itertools.izip(moveFrom, moveTo): lookup.remove(a) lookup.add(b) return sorted(lookup) ", "class Solution def numSub(self, s): MOD = 10**9+7 result, count = 0, 0 for c in s: count = count+1 if c == '1' else 0 result = (result+count)%MOD return result ", "class Solution def minimumPerimeter(self, neededApples): a, b, c, d = 4.0, 6.0, 2.0, float(-neededApples) p = (3*a*c-b**2)/(3*a**2) q = (2*b**3-9*a*b*c+27*a**2*d)/(27*a**3) assert((q/2)**2+(p/3)**3 > 0) x = (-q/2 + ((q/2)**2+(p/3)**3)**0.5)**(1.0/3) + (-q/2 - ((q/2)**2+(p/3)**3)**0.5)**(1.0/3) return 8*int(math.ceil(x - b/(3*a))) ", "class Solution def minimumPerimeter(self, neededApples): x = int((2*neededApples)**(1.0/3)) x -= x%2 assert((x-2)*(x-1)*x < 2*neededApples < (x+2)**3) x += 2 if (x-2)*(x-1)*x < 2*neededApples: x += 2 return 8*(x-2)//2 ", "class Solution def minimumPerimeter(self, neededApples): def check(neededApples, x): return r*(2*r+1)*(2*r+2) >= neededApples left, right = 1, int((neededApples/4.0)**(1.0/3)) while left <= right: mid = left + (right-left)//2 if check(neededApples, mid): right = mid-1 else: left = mid+1 return 8*left ", "class Solution def rangeSumBST(self, root, L, R): result = 0 s = [root] while s: node = s.pop() if node: if L <= node.val <= R: result += node.val if L < node.val: s.append(node.left) if node.val < R: s.append(node.right) return result ", "class Solution def search(self, nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) / 2 if nums[mid] == target: return True elif nums[mid] == nums[left]: left += 1 elif (nums[mid] > nums[left] and nums[left] <= target < nums[mid]) or (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])): right = mid - 1 else: left = mid + 1 return False ", "class Solution def nextPalindrome(self, num): def next_permutation(nums, begin, end): def reverse(nums, begin, end): left, right = begin, end-1 while left < right: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1 k, l = begin-1, begin for i in reversed(xrange(begin, end-1)): if nums[i] < nums[i+1]: k = i break else: reverse(nums, begin, end) return False for i in reversed(xrange(k+1, end)): if nums[i] > nums[k]: l = i break nums[k], nums[l] = nums[l], nums[k] reverse(nums, k+1, end) return True nums = list(num) if not next_permutation(nums, 0, len(nums)//2): return \"\" for i in xrange(len(nums)//2): nums[-1-i] = nums[i] return \"\".join(nums) ", "class Solution def findBestValue(self, arr, target): arr.sort(reverse=True) max_arr = arr[0] while arr and arr[-1]*len(arr) <= target: target -= arr.pop() return max_arr if not arr else (2*target+len(arr)-1)//(2*len(arr)) ", "class Solution def findBestValue(self, arr, target): arr.sort(reverse=True) max_arr = arr[0] while arr and arr[-1]*len(arr) <= target: target -= arr.pop() if not arr: return max_arr x = (target-1)//len(arr) return x if target-x*len(arr) <= (x+1)*len(arr)-target else x+1 ", "class Solution def findBestValue(self, arr, target): def total(arr, v): result = 0 for x in arr: result += min(v, x) return result def check(arr, v, target): return total(arr, v) >= target left, right = 1, max(arr) while left <= right: mid = left + (right-left)//2 if check(arr, mid, target): right = mid-1 else: left = mid+1 return left-1 if target-total(arr, left-1) <= total(arr, left)-target else left ", "class Solution def waysToMakeFair(self, nums): prefix = [0]*2 suffix = [sum(nums[i] for i in xrange(k, len(nums), 2)) for k in xrange(2)] result = 0 for i, num in enumerate(nums): suffix[i%2] -= num result += int(prefix[0]+suffix[1] == prefix[1]+suffix[0]) prefix[i%2] += num return result ", "class Solution def reorderedPowerOf2(self, N): count = collections.Counter(str(N)) return any(count == collections.Counter(str(1 << i)) for i in xrange(31)) ", "class Solution def convert(self, s, numRows): if numRows == 1: return s step, zigzag = 2 * numRows - 2, \"\" for i in xrange(numRows): for j in xrange(i, len(s), step): zigzag += s[j] if 0 < i < numRows - 1 and j + step - 2 * i < len(s): zigzag += s[j + step - 2 * i] return zigzag ", "class Solution def kIncreasing(self, arr, k): def longest_non_decreasing_subsequence(arr): result = [] for x in arr: right = bisect.bisect_right(result, x) if right == len(result): result.append(x) else: result[right] = x return len(result) return len(arr) - sum(longest_non_decreasing_subsequence((arr[j] for j in xrange(i, len(arr), k))) for i in xrange(k)) ", "class Solution def sumEvenAfterQueries(self, A, queries): total = sum(v for v in A if v % 2 == 0) result = [] for v, i in queries: if A[i] % 2 == 0: total -= A[i] A[i] += v if A[i] % 2 == 0: total += A[i] result.append(total) return result ", "class Solution def maxStudents(self, seats): directions = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1)] E, count = collections.defaultdict(list), 0 for i in xrange(len(seats)): for j in xrange(len(seats[0])): if seats[i][j] != '.': continue count += 1 if j%2: continue for dx, dy in directions: ni, nj = i+dx, j+dy if 0 <= ni < len(seats) and 0 <= nj < len(seats[0]) and seats[ni][nj] == '.': E[i*len(seats[0])+j].append(ni*len(seats[0])+nj) return count-len(bipartiteMatch(E)[0]) ", "class Solution def maxStudents(self, seats): directions = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1)] def dfs(seats, e, lookup, matching): i, j = e for dx, dy in directions: ni, nj = i+dx, j+dy if 0 <= ni < len(seats) and 0 <= nj < len(seats[0]) and seats[ni][nj] == '.' and not lookup[ni][nj]: lookup[ni][nj] = True if matching[ni][nj] == -1 or dfs(seats, matching[ni][nj], lookup, matching): matching[ni][nj] = e return True return False def Hungarian(seats): result = 0 matching = [[-1]*len(seats[0]) for _ in xrange(len(seats))] for i in xrange(len(seats)): for j in xrange(0, len(seats[0]), 2): if seats[i][j] != '.': continue lookup = [[False]*len(seats[0]) for _ in xrange(len(seats))] if dfs(seats, (i, j), lookup, matching): result += 1 return result count = 0 for i in xrange(len(seats)): for j in xrange(len(seats[0])): if seats[i][j] == '.': count += 1 return count-Hungarian(seats) ", "class Solution def maxStudents(self, seats): def popcount(n): result = 0 while n: n &= n - 1 result += 1 return result dp = {0: 0} for row in seats: invalid_mask = sum(1 << c for c, v in enumerate(row) if v == '#') new_dp = {} for mask1, v1 in dp.iteritems(): for mask2 in xrange(1 << len(seats[0])): if (mask2 & invalid_mask) or (mask2 & (mask1 << 1)) or (mask2 & (mask1 >> 1)) or (mask2 & (mask2 << 1)) or (mask2 & (mask2 >> 1)): continue new_dp[mask2] = max(new_dp.get(mask2, 0), v1+popcount(mask2)) dp = new_dp return max(dp.itervalues()) if dp else 0 ", "class Solution def __init__(self, rects): self.__rects = list(rects) self.__prefix_sum = map(lambda x : (x[2]-x[0]+1)*(x[3]-x[1]+1), rects) for i in xrange(1, len(self.__prefix_sum)): self.__prefix_sum[i] += self.__prefix_sum[i-1] def pick(self): target = random.randint(0, self.__prefix_sum[-1]-1) left = bisect.bisect_right(self.__prefix_sum, target) rect = self.__rects[left] width, height = rect[2]-rect[0]+1, rect[3]-rect[1]+1 base = self.__prefix_sum[left]-width*height return [rect[0]+(target-base)%width, rect[1]+(target-base)//width] ", "class Solution def maxScoreWords(self, words, letters, score): def backtracking(words, word_scores, word_counts, curr, curr_score, letter_count, result): result[0] = max(result[0], curr_score) for i in xrange(curr, len(words)): if any(letter_count[c] < word_counts[i][c] for c in word_counts[i]): continue backtracking(words, word_scores, word_counts, i+1, curr_score+word_scores[i], letter_count-word_counts[i], result) letter_count = collections.Counter(letters) word_counts = map(collections.Counter, words) word_scores = [sum(score[ord(c)-ord('a')] for c in words[i]) for i in xrange(len(words))] result = [0] backtracking(words, word_scores, word_counts, 0, 0, letter_count, result) return result[0] ", "class Solution def minDifficulty(self, jobDifficulty, d): if len(jobDifficulty) < d: return -1; dp = [[float(\"inf\")]*len(jobDifficulty) for _ in xrange(d)] dp[0][0] = jobDifficulty[0] for i in xrange(1, len(jobDifficulty)): dp[0][i] = max(dp[0][i-1], jobDifficulty[i]) for i in xrange(1, d): for j in xrange(i, len(jobDifficulty)): curr_max = jobDifficulty[j] for k in reversed(xrange(i, j+1)): curr_max = max(curr_max, jobDifficulty[k]) dp[i][j] = min(dp[i][j], dp[i-1][k-1] + curr_max) return dp[d-1][len(jobDifficulty)-1] ", "class Solution def sortTransformedArray(self, nums, a, b, c): f = lambda x, a, b, c : a * x * x + b * x + c result = [] if not nums: return result left, right = 0, len(nums) - 1 d = -1 if a > 0 else 1 while left <= right: if d * f(nums[left], a, b, c) < d * f(nums[right], a, b, c): result.append(f(nums[left], a, b, c)) left += 1 else: result.append(f(nums[right], a, b, c)) right -= 1 return result[::d] ", "class Solution def shortestPathAllKeys(self, grid): directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] def bfs(grid, source, locations): r, c = locations[source] lookup = [[False]*(len(grid[0])) for _ in xrange(len(grid))] lookup[r][c] = True q = collections.deque([(r, c, 0)]) dist = {} while q: r, c, d = q.popleft() if source != grid[r][c] != '.': dist[grid[r][c]] = d continue for direction in directions: cr, cc = r+direction[0], c+direction[1] if not ((0 <= cr < len(grid)) and (0 <= cc < len(grid[cr]))): continue if grid[cr][cc] != '#' and not lookup[cr][cc]: lookup[cr][cc] = True q.append((cr, cc, d+1)) return dist locations = {place: (r, c) for r, row in enumerate(grid) for c, place in enumerate(row) if place not in '.#'} dists = {place: bfs(grid, place, locations) for place in locations} min_heap = [(0, '@', 0)] best = collections.defaultdict(lambda: collections.defaultdict( lambda: float(\"inf\"))) best['@'][0] = 0 target_state = 2**sum(place.islower() for place in locations)-1 while min_heap: cur_d, place, state = heapq.heappop(min_heap) if best[place][state] < cur_d: continue if state == target_state: return cur_d for dest, d in dists[place].iteritems(): next_state = state if dest.islower(): next_state |= (1 << (ord(dest)-ord('a'))) elif dest.isupper(): if not (state & (1 << (ord(dest)-ord('A')))): continue if cur_d+d < best[dest][next_state]: best[dest][next_state] = cur_d+d heapq.heappush(min_heap, (cur_d+d, dest, next_state)) return -1 ", "class Solution def networkBecomesIdle(self, edges, patience): adj = [[] for _ in xrange(len(patience))] for u, v in edges: adj[u].append(v) adj[v].append(u) q = [0] lookup = [False]*len(patience) lookup[0] = True step = 1 result = 0 while q: new_q = [] for u in q: for v in adj[u]: if lookup[v]: continue lookup[v] = True new_q.append(v) result = max(result, ((step*2)-1)//patience[v]*patience[v] + (step*2)) q = new_q step += 1 return 1+result ", "class Solution def removeNthFromEnd(self, head, n): dummy = ListNode(-1) dummy.next = head slow, fast = dummy, dummy for i in xrange(n): fast = fast.next while fast.next: slow, fast = slow.next, fast.next slow.next = slow.next.next return dummy.next ", "class Solution def maxSumAfterOperation(self, nums): prev_with_square = prev_without_square = 0 result = 0 for num in nums: without_square = max(num, num+prev_without_square) with_square = max(num*num, num*num+prev_without_square, num+prev_with_square) result = max(result, with_square) prev_with_square, prev_without_square = with_square, without_square return result ", "class Solution def minPatches(self, nums, n): result = reachable = 0 for x in nums: if x > n: break while not reachable >= x-1: result += 1 reachable += reachable+1 reachable += x while not reachable >= n: result += 1 reachable += reachable+1 return result ", "class Solution def minPatches(self, nums, n): result = reachable = 0 for x in nums: while not reachable >= x-1: result += 1 reachable += reachable+1 if reachable >= n: return result reachable += x if reachable >= n: return result while not reachable >= n: result += 1 reachable += reachable+1 return result ", "class Solution def minPatches(self, nums, n): patch, miss, i = 0, 1, 0 while miss <= n: if i < len(nums) and nums[i] <= miss: miss += nums[i] i += 1 else: miss += miss patch += 1 return patch ", "class Solution def minFlips(self, s): result = float(\"inf\") cnt1 = cnt2 = 0 for i in xrange(2*len(s)-1 if len(s)%2 else len(s)): if i >= len(s): cnt1 -= int(s[i%len(s)])^((i-len(s))%2)^0 cnt2 -= int(s[i%len(s)])^((i-len(s))%2)^1 cnt1 += int(s[i%len(s)])^(i%2)^0 cnt2 += int(s[i%len(s)])^(i%2)^1 if i >= len(s)-1: result = min(result, cnt1, cnt2) return result ", "class Solution def shiftingLetters(self, S, shifts): result = [] times = sum(shifts) % 26 for i, c in enumerate(S): index = ord(c) - ord('a') result.append(chr(ord('a') + (index+times) % 26)) times = (times-shifts[i]) % 26 return \"\".join(result) ", "class Solution def findMaximumElegance(self, items, k): curr = 0 lookup = set() stk = [] for p, c in heapq.nlargest(k, items): if c in lookup: stk.append(p) curr += p lookup.add(c) sl = SortedList() lookup2 = {} for p, c in items: if c in lookup: continue if c in lookup2: if lookup2[c] >= p: continue sl.remove((lookup2[c], c)) sl.add((p, c)) lookup2[c] = p if len(sl) > len(stk): del lookup2[sl[0][1]] del sl[0] result = curr+len(lookup)**2 for p, c in reversed(sl): curr += p-stk.pop() lookup.add(c) result = max(result, curr+len(lookup)**2) return result import random import collections ", "class Solution def findMaximumElegance(self, items, k): def nth_element(nums, n, left=0, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right right = len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 def nlargest(k, nums): nth_element(nums, k-1, compare=lambda a, b: a > b) return sorted(nums[:k], reverse=True) curr = 0 lookup = set() stk = [] for p, c in nlargest(k, items): if c in lookup: stk.append(p) curr += p lookup.add(c) lookup2 = collections.defaultdict(int) for p, c in items: if c in lookup: continue lookup2[c] = max(lookup2[c], p) l = len(lookup) result = curr+l**2 for p in nlargest(min(len(stk), len(lookup2)), lookup2.values()): curr += p-stk.pop() l += 1 result = max(result, curr+l**2) return result ", "class Solution def findMaximumElegance(self, items, k): items.sort(reverse=True) result = curr = 0 lookup = set() stk = [] for i in xrange(k): if items[i][1] in lookup: stk.append(items[i][0]) curr += items[i][0] lookup.add(items[i][1]) result = curr+len(lookup)**2 for i in xrange(k, len(items)): if items[i][1] in lookup: continue if not stk: break curr += items[i][0]-stk.pop() lookup.add(items[i][1]) result = max(result, curr+len(lookup)**2) return result ", "class Solution def minOperations(self, grid, x): def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 nums = [v for row in grid for v in row] if len(set(v%x for v in nums)) > 1: return -1 nth_element(nums, len(nums)//2) median = nums[len(nums)//2] return sum(abs(v-median)//x for v in nums) ", "class Solution def countDivisibleSubstrings(self, word): result = 0 for d in xrange(1, 10): prefix = 0 cnt = collections.Counter([0+d*(-1+1)]) for i, x in enumerate(word): prefix += (ord(x)-ord('a')+1)//3+1 result += cnt[prefix-d*(i+1)] cnt[prefix-d*(i+1)] += 1 return result ", "class Solution def maximumScore(self, scores, edges): def find_top3(scores, x, top3): heapq.heappush(top3, (scores[x], x)) if len(top3) > 3: heapq.heappop(top3) top3 = [[] for _ in xrange(len(scores))] for a, b in edges: find_top3(scores, b, top3[a]) find_top3(scores, a, top3[b]) result = -1 for a, b in edges: for _, c in top3[a]: if c == b: continue for _, d in top3[b]: if d == a or d == c: continue result = max(result, sum(scores[x] for x in (a, b, c, d))) return result ", "class Solution def twoSumBSTs(self, root1, root2, target): def inorder_gen(root, asc=True): result, stack = [], [(root, False)] while stack: root, is_visited = stack.pop() if root is None: continue if is_visited: yield root.val else: if asc: stack.append((root.right, False)) stack.append((root, True)) stack.append((root.left, False)) else: stack.append((root.left, False)) stack.append((root, True)) stack.append((root.right, False)) left_gen, right_gen = inorder_gen(root1, True), inorder_gen(root2, False) left, right = next(left_gen), next(right_gen) while left is not None and right is not None: if left + right < target: left = next(left_gen) elif left + right > target: right = next(right_gen) else: return True return False ", "class Solution def minimumSteps(self, s): result = left = 0 for right in xrange(len(s)): if s[right] != '0': continue result += right-left left += 1 return result ", "class Solution def minimumSteps(self, s): result = 0 left, right = 0, len(s)-1 while left < right: if left < len(s) and s[left] != '1': left += 1 continue if right >= 0 and s[right] != '0': right -= 1 continue result += right-left left += 1 right -= 1 return result ", "class Solution def maximalPathQuality(self, values, edges, maxTime): def iter_dfs(values, adj, maxTime): lookup, lookup2 = [0]*len(adj), set() result = 0 stk = [(1, (0, maxTime, 0))] while stk: step, args = stk.pop() if step == 1: u, time, total = args lookup[u] += 1 if lookup[u] == 1: total += values[u] if not u: result = max(result, total) stk.append((4, (u,))) for v, t in reversed(adj[u]): if (u, v) in lookup2 or time < t: continue stk.append((3, (u, v))) stk.append((1, (v, time-t, total))) stk.append((2, (u, v))) elif step == 2: u, v = args lookup2.add((u, v)) elif step == 3: u, v = args lookup2.remove((u, v)) elif step == 4: u = args[0] lookup[u] -= 1 return result adj = [[] for _ in xrange(len(values))] for u, v, t in edges: adj[u].append((v, t)) adj[v].append((u, t)) return iter_dfs(values, adj, maxTime) ", "class Solution def maximalPathQuality(self, values, edges, maxTime): def dfs(values, adj, u, time, total, lookup, lookup2, result): lookup[u] += 1 if lookup[u] == 1: total += values[u] if not u: result[0] = max(result[0], total) for v, t in adj[u]: if (u, v) in lookup2 or time < t: continue lookup2.add((u, v)) dfs(values, adj, v, time-t, total, lookup, lookup2, result) lookup2.remove((u, v)) lookup[u] -= 1 adj = [[] for _ in xrange(len(values))] for u, v, t in edges: adj[u].append((v, t)) adj[v].append((u, t)) result = [0] dfs(values, adj, 0, maxTime, 0, [0]*len(adj), set(), result) return result[0] ", "class Solution def maximalPathQuality(self, values, edges, maxTime): def dfs(values, adj, u, time, total, lookup, lookup2): lookup[u] += 1 if lookup[u] == 1: total += values[u] result = total if not u else 0 for v, t in adj[u]: if (u, v) in lookup2 or time < t: continue lookup2.add((u, v)) result = max(result, dfs(values, adj, v, time-t, total, lookup, lookup2)) lookup2.remove((u, v)) lookup[u] -= 1 return result adj = [[] for _ in xrange(len(values))] for u, v, t in edges: adj[u].append((v, t)) adj[v].append((u, t)) return dfs(values, adj, 0, maxTime, 0, [0]*len(adj), set()) ", "class Solution def maxGeneticDifference(self, parents, queries): def iter_dfs(adj, qs, trie, result): stk = [(1, adj[-1][0])] while stk: step, node = stk.pop() if step == 1: trie.insert(node, 1) for i, val in qs[node]: result[i] = trie.query(val) stk.append((2, node)) for child in reversed(adj[node]): stk.append((1, child)) elif step == 2: trie.insert(node, -1) adj = collections.defaultdict(list) for node, parent in enumerate(parents): adj[parent].append(node) qs = collections.defaultdict(list) max_val = len(parents)-1 for i, (node, val) in enumerate(queries): qs[node].append((i, val)) max_val = max(max_val, val) result = [0]*len(queries) iter_dfs(adj, qs, Trie(max_val.bit_length()), result) return result import collections class Trie(object): def __init__(self, bit_count): self.__root = {} self.__bit_count = bit_count def insert(self, num, v): node = self.__root for i in reversed(xrange(self.__bit_count)): curr = (num>>i) & 1 new_node = node.setdefault(curr, collections.defaultdict(int)) new_node[\"_cnt\"] += v if not new_node[\"_cnt\"]: del node[curr] break node = new_node def query(self, num): node, result = self.__root, 0 for i in reversed(xrange(self.__bit_count)): curr = (num>>i) & 1 if 1^curr in node: node = node[1^curr] result |= 1<<i else: node = node[curr] return result ", "class Solution def maxGeneticDifference(self, parents, queries): def dfs(adj, qs, node, trie, result): trie.insert(node, 1) for i, val in qs[node]: result[i] = trie.query(val) for child in adj[node]: dfs(adj, qs, child, trie, result) trie.insert(node, -1) adj = collections.defaultdict(list) for node, parent in enumerate(parents): adj[parent].append(node) qs = collections.defaultdict(list) max_val = len(parents)-1 for i, (node, val) in enumerate(queries): qs[node].append((i, val)) max_val = max(max_val, val) result = [0]*len(queries) dfs(adj, qs, adj[-1][0], Trie(max_val.bit_length()), result) return result ", "class Solution def minimizedStringLength(self, s): return len(set(s)) ", "class Solution def paintWalls(self, cost, time): dp = [float(\"inf\")]*(len(cost)+1) dp[0] = 0 for c, t in itertools.izip(cost, time): for j in reversed(xrange(1, len(cost)+1)): dp[j] = min(dp[j], dp[max(j-(t+1), 0)]+c) return dp[-1] ", "class Solution def validArrangement(self, pairs): adj = collections.defaultdict(list) degree = collections.defaultdict(int) for u, v in pairs: adj[u].append(v) degree[u] += 1 degree[v] -= 1 result = [] stk = [next((u for u, c in degree.iteritems() if c == 1), next(degree.iterkeys()))] while stk: while adj[stk[-1]]: stk.append(adj[stk[-1]].pop()) result.append(stk.pop()) result.reverse() return [[result[i], result[i+1]] for i in xrange(len(result)-1)] ", "class Solution def minNonZeroProduct(self, p): MOD = 10**9+7 max_num_mod = (pow(2, p, MOD)-1)%MOD pair_product_mod = (max_num_mod-1)%MOD pair_cnt_mod_m_1 = (pow(2, p-1, MOD-1)-1) % (MOD-1) return (max_num_mod*pow(pair_product_mod, pair_cnt_mod_m_1, MOD)) % MOD ", "class Solution def sumGame(self, num): cnt = total = 0 for i in xrange(len(num)): if num[i] == '?': cnt += (-1 if i < len(num)//2 else 1) else: total += (int(num[i]) if i < len(num)//2 else -int(num[i])) return True if cnt%2 else total != cnt//2*9 ", "class Solution def restoreString(self, s, indices): result = list(s) for i, c in enumerate(result): if indices[i] == i: continue move, j = c, indices[i] while j != i: result[j], move = move, result[j] indices[j], j = j, indices[j] result[i] = move return \"\".join(result) import itertools ", "class Solution def restoreString(self, s, indices): result = ['']*len(s) for i, c in itertools.izip(indices, s): result[i] = c return \"\".join(result) ", "class Solution lookup = {'0':'0', '1':'1', '6':'9', '8':'8', '9':'6'} cache = {} def strobogrammaticInRange(self, low, high): count = self.countStrobogrammaticUntil(high, False) - self.countStrobogrammaticUntil(low, False) + self.isStrobogrammatic(low) return count if count >= 0 else 0 def countStrobogrammaticUntil(self, num, can_start_with_0): if can_start_with_0 and num in self.cache: return self.cache[num] count = 0 if len(num) == 1: for c in ['0', '1', '8']: if num[0] >= c: count += 1 self.cache[num] = count return count for key, val in self.lookup.iteritems(): if can_start_with_0 or key != '0': if num[0] > key: if len(num) == 2: count += 1 else: count += self.countStrobogrammaticUntil('9' * (len(num) - 2), True) elif num[0] == key: if len(num) == 2: if num[-1] >= val: count += 1 else: if num[-1] >= val: count += self.countStrobogrammaticUntil(self.getMid(num), True) elif (self.getMid(num) != '0' * (len(num) - 2)): count += self.countStrobogrammaticUntil(self.getMid(num), True) - self.isStrobogrammatic(self.getMid(num)) if not can_start_with_0: for i in xrange(len(num) - 1, 0, -1): count += self.countStrobogrammaticByLength(i) else: self.cache[num] = count return count def getMid(self, num): return num[1:len(num) - 1] def countStrobogrammaticByLength(self, n): if n == 1: return 3 elif n == 2: return 4 elif n == 3: return 4 * 3 else: return 5 * self.countStrobogrammaticByLength(n - 2) def isStrobogrammatic(self, num): n = len(num) for i in xrange((n+1) / 2): if num[n-1-i] not in self.lookup or num[i] != self.lookup[num[n-1-i]]: return False return True ", "class Solution def minMovesToMakePalindrome(self, s): idxs = [[] for _ in xrange(26)] for i, c in enumerate(s): idxs[ord(c)-ord('a')].append(i) targets, pairs = [0]*len(s), [] for c, idx in enumerate(idxs): for i in xrange(len(idx)//2): pairs.append((idx[i], idx[~i])) if len(idx)%2: targets[idx[len(idx)//2]] = len(s)//2 pairs.sort() for i, (l, r) in enumerate(pairs): targets[l], targets[r] = i, (len(s)-1)-i bit = BIT(len(s)) result = 0 for i in targets: result += i-bit.query(i-1) bit.add(i, 1) return result ", "class Solution def minMovesToMakePalindrome(self, s): s = list(s) result = 0 while s: i = s.index(s[-1]) if i == len(s)-1: result += i//2 else: result += i s.pop(i) s.pop() return result ", "class Solution def solveNQueens(self, n): def dfs(row): if row == n: result.append(map(lambda x: '.'*x + \"Q\" + '.'*(n-x-1), curr)) return for i in xrange(n): if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]: continue cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True curr.append(i) dfs(row+1) curr.pop() cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False result, curr = [], [] cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1) dfs(0) return result ", "class Solution def solveNQueens(self, n): def dfs(col_per_row, xy_diff, xy_sum): cur_row = len(col_per_row) if cur_row == n: ress.append(col_per_row) for col in range(n): if col not in col_per_row and cur_row-col not in xy_diff and cur_row+col not in xy_sum: dfs(col_per_row+[col], xy_diff+[cur_row-col], xy_sum+[cur_row+col]) ress = [] dfs([], [], []) return [['.'*i + 'Q' + '.'*(n-i-1) for i in res] for res in ress] ", "class Solution def pairSum(self, head): def reverseList(head): dummy = ListNode() while head: dummy.next, head.next, head = head, dummy.next, head.next return dummy.next dummy = ListNode(next=head) slow = fast = dummy while fast.next and fast.next.next: slow, fast = slow.next, fast.next.next result = 0 head2 = reverseList(slow) while head: result = max(result, head.val+head2.val) head, head2 = head.next, head2.next return result ", "class Solution def poorPigs(self, buckets, minutesToDie, minutesToTest): return int(math.ceil(math.log(buckets) / math.log(minutesToTest / minutesToDie + 1))) ", "class Solution def numEquivDominoPairs(self, dominoes): counter = collections.Counter((min(x), max(x)) for x in dominoes) return sum(v*(v-1)//2 for v in counter.itervalues()) ", "class Solution def shortestWay(self, source, target): lookup = [[None for _ in xrange(26)] for _ in xrange(len(source)+1)] find_char_next_pos = [None]*26 for i in reversed(xrange(len(source))): find_char_next_pos[ord(source[i])-ord('a')] = i+1 lookup[i] = list(find_char_next_pos) result, start = 1, 0 for c in target: start = lookup[start][ord(c)-ord('a')] if start != None: continue result += 1 start = lookup[0][ord(c)-ord('a')] if start == None: return -1 return result ", "class Solution def sellingWood(self, m, n, prices): dp = [[0]*(n+1) for i in xrange(m+1)] for h, w, p in prices: dp[h][w] = p for i in xrange(1, m+1): for j in xrange(1, n+1): for k in xrange(1, i//2+1): dp[i][j] = max(dp[i][j], dp[k][j]+dp[i-k][j]) for k in xrange(1, j//2+1): dp[i][j] = max(dp[i][j], dp[i][k]+dp[i][j-k]) return dp[m][n] ", "class Solution def sumDigitDifferences(self, nums): base, l = 1, 0 while base <= nums[0]: base *= 10 l += 1 cnts = [[0]*10 for _ in xrange(l)] for x in nums: for i in xrange(l): cnts[i][x%10] += 1 x //= 10 return sum(c*(len(nums)-c) for cnt in cnts for c in cnt)//2 ", "class Solution def subtractProductAndSum(self, n): product, total = 1, 0 while n: n, r = divmod(n, 10) product *= r total += r return product-total import operator ", "class Solution def subtractProductAndSum(self, n): A = map(int, str(n)) return reduce(operator.mul, A) - sum(A) ", "class Solution def minFlips(self, a, b, c): def number_of_1_bits(n): result = 0 while n: n &= n-1 result += 1 return result return number_of_1_bits((a|b)^c) + number_of_1_bits(a&b&~c) ", "class Solution def minFlips(self, a, b, c): result = 0 for i in xrange(31): a_i, b_i, c_i = map(lambda x: x&1, [a, b, c]) if (a_i | b_i) != c_i: result += 2 if a_i == b_i == 1 else 1 a, b, c = a >> 1, b >> 1, c >> 1 return result ", "class Solution def matrixRankTransform(self, matrix): def cb(x, y, z): new_rank[x] = max(new_rank[y], new_rank[z]) lookup = collections.defaultdict(list) for i in xrange(len(matrix)): for j in xrange(len(matrix[0])): lookup[matrix[i][j]].append([i, j]) rank = [0]*(len(matrix)+len(matrix[0])) for x in sorted(lookup): new_rank = rank[:] union_find = UnionFind(len(matrix)+len(matrix[0]), cb) for i, j in lookup[x]: union_find.union_set(i, j+len(matrix)) for i, j in lookup[x]: matrix[i][j] = rank[i] = rank[j+len(matrix)] = new_rank[union_find.find_set(i)]+1 return matrix ", "class Solution def getCommon(self, nums1, nums2): i = j = 0 while i < len(nums1) and j < len(nums2): if nums1[i] < nums2[j]: i += 1 elif nums1[i] > nums2[j]: j += 1 else: return nums1[i] return -1 ", "class Solution def maxPalindromes(self, s, k): result = prev = 0 for mid in xrange(2*len(s)-1): left, right = mid//2, mid//2+mid%2 while left >= prev and right < len(s) and s[left] == s[right]: if right-left+1 >= k: prev = right+1 result += 1 break left, right = left-1, right+1 return result ", "class Solution def minimumOperations(self, nums): result = 0 left, right = 0, len(nums)-1 l, r = nums[left], nums[right] while left < right: if l == r: left += 1 right -= 1 l, r = nums[left], nums[right] continue if l < r: left += 1 l += nums[left] else: right -= 1 r += nums[right] result += 1 return result ", "class Solution def minimumHealth(self, damage, armor): return sum(damage)-min(max(damage), armor)+1 ", "class Solution def maxHeight(self, cuboids): for cuboid in cuboids: cuboid.sort() cuboids.append([0, 0, 0]) cuboids.sort() dp = [0]*len(cuboids) for i in xrange(1, len(cuboids)): for j in xrange(i): if all(cuboids[j][k] <= cuboids[i][k] for k in xrange(3)): dp[i] = max(dp[i], dp[j]+cuboids[i][2]) return max(dp) ", "class Solution def isArraySpecial(self, nums): return all(nums[i]&1 != nums[i+1]&1 for i in xrange(len(nums)-1)) ", "class Solution def removePalindromeSub(self, s): def is_palindrome(s): for i in xrange(len(s)//2): if s[i] != s[-1-i]: return False return True return 2 - is_palindrome(s) - (s == \"\") ", "class Solution def reformatNumber(self, number): number = list(number) src_len = 0 for c in number: if c.isdigit(): number[src_len] = c src_len += 1 dst_len = src_len + (src_len-1)//3 if dst_len > len(number): number.extend([0]*(dst_len-len(number))) while dst_len < len(number): number.pop() curr = dst_len-1 for l, i in enumerate(reversed(xrange(src_len)), (3-src_len%3)%3): if l and l%3 == 0: number[curr] = '-' curr -= 1 number[curr] = number[i] curr -= 1 if dst_len >= 3 and number[dst_len-2] == '-': number[dst_len-3], number[dst_len-2] = number[dst_len-2], number[dst_len-3] return \"\".join(number) ", "class Solution def maximumProfit(self, present, future, budget): dp = [0]*(budget+1) for i, (p, f) in enumerate(itertools.izip(present, future)): if f-p < 0: continue for b in reversed(xrange(p, budget+1)): dp[b] = max(dp[b], dp[b-p]+(f-p)) return dp[-1] import itertools ", "class Solution def maximumProfit(self, present, future, budget): dp = [[0]*(budget+1) for _ in xrange(2)] for i, (p, f) in enumerate(itertools.izip(present, future)): for b in xrange(budget+1): dp[(i+1)%2][b] = max(dp[i%2][b], (dp[i%2][b-p]+(f-p) if b-p >= 0 else 0)) return dp[len(present)%2][-1] ", "class Solution def replaceWords(self, dictionary, sentence): _trie = lambda: collections.defaultdict(_trie) trie = _trie() for word in dictionary: reduce(dict.__getitem__, word, trie).setdefault(\"_end\") def replace(word): curr = trie for i, c in enumerate(word): if c not in curr: break curr = curr[c] if \"_end\" in curr: return word[:i+1] return word return \" \".join(map(replace, sentence.split())) ", "class Solution def maxBoxesInWarehouse(self, boxes, warehouse): boxes.sort(reverse=True) left, right = 0, len(warehouse)-1 for h in boxes: if h <= warehouse[left]: left += 1 elif h <= warehouse[right]: right -= 1 if left > right: break return left + (len(warehouse)-1-right) ", "class Solution def maxConsecutive(self, bottom, top, special): special.sort() result = max(special[0]-bottom, top-special[-1]) for i in xrange(1, len(special)): result = max(result, special[i]-special[i-1]-1) return result ", "class Solution def minimumSize(self, nums, maxOperations): def check(nums, maxOperations, x): return sum((num+x-1)//x-1 for num in nums) <= maxOperations left, right = 1, max(nums) while left <= right: mid = left + (right-left)//2 if check(nums, maxOperations, mid): right = mid-1 else: left = mid+1 return left ", "class Solution def validMountainArray(self, A): i = 0 while i+1 < len(A) and A[i] < A[i+1]: i += 1 j = len(A)-1 while j-1 >= 0 and A[j-1] > A[j]: j -= 1 return 0 < i == j < len(A)-1 ", "class Solution def removeNodes(self, head): stk = [] while head: while stk and stk[-1].val < head.val: stk.pop() if stk: stk[-1].next = head stk.append(head) head = head.next return stk[0] ", "class Solution def maximumPrimeDifference(self, nums): left = next(i for i in xrange(len(nums)) if SPF[nums[i]] == nums[i]) right = next(i for i in reversed(xrange(len(nums))) if SPF[nums[i]] == nums[i]) return right-left ", "class Solution def maxCount(self, banned, n, maxSum): k = min(int((-1+(1+8*maxSum))**0.5/2), n) total = (k+1)*k//2 result = k lookup = set(banned) for x in lookup: if x <= k: total -= x result -= 1 for i in xrange(k+1, n+1): if i in lookup: continue if total+i > maxSum: break total += i result += 1 return result import bisect ", "class Solution def maxCount(self, banned, n, maxSum): def check(x): return (x+1)*x//2-prefix[bisect.bisect_right(sorted_banned, x)] <= maxSum sorted_banned = sorted(set(banned)) prefix = [0]*(len(sorted_banned)+1) for i in xrange(len(sorted_banned)): prefix[i+1] = prefix[i]+sorted_banned[i] left, right = 1, n while left <= right: mid = left + (right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right-bisect.bisect_right(sorted_banned, right) ", "class Solution def isRectangleOverlap(self, rec1, rec2): def intersect(p_left, p_right, q_left, q_right): return max(p_left, q_left) < min(p_right, q_right) return (intersect(rec1[0], rec1[2], rec2[0], rec2[2]) and intersect(rec1[1], rec1[3], rec2[1], rec2[3])) ", "class Solution def maxProfit(self, prices, profits): NEG_INF = float(\"-inf\") def query(sl, k): j = sl.bisect_left((k,)) return sl[j-1][1] if j-1 >= 0 else NEG_INF def update(sl, k, v): j = sl.bisect_left((k,)) if j < len(sl) and sl[j][0] == k: if not (sl[j][1] < v): return del sl[j] elif not (j-1 < 0 or sl[j-1][1] < v): return sl.add((k, v)) while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]: del sl[j+1] result = NEG_INF sl1, sl2 = SortedList(), SortedList() for price, profit in itertools.izip(prices, profits): result = max(result, query(sl2, price)+profit) update(sl1, price, profit) update(sl2, price, query(sl1, price)+profit) return result if result != NEG_INF else -1 from sortedcontainers import SortedList ", "class Solution def maxProfit(self, prices, profits): NEG_INF = float(\"-inf\") right = [NEG_INF]*len(prices) sl = SortedList() for i in reversed(xrange(len(prices))): j = sl.bisect_left((-prices[i],)) if j-1 >= 0: right[i] = sl[j-1][1] if not (j-1 < 0 or sl[j-1][1] < profits[i]): continue sl.add((-prices[i], profits[i])) j = sl.bisect_left((-prices[i], profits[i])) while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]: del sl[j+1] result = NEG_INF sl = SortedList() for i in xrange(len(prices)): j = sl.bisect_left((prices[i],)) if j-1 >= 0: result = max(result, sl[j-1][1]+profits[i]+right[i]) if not (j-1 < 0 or sl[j-1][1] < profits[i]): continue sl.add((prices[i], profits[i])) j = sl.bisect_left((prices[i], profits[i])) while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]: del sl[j+1] return result if result != NEG_INF else -1 import itertools ", "class Solution def maxProfit(self, prices, profits): NEG_INF = float(\"-inf\") class BIT(object): def __init__(self, n, default=0, fn=lambda x, y: x+y): self.__bit = [NEG_INF]*(n+1) self.__default = default self.__fn = fn def update(self, i, val): i += 1 while i < len(self.__bit): self.__bit[i] = self.__fn(self.__bit[i], val) i += (i & -i) def query(self, i): i += 1 ret = self.__default while i > 0: ret = self.__fn(ret, self.__bit[i]) i -= (i & -i) return ret price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))} result = NEG_INF bit1, bit2 = BIT(len(price_to_idx), default=NEG_INF, fn=max), BIT(len(price_to_idx), default=NEG_INF, fn=max) for price, profit in itertools.izip(prices, profits): result = max(result, bit2.query(price_to_idx[price]-1)+profit) bit1.update(price_to_idx[price], profit) bit2.update(price_to_idx[price], bit1.query(price_to_idx[price]-1)+profit) return result if result != NEG_INF else -1 import itertools ", "class Solution def maxProfit(self, prices, profits): NEG_INF = float(\"-inf\") class SegmentTree(object): def __init__(self, N, build_fn=lambda _: None, query_fn=lambda x, y: max(x, y), update_fn=lambda x, y: max(x, y)): self.tree = [None]*(2*2**((N-1).bit_length())) self.base = len(self.tree)//2 self.query_fn = query_fn self.update_fn = update_fn for i in xrange(self.base, self.base+N): self.tree[i] = build_fn(i-self.base) for i in reversed(xrange(1, self.base)): self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1]) def update(self, i, h): x = self.base+i self.tree[x] = self.update_fn(self.tree[x], h) while x > 1: x //= 2 self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1]) def query(self, L, R): if L > R: return None L += self.base R += self.base left = right = None while L <= R: if L & 1: left = self.query_fn(left, self.tree[L]) L += 1 if R & 1 == 0: right = self.query_fn(self.tree[R], right) R -= 1 L //= 2 R //= 2 return self.query_fn(left, right) price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))} result = NEG_INF st1, st2 = SegmentTree(len(price_to_idx)), SegmentTree(len(price_to_idx)) for price, profit in itertools.izip(prices, profits): mx2 = st2.query(0, price_to_idx[price]-1) if mx2 is not None: result = max(result, mx2+profit) st1.update(price_to_idx[price], profit) mx1 = st1.query(0, price_to_idx[price]-1) if mx1 is not None: st2.update(price_to_idx[price], mx1+profit) return result if result != NEG_INF else -1 ", "class Solution def maxProfit(self, prices, profits): NEG_INF = float(\"-inf\") class SegmentTree(object): def __init__(self, N, build_fn=lambda _: None, query_fn=lambda x, y: max(x, y), update_fn=lambda x, y: max(x, y)): self.tree = [None]*(2*2**((N-1).bit_length())) self.base = len(self.tree)//2 self.query_fn = query_fn self.update_fn = update_fn for i in xrange(self.base, self.base+N): self.tree[i] = build_fn(i-self.base) for i in reversed(xrange(1, self.base)): self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1]) def update(self, i, h): x = self.base+i self.tree[x] = self.update_fn(self.tree[x], h) while x > 1: x //= 2 self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1]) def query(self, L, R): if L > R: return None L += self.base R += self.base left = right = None while L <= R: if L & 1: left = self.query_fn(left, self.tree[L]) L += 1 if R & 1 == 0: right = self.query_fn(self.tree[R], right) R -= 1 L //= 2 R //= 2 return self.query_fn(left, right) price_to_idx = {x:i for i, x in enumerate(sorted(set(prices)))} right = [NEG_INF]*len(prices) st = SegmentTree(len(price_to_idx)) for i in reversed(xrange(len(prices))): right[i] = st.query(price_to_idx[prices[i]]+1, len(price_to_idx)-1) st.update(price_to_idx[prices[i]], profits[i]) result = NEG_INF st = SegmentTree(len(price_to_idx)) for i in xrange(len(prices)): left = st.query(0, price_to_idx[prices[i]]-1) if left is not None and right[i] is not None: result = max(result, left+profits[i]+right[i]) st.update(price_to_idx[prices[i]], profits[i]) return result if result != NEG_INF else -1 ", "class Solution def maxSum(self, nums, m, k): lookup = collections.Counter() result = curr = left = 0 for right in xrange(len(nums)): curr += nums[right] lookup[nums[right]] += 1 if right-left+1 == k+1: lookup[nums[left]] -= 1 if lookup[nums[left]] == 0: del lookup[nums[left]] curr -= nums[left] left += 1 if right-left+1 == k and len(lookup) >= m: result = max(result, curr) return result ", "class Solution def strWithout3a3b(self, A, B): result = [] put_A = None while A or B: if len(result) >= 2 and result[-1] == result[-2]: put_A = result[-1] == 'b' else: put_A = A >= B if put_A: A -= 1 result.append('a') else: B -= 1 result.append('b') return \"\".join(result) ", "class Solution def maxPotholes(self, road, budget): def inplace_counting_sort(nums, reverse=False): if not nums: return count = [0]*(max(nums)+1) for num in nums: count[num] += 1 for i in xrange(1, len(count)): count[i] += count[i-1] for i in reversed(xrange(len(nums))): while nums[i] >= 0: count[nums[i]] -= 1 j = count[nums[i]] nums[i], nums[j] = nums[j], ~nums[i] for i in xrange(len(nums)): nums[i] = ~nums[i] if reverse: nums.reverse() ls = [] l = 0 for i in xrange(len(road)): l += 1 if i+1 == len(road) or road[i+1] != road[i]: if road[i] == 'x': ls.append(l) l = 0 inplace_counting_sort(ls) result = 0 for l in reversed(ls): c = min(l+1, budget) if c-1 <= 0: break result += c-1 budget -= c return result ", "class Solution def maxPotholes(self, road, budget): ls = [] l = 0 for i in xrange(len(road)): l += 1 if i+1 == len(road) or road[i+1] != road[i]: if road[i] == 'x': ls.append(l) l = 0 ls.sort() result = 0 for l in reversed(ls): c = min(l+1, budget) if c-1 <= 0: break result += c-1 budget -= c return result ", "class Solution def shortestSequence(self, rolls, k): l = 0 lookup = set() for x in rolls: lookup.add(x) if len(lookup) != k: continue lookup.clear() l += 1 return l+1 ", "class Solution def minOperations(self, n): def popcount(x): return bin(x)[2:].count('1') return popcount(n^(n*0b11)) ", "class Solution def minOperations(self, n): result = 0 while n: if n&1: n >>= 1 n += n&1 result += 1 n >>= 1 return result ", "class Solution def minSwaps(self, nums): result = cnt = w = nums.count(1) for i in xrange(len(nums)+(w-1)): if i >= w: cnt += nums[(i-w)%len(nums)] cnt -= nums[i%len(nums)] result = min(result, cnt) return result ", "class Solution def minCost(self, n, roads, appleCost, k): def dijkstra(start): best = [float(\"inf\")]*len(adj) best[start] = 0 min_heap = [(0, start)] while min_heap: curr, u = heapq.heappop(min_heap) if best[u] < curr: continue for v, w in adj[u]: if best[v] <= curr+w: continue best[v] = curr+w heapq.heappush(min_heap, (curr+w, v)) return best adj = [[] for _ in xrange(n)] for a, b, c in roads: adj[a-1].append((b-1, c)) adj[b-1].append((a-1, c)) return [min(a+d*(k+1) for a, d in itertools.izip(appleCost, dijkstra(u))) for u in xrange(n)] ", "class Solution def maximumCount(self, nums): return max(bisect.bisect_left(nums, 0)-0, len(nums)-bisect.bisect_left(nums, 1)) ", "class Solution def findSubstring(self, s, words): if not words: return [] result, m, n, k = [], len(s), len(words), len(words[0]) if m < n*k: return result lookup = collections.defaultdict(int) for i in words: lookup[i] += 1 for i in xrange(k): left, count = i, 0 tmp = collections.defaultdict(int) for j in xrange(i, m-k+1, k): s1 = s[j:j+k] if s1 in lookup: tmp[s1] += 1 count += 1 while tmp[s1] > lookup[s1]: tmp[s[left:left+k]] -= 1 count -= 1 left += k if count == n: result.append(left) else: tmp = collections.defaultdict(int) count = 0 left = j+k return result ", "class Solution def findSubstring(self, s, words): result, m, n, k = [], len(s), len(words), len(words[0]) if m < n*k: return result lookup = collections.defaultdict(int) for i in words: lookup[i] += 1 for i in xrange(m+1-k*n): cur, j = collections.defaultdict(int), 0 while j < n: word = s[i+j*k:i+j*k+k] if word not in lookup: break cur[word] += 1 if cur[word] > lookup[word]: break j += 1 if j == n: result.append(i) return result ", "class Solution def minimumReplacement(self, nums): def ceil_divide(a, b): return (a+b-1)//b result = 0 curr = nums[-1] for x in reversed(nums): cnt = ceil_divide(x, curr) result += cnt-1 curr = x//cnt return result ", "class Solution def maximumSumQueries(self, nums1, nums2, queries): pairs = sorted(((i, j) for i, j in itertools.izip(nums1, nums2))) result = [0]*len(queries) stk = [] for x, y, i in sorted(((x, y, i) for i, (x, y) in enumerate(queries)), reverse=True): while pairs and pairs[-1][0] >= x: a, b = pairs.pop() while stk and stk[-1][1] <= a+b: stk.pop() if not stk or stk[-1][0] < b: stk.append((b, a+b)) j = bisect.bisect_left(stk, (y,)) result[i] = stk[j][1] if j != len(stk) else -1 return result ", "class Solution def sortByBits(self, arr): def popcount(n): result = 0 while n: n &= n - 1 result += 1 return result arr.sort(key=lambda x: (popcount(x), x)) return arr ", "class Solution def maximumSubtreeSize(self, edges, colors): def iter_dfs(): result = 0 stk = [(1, (0, -1, [1]))] while stk: step, args = stk.pop() if step == 1: u, p, ret = args stk.append((4, (ret,))) stk.append((2, (u, p, ret, 0))) elif step == 2: u, p, ret, i = args if i == len(adj[u]): continue v = adj[u][i] stk.append((2, (u, p, ret, i+1))) if v == p: continue new_ret = [1] stk.append((3, (v, u, new_ret, ret))) stk.append((1, (v, u, new_ret))) elif step == 3: v, u, new_ret, ret = args if ret[0] == -1: continue if new_ret[0] == 0 or colors[v] != colors[u]: ret[0] = -1 continue ret[0] += new_ret[0] elif step == 4: ret = args[0] result = max(result, ret[0]) return result adj = [[] for _ in xrange(len(colors))] for u, v in edges: adj[u].append(v) adj[v].append(u) return iter_dfs() ", "class Solution def maximumSubtreeSize(self, edges, colors): def dfs(u, p): cnt = 1 for v in adj[u]: if v == p: continue c = dfs(v, u) if cnt == -1: continue if c == -1 or colors[v] != colors[u]: cnt = -1 continue cnt += c result[0] = max(result[0], cnt) return cnt adj = [[] for _ in xrange(len(colors))] for u, v in edges: adj[u].append(v) adj[v].append(u) result = [0] dfs(0, -1) return result[0] ", "class Solution def kWeakestRows(self, mat, k): result, lookup = [], set() for j in xrange(len(mat[0])): for i in xrange(len(mat)): if mat[i][j] or i in lookup: continue lookup.add(i) result.append(i) if len(result) == k: return result for i in xrange(len(mat)): if i in lookup: continue lookup.add(i) result.append(i) if len(result) == k: break return result import collections ", "class Solution def kWeakestRows(self, mat, k): lookup = collections.OrderedDict() for j in xrange(len(mat[0])): for i in xrange(len(mat)): if mat[i][j] or i in lookup: continue lookup[i] = True if len(lookup) == k: return lookup.keys() for i in xrange(len(mat)): if i in lookup: continue lookup[i] = True if len(lookup) == k: break return lookup.keys() import random ", "class Solution def kWeakestRows(self, mat, k): def nth_element(nums, n, compare=lambda a, b: a < b): def partition_around_pivot(left, right, pivot_idx, nums, compare): new_pivot_idx = left nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx] for i in xrange(left, right): if compare(nums[i], nums[right]): nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i] new_pivot_idx += 1 nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right] return new_pivot_idx left, right = 0, len(nums) - 1 while left <= right: pivot_idx = random.randint(left, right) new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare) if new_pivot_idx == n: return elif new_pivot_idx > n: right = new_pivot_idx - 1 else: left = new_pivot_idx + 1 nums = [(sum(mat[i]), i) for i in xrange(len(mat))] nth_element(nums, k) return map(lambda x: x[1], sorted(nums[:k])) ", "class Solution def waysToReachTarget(self, target, types): MOD = 10**9+7 dp = [0]*(target+1) dp[0] = 1 for c, m in types: for i in reversed(xrange(1, target+1)): for j in xrange(1, min(i//m, c)+1): dp[i] = (dp[i]+dp[i-j*m])%MOD return dp[-1] ", "class Solution def waysToReachTarget(self, target, types): MOD = 10**9+7 dp = [0]*(target+1) dp[0] = 1 for c, m in types: new_dp = [0]*(target+1) for i in xrange(target+1): for j in xrange(min((target-i)//m, c)+1): new_dp[i+j*m] = (new_dp[i+j*m]+dp[i])%MOD dp = new_dp return dp[-1] ", "class Solution def minimumTime(self, n, edges, disappear): INF = float(\"inf\") def modified_dijkstra(start): best = [-1]*n best[start] = 0 min_heap = [(best[start], start)] while min_heap: curr, u = heapq.heappop(min_heap) if curr != best[u]: continue for v, w in adj[u]: if not curr+w < min(best[v] if best[v] != -1 else INF, disappear[v]): continue best[v] = curr+w heapq.heappush(min_heap, (best[v], v)) return best adj = [[] for _ in xrange(n)] for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) return modified_dijkstra(0) ", "class Solution def minOperationsToMakeMedianK(self, nums, k): def nth_element(nums, n, left=0, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right right = len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 nth_element(nums, len(nums)//2) return (sum(max(nums[i]-k, 0) for i in xrange(len(nums)//2+1))+ sum(max(k-nums[i], 0) for i in xrange(len(nums)//2, len(nums)))) ", "class Solution def minOperationsToMakeMedianK(self, nums, k): nums.sort() return (sum(max(nums[i]-k, 0) for i in xrange(len(nums)//2+1))+ sum(max(k-nums[i], 0) for i in xrange(len(nums)//2, len(nums)))) ", "class Solution def medianSlidingWindow(self, nums, k): sl = SortedList(float(nums[i])for i in xrange(k)) result = [(sl[k//2]+sl[k//2-(1-k%2)])/2] for i in xrange(k, len(nums)): sl.add(float(nums[i])) sl.remove(nums[i-k]) result.append((sl[k//2]+sl[k//2-(1-k%2)])/2) return result import collections import heapq ", "class Solution def medianSlidingWindow(self, nums, k): def lazy_delete(heap, to_remove, sign): while heap and sign*heap[0] in to_remove: to_remove[sign*heap[0]] -= 1 if not to_remove[sign*heap[0]]: del to_remove[sign*heap[0]] heapq.heappop(heap) def full_delete(heap, to_remove, sign): result = [] for x in heap: if sign*x not in to_remove: result.append(x) continue to_remove[sign*x] -= 1 if not to_remove[sign*x]: del to_remove[sign*x] heap[:] = result heapify(heap) min_heap, max_heap = [], [] for i in xrange(k): if i%2 == 0: heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i])) else: heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i])) result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0] to_remove = collections.defaultdict(int) for i in xrange(k, len(nums)): heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i])) if nums[i-k] > -max_heap[0]: heapq.heappush(min_heap, -heapq.heappop(max_heap)) to_remove[nums[i-k]] += 1 lazy_delete(max_heap, to_remove, -1) lazy_delete(min_heap, to_remove, 1) if len(min_heap)+len(max_heap) > 2*k: full_delete(max_heap, to_remove, -1) full_delete(min_heap, to_remove, 1) result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0) return result import collections import heapq ", "class Solution def medianSlidingWindow(self, nums, k): def lazy_delete(heap, to_remove, sign): while heap and sign*heap[0] in to_remove: to_remove[sign*heap[0]] -= 1 if not to_remove[sign*heap[0]]: del to_remove[sign*heap[0]] heapq.heappop(heap) min_heap, max_heap = [], [] for i in xrange(k): if i%2 == 0: heapq.heappush(min_heap, -heapq.heappushpop(max_heap, -nums[i])) else: heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i])) result = [float(min_heap[0])] if k%2 else [(min_heap[0]-max_heap[0])/2.0] to_remove = collections.defaultdict(int) for i in xrange(k, len(nums)): heapq.heappush(max_heap, -heapq.heappushpop(min_heap, nums[i])) if nums[i-k] > -max_heap[0]: heapq.heappush(min_heap, -heapq.heappop(max_heap)) to_remove[nums[i-k]] += 1 lazy_delete(max_heap, to_remove, -1) lazy_delete(min_heap, to_remove, 1) result.append(float(min_heap[0]) if k%2 else (min_heap[0]-max_heap[0])/2.0) return result ", "class Solution def findMaxFish(self, grid): DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1)) def bfs(i, j): result = grid[i][j] grid[i][j] = 0 q = [(i, j)] while q: new_q = [] for i, j in q: for di, dj in DIRECTIONS: ni, nj = i+di, j+dj if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj]): continue result += grid[ni][nj] grid[ni][nj] = 0 new_q.append((ni, nj)) q = new_q return result result = 0 for i in xrange(len(grid)): for j in xrange(len(grid[0])): if grid[i][j]: result = max(result, bfs(i, j)) return result ", "class Solution def findMaxFish(self, grid): DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1)) def dfs(i, j): result = grid[i][j] grid[i][j] = 0 stk = [(i, j)] while stk: i, j = stk.pop() for di, dj in reversed(DIRECTIONS): ni, nj = i+di, j+dj if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj]): continue result += grid[ni][nj] grid[ni][nj] = 0 stk.append((ni, nj)) return result result = 0 for i in xrange(len(grid)): for j in xrange(len(grid[0])): if grid[i][j]: result = max(result, dfs(i, j)) return result ", "class Solution def splitNum(self, num): sorted_num = \"\".join(sorted(str(num))) return int(sorted_num[::2])+int(sorted_num[1::2]) ", "class Solution def wiggleSort(self, nums): for i in xrange(1, len(nums)): if ((i % 2) and nums[i - 1] > nums[i]) or (not (i % 2) and nums[i - 1] < nums[i]): nums[i - 1], nums[i] = nums[i], nums[i - 1] ", "class Solution def wiggleSort(self, nums): nums.sort() med = (len(nums) - 1) // 2 nums[::2], nums[1::2] = nums[med::-1], nums[:med:-1] ", "class Solution def racecar(self, target): dp = [0] * (target+1) for i in xrange(1, target+1): k = i.bit_length() if i == 2**k-1: dp[i] = k continue dp[i] = k+1 + dp[2**k-1 - i] for j in xrange(k-1): dp[i] = min(dp[i], k+j+1 + dp[i - 2**(k-1) + 2**j]) return dp[-1] ", "class Solution def numberOfWays(self, s, t, k): MOD = 10**9+7 def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j+1 > 0 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix def KMP(text, pattern): prefix = getPrefix(pattern) j = -1 for i in xrange(len(text)): while j+1 > 0 and pattern[j+1] != text[i]: j = prefix[j] if pattern[j+1] == text[i]: j += 1 if j+1 == len(pattern): yield i-j j = prefix[j] n = len(s) dp = [0]*2 dp[1] = ((pow(n-1, k, MOD)-(-1)**k)*pow(n, MOD-2, MOD))%MOD dp[0] = (dp[1]+(-1)**k)%MOD return reduce(lambda a, b: (a+b)%MOD, (dp[int(i != 0)] for i in KMP(s+s[:-1], t)), 0) ", "class Solution def numberOfWays(self, s, t, k): MOD = 10**9+7 def matrix_mult(A, B): ZB = zip(*B) return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A] def matrix_expo(A, K): result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))] while K: if K % 2: result = matrix_mult(result, A) A = matrix_mult(A, A) K /= 2 return result def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j+1 > 0 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix def KMP(text, pattern): prefix = getPrefix(pattern) j = -1 for i in xrange(len(text)): while j+1 > 0 and pattern[j+1] != text[i]: j = prefix[j] if pattern[j+1] == text[i]: j += 1 if j+1 == len(pattern): yield i-j j = prefix[j] n = len(s) T = [[0, 1], [n-1, (n-1)-1]] dp = [1, 0] dp = matrix_mult([dp], matrix_expo(T, k))[0] return reduce(lambda a, b: (a+b)%MOD, (dp[int(i != 0)] for i in KMP(s+s[:-1], t)), 0) ", "class Solution def numberOfWays(self, s, t, k): MOD = 10**9+7 def matrix_mult(A, B): ZB = zip(*B) return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A] def matrix_expo(A, K): result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))] while K: if K % 2: result = matrix_mult(result, A) A = matrix_mult(A, A) K /= 2 return result def z_function(s): z = [0]*len(s) l, r = 0, 0 for i in xrange(1, len(z)): if i <= r: z[i] = min(r-i+1, z[i-l]) while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]: z[i] += 1 if i+z[i]-1 > r: l, r = i, i+z[i]-1 return z n = len(s) T = [[0, 1], [n-1, (n-1)-1]] dp = [1, 0] dp = matrix_mult([dp], matrix_expo(T, k))[0] z = z_function(t+s+s[:-1]) return reduce(lambda a, b: (a+b)%MOD, (dp[int(i != 0)] for i in xrange(n) if z[i+len(t)] >= len(t)), 0) ", "class Solution def minimumTime(self, power): def ceil_divide(a, b): return (a+b-1)//b INF = float(\"inf\") dp = {0:0} for gain in xrange(1, len(power)+1): new_dp = collections.defaultdict(lambda:INF) for mask in dp.iterkeys(): for i in xrange(len(power)): if mask&(1<<i) == 0: new_dp[mask|(1<<i)] = min(new_dp[mask|(1<<i)], dp[mask]+ceil_divide(power[i], gain)) dp = new_dp return dp[(1<<len(power))-1] ", "class Solution def subsetsWithDup(self, nums): nums.sort() result = [[]] previous_size = 0 for i in xrange(len(nums)): size = len(result) for j in xrange(size): if i == 0 or nums[i] != nums[i - 1] or j >= previous_size: result.append(list(result[j])) result[-1].append(nums[i]) previous_size = size return result ", "class Solution def subsetsWithDup(self, nums): result = [] i, count = 0, 1 << len(nums) nums.sort() while i < count: cur = [] for j in xrange(len(nums)): if i & 1 << j: cur.append(nums[j]) if cur not in result: result.append(cur) i += 1 return result ", "class Solution def subsetsWithDup(self, nums): result = [] self.subsetsWithDupRecu(result, [], sorted(nums)) return result def subsetsWithDupRecu(self, result, cur, nums): if not nums: if cur not in result: result.append(cur) else: self.subsetsWithDupRecu(result, cur, nums[1:]) self.subsetsWithDupRecu(result, cur + [nums[0]], nums[1:]) ", "class Solution def strongPasswordChecker(self, s): missing_type_cnt = 3 if any('a' <= c <= 'z' for c in s): missing_type_cnt -= 1 if any('A' <= c <= 'Z' for c in s): missing_type_cnt -= 1 if any(c.isdigit() for c in s): missing_type_cnt -= 1 total_change_cnt = 0 one_change_cnt, two_change_cnt, three_change_cnt = 0, 0, 0 i = 2 while i < len(s): if s[i] == s[i-1] == s[i-2]: length = 2 while i < len(s) and s[i] == s[i-1]: length += 1 i += 1 total_change_cnt += length / 3 if length % 3 == 0: one_change_cnt += 1 elif length % 3 == 1: two_change_cnt += 1 else: three_change_cnt += 1 else: i += 1 if len(s) < 6: return max(missing_type_cnt, 6 - len(s)) elif len(s) <= 20: return max(missing_type_cnt, total_change_cnt) else: delete_cnt = len(s) - 20 total_change_cnt -= min(delete_cnt, one_change_cnt * 1) / 1 total_change_cnt -= min(max(delete_cnt - one_change_cnt, 0), two_change_cnt * 2) / 2 total_change_cnt -= min(max(delete_cnt - one_change_cnt - 2 * two_change_cnt, 0), three_change_cnt * 3) / 3 return delete_cnt + max(missing_type_cnt, total_change_cnt) ", "class Solution def minProductSum(self, nums1, nums2): def inner_product(vec1, vec2): return sum(itertools.imap(operator.mul, vec1, vec2)) nums1.sort() nums2.sort(reverse=True) return inner_product(nums1, nums2) ", "class Solution def minimumAbsDifference(self, arr): result = [] min_diff = float(\"inf\") arr.sort() for i in xrange(len(arr)-1): diff = arr[i+1]-arr[i] if diff < min_diff: min_diff = diff result = [[arr[i], arr[i+1]]] elif diff == min_diff: result.append([arr[i], arr[i+1]]) return result ", "class Solution def computeArea(self, A, B, C, D, E, F, G, H): return (D - B) * (C - A) + (G - E) * (H - F) - max(0, (min(C, G) - max(A, E))) * max(0, (min(D, H) - max(B, F))) ", "class Solution def minimumSwap(self, s1, s2): x1, y1 = 0, 0 for i in xrange(len(s1)): if s1[i] == s2[i]: continue x1 += int(s1[i] == 'x') y1 += int(s1[i] == 'y') if x1%2 != y1%2: return -1 return (x1//2 + y1//2) + (x1%2 + y1%2) ", "class Solution def minCostConnectPoints(self, points): result, u = 0, 0 dist = [float(\"inf\")]*len(points) lookup = set() for _ in xrange(len(points)-1): x0, y0 = points[u] lookup.add(u) for v, (x, y) in enumerate(points): if v in lookup: continue dist[v] = min(dist[v], abs(x-x0) + abs(y-y0)) val, u = min((val, v) for v, val in enumerate(dist)) dist[u] = float(\"inf\") result += val return result class UnionFind(object): def __init__(self, n): self.set = range(n) self.rank = [0]*n def find_set(self, x): stk = [] while self.set[x] != x: stk.append(x) x = self.set[x] while stk: self.set[stk.pop()] = x return x def union_set(self, x, y): x_root, y_root = map(self.find_set, (x, y)) if x_root == y_root: return False if self.rank[x_root] < self.rank[y_root]: self.set[x_root] = y_root elif self.rank[x_root] > self.rank[y_root]: self.set[y_root] = x_root else: self.set[y_root] = x_root self.rank[x_root] += 1 return True ", "class Solution def minCostConnectPoints(self, points): edges = [] for u in xrange(len(points)): for v in xrange(u+1, len(points)): edges.append((u, v, abs(points[v][0]-points[u][0]) + abs(points[v][1]-points[u][1]))) edges.sort(key=lambda x: x[2]) result = 0 union_find = UnionFind(len(points)) for u, v, val in edges: if union_find.union_set(u, v): result += val return result ", "class Solution def minimumOperationsToWriteY(self, grid): cnt = [[0]*3 for _ in xrange(2)] for i in xrange(len(grid)): for j in xrange(len(grid[0])): cnt[(i <= (len(grid[0])-1)//2 and (i-j == 0 or i+j == len(grid[0])-1)) or (i > (len(grid[0])-1)//2 == j)][grid[i][j]] += 1 return len(grid)*len(grid[0])-max(cnt[0][i]+cnt[1][j] for i in xrange(3) for j in xrange(3) if i != j) ", "class Solution def minDayskVariants(self, points, k): def add_rec(rec, intervals): x0, y0, x1, y1 = rec intervals.append([[x0, +1], [y0, y1]]) intervals.append([[x1+1, -1], [y0, y1]]) def check(points, k, l): intervals = [] y_set = set() for x, y in points: add_rec([x-l, y-l, x+l, y+l], intervals) y_set.add(y-l) y_set.add(y+l) intervals.sort() y_to_idx = {y:i for i, y in enumerate(sorted(y_set))} st = SegmentTree(len(y_to_idx)) for [_, v], [y0, y1] in intervals: st.update(y_to_idx[y0], y_to_idx[y1], v) if st.query(0, len(y_to_idx)-1) >= k: return True return False points = [[x+y, x-y] for x, y in points] min_x = min(points)[0] max_x = max(points)[0] min_y = min(points, key=lambda x: x[1])[1] max_y = max(points, key=lambda x: x[1])[1] left, right = 0, ((max_x-min_x)+(max_y-min_y)+1)//2 while left <= right: mid = left + (right-left)//2 if check(points, k, mid): right = mid-1 else: left = mid+1 return left import collections ", "class Solution def minDayskVariants(self, points, k): def add_rec(rec, intervals): x0, y0, x1, y1 = rec intervals[x0][y0] += 1 intervals[x0][y1+1] -= 1 intervals[x1+1][y0] -= 1 intervals[x1+1][y1+1] += 1 def check(points, k, l): intervals = collections.defaultdict(lambda:collections.defaultdict(int)) y_set = set() for x, y in points: add_rec([x-l, y-l, x+l, y+l], intervals) y_set.add(y-l) y_set.add(y+l+1) sorted_y = sorted(y_set) sorted_x = sorted(intervals.iterkeys()) count = collections.Counter() for x in sorted_x: for y, c in intervals[x].iteritems(): count[y] += c cnt = 0 for y in sorted_y: cnt += count[y] if cnt >= k: return True return False points = [[x+y, x-y] for x, y in points] min_x = min(points)[0] max_x = max(points)[0] min_y = min(points, key=lambda x: x[1])[1] max_y = max(points, key=lambda x: x[1])[1] left, right = 0, ((max_x-min_x)+(max_y-min_y)+1)//2 while left <= right: mid = left + (right-left)//2 if check(points, k, mid): right = mid-1 else: left = mid+1 return left ", "class Solution def minimumLengthEncoding(self, words): words = list(set(words)) _trie = lambda: collections.defaultdict(_trie) trie = _trie() nodes = [functools.reduce(dict.__getitem__, word[::-1], trie) for word in words] return sum(len(word) + 1 for i, word in enumerate(words) if len(nodes[i]) == 0) ", "class Solution def minFallingPathSum(self, A): for i in xrange(1, len(A)): for j in xrange(len(A[i])): A[i][j] += min(A[i-1][max(j-1, 0):j+2]) return min(A[-1]) ", "class Solution def sumOfBeauties(self, nums): right = [nums[-1]]*len(nums) for i in reversed(xrange(2, len(nums)-1)): right[i] = min(right[i+1], nums[i]) result, left = 0, nums[0] for i in xrange(1, len(nums)-1): if left < nums[i] < right[i+1]: result += 2 elif nums[i-1] < nums[i] < nums[i+1]: result += 1 left = max(left, nums[i]) return result ", "class Solution def spellchecker(self, wordlist, queries): vowels = set(['a', 'e', 'i', 'o', 'u']) def todev(word): return \"\".join('*' if c.lower() in vowels else c.lower() for c in word) words = set(wordlist) caps = {} vows = {} for word in wordlist: caps.setdefault(word.lower(), word) vows.setdefault(todev(word), word) def check(query): if query in words: return query lower = query.lower() if lower in caps: return caps[lower] devow = todev(lower) if devow in vows: return vows[devow] return \"\" return map(check, queries) ", "class Solution def matrixMedian(self, grid): def check(x): return sum(bisect_right(row, x) for row in grid) > (len(grid)*len(grid[0]))//2 left, right = min(row[0] for row in grid), max(row[-1] for row in grid) while left <= right: mid = left + (right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left ", "class Solution def removeVowels(self, S): lookup = set(\"aeiou\") return \"\".join(c for c in S if c not in lookup) ", "class Solution def minDiffInBST(self, root): def dfs(node): if not node: return dfs(node.left) self.result = min(self.result, node.val-self.prev) self.prev = node.val dfs(node.right) self.prev = float('-inf') self.result = float('inf') dfs(root) return self.result ", "class Solution def minOperations(self, s): cnt = sum(int(c) == i%2 for i, c in enumerate(s)) return min(cnt, len(s)-cnt) ", "class Solution def stoneGameVI(self, aliceValues, bobValues): sorted_vals = sorted(((a, b) for a, b in zip(aliceValues, bobValues)), key=sum, reverse=True) return cmp(sum(a for a, _ in sorted_vals[::2]), sum(b for _, b in sorted_vals[1::2])) ", "class Solution def nextClosestTime(self, time): h, m = time.split(\":\") curr = int(h) * 60 + int(m) result = None for i in xrange(curr+1, curr+1441): t = i % 1440 h, m = t // 60, t % 60 result = \"%02d:%02d\" % (h, m) if set(result) <= set(time): break return result ", "class Solution def reachableNodes(self, n, edges, restricted): adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) result = 0 lookup = [False]*n for x in restricted: lookup[x] = True q = [0] lookup[0] = True while q: new_q = [] for u in q: result += 1 for v in adj[u]: if lookup[v]: continue lookup[v] = True new_q.append(v) q = new_q return result ", "class Solution def minMoves(self, target, maxDoubles): result = 0 while target > 1 and maxDoubles: result += 1+target%2 target //= 2 maxDoubles -= 1 return result+(target-1) ", "class Solution def superpalindromesInRange(self, L, R): def is_palindrome(k): return str(k) == str(k)[::-1] K = int((10**((len(R)+1)*0.25))) l, r = int(L), int(R) result = 0 for k in xrange(K): s = str(k) t = s + s[-2::-1] v = int(t)**2 if v > r: break if v >= l and is_palindrome(v): result += 1 for k in xrange(K): s = str(k) t = s + s[::-1] v = int(t)**2 if v > r: break if v >= l and is_palindrome(v): result += 1 return result ", "class Solution def minimumTotal(self, triangle): if not triangle: return 0 cur = triangle[0] + [float(\"inf\")] for i in xrange(1, len(triangle)): next = [] next.append(triangle[i][0] + cur[0]) for j in xrange(1, i + 1): next.append(triangle[i][j] + min(cur[j - 1], cur[j])) cur = next + [float(\"inf\")] return reduce(min, cur) ", "class Solution def numberOfRounds(self, startTime, finishTime): h1, m1 = map(int, startTime.split(\":\")) h2, m2 = map(int, finishTime.split(\":\")) start = h1*60+m1 finish = h2*60+m2 if start > finish: finish += 1440 return max(finish//15-(start+15-1)//15, 0) ", "class Solution def numberOfRounds(self, startTime, finishTime): h1, m1 = map(int, startTime.split(\":\")) h2, m2 = map(int, finishTime.split(\":\")) if m1 > m2: h2 -= 1 m2 += 60 return max((h2-h1)%24*4 + m2//15 - (m1+15-1)//15, 0) ", "class Solution def subArrayRanges(self, nums): result = 0 stk = [] for i in xrange(len(nums)+1): x = nums[i] if i < len(nums) else float(\"inf\") while stk and nums[stk[-1]] <= x: j = stk.pop() k = stk[-1] if stk else -1 result += nums[j]*(j-k)*(i-j) stk.append(i) stk = [] for i in xrange(len(nums)+1): x = nums[i] if i < len(nums) else float(\"-inf\") while stk and nums[stk[-1]] >= x: j = stk.pop() k = stk[-1] if stk else -1 result -= nums[j]*(j-k)*(i-j) stk.append(i) return result ", "class Solution def minTime(self, n, edges, hasApple): graph = collections.defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) result = [0, 0] s = [(1, (-1, 0, result))] while s: step, params = s.pop() if step == 1: par, node, ret = params ret[:] = [0, int(hasApple[node])] for nei in reversed(graph[node]): if nei == par: continue new_ret = [0, 0] s.append((2, (new_ret, ret))) s.append((1, (node, nei, new_ret))) else: new_ret, ret = params ret[0] += new_ret[0]+new_ret[1] ret[1] |= bool(new_ret[0]+new_ret[1]) return 2*result[0] class Solution_Recu(object): def minTime(self, n, edges, hasApple): def dfs(graph, par, node, hasApple): result, extra = 0, int(hasApple[node]) for nei in graph[node]: if nei == par: continue count, found = dfs(graph, node, nei, hasApple) result += count+found extra |= bool(count+found) return result, extra graph = collections.defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) return 2*dfs(graph, -1, 0, hasApple)[0] ", "class Solution def minTime(self, n, edges, hasApple): graph = collections.defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) result = [0] s = [(1, (-1, 0, result))] while s: step, params = s.pop() if step == 1: par, node, ret = params tmp = [int(hasApple[node])] s.append((3, (tmp, ret))) for nei in reversed(graph[node]): if nei == par: continue new_ret = [0] s.append((2, (new_ret, tmp, ret))) s.append((1, (node, nei, new_ret))) elif step == 2: new_ret, tmp, ret = params ret[0] += new_ret[0] tmp[0] |= bool(new_ret[0]) else: tmp, ret = params ret[0] += tmp[0] return 2*max(result[0]-1, 0) class Solution2_Recu(object): def minTime(self, n, edges, hasApple): def dfs(graph, par, node, has_subtree): result, extra = 0, int(hasApple[node]) for nei in graph[node]: if nei == par: continue count = dfs(graph, node, nei, hasApple) result += count extra |= bool(count) return result+extra graph = collections.defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) return 2*max(dfs(graph, -1, 0, hasApple)-1, 0) ", "class Solution def minOperations(self, nums, numsDivide): def gcd(a, b): while b: a, b = b, a%b return a g = reduce(gcd, numsDivide) mn = float(\"inf\") for x in nums: if g%x == 0: mn = min(mn, x) return sum(x < mn for x in nums) if mn != float(\"inf\") else -1 ", "class Solution def numberOfWays(self, s): K = 3 dp = [[0]*2 for _ in xrange(K)] for c in s: j = ord(c)-ord('0') dp[0][j] += 1 for i in xrange(1, len(dp)): dp[i][j] += dp[i-1][1^j] return dp[-1][0]+dp[-1][1] ", "class Solution def findLength(self, A, B): if len(A) < len(B): return self.findLength(B, A) result = 0 dp = [[0] * (len(B)+1) for _ in xrange(2)] for i in xrange(len(A)): for j in xrange(len(B)): if A[i] == B[j]: dp[(i+1)%2][j+1] = dp[i%2][j]+1 else: dp[(i+1)%2][j+1] = 0 result = max(result, max(dp[(i+1)%2])) return result ", "class Solution def findLength(self, A, B): if len(A) > len(B): return self.findLength(B, A) M, p = 10**9+7, 113 p_inv = pow(p, M-2, M) def check(guess): def rolling_hashes(source, length): if length == 0: yield 0, 0 return val, power = 0, 1 for i, x in enumerate(source): val = (val + x*power) % M if i < length - 1: power = (power*p) % M else: yield val, i-(length-1) val = (val-source[i-(length-1)])*p_inv % M hashes = collections.defaultdict(list) for hash_val, i in rolling_hashes(A, guess): hashes[hash_val].append(i) for hash_val, j in rolling_hashes(B, guess): if any(A[i:i+guess] == B[j:j+guess] for i in hashes[hash_val]): return True return False left, right = 0, min(len(A), len(B)) + 1 while left < right: mid = left + (right-left)/2 if not check(mid): right = mid else: left = mid+1 return left-1 ", "class Solution def findLength(self, A, B): if len(A) > len(B): return self.findLength(B, A) def check(length): lookup = set(A[i:i+length] for i in xrange(len(A)-length+1)) return any(B[j:j+length] in lookup for j in xrange(len(B)-length+1)) A = ''.join(map(chr, A)) B = ''.join(map(chr, B)) left, right = 0, min(len(A), len(B)) + 1 while left < right: mid = left + (right-left)/2 if not check(mid): right = mid else: left = mid+1 return left-1 ", "class Solution def equalCountSubstrings(self, s, count): result = 0 for l in xrange(1, min(len(set(s)), len(s)//count)+1): cnt, equal_cnt = collections.Counter(), 0 for i, c in enumerate(s): cnt[c] += 1 equal_cnt += (cnt[c] == count) if i >= count*l: equal_cnt -= (cnt[s[i-count*l]] == count) cnt[s[i-count*l]] -= 1 result += (equal_cnt == l) return result ", "class Solution def hardestWorker(self, n, logs): return logs[max(xrange(len(logs)), key=lambda x: (logs[x][1]-(logs[x-1][1] if x-1 >= 0 else 0), -logs[x][0]))][0] ", "class Solution def minArrayLength(self, nums, k): if 0 in nums: return 1 result = len(nums) curr = nums[0] for i in xrange(1, len(nums)): if curr*nums[i] > k: curr = nums[i] else: curr *= nums[i] result -= 1 return result ", "class Solution def minOperations(self, nums, target): def floor_log2_x(x): return x.bit_length()-1 total = sum(nums) if total < target: return -1 cnt = [0]*(floor_log2_x(max(nums))+1) for x in nums: cnt[floor_log2_x(x)] += 1 result = 0 for i in reversed(xrange(len(cnt))): for _ in xrange(cnt[i]): x = 1<<i if x <= target: target -= x total -= x elif total-x >= target: total -= x else: cnt[i-1] += 2 result += 1 return result ", "class Solution def minOperations(self, nums, target): total = sum(nums) if total < target: return -1 nums.sort() result = 0 while target: x = nums.pop() if x <= target: target -= x total -= x elif total-x >= target: total -= x else: nums.append(x//2) nums.append(x//2) result += 1 return result import heapq ", "class Solution def minOperations(self, nums, target): total = sum(nums) if total < target: return -1 result = 0 max_heap = [-x for x in nums] heapq.heapify(max_heap) while target: x = -heapq.heappop(max_heap) if x <= target: target -= x total -= x elif total-x >= target: total -= x else: heapq.heappush(max_heap, -x//2) heapq.heappush(max_heap, -x//2) result += 1 return result ", "class Solution def minOperations(self, nums, target): def floor_log2_x(x): return x.bit_length()-1 if sum(nums) < target: return -1 cnt = [0]*(floor_log2_x(max(nums))+1) for x in nums: cnt[floor_log2_x(x)] += 1 result = i = 0 while i < len(cnt): if target&(1<<i): if not cnt[i]: j = next(j for j in xrange(i, len(cnt)) if cnt[j]) result += j-i j = i cnt[i] -= 1 continue cnt[i] -= 1 if i+1 < len(cnt): cnt[i+1] += cnt[i]//2 i += 1 return result ", "class Solution def swapNodes(self, head, k): left, right, curr = None, None, head while curr: k -= 1 if right: right = right.next if k == 0: left = curr right = head curr = curr.next left.val, right.val = right.val, left.val return head ", "class Solution def smallestSubsequence(self, s, k, letter, repetition): stk = [] suffix = [0]*(len(s)+1) for i in reversed(xrange(len(suffix)-1)): suffix[i] = suffix[i+1]+(s[i] == letter) for i, c in enumerate(s): while stk and stk[-1] > c and len(stk)+(len(s)-i) > k and (stk[-1] != letter or repetition+1 <= suffix[i]): repetition += (stk.pop() == letter) if len(stk) < min(k-(repetition-(c == letter)), k): repetition -= (c == letter) stk.append(c) return \"\".join(stk) ", "class Solution def minimumCost(self, nums): def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 def nearest_palindromic(x): n = str(x) l = len(n) result = {10**l+1, 10**(l-1)-1} prefix = int(n[:(l+1)/2]) for i in map(str, (prefix-1, prefix, prefix+1)): result.add(int(i+[i, i[:-1]][l%2][::-1])) return result nth_element(nums, len(nums)//2) median = nums[len(nums)//2] if len(nums)%2 == 0: nth_element(nums, len(nums)//2-1) median = (median+nums[len(nums)//2-1])//2 return min(sum(abs(x-p) for x in nums) for p in nearest_palindromic(median)) ", "class Solution def minimumCost(self, nums): def nearest_palindromic(x): n = str(x) l = len(n) result = {10**l+1, 10**(l-1)-1} prefix = int(n[:(l+1)/2]) for i in map(str, (prefix-1, prefix, prefix+1)): result.add(int(i+[i, i[:-1]][l%2][::-1])) return result nums.sort() median = nums[len(nums)//2] if len(nums)%2 == 0: median = (median+nums[len(nums)//2-1])//2 return min(sum(abs(x-p) for x in nums) for p in nearest_palindromic(median)) ", "class Solution def makeSimilar(self, nums, target): nums.sort(key=lambda x: (x%2, x)) target.sort(key=lambda x: (x%2, x)) return sum(abs(x-y)//2 for x, y in itertools.izip(nums, target))//2 ", "class Solution def maximumSumSubsequence(self, nums, queries): MOD = 10**9+7 L0R0, L1R0, L0R1, L1R1 = range(4) class SegmentTree(object): def __init__(self, N, build_fn=lambda _: None, query_fn=lambda x, y: y if x is None else x if y is None else max(x, y), update_fn=lambda x: x): self.tree = [None]*(1<<((N-1).bit_length()+1)) self.base = len(self.tree)>>1 self.query_fn = query_fn self.update_fn = update_fn for i in xrange(self.base, self.base+N): self.tree[i] = build_fn(i-self.base) for i in reversed(xrange(1, self.base)): self.tree[i] = query_fn(self.tree[i<<1], self.tree[(i<<1)+1]) def update(self, i, h): x = self.base+i self.tree[x] = self.update_fn(h) while x > 1: x >>= 1 self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1]) def query(self, L, R): L += self.base R += self.base left = right = None while L <= R: if L & 1: left = self.query_fn(left, self.tree[L]) L += 1 if R & 1 == 0: right = self.query_fn(self.tree[R], right) R -= 1 L >>= 1 R >>= 1 return self.query_fn(left, right) def build(i): return [max(nums[i], 0), 0, 0, 0] def query(x, y): if x is None: return y if y is None: return x return [max(x[L0R1]+y[L1R0], x[L0R0]+y[L1R0], x[L0R1]+y[L0R0]), max(x[L1R1]+y[L1R0], x[L1R0]+y[L1R0], x[L1R1]+y[L0R0]), max(x[L0R1]+y[L1R1], x[L0R0]+y[L1R1], x[L0R1]+y[L0R1]), max(x[L1R1]+y[L1R1], x[L1R0]+y[L1R1], x[L1R1]+y[L0R1])] st = SegmentTree(len(nums), build_fn=build, query_fn=query) result = 0 for i, x in queries: st.update(i, [max(x, 0), 0, 0, 0]) result = (result+max(st.tree[1]))%MOD return result ", "class Solution def maximumScore(self, nums, multipliers): dp = [0]*(len(multipliers)+1) for l, m in enumerate(reversed(multipliers), start=len(nums)-len(multipliers)): dp = [max(m*nums[i]+dp[i+1], m*nums[i+l]+dp[i]) for i in xrange(len(dp)-1)] return dp[0] ", "class Solution def halveArray(self, nums): target = sum(nums)/2.0 max_heap = [-x for x in nums] heapq.heapify(max_heap) result = 1 while max_heap: x = -heapq.heappop(max_heap)/2.0 target -= x if target <= 0.0: break heapq.heappush(max_heap, -x) result += 1 return result ", "class Solution def subarraysWithKDistinct(self, A, K): def atMostK(A, K): count = collections.defaultdict(int) result, left = 0, 0 for right in xrange(len(A)): count[A[right]] += 1 while len(count) > K: count[A[left]] -= 1 if count[A[left]] == 0: count.pop(A[left]) left += 1 result += right-left+1 return result return atMostK(A, K) - atMostK(A, K-1) class Window(object): def __init__(self): self.__count = collections.defaultdict(int) def add(self, x): self.__count[x] += 1 def remove(self, x): self.__count[x] -= 1 if self.__count[x] == 0: self.__count.pop(x) def size(self): return len(self.__count) ", "class Solution def subarraysWithKDistinct(self, A, K): window1, window2 = Window(), Window() result, left1, left2 = 0, 0, 0 for i in A: window1.add(i) while window1.size() > K: window1.remove(A[left1]) left1 += 1 window2.add(i) while window2.size() >= K: window2.remove(A[left2]) left2 += 1 result += left2-left1 return result ", "class Solution def numberOfWays(self, n, x): MOD = 10**9+7 dp = [0]*(n+1) dp[0] = 1 for i in xrange(1, n+1): i_pow_x = i**x if i_pow_x > n: break for j in reversed(xrange(i_pow_x, n+1)): dp[j] = (dp[j]+dp[j-i_pow_x])%MOD return dp[-1] ", "class Solution def minIncrementForUnique(self, A): A.sort() A.append(float(\"inf\")) result, duplicate = 0, 0 for i in xrange(1, len(A)): if A[i-1] == A[i]: duplicate += 1 result -= A[i] else: move = min(duplicate, A[i]-A[i-1]-1) duplicate -= move result += move*A[i-1] + move*(move+1)//2 return result ", "class Solution def hasGroupsSizeX(self, deck): def gcd(a, b): while b: a, b = b, a % b return a vals = collections.Counter(deck).values() return reduce(gcd, vals) >= 2 ", "class Solution def maximumLengthSubstring(self, s): COUNT = 2 result = 0 cnt = [0]*26 left = invalid_cnt = 0 for right, x in enumerate(s): if cnt[ord(x)-ord('a')] == COUNT: invalid_cnt += 1 cnt[ord(x)-ord('a')] += 1 if invalid_cnt: cnt[ord(s[left])-ord('a')] -= 1 if cnt[ord(s[left])-ord('a')] == COUNT: invalid_cnt -= 1 left += 1 return right-left+1 ", "class Solution def maximumLengthSubstring(self, s): COUNT = 2 result = 0 cnt = [0]*26 left = 0 for right, x in enumerate(s): cnt[ord(x)-ord('a')] += 1 while cnt[ord(x)-ord('a')] > COUNT: cnt[ord(s[left])-ord('a')] -= 1 left += 1 result = max(result, right-left+1) return result ", "class Solution def summaryRanges(self, nums): ranges = [] if not nums: return ranges start, end = nums[0], nums[0] for i in xrange(1, len(nums) + 1): if i < len(nums) and nums[i] == end + 1: end = nums[i] else: interval = str(start) if start != end: interval += \"->\" + str(end) ranges.append(interval) if i < len(nums): start = end = nums[i] return ranges ", "class Solution def summaryRanges(self, nums): return [re.sub('->.*>', '->', '->'.join(repr(n) for _, n in g)) for _, g in itertools.groupby(enumerate(nums), lambda i_n: i_n[1]-i_n[0])] ", "class Solution def evenProduct(self, nums): result = (len(nums)+1)*len(nums)//2 cnt = 0 for x in nums: cnt = cnt+1 if x%2 else 0 result -= cnt return result ", "class Solution def evenProduct(self, nums): result = cnt = 0 for i, x in enumerate(nums): if x%2 == 0: cnt = i+1 result += cnt return result ", "class Solution def minNumberOfSemesters(self, n, dependencies, k): reqs = [0]*n for u, v in dependencies: reqs[v-1] |= 1 << (u-1) dp = [n]*(1<<n) dp[0] = 0 for mask in xrange(1<<n): candidates = [] for v in xrange(n): if (mask&(1<<v)) == 0 and (mask&reqs[v]) == reqs[v]: candidates.append(v) for choice in itertools.combinations(candidates, min(len(candidates), k)): new_mask = mask for v in choice: new_mask |= 1<<v dp[new_mask] = min(dp[new_mask], dp[mask]+1) return dp[-1] import collections import heapq class Solution_WA(object): def minNumberOfSemesters(self, n, dependencies, k): def dfs(graph, i, depths): if depths[i] == -1: depths[i] = max(dfs(graph, child, depths) for child in graph[i])+1 if i in graph else 1 return depths[i] degrees = [0]*n graph = collections.defaultdict(list) for u, v in dependencies: graph[u-1].append(v-1) degrees[v-1] += 1 depths = [-1]*n for i in xrange(n): dfs(graph, i, depths) max_heap = [] for i in xrange(n): if not degrees[i]: heapq.heappush(max_heap, (-depths[i], i)) result = 0 while max_heap: new_q = [] for _ in xrange(min(len(max_heap), k)): _, node = heapq.heappop(max_heap) if node not in graph: continue for child in graph[node]: degrees[child] -= 1 if not degrees[child]: new_q.append(child) result += 1 for node in new_q: heapq.heappush(max_heap, (-depths[node], node)) return result ", "class Solution def minimumMoves(self, grid): level, q, lookup = 0, [(0, 0, False)], set() while q: next_q = [] for r, c, is_vertical in q: if (r, c, is_vertical) in lookup: continue if (r, c, is_vertical) == (len(grid)-1, len(grid)-2, False): return level lookup.add((r, c, is_vertical)) if not is_vertical: if c+2 != len(grid[0]) and grid[r][c+2] == 0: next_q.append((r, c+1, is_vertical)) if r+1 != len(grid) and grid[r+1][c] == 0 and grid[r+1][c+1] == 0: next_q.append((r+1, c, is_vertical)) next_q.append((r, c, not is_vertical)) else: if r+2 != len(grid) and grid[r+2][c] == 0: next_q.append((r+1, c, is_vertical)) if c+1 != len(grid) and grid[r][c+1] == 0 and grid[r+1][c+1] == 0: next_q.append((r, c+1, is_vertical)) next_q.append((r, c, not is_vertical)) q = next_q level += 1 return -1 ", "class Solution def smallestMissingValueSubtree(self, parents, nums): def iter_dfs(adj, nums, i, lookup): stk = [i] while stk: i = stk.pop() if nums[i] in lookup: continue lookup.add(nums[i]) for j in adj[i]: stk.append(j) result = [1]*len(parents) i = next((i for i in xrange(len(nums)) if nums[i] == 1), -1) if i == -1: return result adj = [[] for _ in xrange(len(parents))] for j in xrange(1, len(parents)): adj[parents[j]].append(j) lookup = set() miss = 1 while i >= 0: iter_dfs(adj, nums, i, lookup) while miss in lookup: miss += 1 result[i] = miss i = parents[i] return result ", "class Solution def minimizeSet(self, divisor1, divisor2, uniqueCnt1, uniqueCnt2): def gcd(a, b): while b: a, b = b, a%b return a def lcm(a, b): return a//gcd(a, b)*b def count(cnt, d1, d2): l = lcm(d1, d2) return cnt+cnt//(l-1)-int(cnt%(l-1) == 0) return max(count(uniqueCnt1, divisor1, 1), count(uniqueCnt2, divisor2, 1), count(uniqueCnt1+uniqueCnt2, divisor1, divisor2)) ", "class Solution def minimizeSet(self, divisor1, divisor2, uniqueCnt1, uniqueCnt2): def gcd(a, b): while b: a, b = b, a%b return a def lcm(a, b): return a//gcd(a, b)*b def check(cnt): return (cnt-cnt//divisor1 >= uniqueCnt1 and cnt-cnt//divisor2 >= uniqueCnt2 and cnt-cnt//l >= uniqueCnt1+uniqueCnt2) l = lcm(divisor1, divisor2) left, right = 2, 2**31-1 while left <= right: mid = left+(right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left ", "class Solution def minOperationsMaxProfit(self, customers, boardingCost, runningCost): max_run = -1 i = max_prof = prof = waiting = 0 run = 1 while i < len(customers) or waiting > 0: if i < len(customers): waiting += customers[i] i += 1 boarding = min(waiting, 4) waiting -= boarding prof += boarding * boardingCost - runningCost if prof > max_prof: max_prof = prof max_run = run run += 1 return max_run ", "class Solution def evenOddBit(self, n): def popcount(x): return bin(x)[2:].count('1') return [popcount(n&0b0101010101), popcount(n&0b1010101010)] ", "class Solution def minOperations(self, nums1, nums2, k): cnt1 = cnt2 = 0 for x, y in itertools.izip(nums1, nums2): if y == x: continue if k == 0 or (y-x)%k: return -1 if x < y: cnt1 += (y-x)//k else: cnt2 += (x-y)//k return cnt1 if cnt1 == cnt2 else -1 ", "class Solution def mergeTwoLists(self, l1, l2): curr = dummy = ListNode(0) while l1 and l2: if l1.val < l2.val: curr.next = l1 l1 = l1.next else: curr.next = l2 l2 = l2.next curr = curr.next curr.next = l1 or l2 return dummy.next ", "class Solution def minNumberOfFrogs(self, croakOfFrogs): S = \"croak\" lookup = [0]*len(S) result = 0 for c in croakOfFrogs: i = S.find(c) lookup[i] += 1 if lookup[i-1]: lookup[i-1] -= 1 elif i == 0: result += 1 else: return -1 return result if result == lookup[-1] else -1 ", "class Solution def sumRootToLeaf(self, root): M = 10**9 + 7 def sumRootToLeafHelper(root, val): if not root: return 0 val = (val*2 + root.val) % M if not root.left and not root.right: return val return (sumRootToLeafHelper(root.left, val) + sumRootToLeafHelper(root.right, val)) % M return sumRootToLeafHelper(root, 0) ", "class Solution def findNumberOfLIS(self, nums): result, max_len = 0, 0 dp = [[1, 1] for _ in xrange(len(nums))] for i in xrange(len(nums)): for j in xrange(i): if nums[i] > nums[j]: if dp[i][0] == dp[j][0]+1: dp[i][1] += dp[j][1] elif dp[i][0] < dp[j][0]+1: dp[i] = [dp[j][0]+1, dp[j][1]] if max_len == dp[i][0]: result += dp[i][1] elif max_len < dp[i][0]: max_len = dp[i][0] result = dp[i][1] return result ", "class Solution def minSwaps(self, grid): result = 0 for target in reversed(xrange(1, len(grid))): row_idx = len(grid)-1-target while row_idx < len(grid): row = grid[row_idx] if not sum(itertools.islice(row, len(row)-target, len(row))): break row_idx += 1 else: return -1 while row_idx != len(grid)-1-target: grid[row_idx], grid[row_idx-1] = grid[row_idx-1], grid[row_idx] result += 1 row_idx -= 1 return result ", "class Solution def minimumDeletions(self, s): result = b_cnt = 0 for c in s: if c == 'b': b_cnt += 1 elif b_cnt: b_cnt -= 1 result += 1 return result ", "class Solution def canWinNim(self, n): return n % 4 != 0 ", "class Solution def reformat(self, s): def char_gen(start, end, count): for c in xrange(ord(start), ord(end)+1): c = chr(c) for i in xrange(count[c]): yield c yield '' count = collections.defaultdict(int) alpha_cnt = 0 for c in s: count[c] += 1 if c.isalpha(): alpha_cnt += 1 if abs(len(s)-2*alpha_cnt) > 1: return \"\" result = [] it1, it2 = char_gen('a', 'z', count), char_gen('0', '9', count) if alpha_cnt < len(s)-alpha_cnt: it1, it2 = it2, it1 while len(result) < len(s): result.append(next(it1)) result.append(next(it2)) return \"\".join(result) ", "class Solution def findRLEArray(self, encoded1, encoded2): result = [] i = j = remain1 = remain2 = 0 while (remain1 or i < len(encoded1)) and (remain2 or j < len(encoded2)): if not remain1: remain1 = encoded1[i][1] i += 1 if not remain2: remain2 = encoded2[j][1] j += 1 cnt = min(remain1, remain2) remain1 -= cnt remain2 -= cnt if result and result[-1][0] == encoded1[i-1][0]*encoded2[j-1][0]: result[-1][1] += cnt else: result.append([encoded1[i-1][0]*encoded2[j-1][0], cnt]) return result ", "class Solution def singleNumber(self, nums): x_xor_y = reduce(operator.xor, nums) bit = x_xor_y & -x_xor_y result = [0, 0] for i in nums: result[bool(i & bit)] ^= i return result ", "class Solution def singleNumber(self, nums): x_xor_y = 0 for i in nums: x_xor_y ^= i bit = x_xor_y & ~(x_xor_y - 1) x = 0 for i in nums: if i & bit: x ^= i return [x, x ^ x_xor_y] ", "class Solution def singleNumber(self, nums): return [x[0] for x in sorted(collections.Counter(nums).items(), key=lambda i: i[1], reverse=False)[:2]] ", "class Solution def arrangeWords(self, text): result = text.split() result[0] = result[0].lower() result.sort(key=len) result[0] = result[0].title() return \" \".join(result) ", "class Solution def numberOfBeams(self, bank): result = prev = 0 for x in bank: cnt = x.count('1') if not cnt: continue result += prev*cnt prev = cnt return result ", "class Solution def smallestSubarrays(self, nums): result = [0]*len(nums) lookup = [-1]*max(max(nums).bit_length(), 1) for i in reversed(xrange(len(nums))): for bit in xrange(len(lookup)): if nums[i]&(1<<bit): lookup[bit] = i result[i] = max(max(lookup)-i+1, 1) return result ", "class Solution def numberOfArrays(self, s, k): MOD = 10**9 + 7 klen = len(str(k)) dp = [0]*(klen+1) dp[len(s)%len(dp)] = 1 for i in reversed(xrange(len(s))): dp[i%len(dp)] = 0 if s[i] == '0': continue curr = 0 for j in xrange(i, min(i+klen, len(s))): curr = 10*curr + int(s[j]) if curr > k: break dp[i%len(dp)] = (dp[i%len(dp)] + dp[(j+1)%len(dp)])%MOD return dp[0] ", "class Solution def strangePrinter(self, s): def dp(s, i, j, lookup): if i > j: return 0 if (i, j) not in lookup: lookup[(i, j)] = dp(s, i, j-1, lookup) + 1 for k in xrange(i, j): if s[k] == s[j]: lookup[(i, j)] = min(lookup[(i, j)], dp(s, i, k, lookup) + dp(s, k+1, j-1, lookup)) return lookup[(i, j)] lookup = {} return dp(s, 0, len(s)-1, lookup) ", "class Solution def minCost(self, nums, k): dp = [float(\"inf\")]*(len(nums)+1) dp[0] = 0 for i in xrange(len(dp)-1): cnt = [0]*len(nums) d = 0 for j in xrange(i+1, len(dp)): cnt[nums[j-1]] += 1 if cnt[nums[j-1]] == 1: d += 1 elif cnt[nums[j-1]] == 2: d -= 1 dp[j] = min(dp[j], dp[i]+k+((j-i)-d)) return dp[-1] ", "class Solution def wordBreak(self, s, wordDict): n = len(s) max_len = 0 for string in wordDict: max_len = max(max_len, len(string)) can_break = [False for _ in xrange(n + 1)] can_break[0] = True for i in xrange(1, n + 1): for l in xrange(1, min(i, max_len) + 1): if can_break[i-l] and s[i-l:i] in wordDict: can_break[i] = True break return can_break[-1] ", "class Solution def isNumber(self, s): transition_table = [[-1, 0, 3, 1, 2, -1], [-1, 8, -1, 1, 4, 5], [-1, -1, -1, 4, -1, -1], [-1, -1, -1, 1, 2, -1], [-1, 8, -1, 4, -1, 5], [-1, -1, 6, 7, -1, -1], [-1, -1, -1, 7, -1, -1], [-1, 8, -1, 7, -1, -1], [-1, 8, -1, -1, -1, -1]] state = 0 for char in s: inputType = InputType.INVALID if char.isspace(): inputType = InputType.SPACE elif char == '+' or char == '-': inputType = InputType.SIGN elif char.isdigit(): inputType = InputType.DIGIT elif char == '.': inputType = InputType.DOT elif char == 'e' or char == 'E': inputType = InputType.EXPONENT state = transition_table[state][inputType] if state == -1: return False return state == 1 or state == 4 or state == 7 or state == 8 ", "class Solution def isNumber(self, s): import re return bool(re.match(\"^\\s*[\\+-]?((\\d+(\\.\\d*)?)|\\.\\d+)([eE][\\+-]?\\d+)?\\s*$\", s)) ", "class Solution def earliestAndLatest(self, n, firstPlayer, secondPlayer): def memoization(t, l, r, lookup): if (t, l, r) not in lookup: if l == r: return (1, 1) if l > r: l, r, = r, l result = [float(\"inf\"), 0] for i in xrange(l+1): l_win_cnt, l_lose_cnt, nt, pair_cnt = i+1, l-i, (t+1)//2, t//2 min_j = max(l_lose_cnt, r-(pair_cnt-l_lose_cnt)) max_j = min(r-l_win_cnt, (nt-l_win_cnt)-1) for j in xrange(min_j, max_j+1): tmp = memoization(nt, i, j, lookup) result = min(result[0], tmp[0]+1), max(result[1], tmp[1]+1) lookup[t, l, r] = result return lookup[t, l, r] return memoization(n, firstPlayer-1, n-secondPlayer, {}) ", "class Solution def mostFrequentIDs(self, nums, freq): result = [] cnt = collections.Counter() max_heap = [] for x, f in itertools.izip(nums, freq): cnt[x] += f heapq.heappush(max_heap, (-cnt[x], x)) while max_heap and -max_heap[0][0] != cnt[max_heap[0][1]]: heapq.heappop(max_heap) result.append(-max_heap[0][0] if max_heap else 0) return result import collections import itertools from sortedcontainers import SortedList ", "class Solution def mostFrequentIDs(self, nums, freq): result = [] cnt = collections.Counter() cnt2 = collections.Counter() sl = SortedList() for x, f in itertools.izip(nums, freq): sl.discard((cnt[x], cnt2[cnt[x]])) cnt2[cnt[x]] -= 1 if cnt2[cnt[x]]: sl.add((cnt[x], cnt2[cnt[x]])) cnt[x] += f sl.discard((cnt[x], cnt2[cnt[x]])) cnt2[cnt[x]] += 1 sl.add((cnt[x], cnt2[cnt[x]])) result.append(sl[-1][0]) return result ", "class Solution def maximumSetSize(self, nums1, nums2): lookup1, lookup2 = set(nums1), set(nums2) n, c = len(nums1), len(lookup1&lookup2) d1, d2 = min(len(lookup1)-c, n//2), min(len(lookup2)-c, n//2) return min(n, d1+d2+c) ", "class Solution def maximumSetSize(self, nums1, nums2): lookup1, lookup2 = set(nums1), set(nums2) n, c = len(nums1), len(lookup1&lookup2) d1, d2 = min(len(lookup1)-c, n//2), min(len(lookup2)-c, n//2) r1, r2 = n//2-d1, n//2-d2 return d1+d2+min(r1+r2, c) ", "class Solution def numOfMinutes(self, n, headID, manager, informTime): children = collections.defaultdict(list) for child, parent in enumerate(manager): if parent != -1: children[parent].append(child) result = 0 stk = [(headID, 0)] while stk: node, curr = stk.pop() curr += informTime[node] result = max(result, curr) if node not in children: continue for c in children[node]: stk.append((c, curr)) return result ", "class Solution def numOfMinutes(self, n, headID, manager, informTime): def dfs(informTime, children, node): return (max(dfs(informTime, children, c) for c in children[node]) if node in children else 0) + informTime[node] children = collections.defaultdict(list) for child, parent in enumerate(manager): if parent != -1: children[parent].append(child) return dfs(informTime, children, headID) ", "class Solution def maximum69Number (self, num): curr, base, change = num, 3, 0 while curr: if curr%10 == 6: change = base base *= 10 curr //= 10 return num+change ", "class Solution def maximum69Number (self, num): return int(str(num).replace('6', '9', 1)) ", "class Solution def minimumMoney(self, transactions): return sum(max(a-b, 0) for a, b in transactions)+max(a-max(a-b, 0) for a, b in transactions) ", "class Solution def countExcellentPairs(self, nums, k): def popcount(x): return bin(x)[2:].count('1') cnt = collections.Counter(popcount(x) for x in set(nums)) return sum(cnt[i]*cnt[j] for i in cnt.iterkeys() for j in cnt.iterkeys() if i+j >= k) ", "class Solution def countExcellentPairs(self, nums, k): def popcount(x): return bin(x)[2:].count('1') sorted_cnts = sorted(popcount(x) for x in set(nums)) result = 0 left, right = 0, len(sorted_cnts)-1 while left <= right: if sorted_cnts[left]+sorted_cnts[right] < k: left += 1 else: result += 1+2*((right-1)-left+1) right -= 1 return result ", "class Solution def maxPrice(self, items, capacity): result = 0 items.sort(key=lambda x: float(x[0])/x[1], reverse=True) for p, c in items: cnt = min(c, capacity) capacity -= cnt result += (float(p)/c)*cnt return result if capacity == 0 else -1 ", "class Solution def canBeIncreasing(self, nums): deleted = False for i in xrange(1, len(nums)): if nums[i] > nums[i-1]: continue if deleted: return False deleted = True if i >= 2 and nums[i-2] > nums[i]: nums[i] = nums[i-1] return True ", "class Solution def minAddToMakeValid(self, S): add, bal, = 0, 0 for c in S: bal += 1 if c == '(' else -1 if bal == -1: add += 1 bal += 1 return add + bal ", "class Solution def findPaths(self, m, n, N, x, y): M = 1000000000 + 7 dp = [[[0 for _ in xrange(n)] for _ in xrange(m)] for _ in xrange(2)] for moves in xrange(N): for i in xrange(m): for j in xrange(n): dp[(moves + 1) % 2][i][j] = (((1 if (i == 0) else dp[moves % 2][i - 1][j]) + (1 if (i == m - 1) else dp[moves % 2][i + 1][j])) % M + ((1 if (j == 0) else dp[moves % 2][i][j - 1]) + (1 if (j == n - 1) else dp[moves % 2][i][j + 1])) % M) % M return dp[N % 2][x][y] ", "class Solution def minimumCost(self, s): return sum(min(i+1, len(s)-(i+1)) for i in xrange(len(s)-1) if s[i] != s[i+1]) ", "class Solution def zeroFilledSubarray(self, nums): result = 0 prev = -1 for i in xrange(len(nums)): if nums[i]: prev = i continue result += i-prev return result ", "class Solution def numOfSubarrays(self, arr, k, threshold): result, curr = 0, sum(itertools.islice(arr, 0, k-1)) for i in xrange(k-1, len(arr)): curr += arr[i]-(arr[i-k] if i-k >= 0 else 0) result += int(curr >= threshold*k) return result ", "class Solution def numOfSubarrays(self, arr, k, threshold): accu = [0] for x in arr: accu.append(accu[-1]+x) result = 0 for i in xrange(len(accu)-k): if accu[i+k]-accu[i] >= threshold*k: result += 1 return result ", "class Solution def countPoints(self, rings): bits = {'R':0b001, 'G':0b010, 'B':0b100} rods = collections.defaultdict(int) for i in xrange(0, len(rings), 2): rods[int(rings[i+1])] |= bits[rings[i]] return sum(x == 0b111 for x in rods.itervalues()) ", "class Solution def maxProduct(self, nums): m1 = m2 = 0 for num in nums: if num > m1: m1, m2 = num, m1 elif num > m2: m2 = num return (m1-1)*(m2-1) ", "class Solution def getSkyline(self, buildings): intervals = self.ComputeSkylineInInterval(buildings, 0, len(buildings)) res = [] last_end = -1 for interval in intervals: if last_end != -1 and last_end < interval[start]: res.append([last_end, 0]) res.append([interval[start], interval[height]]) last_end = interval[end] if last_end != -1: res.append([last_end, 0]) return res def ComputeSkylineInInterval(self, buildings, left_endpoint, right_endpoint): if right_endpoint - left_endpoint <= 1: return buildings[left_endpoint:right_endpoint] mid = left_endpoint + ((right_endpoint - left_endpoint) / 2) left_skyline = self.ComputeSkylineInInterval(buildings, left_endpoint, mid) right_skyline = self.ComputeSkylineInInterval(buildings, mid, right_endpoint) return self.MergeSkylines(left_skyline, right_skyline) def MergeSkylines(self, left_skyline, right_skyline): i, j = 0, 0 merged = [] while i < len(left_skyline) and j < len(right_skyline): if left_skyline[i][end] < right_skyline[j][start]: merged.append(left_skyline[i]) i += 1 elif right_skyline[j][end] < left_skyline[i][start]: merged.append(right_skyline[j]) j += 1 elif left_skyline[i][start] <= right_skyline[j][start]: i, j = self.MergeIntersectSkylines(merged, left_skyline[i], i, right_skyline[j], j) else: j, i = self.MergeIntersectSkylines(merged, right_skyline[j], j, left_skyline[i], i) merged += left_skyline[i:] merged += right_skyline[j:] return merged def MergeIntersectSkylines(self, merged, a, a_idx, b, b_idx): if a[end] <= b[end]: if a[height] > b[height]: if b[end] != a[end]: b[start] = a[end] merged.append(a) a_idx += 1 else: b_idx += 1 elif a[height] == b[height]: b[start] = a[start] a_idx += 1 else: if a[start] != b[start]: merged.append([a[start], b[start], a[height]]) a_idx += 1 else: if a[height] >= b[height]: b_idx += 1 else: if a[start] != b[start]: merged.append([a[start], b[start], a[height]]) a[start] = b[end] merged.append(b) b_idx += 1 return a_idx, b_idx ", "class Solution def depthSum(self, nestedList): def depthSumHelper(nestedList, depth): res = 0 for l in nestedList: if l.isInteger(): res += l.getInteger() * depth else: res += depthSumHelper(l.getList(), depth + 1) return res return depthSumHelper(nestedList, 1) ", "class Solution def minimizeError(self, prices, target): def kthElement(nums, k, compare=lambda a, b: a < b): def PartitionAroundPivot(left, right, pivot_idx, nums, compare): new_pivot_idx = left nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx] for i in xrange(left, right): if compare(nums[i], nums[right]): nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i] new_pivot_idx += 1 nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right] return new_pivot_idx left, right = 0, len(nums) - 1 while left <= right: pivot_idx = random.randint(left, right) new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare) if new_pivot_idx == k: return elif new_pivot_idx > k: right = new_pivot_idx - 1 else: left = new_pivot_idx + 1 errors = [] lower, upper = 0, 0 for i, p in enumerate(map(float, prices)): lower += int(math.floor(p)) upper += int(math.ceil(p)) if p != math.floor(p): errors.append(p-math.floor(p)) if not lower <= target <= upper: return \"-1\" lower_round_count = upper-target kthElement(errors, lower_round_count) result = 0.0 for i in xrange(len(errors)): if i < lower_round_count: result += errors[i] else: result += 1.0-errors[i] return \"{:.3f}\".format(result) ", "class Solution def maxProductDifference(self, nums): largest, smallest = [0]*2, [float(\"inf\")]*2 for x in nums: if x >= largest[0]: largest[:] = [x, largest[0]] elif x > largest[1]: largest[1] =x if x <= smallest[0]: smallest[:] = [x, smallest[0]] elif x < smallest[1]: smallest[1] = x return largest[0]*largest[1] - smallest[0]*smallest[1] ", "class Solution def minMoves(self, nums, k): def moves(i, j): return prefix[j+1]-prefix[i] idxs = [i for i, x in enumerate(nums) if x] prefix = [0]*(len(idxs)+1) for i in xrange(len(idxs)): prefix[i+1] = prefix[i]+idxs[i] result = float(\"inf\") for i in xrange(len(idxs)-k+1): result = min(result, -moves(i, i+k//2-1) + moves(i+(k+1)//2, i+k-1)) result -= (k//2)*((k+1)//2) return result ", "class Solution def superEggDrop(self, K, N): def check(n, K, N): total, c = 0, 1 for k in xrange(1, K+1): c *= n-k+1 c //= k total += c if total >= N: return True return False left, right = 1, N while left <= right: mid = left + (right-left)//2 if check(mid, K, N): right = mid-1 else: left = mid+1 return left ", "class Solution def checkValidString(self, s): lower, upper = 0, 0 for c in s: lower += 1 if c == '(' else -1 upper -= 1 if c == ')' else -1 if upper < 0: break lower = max(lower, 0) return lower == 0 ", "class Solution def colorTheArray(self, n, queries): def update(i): if not nums[i]: return 0 cnt = 0 if i-1 >= 0 and nums[i-1] == nums[i]: cnt += 1 if i+1 < n and nums[i+1] == nums[i]: cnt += 1 return cnt nums = [0]*n result = [0]*len(queries) curr = 0 for idx, (i, c) in enumerate(queries): curr -= update(i) nums[i] = c curr += update(i) result[idx] = curr return result ", "class Solution def numberOfSets(self, n, k): def nCr(n, k, mod): return (fact[n]*inv_fact[n-k] % mod) * inv_fact[k] % mod return nCr(n+k-1, 2*k, MOD) ", "class Solution def numberOfSets(self, n, k): MOD = 10**9+7 def nCr(n, r): if n-r < r: return nCr(n, n-r) c = 1 for k in xrange(1, r+1): c *= n-k+1 c //= k return c return nCr(n+k-1, 2*k) % MOD ", "class Solution def minimumDifference(self, nums): max_heap = [] for i in xrange(len(nums)//3): heapq.heappush(max_heap, -nums[i]) prefix = [0]*(len(nums)//3+1) prefix[0] = -sum(max_heap) for i in xrange(len(nums)//3): x = -heapq.heappushpop(max_heap, -nums[i+len(nums)//3]) prefix[i+1] = prefix[i]-x+nums[i+len(nums)//3] min_heap = [] for i in reversed(xrange(len(nums)//3*2, len(nums))): heapq.heappush(min_heap, nums[i]) suffix = sum(min_heap) result = prefix[len(nums)//3]-suffix for i in reversed(xrange(len(nums)//3)): x = heapq.heappushpop(min_heap, nums[i+len(nums)//3]) suffix += -x+nums[i+len(nums)//3] result = min(result, prefix[i]-suffix) return result ", "class Solution def findSmallestRegion(self, regions, region1, region2): parents = {region[i] : region[0] for region in regions for i in xrange(1, len(region))} lookup = {region1} while region1 in parents: region1 = parents[region1] lookup.add(region1) while region2 not in lookup: region2 = parents[region2] return region2 ", "class Solution def repeatedNTimes(self, A): for i in xrange(2, len(A)): if A[i-1] == A[i] or A[i-2] == A[i]: return A[i] return A[0] ", "class Solution def totalSteps(self, nums): dp = [0]*len(nums) stk = [] for i in reversed(xrange(len(nums))): while stk and nums[stk[-1]] < nums[i]: dp[i] = max(dp[i]+1, dp[stk.pop()]) stk.append(i) return max(dp) ", "class Solution def totalSteps(self, nums): dp = [0]*len(nums) stk = [] for i in xrange(len(nums)): curr = 0 while stk and nums[stk[-1]] <= nums[i]: curr = max(curr, dp[stk.pop()]) if stk: dp[i] = curr+1 stk.append(i) return max(dp) ", "class Solution def maxSumOfThreeSubarrays(self, nums, k): n = len(nums) accu = [0] for num in nums: accu.append(accu[-1]+num) left_pos = [0] * n total = accu[k]-accu[0] for i in xrange(k, n): if accu[i+1]-accu[i+1-k] > total: left_pos[i] = i+1-k total = accu[i+1]-accu[i+1-k] else: left_pos[i] = left_pos[i-1] right_pos = [n-k] * n total = accu[n]-accu[n-k] for i in reversed(xrange(n-k)): if accu[i+k]-accu[i] > total: right_pos[i] = i total = accu[i+k]-accu[i] else: right_pos[i] = right_pos[i+1] result, max_sum = [], 0 for i in xrange(k, n-2*k+1): left, right = left_pos[i-1], right_pos[i+k] total = (accu[i+k]-accu[i]) + (accu[left+k]-accu[left]) + (accu[right+k]-accu[right]) if total > max_sum: max_sum = total result = [left, i, right] return result ", "class Solution def numberOfCleanRooms(self, room): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] result = r = c = d = 0 while not room[r][c]&(1<<(d+1)): result += (room[r][c]>>1) == 0 room[r][c] |= (1<<(d+1)) dr, dc = directions[d] nr, nc = r+dr, c+dc if 0 <= nr < len(room) and 0 <= nc < len(room[0]) and not (room[nr][nc]&1): r, c = nr, nc else: d = (d+1)%4 return result ", "class Solution def minCost(self, houses, cost, m, n, target): dp = [[[float(\"inf\") for _ in xrange(n)] for _ in xrange(target)] for _ in xrange(2)] for i in xrange(m): dp[i%2] = [[float(\"inf\") for _ in xrange(n)] for _ in xrange(target)] for j in xrange(min(target, i+1)): for k in xrange(n): if houses[i] and houses[i]-1 != k: continue same = dp[(i-1)%2][j][k] if i-1 >= 0 else 0 diff = (min([dp[(i-1)%2][j-1][nk] for nk in xrange(n) if nk != k] or [float(\"inf\")]) if j-1 >= 0 else float(\"inf\")) if i-1 >= 0 else 0 paint = cost[i][k] if not houses[i] else 0 dp[i%2][j][k] = min(same, diff)+paint result = min(dp[(m-1)%2][-1]) return result if result != float(\"inf\") else -1 ", "class Solution def minCost(self, houses, cost, m, n, target): dp = {(0, 0): 0} for i, p in enumerate(houses): new_dp = {} for nk in (xrange(1, n+1) if not p else [p]): for j, k in dp: nj = j + (k != nk) if nj > target: continue new_dp[nj, nk] = min(new_dp.get((nj, nk), float(\"inf\")), dp[j, k] + (cost[i][nk-1] if nk != p else 0)) dp = new_dp return min([dp[j, k] for j, k in dp if j == target] or [-1]) ", "class Solution def shuffle(self, nums, n): def index(i): return 2*i if i < n else 2*(i-n)+1 for i in xrange(len(nums)): j = i while nums[i] >= 0: j = index(j) nums[i], nums[j] = nums[j], ~nums[i] for i in xrange(len(nums)): nums[i] = ~nums[i] return nums ", "class Solution def numberOfBoomerangs(self, points): result = 0 for i in xrange(len(points)): group = collections.defaultdict(int) for j in xrange(len(points)): if j == i: continue dx, dy = points[i][0] - points[j][0], points[i][1] - points[j][1] group[dx**2 + dy**2] += 1 for _, v in group.iteritems(): if v > 1: result += v * (v-1) return result def numberOfBoomerangs2(self, points): cnt = 0 for a, i in enumerate(points): dis_list = [] for b, k in enumerate(points[:a] + points[a + 1:]): dis_list.append((k[0] - i[0]) ** 2 + (k[1] - i[1]) ** 2) for z in collections.Counter(dis_list).values(): if z > 1: cnt += z * (z - 1) return cnt ", "class Solution def minimumSplits(self, nums): def gcd(a, b): while b: a, b = b, a%b return a result, g = 1, 0 for x in nums: g = gcd(g, x) if g == 1: g = x result += 1 return result ", "class Solution def numPairsDivisibleBy60(self, time): result = 0 count = collections.Counter() for t in time: result += count[-t%60] count[t%60] += 1 return result ", "class Solution def minimumTime(self, hens, grains): def check(x): i = 0 for h in hens: if h-grains[i] > x: return False elif h-grains[i] > 0: d = h-grains[i] c = max(x-2*d, (x-d)//2) else: c = x while i < len(grains) and grains[i] <= h+c: i += 1 if i == len(grains): return True return False hens.sort() grains.sort() left, right = 0, 2*(max(grains[-1], hens[-1])-min(grains[0], hens[0])) while left <= right: mid = left+(right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left ", "class Solution def findMinDifference(self, timePoints): minutes = map(lambda x: int(x[:2]) * 60 + int(x[3:]), timePoints) minutes.sort() return min((y - x) % (24 * 60) for x, y in zip(minutes, minutes[1:] + minutes[:1])) ", "class Solution def frequencySort(self, nums): count = collections.Counter(nums) return sorted(nums, key=lambda x: (count[x], -x)) ", "class Solution def nthSuperUglyNumber(self, n, primes): heap, uglies, idx, ugly_by_last_prime = [], [0] * n, [0] * len(primes), [0] * n uglies[0] = 1 for k, p in enumerate(primes): heapq.heappush(heap, (p, k)) for i in xrange(1, n): uglies[i], k = heapq.heappop(heap) ugly_by_last_prime[i] = k idx[k] += 1 while ugly_by_last_prime[idx[k]] > k: idx[k] += 1 heapq.heappush(heap, (primes[k] * uglies[idx[k]], k)) return uglies[-1] ", "class Solution def nthSuperUglyNumber(self, n, primes): uglies, idx, heap, ugly_set = [0] * n, [0] * len(primes), [], set([1]) uglies[0] = 1 for k, p in enumerate(primes): heapq.heappush(heap, (p, k)) ugly_set.add(p) for i in xrange(1, n): uglies[i], k = heapq.heappop(heap) while (primes[k] * uglies[idx[k]]) in ugly_set: idx[k] += 1 heapq.heappush(heap, (primes[k] * uglies[idx[k]], k)) ugly_set.add(primes[k] * uglies[idx[k]]) return uglies[-1] ", "class Solution def nthSuperUglyNumber(self, n, primes): uglies, idx, heap = [1], [0] * len(primes), [] for k, p in enumerate(primes): heapq.heappush(heap, (p, k)) for i in xrange(1, n): min_val, k = heap[0] uglies += [min_val] while heap[0][0] == min_val: min_val, k = heapq.heappop(heap) idx[k] += 1 heapq.heappush(heap, (primes[k] * uglies[idx[k]], k)) return uglies[-1] ", "class Solution def nthSuperUglyNumber(self, n, primes): uglies = [0] * n uglies[0] = 1 ugly_by_prime = list(primes) idx = [0] * len(primes) for i in xrange(1, n): uglies[i] = min(ugly_by_prime) for k in xrange(len(primes)): if uglies[i] == ugly_by_prime[k]: idx[k] += 1 ugly_by_prime[k] = primes[k] * uglies[idx[k]] return uglies[-1] ", "class Solution def nthSuperUglyNumber(self, n, primes): ugly_number = 0 heap = [] heapq.heappush(heap, 1) for p in primes: heapq.heappush(heap, p) for _ in xrange(n): ugly_number = heapq.heappop(heap) for i in xrange(len(primes)): if ugly_number % primes[i] == 0: for j in xrange(i + 1): heapq.heappush(heap, ugly_number * primes[j]) break return ugly_number ", "class Solution def maxValue(self, events, k): events.sort(key=lambda x: x[1]) sorted_ends = [x[1] for x in events] dp = [[0]*(k+1) for _ in xrange(len(events)+1)] for i in xrange(1, len(events)+1): prev_i_m_1 = bisect.bisect_left(sorted_ends, events[i-1][0])-1 for j in xrange(1, k+1): dp[i][j] = max(dp[i-1][j], dp[prev_i_m_1+1][j-1]+events[i-1][2]) return dp[-1][-1] import bisect ", "class Solution def maxValue(self, events, k): events.sort() sorted_starts = [x[0] for x in events] dp = [[0]*(k+1) for _ in xrange(len(events)+1)] for i in reversed(xrange(len(events))): next_i = bisect.bisect_right(sorted_starts, events[i][1])-1 for j in xrange(1, k+1): dp[i][j] = max(dp[i+1][j], dp[next_i+1][j-1]+events[i][2]) return dp[0][-1] ", "class Solution def goodBinaryStrings(self, minLength, maxLength, oneGroup, zeroGroup): MOD = 10**9+7 result = 0 w = max(oneGroup, zeroGroup)+1 dp = [0]*w for i in xrange(maxLength+1): dp[i%w] = 1 if i == 0 else 0 if i-oneGroup >= 0: dp[i%w] = (dp[i%w]+dp[(i-oneGroup)%w])%MOD if i-zeroGroup >= 0: dp[i%w] = (dp[i%w]+dp[(i-zeroGroup)%w])%MOD if i >= minLength: result = (result+dp[i%w])%MOD return result ", "class Solution def goodBinaryStrings(self, minLength, maxLength, oneGroup, zeroGroup): MOD = 10**9+7 result = 0 w = max(oneGroup, zeroGroup)+1 dp = [0]*w dp[0] = 1 for i in xrange(maxLength+1): if i >= minLength: result = (result+dp[i%w])%MOD if i+oneGroup <= maxLength: dp[(i+oneGroup)%w] = (dp[(i+oneGroup)%w]+dp[i%w])%MOD if i+zeroGroup <= maxLength: dp[(i+zeroGroup)%w] = (dp[(i+zeroGroup)%w]+dp[i%w])%MOD dp[i%w] = 0 return result ", "class Solution def scoreOfString(self, s): return sum(abs(ord(s[i+1])-ord(s[i])) for i in xrange(len(s)-1)) ", "class Solution def removeOuterParentheses(self, S): deep = 1 result, cnt = [], 0 for c in S: if c == '(' and cnt >= deep: result.append(c) if c == ')' and cnt > deep: result.append(c) cnt += 1 if c == '(' else -1 return \"\".join(result) ", "class Solution def removeOnes(self, grid): return all(grid[i] == grid[0] or all(grid[i][j] != grid[0][j] for j in xrange(len(grid[0]))) for i in xrange(1, len(grid))) ", "class Solution def projectionArea(self, grid): result = 0 for i in xrange(len(grid)): max_row, max_col = 0, 0 for j in xrange(len(grid)): if grid[i][j]: result += 1 max_row = max(max_row, grid[i][j]) max_col = max(max_col, grid[j][i]) result += max_row + max_col return result ", "class Solution def minimumWhiteTiles(self, floor, numCarpets, carpetLen): dp = [[0]*(numCarpets+1) for _ in xrange(len(floor)+1)] for i in xrange(1, len(dp)): dp[i][0] = dp[i-1][0] + int(floor[i-1]) for j in xrange(1, numCarpets+1): dp[i][j] = min(dp[i-1][j] + int(floor[i-1]), dp[max(i-carpetLen, 0)][j-1]) return dp[-1][-1] ", "class Solution def findItinerary(self, tickets): adj = collections.defaultdict(list) for ticket in tickets: adj[ticket[0]].append(ticket[1]) for x in adj.itervalues(): x.sort(reverse=True) origin = \"JFK\" result = [] stk = [origin] while stk: while adj[stk[-1]]: stk.append(adj[stk[-1]].pop()) result.append(stk.pop()) result.reverse() return result import collections ", "class Solution def findItinerary(self, tickets): def route_helper(origin, ticket_cnt, graph, ans): if ticket_cnt == 0: return True for i, (dest, valid) in enumerate(graph[origin]): if valid: graph[origin][i][1] = False ans.append(dest) if route_helper(dest, ticket_cnt - 1, graph, ans): return ans ans.pop() graph[origin][i][1] = True return False graph = collections.defaultdict(list) for ticket in tickets: graph[ticket[0]].append([ticket[1], True]) for k in graph.keys(): graph[k].sort() origin = \"JFK\" ans = [origin] route_helper(origin, len(tickets), graph, ans) return ans ", "class Solution def reversePrefix(self, word, ch): i = word.find(ch) return word[:i+1][::-1]+word[i+1:] ", "class Solution def removeComments(self, source): in_block = False result, newline = [], [] for line in source: i = 0 while i < len(line): if not in_block and i+1 < len(line) and line[i:i+2] == '/*': in_block = True i += 1 elif in_block and i+1 < len(line) and line[i:i+2] == '*/': in_block = False i += 1 elif not in_block and i+1 < len(line) and line[i:i+2] == '//': break elif not in_block: newline.append(line[i]) i += 1 if newline and not in_block: result.append(\"\".join(newline)) newline = [] return result ", "class Solution def minInterval(self, intervals, queries): intervals.sort() queries = [(q, i) for i, q in enumerate(queries)] queries.sort() min_heap = [] i = 0 result =[-1]*len(queries) for q, idx in queries: while i != len(intervals) and intervals[i][0] <= q: heapq.heappush(min_heap, [intervals[i][1]-intervals[i][0]+1, i]) i += 1 while min_heap and intervals[min_heap[0][1]][1] < q: heapq.heappop(min_heap) result[idx] = min_heap[0][0] if min_heap else -1 return result ", "class Solution def trapRainWater(self, heightMap): m = len(heightMap) if not m: return 0 n = len(heightMap[0]) if not n: return 0 is_visited = [[False for i in xrange(n)] for j in xrange(m)] heap = [] for i in xrange(m): heappush(heap, [heightMap[i][0], i, 0]) is_visited[i][0] = True heappush(heap, [heightMap[i][n-1], i, n-1]) is_visited[i][n-1] = True for j in xrange(1, n-1): heappush(heap, [heightMap[0][j], 0, j]) is_visited[0][j] = True heappush(heap, [heightMap[m-1][j], m-1, j]) is_visited[m-1][j] = True trap = 0 while heap: height, i, j = heappop(heap) for (dx, dy) in [(1,0), (-1,0), (0,1), (0,-1)]: x, y = i+dx, j+dy if 0 <= x < m and 0 <= y < n and not is_visited[x][y]: trap += max(0, height - heightMap[x][y]) heappush(heap, [max(height, heightMap[x][y]), x, y]) is_visited[x][y] = True return trap ", "class Solution def maximumTop(self, nums, k): if len(nums) == 1 == k%2: return -1 if k <= 1: return nums[k] return max(nums[i] for i in xrange(min(k+1, len(nums))) if i != k-1) ", "class Solution def waysToSplitArray(self, nums): total = sum(nums) result = curr = 0 for i in xrange(len(nums)-1): curr += nums[i] result += int(curr >= total-curr) return result ", "class Solution def reorderLogFiles(self, logs): def f(log): i, content = log.split(\" \", 1) return (0, content, i) if content[0].isalpha() else (1,) logs.sort(key=f) return logs ", "class Solution def minimumRightShifts(self, nums): i = next((i for i in xrange(len(nums)) if not nums[i] < nums[(i+1)%len(nums)]), len(nums)) j = next((j for j in xrange(i+1, len(nums)) if not nums[j%len(nums)] < nums[(j+1)%len(nums)]), len(nums)) return len(nums)-(i+1) if j == len(nums) else -1 ", "class Solution def mergeKLists(self, lists): def mergeTwoLists(l1, l2): curr = dummy = ListNode(0) while l1 and l2: if l1.val < l2.val: curr.next = l1 l1 = l1.next else: curr.next = l2 l2 = l2.next curr = curr.next curr.next = l1 or l2 return dummy.next if not lists: return None left, right = 0, len(lists) - 1 while right > 0: lists[left] = mergeTwoLists(lists[left], lists[right]) left += 1 right -= 1 if left >= right: left = 0 return lists[0] ", "class Solution def mergeKLists(self, lists): def mergeTwoLists(l1, l2): curr = dummy = ListNode(0) while l1 and l2: if l1.val < l2.val: curr.next = l1 l1 = l1.next else: curr.next = l2 l2 = l2.next curr = curr.next curr.next = l1 or l2 return dummy.next def mergeKListsHelper(lists, begin, end): if begin > end: return None if begin == end: return lists[begin] return mergeTwoLists(mergeKListsHelper(lists, begin, (begin + end) / 2), mergeKListsHelper(lists, (begin + end) / 2 + 1, end)) return mergeKListsHelper(lists, 0, len(lists) - 1) import heapq ", "class Solution def mergeKLists(self, lists): dummy = ListNode(0) current = dummy heap = [] for sorted_list in lists: if sorted_list: heapq.heappush(heap, (sorted_list.val, sorted_list)) while heap: smallest = heapq.heappop(heap)[1] current.next = smallest current = current.next if smallest.next: heapq.heappush(heap, (smallest.next.val, smallest.next)) return dummy.next ", "class Solution def isPalindrome(self, s): i, j = 0, len(s) - 1 while i < j: while i < j and not s[i].isalnum(): i += 1 while i < j and not s[j].isalnum(): j -= 1 if s[i].lower() != s[j].lower(): return False i, j = i + 1, j - 1 return True ", "class Solution def minCost(self, costs): if not costs: return 0 min_cost = [costs[0], [0, 0, 0]] n = len(costs) for i in xrange(1, n): min_cost[i % 2][0] = costs[i][0] + min(min_cost[(i - 1) % 2][1], min_cost[(i - 1) % 2][2]) min_cost[i % 2][1] = costs[i][1] + min(min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][2]) min_cost[i % 2][2] = costs[i][2] + min(min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][1]) return min(min_cost[(n - 1) % 2]) ", "class Solution def minCost(self, costs): if not costs: return 0 n = len(costs) for i in xrange(1, n): costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]) costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]) costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]) return min(costs[n - 1]) ", "class Solution def findFrequentTreeSum(self, root): def countSubtreeSumHelper(root, counts): if not root: return 0 total = root.val + countSubtreeSumHelper(root.left, counts) + countSubtreeSumHelper(root.right, counts) counts[total] += 1 return total counts = collections.defaultdict(int) countSubtreeSumHelper(root, counts) max_count = max(counts.values()) if counts else 0 return [total for total, count in counts.iteritems() if count == max_count] ", "class Solution def findMaxForm(self, strs, m, n): dp = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)] for s in strs: zero_count, one_count = 0, 0 for c in s: if c == '0': zero_count += 1 elif c == '1': one_count += 1 for i in reversed(xrange(zero_count, m+1)): for j in reversed(xrange(one_count, n+1)): dp[i][j] = max(dp[i][j], dp[i-zero_count][j-one_count]+1) return dp[m][n] ", "class Solution def countComponents(self, n, edges): union_find = UnionFind(n) for i, j in edges: union_find.union_set(i, j) return union_find.count ", "class Solution def minTransfers(self, transactions): accounts = collections.defaultdict(int) for src, dst, amount in transactions: accounts[src] += amount accounts[dst] -= amount debts = [account for account in accounts.itervalues() if account] dp = [0]*(2**len(debts)) sums = [0]*(2**len(debts)) for i in xrange(len(dp)): bit = 1 for j in xrange(len(debts)): if (i & bit) == 0: nxt = i | bit sums[nxt] = sums[i]+debts[j] if sums[nxt] == 0: dp[nxt] = max(dp[nxt], dp[i]+1) else: dp[nxt] = max(dp[nxt], dp[i]) bit <<= 1 return len(debts)-dp[-1] ", "class Solution def arithmeticTriplets(self, nums, diff): lookup = set(nums) return sum((x-diff in lookup) and (x-2*diff in lookup) for x in nums) import collections ", "class Solution def arithmeticTriplets(self, nums, diff): result = 0 cnt1 = collections.Counter() cnt2 = collections.Counter() for x in nums: result += cnt2[x-diff] cnt2[x] += cnt1[x-diff] cnt1[x] += 1 return result ", "class Solution def generateTrees(self, n): return self.generateTreesRecu(1, n) def generateTreesRecu(self, low, high): result = [] if low > high: result.append(None) for i in xrange(low, high + 1): left = self.generateTreesRecu(low, i - 1) right = self.generateTreesRecu(i + 1, high) for j in left: for k in right: cur = TreeNode(i) cur.left = j cur.right = k result.append(cur) return result ", "class Solution def numberOfCategories(self, n, categoryHandler): return sum(all(not categoryHandler.haveSameCategory(j, i) for j in xrange(i)) for i in xrange(n)) ", "class Solution def minMalwareSpread(self, graph, initial): initial_set = set(initial) clean = [i for i in xrange(len(graph)) if i not in initial_set] union_find = UnionFind(len(graph)) for i in xrange(len(clean)): for j in xrange(i+1, len(clean)): if graph[clean[i]][clean[j]] == 1: union_find.union_set(clean[i], clean[j]) union_size = collections.Counter(union_find.find_set(i) for i in xrange(len(graph))) shared_union = collections.defaultdict(set) for i in initial: for j in clean: if graph[i][j] == 1: x = union_find.find_set(j) shared_union[x].add(i) result, total = float(\"inf\"), float(\"-inf\") for i in initial: lookup = set() curr = 0 for j in clean: if graph[i][j] == 1: x = union_find.find_set(j) if len(shared_union[x]) == 1 and x not in lookup: curr += union_size[x] lookup.add(x) if curr > total or (curr == total and i < result): total = curr result = i return result ", "class Solution def maxValueAfterReverse(self, nums): result, add, max_pair, min_pair = 0, 0, float(\"-inf\"), float(\"inf\") for i in xrange(1, len(nums)): result += abs(nums[i-1]-nums[i]) add = max(add, abs(nums[0]-nums[i]) - abs(nums[i-1]-nums[i]), abs(nums[-1]-nums[i-1]) - abs(nums[i-1]-nums[i])) min_pair = min(min_pair, max(nums[i-1], nums[i])) max_pair = max(max_pair, min(nums[i-1], nums[i])) return result + max(add, (max_pair-min_pair)*2) ", "class Solution def isPrintable(self, targetGrid): VISITING, VISITED = range(2) def has_cycle(adj, color, lookup): stk = [(1, color)] while stk: step, color = stk.pop() if step == 1: lookup[color] = VISITING stk.append((2, color)) for new_color in adj[color]: if new_color in lookup: if lookup[new_color] == VISITED: continue return True stk.append((1, new_color)) elif step == 2: lookup[color] = VISITED return False boxes = collections.defaultdict(lambda:[len(targetGrid), len(targetGrid[0]), -1, -1]) for r, row in enumerate(targetGrid): for c, color in enumerate(row): boxes[color][0] = min(boxes[color][0], r) boxes[color][1] = min(boxes[color][1], c) boxes[color][2] = max(boxes[color][2], r) boxes[color][3] = max(boxes[color][3], c) adj = collections.defaultdict(set) for color, (min_r, min_c, max_r, max_c) in boxes.iteritems(): for r in xrange(min_r, max_r+1): for c in xrange(min_c, max_c+1): if targetGrid[r][c] != color: adj[color].add(targetGrid[r][c]) lookup = {} return all(color in lookup or not has_cycle(adj, color, lookup) for color in boxes.iterkeys()) ", "class Solution def isPrintable(self, targetGrid): VISITING, VISITED = range(2) def has_cycle(adj, color, lookup): lookup[color] = VISITING for new_color in adj[color]: if (new_color not in lookup and has_cycle(adj, new_color, lookup)) or lookup[new_color] == VISITING: return True lookup[color] = VISITED return False MAX_COLOR = 60 adj = collections.defaultdict(set) for color in xrange(1, MAX_COLOR+1): min_r = len(targetGrid) min_c = len(targetGrid[0]) max_r = -1 max_c = -1 for r in xrange(len(targetGrid)): for c in xrange(len(targetGrid[r])): if targetGrid[r][c] == color: min_r = min(min_r, r) min_c = min(min_c, c) max_r = max(max_r, r) max_c = max(max_c, c) for r in xrange(min_r, max_r+1): for c in xrange(min_c, max_c+1): if targetGrid[r][c] != color: adj[color].add(targetGrid[r][c]) lookup = {} return all(color in lookup or not has_cycle(adj, color, lookup) for color in xrange(1, MAX_COLOR+1)) ", "class Solution def minScore(self, n, roads): def bfs(): lookup = [False]*len(adj) q = [0] lookup[0] = True while q: new_q = [] for u in q: for v, _ in adj[u]: if lookup[v]: continue lookup[v] = True new_q.append(v) q = new_q return lookup adj = [[] for _ in xrange(n)] for u, v, w in roads: adj[u-1].append((v-1, w)) adj[v-1].append((u-1, w)) lookup = bfs() return min(w for u, _, w in roads if lookup[u-1]) ", "class Solution def minimumSeconds(self, nums): lookup = collections.defaultdict(int) dist = collections.defaultdict(int) for i in xrange(2*len(nums)): x = nums[i%len(nums)] dist[x] = max(dist[x], i-lookup[x]) lookup[x] = i return min(dist.itervalues())//2 ", "class Solution def singleNumber(self, A): one, two = 0, 0 for x in A: one, two = (~x & one) | (x & ~one & ~two), (~x & two) | (x & one) return one ", "class Solution def singleNumber(self, A): one, two, carry = 0, 0, 0 for x in A: two |= one & x one ^= x carry = one & two one &= ~carry two &= ~carry return one ", "class Solution def singleNumber(self, nums): return (collections.Counter(list(set(nums)) * 3) - collections.Counter(nums)).keys()[0] ", "class Solution def singleNumber(self, nums): return (sum(set(nums)) * 3 - sum(nums)) / 2 class SolutionEX(object): def singleNumber(self, A): one, two, three = 0, 0, 0 for x in A: one, two, three = (~x & one) | (x & ~one & ~two & ~three), (~x & two) | (x & one), (~x & three) | (x & two) return two ", "class Solution def findShortestPath(self, master): directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)} rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'} def dfs(pos, target, master, lookup, adj): if target[0] is None and master.isTarget(): target[0] = pos lookup.add(pos) for d, (di, dj) in directions.iteritems(): if not master.canMove(d): continue nei = (pos[0]+di, pos[1]+dj) if nei in adj[pos]: continue adj[pos][nei] = master.move(d) if nei not in lookup: dfs(nei, target, master, lookup, adj) adj[nei][pos] = master.move(rollback[d]) def dijkstra(adj, start, target): dist = {start:0} min_heap = [(0, start)] while min_heap: curr, u = heapq.heappop(min_heap) if dist[u] < curr: continue for v, w in adj[u].iteritems(): if v in dist and dist[v] <= curr+w: continue dist[v] = curr+w heapq.heappush(min_heap, (curr+w, v)) return dist[target] if target in dist else -1 start = (0, 0) target = [None] adj = collections.defaultdict(dict) dfs(start, target, master, set(), adj) if not target[0]: return -1 return dijkstra(adj, start, target[0]) ", "class Solution def countDifferentSubsequenceGCDs(self, nums): max_num, nums_set = max(nums), set(nums) result = 0 for i in xrange(1, max_num+1): d = 0 for x in xrange(i, max_num+1, i): if x not in nums_set: continue d = fractions.gcd(d, x) if d == i: result += 1 break return result ", "class Solution def findRelativeRanks(self, nums): sorted_nums = sorted(nums)[::-1] ranks = [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"] + map(str, range(4, len(nums) + 1)) return map(dict(zip(sorted_nums, ranks)).get, nums) ", "class Solution def captureForts(self, forts): result = left = 0 for right in xrange(len(forts)): if not forts[right]: continue if forts[right] == -forts[left]: result = max(result, right-left-1) left = right return result ", "class Solution def wordPatternMatch(self, pattern, str): w2p, p2w = {}, {} return self.match(pattern, str, 0, 0, w2p, p2w) def match(self, pattern, str, i, j, w2p, p2w): is_match = False if i == len(pattern) and j == len(str): is_match = True elif i < len(pattern) and j < len(str): p = pattern[i] if p in p2w: w = p2w[p] if w == str[j:j+len(w)]: is_match = self.match(pattern, str, i + 1, j + len(w), w2p, p2w) else: for k in xrange(j, len(str)): w = str[j:k+1] if w not in w2p: w2p[w], p2w[p] = p, w is_match = self.match(pattern, str, i + 1, k + 1, w2p, p2w) w2p.pop(w), p2w.pop(p) if is_match: break return is_match ", "class Solution def stoneGame(self, piles): if len(piles) % 2 == 0 or len(piles) == 1: return True dp = [0] * len(piles) for i in reversed(xrange(len(piles))): dp[i] = piles[i] for j in xrange(i+1, len(piles)): dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1]) return dp[-1] >= 0 ", "class Solution def threeEqualParts(self, A): total = sum(A) if total % 3 != 0: return [-1, -1] if total == 0: return [0, len(A)-1] count = total//3 nums = [0]*3 c = 0 for i in xrange(len(A)): if A[i] == 1: if c % count == 0: nums[c//count] = i c += 1 while nums[2] != len(A): if not A[nums[0]] == A[nums[1]] == A[nums[2]]: return [-1, -1] nums[0] += 1 nums[1] += 1 nums[2] += 1 return [nums[0]-1, nums[1]] ", "class Solution def minimizeXor(self, num1, num2): def popcount(x): return bin(x)[2:].count('1') cnt1, cnt2 = popcount(num1), popcount(num2) result = num1 cnt = abs(cnt1-cnt2) expect = 1 if cnt1 >= cnt2 else 0 i = 0 while cnt: if ((num1>>i)&1) == expect: cnt -= 1 result ^= 1<<i i += 1 return result ", "class Solution def maxSideLength(self, mat, threshold): def check(dp, mid, threshold): for i in xrange(mid, len(dp)): for j in xrange(mid, len(dp[0])): if dp[i][j] - dp[i-mid][j] - dp[i][j-mid] + dp[i-mid][j-mid] <= threshold: return True return False dp = [[0 for _ in xrange(len(mat[0])+1)] for _ in xrange(len(mat)+1)] for i in xrange(1, len(mat)+1): for j in xrange(1, len(mat[0])+1): dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1] left, right = 0, min(len(mat), len(mat[0])+1) while left <= right: mid = left + (right-left)//2 if not check(dp, mid, threshold): right = mid-1 else: left = mid+1 return right ", "class Solution def pathInZigZagTree(self, label): count = 2**label.bit_length() result = [] while label >= 1: result.append(label) label = ((count//2) + ((count-1)-label)) // 2 count //= 2 result.reverse() return result ", "class Solution def getSmallestString(self, n, k): MAX_DIFF = ord('z')-ord('a') k -= n result = ['a']*n for i in reversed(xrange(n)): tmp = min(k, MAX_DIFF) result[i] = chr(ord('a')+tmp) k -= tmp if k == 0: break return \"\".join(result) ", "class Solution def waysToSplit(self, nums): MOD = 10**9+7 prefix = [0] for x in nums: prefix.append(prefix[-1]+x) result = left = right = 0 for i in xrange(len(nums)): left = max(left, i+1) while left+1 < len(nums) and prefix[i+1] > prefix[left+1]-prefix[i+1]: left += 1 right = max(right, left) while right+1 < len(nums) and prefix[right+1]-prefix[i+1] <= prefix[-1]-prefix[right+1]: right += 1 result = (result + (right-left))%MOD return result ", "class Solution def smallestStringWithSwaps(self, s, pairs): union_find = UnionFind(len(s)) for x,y in pairs: union_find.union_set(x, y) components = collections.defaultdict(list) for i in xrange(len(s)): components[union_find.find_set(i)].append(s[i]) for i in components.iterkeys(): components[i].sort(reverse=True) result = [] for i in xrange(len(s)): result.append(components[union_find.find_set(i)].pop()) return \"\".join(result) import itertools ", "class Solution def smallestStringWithSwaps(self, s, pairs): def dfs(i, adj, lookup, component): lookup.add(i) component.append(i) for j in adj[i]: if j in lookup: continue dfs(j, adj, lookup, component) adj = collections.defaultdict(list) for i, j in pairs: adj[i].append(j) adj[j].append(i) lookup = set() result = list(s) for i in xrange(len(s)): if i in lookup: continue component = [] dfs(i, adj, lookup, component) component.sort() chars = sorted(result[k] for k in component) for comp, char in itertools.izip(component, chars): result[comp] = char return \"\".join(result) ", "class Solution def findShortestPath(self, master): directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)} rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'} def dfs(pos, target, master, lookup, adj): if target[0] is None and master.isTarget(): target[0] = pos lookup.add(pos) for d, (di, dj) in directions.iteritems(): if not master.canMove(d): continue nei = (pos[0]+di, pos[1]+dj) adj[pos].add(nei) adj[nei].add(pos) if nei in lookup: continue master.move(d) dfs(nei, target, master, lookup, adj) master.move(rollback[d]) def bi_bfs(adj, start, target): left, right = {start}, {target} lookup = set() steps = 0 while left: for pos in left: lookup.add(pos) new_left = set() for pos in left: if pos in right: return steps for nei in adj[pos]: if nei in lookup: continue new_left.add(nei) left = new_left steps += 1 if len(left) > len(right): left, right = right, left return -1 start = (0, 0) target = [None] adj = collections.defaultdict(set) dfs(start, target, master, set(), adj) if not target[0]: return -1 return bi_bfs(adj, start, target[0]) ", "class Solution def findShortestPath(self, master): directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)} rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'} def dfs(pos, target, master, lookup, adj): if target[0] is None and master.isTarget(): target[0] = pos lookup.add(pos) for d, (di, dj) in directions.iteritems(): if not master.canMove(d): continue nei = (pos[0]+di, pos[1]+dj) adj[pos].add(nei) adj[nei].add(pos) if nei in lookup: continue master.move(d) dfs(nei, target, master, lookup, adj) master.move(rollback[d]) def bfs(adj, start, target): q = [start] lookup = set(q) steps = 0 while q: new_q = [] for pos in q: if pos == target: return steps for nei in adj[pos]: if nei in lookup: continue lookup.add(nei) new_q.append(nei) q = new_q steps += 1 return -1 start = (0, 0) target = [None] adj = collections.defaultdict(set) dfs(start, target, master, set(), adj) if not target[0]: return -1 return bfs(adj, start, target[0]) ", "class Solution def minCostToMoveChips(self, chips): count = [0]*2 for p in chips: count[p%2] += 1 return min(count) ", "class Solution def sumSubseqWidths(self, A): M = 10**9+7 result, c = 0, 1 A.sort() for i in xrange(len(A)): result = (result + (A[i]-A[len(A)-1-i])*c % M) % M c = (c<<1) % M return result ", "class Solution def oddEvenList(self, head): if head: odd_tail, cur = head, head.next while cur and cur.next: even_head = odd_tail.next odd_tail.next = cur.next odd_tail = odd_tail.next cur.next = odd_tail.next odd_tail.next = even_head cur = cur.next return head ", "class Solution def search(self, nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) / 2 if nums[mid] == target: return mid elif (nums[mid] >= nums[left] and nums[left] <= target < nums[mid]) or (nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])): right = mid - 1 else: left = mid + 1 return -1 ", "class Solution def getModifiedArray(self, length, updates): result = [0] * length for update in updates: result[update[0]] += update[2] if update[1]+1 < length: result[update[1]+1] -= update[2] for i in xrange(1, length): result[i] += result[i-1] return result ", "class Solution def subarrayGCD(self, nums, k): def gcd(a, b): while b: a, b = b, a%b return a result = 0 dp = collections.Counter() for x in nums: new_dp = collections.Counter() if x%k == 0: dp[x] += 1 for g, cnt in dp.iteritems(): new_dp[gcd(g, x)] += cnt dp = new_dp result += dp[k] return result ", "class Solution def subarrayGCD(self, nums, k): def gcd(a, b): while b: a, b = b, a%b return a result = 0 for i in xrange(len(nums)): g = 0 for j in xrange(i, len(nums)): if nums[j]%k: break g = gcd(g, nums[j]) result += int(g == k) return result ", "class Solution def getPermutation(self, n, k): seq, k, fact = \"\", k - 1, math.factorial(n - 1) perm = [i for i in xrange(1, n + 1)] for i in reversed(xrange(n)): curr = perm[k / fact] seq += str(curr) perm.remove(curr) if i > 0: k %= fact fact /= i return seq ", "class Solution def maxConsecutiveAnswers(self, answerKey, k): result = max_count = 0 count = collections.Counter() for i in xrange(len(answerKey)): count[answerKey[i]] += 1 max_count = max(max_count, count[answerKey[i]]) if result-max_count >= k: count[answerKey[i-result]] -= 1 else: result += 1 return result ", "class Solution def sumOfPower(self, nums): MOD = 10**9+7 nums.sort() result = dp = 0 for x in nums: result = (result+(x**2)*(dp+x))%MOD dp = (dp+(dp+x))%MOD return result ", "class Solution def bestClosingTime(self, customers): result = mx = curr = 0 for i, x in enumerate(customers): curr += 1 if x == 'Y' else -1 if curr > mx: mx = curr result = i+1 return result ", "class Solution def minimumCost(self, start, target, specialRoads): start, target = tuple(start), tuple(target) adj = collections.defaultdict(list, {target:[]}) for x1, y1, x2, y2, c in specialRoads: adj[x1, y1].append((x2, y2, c)) dist = {start:0} lookup = set() while len(lookup) != len(dist): d, x1, y1 = min((dist[x1, y1], x1, y1) for x1, y1 in dist.iterkeys() if (x1, y1) not in lookup) lookup.add((x1, y1)) if (x1, y1) == target: return d for x2, y2, c in adj[x1, y1]: if not ((x2, y2) not in dist or dist[x2, y2] > d+c): continue dist[x2, y2] = d+c for x2, y2 in adj.iterkeys(): if not ((x2, y2) not in dist or dist[x2, y2] > d+abs(x2-x1)+abs(y2-y1)): continue dist[x2, y2] = d+abs(x2-x1)+abs(y2-y1) import collections import heapq ", "class Solution def minimumCost(self, start, target, specialRoads): start, target = tuple(start), tuple(target) adj = collections.defaultdict(list, {target:[]}) for x1, y1, x2, y2, c in specialRoads: adj[x1, y1].append((x2, y2, c)) min_heap = [(0, start)] dist = {start:0} while min_heap: d, (x1, y1) = heapq.heappop(min_heap) if d > dist[x1, y1]: continue if (x1, y1) == target: return d for x2, y2, c in adj[x1, y1]: if not ((x2, y2) not in dist or dist[x2, y2] > d+c): continue dist[x2, y2] = d+c heapq.heappush(min_heap, (dist[x2, y2], (x2, y2))) for x2, y2 in adj.iterkeys(): if not ((x2, y2) not in dist or dist[x2, y2] > d+abs(x2-x1)+abs(y2-y1)): continue dist[x2, y2] = d+abs(x2-x1)+abs(y2-y1) heapq.heappush(min_heap, (dist[x2, y2], (x2, y2))) return -1 ", "class Solution def numberOfLines(self, widths, S): result = [1, 0] for c in S: w = widths[ord(c)-ord('a')] result[1] += w if result[1] > 100: result[0] += 1 result[1] = w return result ", "class Solution def maximumAlternatingSubarraySum(self, nums): def kadane(nums, start): result = float(\"-inf\") curr = odd = 0 for i in xrange(start, len(nums)): curr = (curr+nums[i]) if not odd else max(curr-nums[i], 0) result = max(result, curr) odd ^= 1 return result return max(kadane(nums, 0), kadane(nums, 1)) ", "class Solution def maximumRobots(self, chargeTimes, runningCosts, budget): result = left = curr = 0 dq = collections.deque() for right in xrange(len(chargeTimes)): while dq and chargeTimes[dq[-1]] <= chargeTimes[right]: dq.pop() dq.append(right) curr += runningCosts[right] if chargeTimes[dq[0]]+(right-left+1)*curr > budget: if dq[0] == left: dq.popleft() curr -= runningCosts[left] left += 1 return right-left+1 import collections ", "class Solution def maximumRobots(self, chargeTimes, runningCosts, budget): result = left = curr = 0 dq = collections.deque() for right in xrange(len(chargeTimes)): while dq and chargeTimes[dq[-1]] <= chargeTimes[right]: dq.pop() dq.append(right) curr += runningCosts[right] while dq and chargeTimes[dq[0]]+(right-left+1)*curr > budget: if dq[0] == left: dq.popleft() curr -= runningCosts[left] left += 1 result = max(result, right-left+1) return result ", "class Solution def sumNumbers(self, root): return self.sumNumbersRecu(root, 0) def sumNumbersRecu(self, root, num): if root is None: return 0 if root.left is None and root.right is None: return num * 10 + root.val return self.sumNumbersRecu(root.left, num * 10 + root.val) + self.sumNumbersRecu(root.right, num * 10 + root.val) ", "class Solution def arrayChange(self, nums, operations): lookup = {x:i for i, x in enumerate(nums)} for x, y in operations: lookup[y] = lookup.pop(x) for x, i in lookup.iteritems(): nums[i] = x return nums ", "class Solution def arrayChange(self, nums, operations): lookup = {x:i for i, x in enumerate(nums)} for x, y in operations: nums[lookup[x]] = y lookup[y] = lookup.pop(x) return nums ", "class Solution def maxScore(self, nums1, nums2, k): result = curr = 0 min_heap = [] for a, b in sorted(itertools.izip(nums1, nums2), key=lambda x: x[1], reverse=True): curr += a heapq.heappush(min_heap, a) if len(min_heap) > k: curr -= heapq.heappop(min_heap) if len(min_heap) == k: result = max(result, curr*b) return result ", "class Solution def smallestValue(self, n): while True: curr, new_n = n, 0 for p in PRIMES: if p**2 > curr: break while curr%p == 0: curr //= p new_n += p if curr > 1: new_n += curr if new_n == n: break n = new_n return n ", "class Solution def minSizeSubarray(self, nums, target): INF = float(\"inf\") q, target = divmod(target, sum(nums)) if not target: return q*len(nums) result = INF curr = left = 0 for right in xrange((len(nums)-1)+(len(nums)-1)): curr += nums[right%len(nums)] while curr > target: curr -= nums[left%len(nums)] left += 1 if curr == target: result = min(result, right-left+1) return result+q*len(nums) if result != INF else -1 ", "class Solution def minSizeSubarray(self, nums, target): INF = float(\"inf\") q, target = divmod(target, sum(nums)) if not target: return q*len(nums) result = INF lookup = {0:-1} prefix = 0 for right in xrange((len(nums)-1)+(len(nums)-1)): prefix += nums[right%len(nums)] if prefix-target in lookup: result = min(result, right-lookup[prefix-target]) lookup[prefix] = right return result+q*len(nums) if result != INF else -1 ", "class Solution def minCost(self, basket1, basket2): def nth_element(nums, n, left=0, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right right = len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 cnt = collections.Counter() for x in basket1: cnt[x] += 1 for x in basket2: cnt[x] -= 1 mn = min(cnt.iterkeys()) swaps = [] for k, v in cnt.iteritems(): if v%2: return -1 swaps.extend(k for _ in xrange(abs(v)//2)) nth_element(swaps, len(swaps)//2) return sum(min(swaps[i], mn*2) for i in xrange(len(swaps)//2)) ", "class Solution def prevPermOpt1(self, A): for left in reversed(xrange(len(A)-1)): if A[left] > A[left+1]: break else: return A right = len(A)-1 while A[left] <= A[right]: right -= 1 while A[right-1] == A[right]: right -= 1 A[left], A[right] = A[right], A[left] return A ", "class Solution def removeStones(self, stones): MAX_ROW = 10000 union_find = UnionFind(2*MAX_ROW) for r, c in stones: union_find.union_set(r, c+MAX_ROW) return len(stones) - len({union_find.find_set(r) for r, _ in stones}) ", "class Solution def findSmallestInteger(self, nums, value): cnt = collections.Counter(x%value for x in nums) mn = min((cnt[i], i) for i in xrange(value))[1] return value*cnt[mn]+mn import collections ", "class Solution def findSmallestInteger(self, nums, value): cnt = collections.Counter(x%value for x in nums) for i in xrange(len(nums)+1): if not cnt[i%value]: return i cnt[i%value] -= 1 ", "class Solution def isPossibleToSplit(self, nums): return all(v <= 2 for v in collections.Counter(nums).itervalues()) ", "class Solution def maximumUnits(self, boxTypes, truckSize): boxTypes.sort(key=lambda x: x[1], reverse=True) result = 0 for box, units in boxTypes: if truckSize > box: truckSize -= box result += box*units else: result += truckSize*units break return result ", "class Solution def reorderSpaces(self, text): text = list(text) space_count, word_count = 0, 0 for i, c in enumerate(text): if c == ' ': space_count += 1 elif i == 0 or text[i-1] == ' ': word_count += 1 left, i = 0, 0 while i < len(text): has_word = False while i < len(text) and text[i] != ' ': text[left], text[i] = text[i], text[left] left += 1 i += 1 has_word = True if has_word: left += 1 i += 1 equal_count = space_count//(word_count-1) if word_count-1 > 0 else 0 extra_count = space_count%(word_count-1) if word_count-1 > 0 else space_count right, i = len(text)-1-extra_count, len(text)-1 while i >= 0: has_word = False while i >= 0 and text[i] != ' ': text[right], text[i] = text[i], text[right] right -= 1 i -= 1 has_word = True if has_word: right -= equal_count i -= 1 return \"\".join(text) ", "class Solution def longestPalindrome(self, word1, word2): s = word1+word2 dp = [[0]*len(s) for _ in xrange(len(s))] result = 0 for j in xrange(len(s)): dp[j][j] = 1 for i in reversed(xrange(j)): if s[i] == s[j]: dp[i][j] = 2 if i+1 == j else dp[i+1][j-1] + 2 if i < len(word1) <= j: result = max(result, dp[i][j]) else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return result ", "class Solution def longestPalindrome(self, word1, word2): s = word1+word2 dp = [[0]*len(s) for _ in xrange(len(s))] for j in xrange(len(s)): dp[j][j] = 1 for i in reversed(xrange(j)): if s[i] == s[j]: dp[i][j] = 2 if i+1 == j else dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return max([dp[i][j] for i in xrange(len(word1)) for j in xrange(len(word1), len(s)) if s[i] == s[j]] or [0]) ", "class Solution def minimumValueSum(self, nums, andValues): INF = float(\"inf\") L = max(nums).bit_length() def update(cnt, x, d): for i in xrange(L): if x&(1<<i): cnt[i] += d def mask(cnt, l): return reduce(lambda accu, i: accu|(1<<i), (i for i in xrange(L) if cnt[i] == l), 0) dp = [INF]*(len(nums)+1) dp[0] = 0 for j in xrange(len(andValues)): new_dp = [INF]*(len(nums)+1) cnt = [0]*L l = [0]*len(dp) dq = collections.deque() left = idx = j for right in xrange(j, len(nums)): update(cnt, nums[right], +1) if mask(cnt, right-left+1) <= andValues[j]: while left <= right: if mask(cnt, right-left+1) > andValues[j]: break update(cnt, nums[left], -1) left += 1 left -= 1 update(cnt, nums[left], +1) if (andValues[j]&nums[right]) == andValues[j]: l[right + 1] = l[right]+1 if mask(cnt, right-left+1) != andValues[j]: continue while idx <= left: while dq and dp[dq[-1]] >= dp[idx]: dq.pop() dq.append(idx) idx += 1 while dq and dq[0] < left-l[left]: dq.popleft() if dq: new_dp[right+1] = dp[dq[0]]+nums[right] dp = new_dp return dp[-1] if dp[-1] != INF else -1 ", "class Solution def minimumValueSum(self, nums, andValues): INF = float(\"inf\") class SparseTable(object): def __init__(self, arr, fn): self.fn = fn self.bit_length = [0] n = len(arr) k = n.bit_length()-1 for i in xrange(k+1): self.bit_length.extend(i+1 for _ in xrange(min(1<<i, (n+1)-len(self.bit_length)))) self.st = [[0]*n for _ in xrange(k+1)] self.st[0] = arr[:] for i in xrange(1, k+1): for j in xrange((n-(1<<i))+1): self.st[i][j] = fn(self.st[i-1][j], self.st[i-1][j+(1<<(i-1))]) def query(self, L, R): i = self.bit_length[R-L+1]-1 return self.fn(self.st[i][L], self.st[i][R-(1<<i)+1]) dp = [INF]*(len(nums)+1) dp[0] = 0 for j in xrange(len(andValues)): new_dp = [INF]*(len(nums)+1) masks = [] st = SparseTable(dp, min) for i in xrange(j, len(nums)): masks.append([nums[i], i]) for x in masks: x[0] &= nums[i] masks = [x for k, x in enumerate(masks) if k == 0 or masks[k-1][0] != masks[k][0]] for k, [mask, left] in enumerate(masks): if mask == andValues[j]: right = masks[k+1][1]-1 if k+1 != len(masks) else i new_dp[i+1] = min(new_dp[i+1], st.query(left, right)+nums[i]) break dp = new_dp return dp[-1] if dp[-1] != INF else -1 import collections ", "class Solution def minimumValueSum(self, nums, andValues): INF = float(\"inf\") FULL_MASK = (1<<max(nums).bit_length())-1 def memoization(i, j, mask): if i == len(nums) and j == len(andValues): return 0 if i == len(nums) or j == len(andValues) or mask < andValues[j]: return INF if mask not in lookup[i][j]: curr = memoization(i+1, j, mask&nums[i]) if mask&nums[i] == andValues[j]: curr = min(curr, nums[i]+memoization(i+1, j+1, FULL_MASK)) lookup[i][j][mask] = curr return lookup[i][j][mask] lookup = [[collections.defaultdict(int) for _ in xrange(len(andValues))] for _ in xrange(len(nums))] result = memoization(0, 0, FULL_MASK) return result if result != INF else -1 ", "class Solution def selfDivisiblePermutationCount(self, n): def popcount(x): return bin(x).count('1') def gcd(a, b): while b: a, b = b, a%b return a lookup = [[gcd(i+1, j+1) == 1 for j in xrange(n)] for i in xrange(n)] dp = [0]*(1<<n) dp[0] = 1 for mask in xrange(1<<n): i = popcount(mask) for j in xrange(n): if mask&(1<<j) == 0 and lookup[i][j]: dp[mask|(1<<j)] += dp[mask] return dp[-1] ", "class Solution def optimalDivision(self, nums): if len(nums) == 1: return str(nums[0]) if len(nums) == 2: return str(nums[0]) + \"/\" + str(nums[1]) result = [str(nums[0]) + \"/(\" + str(nums[1])] for i in xrange(2, len(nums)): result += \"/\" + str(nums[i]) result += \")\" return \"\".join(result) ", "class Solution def shortestPathBinaryMatrix(self, grid): directions = [(-1, -1), (-1, 0), (-1, 1), ( 0, -1), ( 0, 1), ( 1, -1), ( 1, 0), ( 1, 1)] result = 0 q = collections.deque([(0, 0)]) while q: result += 1 next_depth = collections.deque() while q: i, j = q.popleft() if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not grid[i][j]: grid[i][j] = 1 if i == len(grid)-1 and j == len(grid)-1: return result for d in directions: next_depth.append((i+d[0], j+d[1])) q = next_depth return -1 ", "class Solution def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes): result = 0 q = collections.deque(initialBoxes) while q: changed = False for _ in xrange(len(q)): box = q.popleft() if not status[box]: q.append(box) continue changed = True result += candies[box] for contained_key in keys[box]: status[contained_key] = 1 for contained_box in containedBoxes[box]: q.append(contained_box) if not changed: break return result ", "class Solution def countCombinations(self, pieces, positions): directions = {\"rook\": [(0, 1), (1, 0), (0, -1), (-1, 0)], \"bishop\": [(1, 1), (1, -1), (-1, 1), (-1, -1)], \"queen\" : [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]} all_mask = 2**7-1 def backtracking(pieces, positions, i, lookup): if i == len(pieces): return 1 result = 0 r, c = positions[i] r, c = r-1, c-1 mask = all_mask if not (lookup[r][c]&mask): lookup[r][c] += mask result += backtracking(pieces, positions, i+1, lookup) lookup[r][c] -= mask for dr, dc in directions[pieces[i]]: bit, nr, nc = 1, r+dr, c+dc mask = all_mask while 0 <= nr < 8 and 0 <= nc < 8 and not (lookup[nr][nc]&bit): lookup[nr][nc] += bit mask -= bit if not (lookup[nr][nc]&mask): lookup[nr][nc] += mask result += backtracking(pieces, positions, i+1, lookup) lookup[nr][nc] -= mask bit, nr, nc = bit<<1, nr+dr, nc+dc while bit>>1: bit, nr, nc = bit>>1, nr-dr, nc-dc lookup[nr][nc] -= bit return result return backtracking(pieces, positions, 0, [[0]*8 for _ in range(8)]) ", "class Solution def rearrangeSticks(self, n, k): MOD = 10**9+7 dp = [[0 for _ in xrange(k+1)] for _ in xrange(2)] dp[1][1] = 1 for i in xrange(2, n+1): for j in xrange(1, min(i, k)+1): dp[i%2][j] = (dp[(i-1)%2][j-1]+(i-1)*dp[(i-1)%2][j]) % MOD return dp[n%2][k] ", "class Solution def colorTheGrid(self, m, n): MOD = 10**9+7 def backtracking(mask1, mask2, basis, result): if not basis: result.append(mask2) return for i in xrange(3): if (mask1 == -1 or mask1//basis%3 != i) and (mask2 == -1 or mask2//(basis*3)%3 != i): backtracking(mask1, mask2+i*basis if mask2 != -1 else i*basis, basis//3, result) def matrix_mult(A, B): ZB = zip(*B) return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A] def matrix_expo(A, K): result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))] while K: if K % 2: result = matrix_mult(result, A) A = matrix_mult(A, A) K /= 2 return result def normalize(basis, mask): norm = {} result = 0 while basis: x = mask//basis%3 if x not in norm: norm[x] = len(norm) result += norm[x]*basis basis //= 3 return result if m > n: m, n = n, m basis = 3**(m-1) masks = [] backtracking(-1, -1, basis, masks) assert(len(masks) == 3 * 2**(m-1)) lookup = {mask:normalize(basis, mask) for mask in masks} normalized_mask_cnt = collections.Counter(lookup[mask] for mask in masks) assert(len(normalized_mask_cnt) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1)) adj = collections.defaultdict(list) for mask in normalized_mask_cnt.iterkeys(): backtracking(mask, -1, basis, adj[mask]) normalized_adj = collections.defaultdict(lambda:collections.defaultdict(int)) for mask1, masks2 in adj.iteritems(): for mask2 in masks2: normalized_adj[mask1][lookup[mask2]] = (normalized_adj[mask1][lookup[mask2]]+1)%MOD assert(2*3**m // 3 // 2 // 3 <= sum(len(v) for v in normalized_adj.itervalues()) <= 2*3**m // 3 // 2) return reduce(lambda x,y: (x+y)%MOD, matrix_mult([normalized_mask_cnt.values()], matrix_expo([[normalized_adj[mask1][mask2] for mask2 in normalized_mask_cnt.iterkeys()] for mask1 in normalized_mask_cnt.iterkeys()], n-1))[0], 0) import collections ", "class Solution def colorTheGrid(self, m, n): MOD = 10**9+7 def find_masks(m, basis): masks = [0] for c in xrange(m): new_masks = [] for mask in masks: choices = {0, 1, 2} if c > 0: choices.discard(mask//basis) for x in choices: new_masks.append((x*basis)+(mask//3)) masks = new_masks return masks def find_adj(m, basis, dp): adj = collections.defaultdict(list) for mask in dp.iterkeys(): adj[mask].append(mask) for c in xrange(m): assert(sum(len(v) for v in adj.itervalues()) == (3**c * 2**(m-(c-1)) if c >= 1 else 3 * 2**(m-1)) // 3 // (2 if m >= 2 else 1)) new_adj = collections.defaultdict(list) for mask1, mask2s in adj.iteritems(): for mask in mask2s: choices = {0, 1, 2} choices.discard(mask%3) if c > 0: choices.discard(mask//basis) for x in choices: new_adj[mask1].append((x*basis)+(mask//3)) adj = new_adj assert(sum(3**c * 2**(m-(c-1)) if c >= 1 else 3 * 2**(m-1) for c in xrange(m)) == 4*3**m-9*2**(m-1)) return adj def normalize(basis, mask): norm = {} result = 0 while basis: x = mask//basis%3 if x not in norm: norm[x] = len(norm) result += norm[x]*basis basis //= 3 return result if m > n: m, n = n, m basis = 3**(m-1) masks = find_masks(m, basis) assert(len(masks) == 3 * 2**(m-1)) lookup = {mask:normalize(basis, mask) for mask in masks} dp = collections.Counter(lookup[mask] for mask in masks) adj = find_adj(m, basis, dp) normalized_adj = collections.defaultdict(lambda:collections.defaultdict(int)) for mask1, mask2s in adj.iteritems(): for mask2 in mask2s: normalized_adj[lookup[mask1]][lookup[mask2]] = (normalized_adj[lookup[mask1]][lookup[mask2]]+1)%MOD assert(2*3**m // 3 // 2 // 3 <= sum(len(v) for v in normalized_adj.itervalues()) <= 2*3**m // 3 // 2) for _ in xrange(n-1): assert(len(dp) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1)) new_dp = collections.Counter() for mask, v in dp.iteritems(): for new_mask, cnt in normalized_adj[mask].iteritems(): new_dp[lookup[new_mask]] = (new_dp[lookup[new_mask]] + v*cnt) % MOD dp = new_dp return reduce(lambda x,y: (x+y)%MOD, dp.itervalues(), 0) import collections ", "class Solution def colorTheGrid(self, m, n): MOD = 10**9+7 def normalize(basis, mask, lookup): if mask not in lookup[basis]: norm = {} result, b = 0, basis while b: x = mask//b%3 if x not in norm: norm[x] = len(norm) result += norm[x]*b b //= 3 lookup[basis][mask] = result return lookup[basis][mask] if m > n: m, n = n, m basis = b = 3**(m-1) lookup = collections.defaultdict(dict) dp = collections.Counter({0: 1}) for idx in xrange(m*n): r, c = divmod(idx, m) assert(r != 0 or c != 0 or len(dp) == 1) assert(r != 0 or c == 0 or len(dp) == 3*2**(c-1) // 3 // (2 if c >= 2 else 1)) assert(r == 0 or c != 0 or len(dp) == 3*2**(m-1) // 3 // (2 if m >= 2 else 1)) assert(r == 0 or c == 0 or len(dp) == (1 if m == 1 else 2 if m == 2 else 3*3 * 2**(m-2) // 3 // 2)) new_dp = collections.Counter() for mask, v in dp.iteritems(): choices = {0, 1, 2} if r > 0: choices.discard(mask%3) if c > 0: choices.discard(mask//basis) for x in choices: new_mask = normalize(basis//b, ((x*basis)+(mask//3))//b, lookup)*b new_dp[new_mask] = (new_dp[new_mask]+v)%MOD if b > 1: b //= 3 dp = new_dp return reduce(lambda x,y: (x+y)%MOD, dp.itervalues(), 0) ", "class Solution def smallestRange(self, nums): left, right = float(\"inf\"), float(\"-inf\") min_heap = [] for row in nums: left = min(left, row[0]) right = max(right, row[0]) it = iter(row) heapq.heappush(min_heap, (next(it, None), it)) result = (left, right) while min_heap: (val, it) = heapq.heappop(min_heap) val = next(it, None) if val is None: break heapq.heappush(min_heap, (val, it)) left, right = min_heap[0][0], max(right, val) if right - left < result[1] - result[0]: result = (left, right) return result ", "class Solution def maxSumBST(self, root): result = 0 stk = [[root, None, []]] while stk: node, tmp, ret = stk.pop() if tmp: lvalid, lsum, lmin, lmax = tmp[0] rvalid, rsum, rmin, rmax = tmp[1] if lvalid and rvalid and lmax < node.val < rmin: total = lsum + node.val + rsum result = max(result, total) ret[:] = [True, total, min(lmin, node.val), max(node.val, rmax)] continue ret[:] = [False, 0, 0, 0] continue if not node: ret[:] = [True, 0, float(\"inf\"), float(\"-inf\")] continue new_tmp = [[], []] stk.append([node, new_tmp, ret]) stk.append([node.right, None, new_tmp[1]]) stk.append([node.left, None, new_tmp[0]]) return result ", "class Solution def maxSumBST(self, root): def dfs(node, result): if not node: return True, 0, float(\"inf\"), float(\"-inf\") lvalid, lsum, lmin, lmax = dfs(node.left, result) rvalid, rsum, rmin, rmax = dfs(node.right, result) if lvalid and rvalid and lmax < node.val < rmin: total = lsum + node.val + rsum result[0] = max(result[0], total) return True, total, min(lmin, node.val), max(node.val, rmax) return False, 0, 0, 0 result = [0] dfs(root, result) return result[0] ", "class Solution def maxSubArrayLen(self, nums, k): sums = {} cur_sum, max_len = 0, 0 for i in xrange(len(nums)): cur_sum += nums[i] if cur_sum == k: max_len = i + 1 elif cur_sum - k in sums: max_len = max(max_len, i - sums[cur_sum - k]) if cur_sum not in sums: sums[cur_sum] = i return max_len ", "class Solution def rearrangeCharacters(self, s, target): cnt1 = collections.Counter(s) cnt2 = collections.Counter(target) return min(cnt1[k]//v for k, v in cnt2.iteritems()) ", "class Solution def getFood(self, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] q = [] for r in xrange(len(grid)): for c in xrange(len(grid[0])): if grid[r][c] == '*': q.append((r, c)) break result = 0 while q: result += 1 new_q = [] for r, c in q: for dr, dc in directions: nr, nc = r+dr, c+dc if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] != 'X'): continue if grid[nr][nc] == '#': return result grid[nr][nc] = 'X' new_q.append((nr, nc)) q = new_q return -1 ", "class Solution def maximumCoins(self, heroes, monsters, coins): idxs1 = range(len(heroes)) idxs1.sort(key=lambda x: heroes[x]) idxs2 = range(len(monsters)) idxs2.sort(key=lambda x: monsters[x]) result = [0]*len(idxs1) i = curr = 0 for idx in idxs1: for i in xrange(i, len(idxs2)): if monsters[idxs2[i]] > heroes[idx]: break curr += coins[idxs2[i]] else: i = len(idxs2) result[idx] = curr return result ", "class Solution def intersectionSizeTwo(self, intervals): intervals.sort(key = lambda s_e: (s_e[0], -s_e[1])) cnts = [2] * len(intervals) result = 0 while intervals: (start, _), cnt = intervals.pop(), cnts.pop() for s in xrange(start, start+cnt): for i in xrange(len(intervals)): if cnts[i] and s <= intervals[i][1]: cnts[i] -= 1 result += cnt return result ", "class Solution def stoneGameV(self, stoneValue): n = len(stoneValue) prefix = [0] for v in stoneValue: prefix.append(prefix[-1] + v) mid = range(n) dp = [[0]*n for _ in xrange(n)] for i in xrange(n): dp[i][i] = stoneValue[i] max_score = 0 for l in xrange(2, n+1): for i in xrange(n-l+1): j = i+l-1 while prefix[mid[i]]-prefix[i] < prefix[j+1]-prefix[mid[i]]: mid[i] += 1 p = mid[i] max_score = 0 if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]: max_score = max(dp[i][p-1], dp[j][p]) else: if i <= p-2: max_score = max(max_score, dp[i][p-2]) if p <= j: max_score = max(max_score, dp[j][p]) dp[i][j] = max(dp[i][j-1], (prefix[j+1]-prefix[i]) + max_score) dp[j][i] = max(dp[j][i+1], (prefix[j+1]-prefix[i]) + max_score) return max_score ", "class Solution def stoneGameV(self, stoneValue): n = len(stoneValue) prefix = [0] for v in stoneValue: prefix.append(prefix[-1] + v) mid = [[0]*n for _ in xrange(n)] for l in xrange(1, n+1): for i in xrange(n-l+1): j = i+l-1 p = i if l == 1 else mid[i][j-1] while prefix[p]-prefix[i] < prefix[j+1]-prefix[p]: p += 1 mid[i][j] = p rmq = [[0]*n for _ in xrange(n)] for i in xrange(n): rmq[i][i] = stoneValue[i] dp = [[0]*n for _ in xrange(n)] for l in xrange(2, n+1): for i in xrange(n-l+1): j = i+l-1 p = mid[i][j] max_score = 0 if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]: max_score = max(rmq[i][p-1], rmq[j][p]) else: if i <= p-2: max_score = max(max_score, rmq[i][p-2]) if p <= j: max_score = max(max_score, rmq[j][p]) dp[i][j] = max_score rmq[i][j] = max(rmq[i][j-1], (prefix[j+1]-prefix[i]) + max_score) rmq[j][i] = max(rmq[j][i+1], (prefix[j+1]-prefix[i]) + max_score) return dp[0][n-1] ", "class Solution def countShips(self, sea, topRight, bottomLeft): result = 0 if topRight.x >= bottomLeft.x and topRight.y >= bottomLeft.y and sea.hasShips(topRight, bottomLeft): if (topRight.x, topRight.y) == (bottomLeft.x, bottomLeft.y): return 1 mid_x, mid_y = (topRight.x+bottomLeft.x)//2, (topRight.y+bottomLeft.y)//2 result += self.countShips(sea, topRight, Point(mid_x+1, mid_y+1)) result += self.countShips(sea, Point(mid_x, topRight.y), Point(bottomLeft.x, mid_y+1)) result += self.countShips(sea, Point(topRight.x, mid_y), Point(mid_x+1, bottomLeft.y)) result += self.countShips(sea, Point(mid_x, mid_y), bottomLeft) return result ", "class Solution def beautySum(self, s): result = 0 for i in xrange(len(s)): lookup = [0]*26 for j in xrange(i, len(s)): lookup[ord(s[j])-ord('a')] += 1 result += max(lookup) - min(x for x in lookup if x) return result ", "class Solution def minimumSubarrayLength(self, nums, k): def update(x, d, curr): for i in xrange(len(cnt)): if x < (1<<i): break if not (x&(1<<i)): continue if cnt[i] == 0: curr ^= 1<<i cnt[i] += d if cnt[i] == 0: curr ^= 1<<i return curr total = reduce(lambda x, y: x|y, nums) if total < k: return -1 cnt = [0]*total.bit_length() result = len(nums) left = curr = 0 for right in xrange(len(nums)): curr = update(nums[right], +1, curr) while left <= right and curr >= k: result = min(result, right-left+1) curr = update(nums[left], -1, curr) left += 1 return result ", "class Solution def minimumSubarrayLength(self, nums, k): result = float(\"inf\") for left in xrange(len(nums)): curr = 0 for right in xrange(left, len(nums)): curr |= nums[right] if curr < k: continue result = min(result, right-left+1) break return result if result != float(\"inf\") else -1 ", "class Solution def pivotArray(self, nums, pivot): result = [pivot]*len(nums) left, right = 0, len(nums)-sum(x > pivot for x in nums) for x in nums: if x < pivot: result[left] = x left += 1 elif x > pivot: result[right] = x right += 1 return result ", "class Solution def numPrimeArrangements(self, n): def count_primes(n): if n <= 1: return 0 is_prime = [True]*((n+1)//2) cnt = len(is_prime) for i in xrange(3, n+1, 2): if i*i > n: break if not is_prime[i//2]: continue for j in xrange(i*i, n+1, 2*i): if not is_prime[j//2]: continue cnt -= 1 is_prime[j//2] = False return cnt def factorial(n): result = 1 for i in xrange(2, n+1): result = (result*i)%MOD return result MOD = 10**9+7 cnt = count_primes(n) return factorial(cnt) * factorial(n-cnt) % MOD ", "class Solution def repeatedSubstringPattern(self, str): def getPrefix(pattern): prefix = [-1] * len(pattern) j = -1 for i in xrange(1, len(pattern)): while j > -1 and pattern[j + 1] != pattern[i]: j = prefix[j] if pattern[j + 1] == pattern[i]: j += 1 prefix[i] = j return prefix prefix = getPrefix(str) return prefix[-1] != -1 and (prefix[-1] + 1) % (len(str) - prefix[-1] - 1) == 0 def repeatedSubstringPattern2(self, str): if not str: return False ss = (str + str)[1:-1] return ss.find(str) != -1 ", "class Solution def minSubsequence(self, nums): result, total, curr = [], sum(nums), 0 nums.sort(reverse=True) for i, x in enumerate(nums): curr += x if curr > total-curr: break return nums[:i+1] ", "class Solution def palindromePairs(self, words): def is_palindrome(s, i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True res = [] lookup = collections.defaultdict(dict) for i, word in enumerate(words): lookup[len(word)][word] = i for i in xrange(len(words)): for j in xrange(len(words[i]) + 1): if j in lookup and is_palindrome(words[i], j, len(words[i])-1): suffix = words[i][:j][::-1] bucket = lookup[len(suffix)] if suffix in bucket and bucket[suffix] != i: res.append([i, bucket[suffix]]) if j > 0 and len(words[i])-j in lookup and is_palindrome(words[i], 0, j-1): prefix = words[i][j:][::-1] bucket = lookup[len(prefix)] if prefix in bucket and bucket[prefix] != i: res.append([bucket[prefix], i]) return res class Solution_TLE(object): def palindromePairs(self, words): def manacher(s, P): def preProcess(s): if not s: return ['^', '$'] T = ['^'] for c in s: T += [\"#\", c] T += ['#', '$'] return T T = preProcess(s) center, right = 0, 0 for i in xrange(1, len(T) - 1): i_mirror = 2 * center - i if right > i: P[i] = min(right - i, P[i_mirror]) else: P[i] = 0 while T[i + 1 + P[i]] == T[i - 1 - P[i]]: P[i] += 1 if i + P[i] > right: center, right = i, i + P[i] prefix, suffix = collections.defaultdict(list), collections.defaultdict(list) for i, word in enumerate(words): P = [0] * (2 * len(word) + 3) manacher(word, P) for j in xrange(len(P)): if j - P[j] == 1: prefix[word[(j + P[j]) // 2:]].append(i) if j + P[j] == len(P) - 2: suffix[word[:(j - P[j]) // 2]].append(i) res = [] for i, word in enumerate(words): for j in prefix[word[::-1]]: if j != i: res.append([i, j]) for j in suffix[word[::-1]]: if len(word) != len(words[j]): res.append([j, i]) return res class TrieNode(object): def __init__(self): self.word_idx = -1 self.leaves = {} def insert(self, word, i): cur = self for c in word: if not c in cur.leaves: cur.leaves[c] = TrieNode() cur = cur.leaves[c] cur.word_idx = i def find(self, s, idx, res): cur = self for i in reversed(xrange(len(s))): if s[i] in cur.leaves: cur = cur.leaves[s[i]] if cur.word_idx not in (-1, idx) and self.is_palindrome(s, i - 1): res.append([cur.word_idx, idx]) else: break def is_palindrome(self, s, j): i = 0 while i <= j: if s[i] != s[j]: return False i += 1 j -= 1 return True class Solution_MLE(object): def palindromePairs(self, words): res = [] trie = TrieNode() for i in xrange(len(words)): trie.insert(words[i], i) for i in xrange(len(words)): trie.find(words[i], i, res) return res ", "class Solution def nthUglyNumber(self, n): ugly_number = 0 heap = [] heapq.heappush(heap, 1) for _ in xrange(n): ugly_number = heapq.heappop(heap) if ugly_number % 2 == 0: heapq.heappush(heap, ugly_number * 2) elif ugly_number % 3 == 0: heapq.heappush(heap, ugly_number * 2) heapq.heappush(heap, ugly_number * 3) else: heapq.heappush(heap, ugly_number * 2) heapq.heappush(heap, ugly_number * 3) heapq.heappush(heap, ugly_number * 5) return ugly_number def nthUglyNumber2(self, n): ugly = [1] i2 = i3 = i5 = 0 while len(ugly) < n: while ugly[i2] * 2 <= ugly[-1]: i2 += 1 while ugly[i3] * 3 <= ugly[-1]: i3 += 1 while ugly[i5] * 5 <= ugly[-1]: i5 += 1 ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5)) return ugly[-1] def nthUglyNumber3(self, n): q2, q3, q5 = [2], [3], [5] ugly = 1 for u in heapq.merge(q2, q3, q5): if n == 1: return ugly if u > ugly: ugly = u n -= 1 q2 += 2 * u, q3 += 3 * u, q5 += 5 * u, ", "class Solution ugly = sorted(2**a * 3**b * 5**c for a in range(32) for b in range(20) for c in range(14)) def nthUglyNumber(self, n): return self.ugly[n-1] ", "class Solution def unequalTriplets(self, nums): K = 3 cnt = collections.Counter() dp = [0]*K for x in nums: cnt[x] += 1 other_cnt = 1 for i in xrange(K): dp[i] += other_cnt other_cnt = dp[i]-cnt[x]*other_cnt return dp[K-1] ", "class Solution def solve(self, nums, queries): MOD = 10**9+7 prefix = {} result = [] for x, y in queries: if y*y > len(nums): total = 0 for i in xrange(x, len(nums), y): total += nums[i] total %= MOD result.append(total) else: begin = x%y if (begin, y) not in prefix: prefix[(begin, y)] = [0] for i in xrange(begin, len(nums), y): prefix[(begin, y)].append((prefix[(begin, y)][-1] + nums[i]) % MOD) result.append((prefix[(begin, y)][-1]-prefix[(begin, y)][x//y]) % MOD) return result ", "class Solution def minimumCardPickup(self, cards): lookup = {} result = float(\"inf\") for i, x in enumerate(cards): if x in lookup: result = min(result, i-lookup[x]+1) lookup[x] = i return result if result != float(\"inf\") else -1 ", "class Solution def minimizeSum(self, nums): nums.sort() return min(nums[-3+i]-nums[i] for i in xrange(3)) ", "class Solution def smallestChair(self, times, targetFriend): events = [] for i, (s, e) in enumerate(times): events.append((s, True, i)) events.append((e, False, i)) events.sort() lookup = {} min_heap = [] for _, arrival, i in events: if not arrival: heapq.heappush(min_heap, lookup.pop(i)) continue lookup[i] = heapq.heappop(min_heap) if min_heap else len(lookup) if i == targetFriend: break return lookup[targetFriend] ", "class Solution def minMaxDifference(self, num): def f(dst): result = 0 base = 1 while base <= num: base *= 10 base //= 10 src = -1 while base: d = num//base%10 if src == -1 and d != dst: src = d result += base*(dst if d == src else d) base //= 10 return result return f(9)-f(0) ", "class Solution def numMatchingSubseq(self, S, words): waiting = collections.defaultdict(list) for word in words: it = iter(word) waiting[next(it, None)].append(it) for c in S: for it in waiting.pop(c, ()): waiting[next(it, None)].append(it) return len(waiting[None]) ", "class Solution def numTrees(self, n): if n == 0: return 1 def combination(n, k): count = 1 for i in xrange(1, k + 1): count = count * (n - i + 1) / i return count return combination(2 * n, n) - combination(2 * n, n - 1) ", "class Solution def numTrees(self, n): counts = [1, 1] for i in xrange(2, n + 1): count = 0 for j in xrange(i): count += counts[j] * counts[i - j - 1] counts.append(count) return counts[-1] ", "class Solution def shortestAlternatingPaths(self, n, red_edges, blue_edges): neighbors = [[set() for _ in xrange(2)] for _ in xrange(n)] for i, j in red_edges: neighbors[i][0].add(j) for i, j in blue_edges: neighbors[i][1].add(j) INF = max(2*n-3, 0)+1 dist = [[INF, INF] for i in xrange(n)] dist[0] = [0, 0] q = collections.deque([(0, 0), (0, 1)]) while q: i, c = q.popleft() for j in neighbors[i][c]: if dist[j][c] != INF: continue dist[j][c] = dist[i][1^c]+1 q.append((j, 1^c)) return [x if x != INF else -1 for x in map(min, dist)] ", "class Solution def minPathSum(self, grid): sum = list(grid[0]) for j in xrange(1, len(grid[0])): sum[j] = sum[j - 1] + grid[0][j] for i in xrange(1, len(grid)): sum[0] += grid[i][0] for j in xrange(1, len(grid[0])): sum[j] = min(sum[j - 1], sum[j]) + grid[i][j] return sum[-1] ", "class Solution def getSum(self, a, b): bit_length = 32 neg_bit, mask = (1 << bit_length) >> 1, ~(~0 << bit_length) a = (a | ~mask) if (a & neg_bit) else (a & mask) b = (b | ~mask) if (b & neg_bit) else (b & mask) while b: carry = a & b a ^= b a = (a | ~mask) if (a & neg_bit) else (a & mask) b = carry << 1 b = (b | ~mask) if (b & neg_bit) else (b & mask) return a def getSum2(self, a, b): MAX = 0x7FFFFFFF MIN = 0x80000000 mask = 0xFFFFFFFF while b: a, b = (a ^ b) & mask, ((a & b) << 1) & mask return a if a <= MAX else ~(a ^ mask) def minus(self, a, b): b = self.getSum(~b, 1) return self.getSum(a, b) def multiply(self, a, b): isNeg = (a > 0) ^ (b > 0) x = a if a > 0 else self.getSum(~a, 1) y = b if b > 0 else self.getSum(~b, 1) ans = 0 while y & 0x01: ans = self.getSum(ans, x) y >>= 1 x <<= 1 return self.getSum(~ans, 1) if isNeg else ans def divide(self, a, b): isNeg = (a > 0) ^ (b > 0) x = a if a > 0 else self.getSum(~a, 1) y = b if b > 0 else self.getSum(~b, 1) ans = 0 for i in range(31, -1, -1): if (x >> i) >= y: x = self.minus(x, y << i) ans = self.getSum(ans, 1 << i) return self.getSum(~ans, 1) if isNeg else ans ", "class Solution def mostExpensiveItem(self, primeOne, primeTwo): return primeOne*primeTwo-primeOne-primeTwo ", "class Solution def mostExpensiveItem(self, primeOne, primeTwo): dp = [False]*max(primeOne, primeTwo) dp[0] = True result = 1 for i in xrange(2, primeOne*primeTwo): dp[i%len(dp)] = dp[(i-primeOne)%len(dp)] or dp[(i-primeTwo)%len(dp)] if not dp[i%len(dp)]: result = i return result ", "class Solution def removeCoveredIntervals(self, intervals): intervals.sort(key=lambda x: [x[0], -x[1]]) result, max_right = 0, 0 for left, right in intervals: result += int(right > max_right) max_right = max(max_right, right) return result ", "class Solution def maxEvents(self, events): events.sort(reverse=True) min_heap = [] result = 0 for d in xrange(1, max(events, key=lambda x:x[1])[1]+1): while events and events[-1][0] == d: heapq.heappush(min_heap, events.pop()[1]) while min_heap and min_heap[0] == d-1: heapq.heappop(min_heap) if not min_heap: continue heapq.heappop(min_heap) result += 1 return result ", "class Solution def minTimeToVisitAllPoints(self, points): return sum(max(abs(points[i+1][0] - points[i][0]), abs(points[i+1][1] - points[i][1])) for i in xrange(len(points)-1)) ", "class Solution def maxFreq(self, s, maxLetters, minSize, maxSize): M, p = 10**9+7, 113 power, rolling_hash = pow(p, minSize-1, M), 0 left = 0 lookup, count = collections.defaultdict(int), collections.defaultdict(int) for right in xrange(len(s)): count[s[right]] += 1 if right-left+1 > minSize: count[s[left]] -= 1 rolling_hash = (rolling_hash - ord(s[left])*power) % M if count[s[left]] == 0: count.pop(s[left]) left += 1 rolling_hash = (rolling_hash*p + ord(s[right])) % M if right-left+1 == minSize and len(count) <= maxLetters: lookup[rolling_hash] += 1 return max(lookup.values() or [0]) ", "class Solution def maxFreq(self, s, maxLetters, minSize, maxSize): lookup = {} for right in xrange(minSize-1, len(s)): word = s[right-minSize+1:right+1] if word in lookup: lookup[word] += 1 elif len(collections.Counter(word)) <= maxLetters: lookup[word] = 1 return max(lookup.values() or [0]) ", "class Solution def maximizeWin(self, prizePositions, k): dp = [0]*(len(prizePositions)+1) result = left = 0 for right in xrange(len(prizePositions)): while prizePositions[right]-prizePositions[left] > k: left += 1 dp[right+1] = max(dp[right], right-left+1) result = max(result, dp[left]+(right-left+1)) return result ", "class Solution def solveSudoku(self, board): def isValid(board, x, y): for i in xrange(9): if i != x and board[i][y] == board[x][y]: return False for j in xrange(9): if j != y and board[x][j] == board[x][y]: return False i = 3 * (x / 3) while i < 3 * (x / 3 + 1): j = 3 * (y / 3) while j < 3 * (y / 3 + 1): if (i != x or j != y) and board[i][j] == board[x][y]: return False j += 1 i += 1 return True def solver(board): for i in xrange(len(board)): for j in xrange(len(board[0])): if(board[i][j] == '.'): for k in xrange(9): board[i][j] = chr(ord('1') + k) if isValid(board, i, j) and solver(board): return True board[i][j] = '.' return False return True solver(board) ", "class Solution def stringShift(self, s, shift): left_shifts = 0 for direction, amount in shift: if not direction: left_shifts += amount else: left_shifts -= amount left_shifts %= len(s) return s[left_shifts:] + s[:left_shifts] ", "class Solution def numOfPairs(self, nums, target): lookup = collections.Counter() result = 0 for num in nums: cnt1, cnt2 = lookup[-(len(target)-len(num))], lookup[len(target)-len(num)] if target.startswith(num): result += cnt1 lookup[len(num)] += 1 if target.endswith(num): result += cnt2 lookup[-len(num)] += 1 return result import collections ", "class Solution def numOfPairs(self, nums, target): prefix, suffix = collections.Counter(), collections.Counter() result = 0 for num in nums: if target.startswith(num): result += suffix[len(target)-len(num)] if target.endswith(num): result += prefix[len(target)-len(num)] if target.startswith(num): prefix[len(num)] += 1 if target.endswith(num): suffix[len(num)] += 1 return result ", "class Solution def validPalindrome(self, s): def validPalindrome(s, left, right): while left < right: if s[left] != s[right]: return False left, right = left+1, right-1 return True left, right = 0, len(s)-1 while left < right: if s[left] != s[right]: return validPalindrome(s, left, right-1) or validPalindrome(s, left+1, right) left, right = left+1, right-1 return True ", "class Solution def interchangeableRectangles(self, rectangles): count = collections.defaultdict(int) for w, h in rectangles: g = fractions.gcd(w, h) count[(w//g, h//g)] += 1 return sum(c*(c-1)//2 for c in count.itervalues()) ", "class Solution def removeInvalidParentheses(self, s): def findMinRemove(s): left_removed, right_removed = 0, 0 for c in s: if c == '(': left_removed += 1 elif c == ')': if not left_removed: right_removed += 1 else: left_removed -= 1 return (left_removed, right_removed) def isValid(s): sum = 0 for c in s: if c == '(': sum += 1 elif c == ')': sum -= 1 if sum < 0: return False return sum == 0 def removeInvalidParenthesesHelper(start, left_removed, right_removed): if left_removed == 0 and right_removed == 0: tmp = \"\" for i, c in enumerate(s): if i not in removed: tmp += c if isValid(tmp): res.append(tmp) return for i in xrange(start, len(s)): if right_removed == 0 and left_removed > 0 and s[i] == '(': if i == start or s[i] != s[i - 1]: removed[i] = True removeInvalidParenthesesHelper(i + 1, left_removed - 1, right_removed) del removed[i] elif right_removed > 0 and s[i] == ')': if i == start or s[i] != s[i - 1]: removed[i] = True removeInvalidParenthesesHelper(i + 1, left_removed, right_removed - 1) del removed[i] res, removed = [], {} (left_removed, right_removed) = findMinRemove(s) removeInvalidParenthesesHelper(0, left_removed, right_removed) return res ", "class Solution def numSubseq(self, nums, target): MOD = 10**9 + 7 nums.sort() result = 0 left, right = 0, len(nums)-1 while left <= right: if nums[left]+nums[right] > target: right -= 1 else: result = (result+pow(2, right-left, MOD))%MOD left += 1 return result ", "class Solution def maximumElementAfterDecrementingAndRearranging(self, arr): arr.sort() result = 1 for i in xrange(1, len(arr)): result = min(result+1, arr[i]) return result ", "class Solution def maxTotalFruits(self, fruits, startPos, k): max_pos = max(startPos, fruits[-1][0]) cnt = [0]*(1+max_pos) for p, a in fruits: cnt[p] = a prefix = [0] for x in cnt: prefix.append(prefix[-1]+x) result = 0 for left_dist in xrange(min(startPos, k)+1): right_dist = max(k-2*left_dist, 0) left, right = startPos-left_dist, min(startPos+right_dist, max_pos) result = max(result, prefix[right+1]-prefix[left]) for right_dist in xrange(min(max_pos-startPos, k)+1): left_dist = max(k-2*right_dist, 0) left, right = max(startPos-left_dist, 0), startPos+right_dist result = max(result, prefix[right+1]-prefix[left]) return result ", "class Solution def validSquare(self, p1, p2, p3, p4): def dist(p1, p2): return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 lookup = set([dist(p1, p2), dist(p1, p3), dist(p1, p4), dist(p2, p3), dist(p2, p4), dist(p3, p4)]) return 0 not in lookup and len(lookup) == 2 ", "class Solution def findMinMoves(self, machines): total = sum(machines) if total % len(machines): return -1 result, target, curr = 0, total / len(machines), 0 for n in machines: curr += n - target result = max(result, max(n - target, abs(curr))) return result ", "class Solution def setZeroes(self, matrix): first_col = reduce(lambda acc, i: acc or matrix[i][0] == 0, xrange(len(matrix)), False) first_row = reduce(lambda acc, j: acc or matrix[0][j] == 0, xrange(len(matrix[0])), False) for i in xrange(1, len(matrix)): for j in xrange(1, len(matrix[0])): if matrix[i][j] == 0: matrix[i][0], matrix[0][j] = 0, 0 for i in xrange(1, len(matrix)): for j in xrange(1, len(matrix[0])): if matrix[i][0] == 0 or matrix[0][j] == 0: matrix[i][j] = 0 if first_col: for i in xrange(len(matrix)): matrix[i][0] = 0 if first_row: for j in xrange(len(matrix[0])): matrix[0][j] = 0 ", "class Solution def treeDiameter(self, edges): graph, length = collections.defaultdict(set), 0 for u, v in edges: graph[u].add(v) graph[v].add(u) curr_level = {(None, u) for u, neighbors in graph.iteritems() if len(neighbors) == 1} while curr_level: curr_level = {(u, v) for prev, u in curr_level for v in graph[u] if v != prev} length += 1 return max(length-1, 0) ", "class Solution def maxDepth(self, root): if not root: return 0 depth = 0 for child in root.children: depth = max(depth, self.maxDepth(child)) return 1+depth ", "class Solution def canAttendMeetings(self, intervals): intervals.sort(key=lambda x: x[0]) for i in xrange(1, len(intervals)): if intervals[i][0] < intervals[i-1][1]: return False return True ", "class Solution def checkPartitioning(self, s): def manacher(s): s = '^#' + '#'.join(s) + '#$' P = [0]*len(s) C, R = 0, 0 for i in xrange(1, len(s)-1): i_mirror = 2*C-i if R > i: P[i] = min(R-i, P[i_mirror]) while s[i+1+P[i]] == s[i-1-P[i]]: P[i] += 1 if i+P[i] > R: C, R = i, i+P[i] return P P = manacher(s) prefix, suffix = [], [] for i in xrange(2, len(P)-2): if i-1-P[i] == 0: prefix.append(i) if i+1+P[i] == len(P)-1: suffix.append(i) for i in prefix: for j in suffix: left, right = i+1+P[i], j-1-P[j] if left > right: continue mid = left + (right-left)//2 if P[mid] >= mid-left: return True return False ", "class Solution def checkPartitioning(self, s): dp = [[False]*len(s) for _ in xrange(len(s))] for i in reversed(xrange(len(s))): for j in xrange(i, len(s)): if s[i] == s[j] and (j-i < 2 or dp[i+1][j-1]): dp[i][j] = True for i in xrange(1, len(s)-1): if not dp[0][i-1]: continue for j in xrange(i+1, len(s)): if not dp[j][-1]: continue if dp[i][j-1]: return True return False ", "class Solution def swimInWater(self, grid): n = len(grid) positions = [None] * (n**2) for i in xrange(n): for j in xrange(n): positions[grid[i][j]] = (i, j) directions = ((-1, 0), (1, 0), (0, -1), (0, 1)) union_find = UnionFind(n**2) for elevation in xrange(n**2): i, j = positions[elevation] for direction in directions: x, y = i+direction[0], j+direction[1] if 0 <= x < n and 0 <= y < n and grid[x][y] <= elevation: union_find.union_set(i*n+j, x*n+y) if union_find.find_set(0) == union_find.find_set(n**2-1): return elevation return n**2-1 ", "class Solution def mostFrequentEven(self, nums): cnt = collections.Counter(x for x in nums if x%2 == 0) return max(cnt.iterkeys(), key=lambda x: (cnt[x], -x)) if cnt else -1 ", "class Solution def minFallingPathSum(self, arr): for i in xrange(1, len(arr)): smallest_two = heapq.nsmallest(2, arr[i-1]) for j in xrange(len(arr[0])): arr[i][j] += smallest_two[1] if arr[i-1][j] == smallest_two[0] else smallest_two[0] return min(arr[-1]) ", "class Solution def snakesAndLadders(self, board): def coordinate(n, s): a, b = divmod(s-1, n) r = n-1-a c = b if r%2 != n%2 else n-1-b return r, c n = len(board) lookup = {1: 0} q = collections.deque([1]) while q: s = q.popleft() if s == n*n: return lookup[s] for s2 in xrange(s+1, min(s+6, n*n)+1): r, c = coordinate(n, s2) if board[r][c] != -1: s2 = board[r][c] if s2 not in lookup: lookup[s2] = lookup[s]+1 q.append(s2) return -1 ", "class Solution def wallsAndGates(self, rooms): INF = 2147483647 q = deque([(i, j) for i, row in enumerate(rooms) for j, r in enumerate(row) if not r]) while q: (i, j) = q.popleft() for I, J in (i+1, j), (i-1, j), (i, j+1), (i, j-1): if 0 <= I < len(rooms) and 0 <= J < len(rooms[0]) and rooms[I][J] == INF: rooms[I][J] = rooms[i][j] + 1 q.append((I, J)) ", "class Solution def minChanges(self, s): return sum(s[i] != s[i+1] for i in xrange(0, len(s), 2)) ", "class Solution def minOperations(self, nums, k): result = 0 heapq.heapify(nums) while nums: if nums[0] >= k: break mn1 = heapq.heappop(nums) mn2 = heapq.heappop(nums) heapq.heappush(nums, 2*mn1+mn2) result += 1 return result ", "class Solution def minDistance(self, height, width, tree, squirrel, nuts): def distance(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) result = 0 d = float(\"inf\") for nut in nuts: result += (distance(nut, tree) * 2) d = min(d, distance(nut, squirrel) - distance(nut, tree)) return result + d ", "class Solution def minIncrementOperations(self, nums, k): W = 3 dp = [0]*W for i, x in enumerate(nums): dp[i%W] = min(dp[j%W] for j in xrange(i-W, i))+max(k-x, 0) return min(dp) ", "class Solution def partitionLabels(self, S): lookup = {c: i for i, c in enumerate(S)} first, last = 0, 0 result = [] for i, c in enumerate(S): last = max(last, lookup[c]) if i == last: result.append(i-first+1) first = i+1 return result ", "class Solution def maximumProduct(self, nums, k): MOD = 10**9+7 nums.sort() total = sum(nums) for i in reversed(xrange(len(nums))): if nums[i]*(i+1)-total <= k: break total -= nums[i] q, r = divmod(k+total, i+1) return (pow(q, (i+1)-r, MOD)*pow(q+1, r, MOD)* reduce(lambda x, y: x*y%MOD, (nums[j] for j in xrange(i+1, len(nums))), 1)) % MOD import collections ", "class Solution def maximumProduct(self, nums, k): MOD = 10**9+7 cnt = collections.Counter(nums) min_num = min(cnt.iterkeys()) while k: c = min(cnt[min_num], k) cnt[min_num] -= c cnt[min_num+1] += c if not cnt[min_num]: del cnt[min_num] min_num += 1 k -= c return reduce(lambda total, x: total*pow(x[0], x[1], MOD)%MOD, cnt.iteritems(), 1) import heapq ", "class Solution def maximumProduct(self, nums, k): MOD = 10**9+7 min_heap = nums heapq.heapify(min_heap) while k: heapq.heappush(min_heap, heapq.heappop(min_heap)+1) k -= 1 return reduce(lambda x, y: x*y%MOD, min_heap) ", "class Solution def checkRecord(self, s): count_A = 0 for i in xrange(len(s)): if s[i] == 'A': count_A += 1 if count_A == 2: return False if i < len(s) - 2 and s[i] == s[i+1] == s[i+2] == 'L': return False return True ", "class Solution def isMonotonic(self, A): inc, dec = False, False for i in xrange(len(A)-1): if A[i] < A[i+1]: inc = True elif A[i] > A[i+1]: dec = True return not inc or not dec ", "class Solution def largestEvenSum(self, nums, k): def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 nth_element(nums, k-1, compare=lambda a, b: a > b) total = sum(nums[i] for i in xrange(k)) if total%2 == 0: return total min_k = [float(\"inf\")]*2 for i in xrange(k): min_k[nums[i]%2] = min(min_k[nums[i]%2], nums[i]) result = -1 for i in xrange(k, len(nums)): result = max(result, total-min_k[not (nums[i]%2)]+nums[i]) return result ", "class Solution def matchPlayersAndTrainers(self, players, trainers): players.sort() trainers.sort() result = 0 for x in trainers: if players[result] > x: continue result += 1 if result == len(players): break return result ", "class Solution def minInsertions(self, s): add, bal = 0, 0 for c in s: if c == '(': if bal > 0 and bal%2: add += 1 bal -= 1 bal += 2 else: bal -= 1 if bal < 0: add += 1 bal += 2 return add + bal ", "class Solution def countValidWords(self, sentence): result = token = hyphen = 0 for i in xrange(len(sentence)+1): if i == len(sentence) or sentence[i] == ' ': if token == 1: result += 1 token = hyphen = 0 continue if sentence[i].isdigit() or (sentence[i] in \"!.,\" and not (i == len(sentence)-1 or sentence[i+1] == ' ')) or (sentence[i] == '-' and not (hyphen == 0 and 0 < i < len(sentence)-1 and sentence[i-1].isalpha() and sentence[i+1].isalpha())): token = -1 continue if token == 0: token = 1 if sentence[i] == '-': hyphen = 1 return result ", "class Solution def atMostNGivenDigitSet(self, D, N): str_N = str(N) set_D = set(D) result = sum(len(D)**i for i in xrange(1, len(str_N))) i = 0 while i < len(str_N): result += sum(c < str_N[i] for c in D) * (len(D)**(len(str_N)-i-1)) if str_N[i] not in set_D: break i += 1 return result + int(i == len(str_N)) ", "class Solution def minMalwareSpread(self, graph, initial): union_find = UnionFind(len(graph)) for i in xrange(len(graph)): for j in xrange(i+1, len(graph)): if graph[i][j] == 1: union_find.union_set(i, j) union_size = collections.Counter(union_find.find_set(i) for i in xrange(len(graph))) malware_count = collections.Counter(union_find.find_set(i) for i in initial) return min(initial, key=lambda x: [malware_count[union_find.find_set(x)] > 1, -union_size[union_find.find_set(x)], x]) ", "class Solution def numberOfPairs(self, nums): cnt = [0]*(max(nums)+1) pair_cnt = 0 for x in nums: cnt[x] ^= 1 if not cnt[x]: pair_cnt += 1 return [pair_cnt, len(nums)-2*pair_cnt] import collections ", "class Solution def numberOfPairs(self, nums): cnt = collections.Counter(nums); pair_cnt = sum(x//2 for x in cnt.itervalues()) return [pair_cnt, len(nums)-2*pair_cnt] ", "class Solution def maxDistance(self, arrays): result, min_val, max_val = 0, arrays[0][0], arrays[0][-1] for i in xrange(1, len(arrays)): result = max(result, max(max_val - arrays[i][0], arrays[i][-1] - min_val)) min_val = min(min_val, arrays[i][0]) max_val = max(max_val, arrays[i][-1]) return result ", "class Solution def makeIntegerBeautiful(self, n, target): total, m = 0, n while m: total += m%10 m //= 10 m, l = n, 0 while total > target: while True: total -= m%10 m //= 10 l += 1 if m%10 != 9: break total += 1 m += 1 return m*10**l-n ", "class Solution def minimumDeletions(self, nums): i, j = nums.index(min(nums)), nums.index(max(nums)) if i > j: i, j = j, i return min((i+1)+(len(nums)-j), j+1, len(nums)-i) ", "class Solution def preorder(self, root): if not root: return [] result, stack = [], [root] while stack: node = stack.pop() result.append(node.val) for child in reversed(node.children): if child: stack.append(child) return result ", "class Solution def preorder(self, root): def dfs(root, result): result.append(root.val) for child in root.children: if child: dfs(child, result) result = [] if root: dfs(root, result) return result ", "class Solution def minimumMoves(self, nums, k, maxChanges): idxs = [i for i, x in enumerate(nums) if x] prefix = [0]*(len(idxs)+1) for i in xrange(len(idxs)): prefix[i+1] = prefix[i]+idxs[i] result = float(\"inf\") cnt = max(k-maxChanges, 0) for l in xrange(cnt, min(cnt+3, k, len(idxs))+1): cnt1 = (k-l)*2 for i in xrange(len(idxs)-l+1): cnt2 = (prefix[(i+l-1)+1]-prefix[(i+l-1)-(l//2-1)])-(prefix[(i+(l//2-1))+1]-prefix[i]) result = min(result, cnt2+cnt1) return result ", "class Solution def maxScore(self, grid): POS_INF = float(\"inf\") NEG_INF = float(\"-inf\") result = NEG_INF for i in xrange(len(grid)): for j in xrange(len(grid[0])): mn = POS_INF if i-1 >= 0: mn = min(mn, grid[i-1][j]) if j-1 >= 0: mn = min(mn, grid[i][j-1]) result = max(result, grid[i][j]-mn) grid[i][j] = min(grid[i][j], mn) return result ", "class Solution def myPow(self, x, n): result = 1 abs_n = abs(n) while abs_n: if abs_n & 1: result *= x abs_n >>= 1 x *= x return 1 / result if n < 0 else result ", "class Solution def myPow(self, x, n): if n < 0 and n != -n: return 1.0 / self.myPow(x, -n) if n == 0: return 1 v = self.myPow(x, n / 2) if n % 2 == 0: return v * v else: return v * v * x ", "class Solution def minSumSquareDiff(self, nums1, nums2, k1, k2): def check(diffs, k, x): return sum(max(d-x, 0) for d in diffs) <= k diffs = sorted((abs(i-j) for i, j in itertools.izip(nums1, nums2)), reverse=True) k = min(k1+k2, sum(diffs)) left, right = 0, diffs[0] while left <= right: mid = left + (right-left)//2 if check(diffs, k, mid): right = mid-1 else: left = mid+1 k -= sum(max(d-left, 0) for d in diffs) for i in xrange(len(diffs)): diffs[i] = min(diffs[i], left)-int(i < k) return sum(d**2 for d in diffs) ", "class Solution def numberOfWeakCharacters(self, properties): properties.sort(cmp=lambda a, b: cmp(b[1], a[1]) if a[0] == b[0] else cmp(a[0], b[0])) result = max_d = 0 for a, d in reversed(properties): if d < max_d: result += 1 max_d = max(max_d, d) return result import collections ", "class Solution def numberOfWeakCharacters(self, properties): lookup = collections.defaultdict(list) for a, d in properties: lookup[a].append(d) result = max_d = 0 for a in sorted(lookup.iterkeys(), reverse=True): result += sum(d < max_d for d in lookup[a]) max_d = max(max_d, max(lookup[a])) return result ", "class Solution def numberOfSteps (self, num): result = 0 while num: result += 2 if num%2 else 1 num //= 2 return max(result-1, 0) ", "class Solution def isThree(self, n): cnt = 0 i = 1 while i*i <= n and cnt <= 3: if n%i == 0: cnt += 1 if i*i == n else 2 i += 1 return cnt == 3 ", "class Solution def rangeSum(self, nums, n, left, right): def countUntil(nums, target): result, curr, left = 0, 0, 0 for right in xrange(len(nums)): curr += nums[right] while curr > target: curr -= nums[left] left += 1 result += right-left+1 return result def sumUntil(nums, prefix, target): result, curr, total, left = 0, 0, 0, 0 for right in xrange(len(nums)): curr += nums[right] total += nums[right]*(right-left+1) while curr > target: curr -= nums[left] total -= prefix[right+1]-prefix[(left-1)+1] left += 1 result += total return result def sumLessOrEqualTo(prefix, nums, left, right, count): while left <= right: mid = left + (right-left)//2 if countUntil(nums, mid)-count >= 0: right = mid-1 else: left = mid+1 return sumUntil(nums, prefix, left)-left*(countUntil(nums, left)-count) MOD = 10**9+7 prefix = [0]*(len(nums)+1) for i in xrange(len(nums)): prefix[i+1] = prefix[i]+nums[i] m, M = min(nums), sum(nums) return (sumLessOrEqualTo(prefix, nums, m, M, right) - sumLessOrEqualTo(prefix, nums, m, M, left-1))%MOD import heapq ", "class Solution def rangeSum(self, nums, n, left, right): MOD = 10**9+7 min_heap = []; for i, num in enumerate(nums, 1): heapq.heappush(min_heap, (num, i)) result = 0 for i in xrange(1, right+1): total, j = heapq.heappop(min_heap) if i >= left: result = (result+total)%MOD if j+1 <= n: heapq.heappush(min_heap, (total+nums[j], j+1)) return result ", "class Solution def totalStrength(self, strength): MOD = 10**9+7 curr = 0 prefix = [0]*(len(strength)+1) for i in xrange(len(strength)): curr = (curr+strength[i])%MOD prefix[i+1] = (prefix[i]+curr)%MOD stk, result = [-1], 0 for i in xrange(len(strength)+1): while stk[-1] != -1 and (i == len(strength) or strength[stk[-1]] >= strength[i]): x, y, z = stk[-2]+1, stk.pop(), i-1 result = (result+(strength[y]*((y-x+1)*(prefix[z+1]-prefix[y])-(z-y+1)*(prefix[y]-prefix[max(x-1, 0)]))))%MOD stk.append(i) return result ", "class Solution def totalStrength(self, strength): MOD = 10**9+7 prefix, prefix2 = [0]*(len(strength)+1), [0]*(len(strength)+1) for i in xrange(len(strength)): prefix[i+1] = (prefix[i]+strength[i])%MOD prefix2[i+1] = (prefix2[i]+strength[i]*(i+1))%MOD suffix, suffix2 = [0]*(len(strength)+1), [0]*(len(strength)+1) for i in reversed(xrange(len(strength))): suffix[i] = (suffix[i+1]+strength[i])%MOD suffix2[i] = (suffix2[i+1]+strength[i]*(len(strength)-i))%MOD stk, result = [-1], 0 for i in xrange(len(strength)+1): while stk[-1] != -1 and (i == len(strength) or strength[stk[-1]] >= strength[i]): x, y, z = stk[-2]+1, stk.pop(), i-1 result = (result+(strength[y]*((z-y+1)*((prefix2[y+1]-prefix2[x])-x*(prefix[y+1]-prefix[x]))+ (y-x+1)*((suffix2[y+1]-suffix2[z+1])-(len(strength)-(z+1))*(suffix[y+1]-suffix[z+1])))))%MOD stk.append(i) return result ", "class Solution def maximumRemovals(self, s, p, removable): def check(s, p, removable, x): lookup = set(removable[i] for i in xrange(x)) j = 0 for i in xrange(len(s)): if i in lookup or s[i] != p[j]: continue j += 1 if j == len(p): return True return False left, right = 0, len(removable) while left <= right: mid = left + (right-left)//2 if not check(s, p, removable, mid): right = mid-1 else: left = mid+1 return right ", "class Solution def maximumRemovals(self, s, p, removable): def check(s, p, lookup, x): j = 0 for i in xrange(len(s)): if lookup[i] <= x or s[i] != p[j]: continue j += 1 if j == len(p): return True return False lookup = [float(\"inf\")]*len(s) for i, r in enumerate(removable): lookup[r] = i+1 left, right = 0, len(removable) while left <= right: mid = left + (right-left)//2 if not check(s, p, lookup, mid): right = mid-1 else: left = mid+1 return right ", "class Solution def wordsTyping(self, sentence, rows, cols): def words_fit(sentence, start, cols): if len(sentence[start]) > cols: return 0 s, count = len(sentence[start]), 1 i = (start + 1) % len(sentence) while s + 1 + len(sentence[i]) <= cols: s += 1 + len(sentence[i]) count += 1 i = (i + 1) % len(sentence) return count wc = [0] * len(sentence) for i in xrange(len(sentence)): wc[i] = words_fit(sentence, i, cols) words, start = 0, 0 for i in xrange(rows): words += wc[start] start = (start + wc[start]) % len(sentence) return words / len(sentence) ", "class Solution def subtreeWithAllDeepest(self, root): Result = collections.namedtuple(\"Result\", (\"node\", \"depth\")) def dfs(node): if not node: return Result(None, 0) left, right = dfs(node.left), dfs(node.right) if left.depth > right.depth: return Result(left.node, left.depth+1) if left.depth < right.depth: return Result(right.node, right.depth+1) return Result(node, left.depth+1) return dfs(root).node ", "class Solution def maxXor(self, n, edges, values): def iter_dfs(): lookup = [0]*len(values) stk = [(1, 0, -1)] while stk: step, u, p = stk.pop() if step == 1: stk.append((2, u, p)) for v in adj[u]: if v == p: continue stk.append((1, v, u)) elif step == 2: lookup[u] = values[u]+sum(lookup[v] for v in adj[u] if v != p) return lookup def iter_dfs2(): trie = Trie(lookup[0].bit_length()) result = [0] stk = [(1, (0, -1, result))] while stk: step, args = stk.pop() if step == 1: u, p, ret = args ret[0] = max(trie.query(lookup[u]), 0) stk.append((3, (u,))) for v in adj[u]: if v == p: continue new_ret = [0] stk.append((2, (new_ret, ret))) stk.append((1, (v, u, new_ret))) elif step == 2: new_ret, ret = args ret[0] = max(ret[0], new_ret[0]) elif step == 3: u = args[0] trie.insert(lookup[u]) return result[0] adj = [[] for _ in xrange(len(values))] for u, v in edges: adj[u].append(v) adj[v].append(u) lookup = iter_dfs() return iter_dfs2() class Trie(object): def __init__(self, bit_length): self.__root = {} self.__bit_length = bit_length def insert(self, num): node = self.__root for i in reversed(xrange(self.__bit_length)): curr = (num>>i) & 1 if curr not in node: node[curr] = {} node = node[curr] def query(self, num): if not self.__root: return -1 node, result = self.__root, 0 for i in reversed(xrange(self.__bit_length)): curr = (num>>i) & 1 if 1^curr in node: node = node[1^curr] result |= 1<<i else: node = node[curr] return result ", "class Solution def maxXor(self, n, edges, values): def dfs(u, p): lookup[u] = values[u]+sum(dfs(v, u) for v in adj[u] if v != p) return lookup[u] def dfs2(u, p): result = max(trie.query(lookup[u]), 0) for v in adj[u]: if v == p: continue result = max(result, dfs2(v, u)) trie.insert(lookup[u]) return result adj = [[] for _ in xrange(len(values))] for u, v in edges: adj[u].append(v) adj[v].append(u) lookup = [0]*len(values) dfs(0, -1) trie = Trie(lookup[0].bit_length()) return dfs2(0, -1) ", "class Solution def maximumStrength(self, nums, k): dp = [0]*(len(nums)+1) for i in xrange(k): new_dp = [float(\"-inf\")]*(len(nums)+1) for j in xrange(len(nums)): new_dp[j+1] = max(new_dp[j], dp[j])+nums[j]*(k-i)*(1 if i%2 == 0 else -1) dp = new_dp return max(dp) ", "class Solution def maximumStrength(self, nums, k): dp = [[float(\"-inf\")]*(len(nums)+1) for _ in xrange(k+1)] dp[0] = [0]*(len(nums)+1) for i in xrange(k): for j in xrange(len(nums)): dp[i+1][j+1] = max(dp[i+1][j], dp[i][j])+nums[j]*(k-i)*(1 if i%2 == 0 else -1) return max(dp[-1]) ", "class Solution def minAvailableDuration(self, slots1, slots2, duration): min_heap = list(filter(lambda slot: slot[1] - slot[0] >= duration, slots1 + slots2)) heapq.heapify(min_heap) while len(min_heap) > 1: left = heapq.heappop(min_heap) right = min_heap[0] if left[1]-right[0] >= duration: return [right[0], right[0]+duration] return [] ", "class Solution def minAvailableDuration(self, slots1, slots2, duration): slots1.sort(key = lambda x: x[0]) slots2.sort(key = lambda x: x[0]) i, j = 0, 0 while i < len(slots1) and j < len(slots2): left = max(slots1[i][0], slots2[j][0]) right = min(slots1[i][1], slots2[j][1]) if left+duration <= right: return [left, left+duration] if slots1[i][1] < slots2[j][1]: i += 1 else: j += 1 return [] ", "class Solution def shortestDistanceColor(self, colors, queries): dp = [[-1 for _ in xrange(len(colors))] for _ in xrange(3)] dp[colors[0]-1][0] = 0 for i in xrange(1, len(colors)): for color in xrange(3): dp[color][i] = dp[color][i-1] dp[colors[i]-1][i] = i dp[colors[len(colors)-1]-1][len(colors)-1] = len(colors)-1 for i in reversed(xrange(len(colors)-1)): for color in xrange(3): if dp[color][i+1] == -1: continue if dp[color][i] == -1 or abs(dp[color][i+1]-i) < abs(dp[color][i]-i): dp[color][i] = dp[color][i+1] dp[colors[i]-1][i] = i return [abs(dp[color-1][i]-i) if dp[color-1][i] != -1 else -1 for i, color in queries] ", "class Solution def maximumBags(self, capacity, rocks, additionalRocks): for i in xrange(len(capacity)): capacity[i] -= rocks[i] capacity.sort() for i, c in enumerate(capacity): if c > additionalRocks: return i additionalRocks -= c return len(capacity) ", "class Solution def countBlackBlocks(self, m, n, coordinates): L = 2 cnt = collections.Counter() for x, y in coordinates: for nx in xrange(max(x-(L-1), 0), min(x+1, m-(L-1))): for ny in xrange(max(y-(L-1), 0), min(y+1, n-(L-1))): cnt[nx, ny] += 1 result = [0]*(L**2+1) for c in cnt.itervalues(): result[c] += 1 result[0] = (m-(L-1))*(n-(L-1))-sum(result[i] for i in xrange(1, len(result))) return result ", "class Solution def sortArray(self, nums): def mergeSort(left, right, nums): if left == right: return mid = left + (right-left)//2 mergeSort(left, mid, nums) mergeSort(mid+1, right, nums) r = mid+1 tmp = [] for l in xrange(left, mid+1): while r <= right and nums[r] < nums[l]: tmp.append(nums[r]) r += 1 tmp.append(nums[l]) nums[left:left+len(tmp)] = tmp mergeSort(0, len(nums)-1, nums) return nums import random ", "class Solution def sortArray(self, nums): def nth_element(nums, left, n, right, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target): i = left while i <= right: if compare(nums[i], target): nums[i], nums[left] = nums[left], nums[i] left += 1 i += 1 elif compare(target, nums[i]): nums[i], nums[right] = nums[right], nums[i] right -= 1 else: i += 1 return left, right while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx]) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 def quickSort(left, right, nums): if left > right: return mid = left + (right-left)//2 nth_element(nums, left, mid, right) quickSort(left, mid-1, nums) quickSort(mid+1, right, nums) quickSort(0, len(nums)-1, nums) return nums ", "class Solution def movesToChessboard(self, board): N = len(board) result = 0 for count in (collections.Counter(map(tuple, board)), collections.Counter(itertools.izip(*board))): if len(count) != 2 or sorted(count.values()) != [N/2, (N+1)/2]: return -1 seq1, seq2 = count if any(x == y for x, y in itertools.izip(seq1, seq2)): return -1 begins = [int(seq1.count(1) * 2 > N)] if N%2 else [0, 1] result += min(sum(int(i%2 != v) for i, v in enumerate(seq1, begin)) for begin in begins) / 2 return result ", "class Solution def subarraySum(self, nums, k): result = 0 accumulated_sum = 0 lookup = collections.defaultdict(int) lookup[0] += 1 for num in nums: accumulated_sum += num result += lookup[accumulated_sum - k] lookup[accumulated_sum] += 1 return result ", "class Solution def connect(self, root): head = root while head: cur = head while cur and cur.left: cur.left.next = cur.right if cur.next: cur.right.next = cur.next.left cur = cur.next head = head.left ", "class Solution def connect(self, root): if root is None: return if root.left: root.left.next = root.right if root.right and root.next: root.right.next = root.next.left self.connect(root.left) self.connect(root.right) ", "class Solution def minDays(self, bloomDay, m, k): def check(bloomDay, m, k, x): result = count = 0 for d in bloomDay: count = count+1 if d <= x else 0 if count == k: count = 0 result += 1 if result == m: break return result >= m if m*k > len(bloomDay): return -1 left, right = 1, max(bloomDay) while left <= right: mid = left + (right-left)//2 if check(bloomDay, m, k, mid): right = mid-1 else: left = mid+1 return left ", "class Solution def minimumKeypresses(self, s): return sum(cnt*(i//9+1) for i, cnt in enumerate(sorted(collections.Counter(s).itervalues(), reverse=True))) ", "class Solution def monotoneIncreasingDigits(self, N): nums = map(int, list(str(N))) leftmost_inverted_idx = len(nums) for i in reversed(xrange(1, len(nums))): if nums[i-1] > nums[i]: leftmost_inverted_idx = i nums[i-1] -= 1 for i in xrange(leftmost_inverted_idx, len(nums)): nums[i] = 9 return int(\"\".join(map(str, nums))) ", "class Solution def modifiedMatrix(self, matrix): for j in xrange(len(matrix[0])): mx = max(matrix[i][j] for i in xrange(len(matrix))) for i in xrange(len(matrix)): if matrix[i][j] == -1: matrix[i][j] = mx return matrix ", "class Solution def maxSumMinProduct(self, nums): MOD = 10**9+7 prefix = [0]*(len(nums)+1) for i in xrange(len(nums)): prefix[i+1] = prefix[i]+nums[i] stk, result = [-1], 0 for i in xrange(len(nums)+1): while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] >= nums[i]): result = max(result, nums[stk.pop()]*(prefix[(i-1)+1]-prefix[stk[-1]+1])) stk.append(i) return result%MOD ", "class Solution def shortestCommonSupersequence(self, str1, str2): dp = [[0 for _ in xrange(len(str2)+1)] for _ in xrange(2)] bt = [[None for _ in xrange(len(str2)+1)] for _ in xrange(len(str1)+1)] for i, c in enumerate(str1): bt[i+1][0] = (i, 0, c) for j, c in enumerate(str2): bt[0][j+1] = (0, j, c) for i in xrange(len(str1)): for j in xrange(len(str2)): if dp[i % 2][j+1] > dp[(i+1) % 2][j]: dp[(i+1) % 2][j+1] = dp[i % 2][j+1] bt[i+1][j+1] = (i, j+1, str1[i]) else: dp[(i+1) % 2][j+1] = dp[(i+1) % 2][j] bt[i+1][j+1] = (i+1, j, str2[j]) if str1[i] != str2[j]: continue if dp[i % 2][j]+1 > dp[(i+1) % 2][j+1]: dp[(i+1) % 2][j+1] = dp[i % 2][j]+1 bt[i+1][j+1] = (i, j, str1[i]) i, j = len(str1), len(str2) result = [] while i != 0 or j != 0: i, j, c = bt[i][j] result.append(c) result.reverse() return \"\".join(result) ", "class Solution def generate(self, numRows): result = [] for i in xrange(numRows): result.append([]) for j in xrange(i + 1): if j in (0, i): result[i].append(1) else: result[i].append(result[i - 1][j - 1] + result[i - 1][j]) return result def generate2(self, numRows): if not numRows: return [] res = [[1]] for i in range(1, numRows): res += [map(lambda x, y: x + y, res[-1] + [0], [0] + res[-1])] return res[:numRows] def generate3(self, numRows): if numRows == 0: return [] if numRows == 1: return [[1]] res = [[1], [1, 1]] def add(nums): res = nums[:1] for i, j in enumerate(nums): if i < len(nums) - 1: res += [nums[i] + nums[i + 1]] res += nums[:1] return res while len(res) < numRows: res.extend([add(res[-1])]) return res ", "class Solution def getLucky(self, s, k): total = reduce(lambda total, x: total+sum(divmod((ord(x)-ord('a')+1), 10)), s, 0) while k > 1 and total > 9: new_total = 0 while total: total, x = divmod(total, 10) new_total += x total = new_total k -= 1 return total ", "class Solution def maxBalancedSubsequenceSum(self, nums): NEG_INF = float(\"-inf\") def query(sl, k): j = sl.bisect_left((k,)) return sl[j-1][1] if j-1 >= 0 else NEG_INF def update(sl, k, v): j = sl.bisect_left((k,)) if j < len(sl) and sl[j][0] == k: if not (sl[j][1] < v): return del sl[j] elif not (j-1 < 0 or sl[j-1][1] < v): return sl.add((k, v)) while j+1 < len(sl) and sl[j+1][1] <= sl[j][1]: del sl[j+1] sl = SortedList() for i, x in enumerate(nums): v = max(query(sl, (x-i)+1), 0)+x update(sl, x-i, v) return sl[-1][1] ", "class Solution def maxBalancedSubsequenceSum(self, nums): NEG_INF = float(\"-inf\") class BIT(object): def __init__(self, n, default=0, fn=lambda x, y: x+y): self.__bit = [NEG_INF]*(n+1) self.__default = default self.__fn = fn def update(self, i, val): i += 1 while i < len(self.__bit): self.__bit[i] = self.__fn(self.__bit[i], val) i += (i & -i) def query(self, i): i += 1 ret = self.__default while i > 0: ret = self.__fn(ret, self.__bit[i]) i -= (i & -i) return ret val_to_idx = {x:i for i, x in enumerate(sorted({x-i for i, x in enumerate(nums)}))} bit = BIT(len(val_to_idx), default=NEG_INF, fn=max) for i, x in enumerate(nums): v = max(bit.query(val_to_idx[x-i]), 0)+x bit.update(val_to_idx[x-i], v) return bit.query(len(val_to_idx)-1) ", "class Solution def maxBalancedSubsequenceSum(self, nums): NEG_INF = float(\"-inf\") class SegmentTree(object): def __init__(self, N, build_fn=lambda _: None, query_fn=lambda x, y: max(x, y), update_fn=lambda x, y: max(x, y)): self.tree = [None]*(2*2**((N-1).bit_length())) self.base = len(self.tree)//2 self.query_fn = query_fn self.update_fn = update_fn for i in xrange(self.base, self.base+N): self.tree[i] = build_fn(i-self.base) for i in reversed(xrange(1, self.base)): self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1]) def update(self, i, h): x = self.base+i self.tree[x] = self.update_fn(self.tree[x], h) while x > 1: x //= 2 self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1]) def query(self, L, R): if L > R: return None L += self.base R += self.base left = right = None while L <= R: if L & 1: left = self.query_fn(left, self.tree[L]) L += 1 if R & 1 == 0: right = self.query_fn(self.tree[R], right) R -= 1 L //= 2 R //= 2 return self.query_fn(left, right) val_to_idx = {x:i for i, x in enumerate(sorted({x-i for i, x in enumerate(nums)}))} st = SegmentTree(len(val_to_idx)) for i, x in enumerate(nums): v = max(st.query(0, val_to_idx[x-i]), 0)+x st.update(val_to_idx[x-i], v) return st.query(0, len(val_to_idx)-1) ", "class Solution def depthSumInverse(self, nestedList): def depthSumInverseHelper(list, depth, result): if len(result) < depth + 1: result.append(0) if list.isInteger(): result[depth] += list.getInteger() else: for l in list.getList(): depthSumInverseHelper(l, depth + 1, result) result = [] for list in nestedList: depthSumInverseHelper(list, 0, result) sum = 0 for i in reversed(xrange(len(result))): sum += result[i] * (len(result) - i) return sum ", "class Solution def sequenceReconstruction(self, org, seqs): if not seqs: return False pos = [0] * (len(org) + 1) for i in xrange(len(org)): pos[org[i]] = i is_matched = [False] * (len(org) + 1) cnt_to_match = len(org) - 1 for seq in seqs: for i in xrange(len(seq)): if not 0 < seq[i] <= len(org): return False if i == 0: continue if pos[seq[i-1]] >= pos[seq[i]]: return False if is_matched[seq[i-1]] == False and pos[seq[i-1]] + 1 == pos[seq[i]]: is_matched[seq[i-1]] = True cnt_to_match -= 1 return cnt_to_match == 0 ", "class Solution def sequenceReconstruction(self, org, seqs): graph = collections.defaultdict(set) indegree = collections.defaultdict(int) integer_set = set() for seq in seqs: for i in seq: integer_set.add(i) if len(seq) == 1: if seq[0] not in indegree: indegree[seq[0]] = 0 continue for i in xrange(len(seq)-1): if seq[i] not in indegree: indegree[seq[i]] = 0 if seq[i+1] not in graph[seq[i]]: graph[seq[i]].add(seq[i+1]) indegree[seq[i+1]] += 1 cnt_of_zero_indegree = 0 res = [] q = [] for i in indegree: if indegree[i] == 0: cnt_of_zero_indegree += 1 if cnt_of_zero_indegree > 1: return False q.append(i) while q: i = q.pop() res.append(i) cnt_of_zero_indegree = 0 for j in graph[i]: indegree[j] -= 1 if indegree[j] == 0: cnt_of_zero_indegree += 1 if cnt_of_zero_indegree > 1: return False q.append(j) return res == org and len(org) == len(integer_set) ", "class Solution def modifiedGraphEdges(self, n, edges, source, destination, target): def dijkstra(start, x): best = [target+1]*len(adj) best[start] = 0 min_heap = [(0, start)] while min_heap: curr, u = heapq.heappop(min_heap) if curr > best[u]: continue for v, w in adj[u]: if w == -1: w = x if curr+w >= best[v]: continue best[v] = curr+w heapq.heappush(min_heap, (best[v], v)) return best adj = [[] for _ in xrange(n)] for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) left = dijkstra(source, 1) if not (left[destination] <= target): return [] right= dijkstra(destination, target+1) if not (right[source] >= target): return [] for e in edges: if e[2] == -1: e[2] = max(target-left[e[0]]-right[e[1]], target-left[e[1]]-right[e[0]], 1) return edges ", "class Solution def rearrangeArray(self, nums): pos, neg = 0, 1 result = [0]*len(nums) for x in nums: if x > 0: result[pos] = x pos += 2 else: result[neg] = x neg += 2 return result ", "class Solution def rearrangeArray(self, nums): def pos(): for x in nums: if x > 0: yield x def neg(): for x in nums: if x < 0: yield x gen_pos = pos() gen_neg = neg() return [next(gen_pos) if i%2 == 0 else next(gen_neg) for i in xrange(len(nums))] ", "class Solution def rearrangeArray(self, nums): pos, neg = [], [] for i in reversed(xrange(len(nums))): if nums[i] > 0: pos.append(nums[i]) else: neg.append(nums[i]) result = [] for i in xrange(len(nums)): if i%2 == 0: result.append(pos.pop()) else: result.append(neg.pop()) return result ", "class Solution def removeDuplicateLetters(self, s): remaining = Counter(s) in_stack, stk = set(), [] for c in s: if c not in in_stack: while stk and stk[-1] > c and remaining[stk[-1]]: in_stack.remove(stk.pop()) stk += c in_stack.add(c) remaining[c] -= 1 return \"\".join(stk) ", "class Solution def minOperations(self, nums): def gcd(a, b): while b: a, b = b, a%b return a cnt = nums.count(1) if cnt: return len(nums)-cnt result = float(\"inf\") for i in xrange(len(nums)): g = nums[i] for j in range(i+1, len(nums)): g = gcd(g, nums[j]) if g == 1: result = min(result, j-i) break return result+(len(nums)-1) if result != float(\"inf\") else -1 ", "class Solution def distinctAverages(self, nums): lookup = set() nums.sort() left, right = 0, len(nums)-1 while left < right: lookup.add(nums[left]+nums[right]) left, right = left+1, right-1 return len(lookup) ", "class Solution def subarrayLCM(self, nums, k): def gcd(a, b): while b: a, b = b, a%b return a def lcm(a, b): return a//gcd(a, b)*b result = 0 dp = collections.Counter() for x in nums: new_dp = collections.Counter() if k%x == 0: dp[x] += 1 for l, cnt in dp.iteritems(): new_dp[lcm(l, x)] += cnt dp = new_dp result += dp[k] return result ", "class Solution def subarrayLCM(self, nums, k): def gcd(a, b): while b: a, b = b, a%b return a def lcm(a, b): return a//gcd(a, b)*b result = 0 for i in xrange(len(nums)): l = 1 for j in xrange(i, len(nums)): if k%nums[j]: break l = lcm(l, nums[j]) result += int(l == k) return result ", "class Solution def minCost(self, n, cuts): sorted_cuts = sorted(cuts + [0, n]) dp = [[0]*len(sorted_cuts) for _ in xrange(len(sorted_cuts))] for l in xrange(2, len(sorted_cuts)): for i in xrange(len(sorted_cuts)-l): dp[i][i+l] = min(dp[i][j]+dp[j][i+l] for j in xrange(i+1, i+l)) + sorted_cuts[i+l]-sorted_cuts[i] return dp[0][len(sorted_cuts)-1] ", "class Solution def sumDistance(self, nums, s, d): MOD = 10**9+7 for i in xrange(len(nums)): nums[i] += d if s[i] == 'R' else -d nums.sort() return reduce(lambda x, y: (x+y)%MOD, ((i-(len(nums)-(i+1)))*x for i, x in enumerate(nums))) ", "class Solution def fullBloomFlowers(self, flowers, persons): cnt = collections.Counter() for s, e in flowers: cnt[s] += 1 cnt[e+1] -= 1 events = sorted(cnt.iterkeys()) prefix = [0] for x in events: prefix.append(prefix[-1]+cnt[x]) return [prefix[bisect.bisect_right(events, t)] for t in persons] import bisect ", "class Solution def fullBloomFlowers(self, flowers, persons): starts, ends = [], [] for s, e in flowers: starts.append(s) ends.append(e+1) starts.sort() ends.sort() return [bisect.bisect_right(starts, t)-bisect.bisect_right(ends, t) for t in persons] ", "class Solution def truncateSentence(self, s, k): for i in xrange(len(s)): if s[i] == ' ': k -= 1 if not k: return s[:i] return s ", "class Solution def maxCount(self, m, n, ops): for op in ops: m = min(m, op[0]) n = min(n, op[1]) return m*n ", "class Solution def minimumAddedCoins(self, coins, target): coins.sort() result = reachable = 0 for x in coins: while not reachable >= x-1: result += 1 reachable += reachable+1 reachable += x while not reachable >= target: result += 1 reachable += reachable+1 return result ", "class Solution def minimumAddedCoins(self, coins, target): coins.sort() result = reachable = 0 for x in coins: while not reachable >= x-1: result += 1 reachable += reachable+1 if reachable >= target: return result reachable += x if reachable >= target: return result while not reachable >= target: result += 1 reachable += reachable+1 return result ", "class Solution def minDays(self, grid): DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)] def floodfill(grid, i, j, lookup): stk = [(i, j)] lookup[i][j] = 1 while stk: i, j = stk.pop() for di, dj in DIRECTIONS: ni, nj = i+di, j+dj if not (0 <= ni < R and 0 <= nj < C and grid[ni][nj] and not lookup[ni][nj]): continue lookup[ni][nj] = 1 stk.append((ni, nj)) def count_islands(grid): lookup = [[0]*C for _ in xrange(R)] island_cnt = 0 for i in xrange(R): for j in xrange(C): if grid[i][j] == 0 or lookup[i][j]: continue island_cnt += 1 floodfill(grid, i, j, lookup) return island_cnt R, C = len(grid), len(grid[0]) if count_islands(grid) != 1: return 0 adj = [[] for _ in xrange(R*C)] cnt, idx = 0, -1 for i in xrange(R): for j in xrange(C): if grid[i][j] == 0: continue cnt += 1 if idx == -1: idx = i*C+j for di, dj in DIRECTIONS: ni, nj = i+di, j+dj if 0 <= ni < R and 0 <= nj < C and grid[ni][nj] == grid[i][j]: adj[i*C+j].append(ni*C+nj) return 1 if cnt == 1 or iter_get_articulation_points(adj, idx) else 2 class PersistentUnionFind(object): def __init__(self, n): self.set = range(n) self.size = [1]*n self.snapshots = [] self.undos = [] def find_set(self, x): stk = [] while self.set[x] != x: stk.append(x) x = self.set[x] while stk: y = stk.pop() self.undos.append((~y, self.set[y])) self.set[y] = x return x def union_set(self, x, y): x, y = self.find_set(x), self.find_set(y) if x == y: return False if self.size[x] > self.size[y]: x, y = y, x self.undos.append((x, y)) self.set[x] = self.set[y] self.size[y] += self.size[x] return True def total(self, x): return self.size[self.find_set(x)] def snapshot(self): self.snapshots.append(len(self.undos)) def rollback(self): for _ in xrange(len(self.undos)-self.snapshots.pop()): x, y = self.undos.pop() if x >= 0: self.size[y] -= self.size[x] self.set[x] = x else: self.set[~x] = y ", "class Solution def minDays(self, grid): DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)] def floodfill(grid, i, j, lookup): stk = [(i, j)] lookup[i][j] = 1 while stk: i, j = stk.pop() for di, dj in DIRECTIONS: ni, nj = i+di, j+dj if not (0 <= ni < R and 0 <= nj < C and grid[ni][nj] and not lookup[ni][nj]): continue lookup[ni][nj] = 1 stk.append((ni, nj)) def count_islands(grid): lookup = [[0]*C for _ in xrange(R)] island_cnt = 0 for i in xrange(R): for j in xrange(C): if grid[i][j] == 0 or lookup[i][j]: continue island_cnt += 1 floodfill(grid, i, j, lookup) return island_cnt def merge(i): r, c = divmod(i, C) for dr, dc in DIRECTIONS: nr, nc = r+dr, c+dc ni = nr*C+nc if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] == grid[r][c] and lookup[ni]: uf.union_set(i, ni) def check(i): r, c = divmod(i, C) if grid[r][c] == 0: return False lookup = set() for dr, dc in DIRECTIONS: nr, nc = r+dr, c+dc if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] == grid[r][c]: lookup.add(uf.find_set(nr*C+nc)) return len(lookup) != 1 def dfs(left, right): if left == right: return check(left) mid = left + (right-left)//2 l1, r1, l2, r2 = left, mid, mid+1, right for _ in xrange(2): uf.snapshot() for i in xrange(l1, r1+1): lookup[i] = True merge(i) if dfs(l2, r2): return True for i in xrange(l1, r1+1): lookup[i] = False uf.rollback() l1, r1, l2, r2 = l2, r2, l1, r1 return False R, C = len(grid), len(grid[0]) if count_islands(grid) != 1: return 0 uf = PersistentUnionFind(R*C) lookup = [False]*(R*C) return 1 if dfs(0, R*C-1) else 2 ", "class Solution def minDays(self, grid): DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)] def floodfill(grid, i, j, lookup): stk = [(i, j)] lookup[i][j] = 1 while stk: i, j = stk.pop() for di, dj in DIRECTIONS: ni, nj = i+di, j+dj if not (0 <= ni < R and 0 <= nj < C and grid[ni][nj] and not lookup[ni][nj]): continue lookup[ni][nj] = 1 stk.append((ni, nj)) def count_islands(grid): lookup = [[0]*C for _ in xrange(R)] island_cnt = 0 for i in xrange(R): for j in xrange(C): if grid[i][j] == 0 or lookup[i][j]: continue island_cnt += 1 floodfill(grid, i, j, lookup) return island_cnt R, C = len(grid), len(grid[0]) if count_islands(grid) != 1: return 0 for i in xrange(R): for j in xrange(C): if grid[i][j] == 0: continue grid[i][j] = 0 island_cnt = count_islands(grid) grid[i][j] = 1 if island_cnt != 1: return 1 return 2 ", "class Solution def minimumWeight(self, n, edges, src1, src2, dest): def dijkstra(adj, start): best = [float(\"inf\")]*len(adj) best[start] = 0 min_heap = [(0, start)] while min_heap: curr, u = heapq.heappop(min_heap) if best[u] < curr: continue for v, w in adj[u]: if best[v] <= curr+w: continue best[v] = curr+w heapq.heappush(min_heap, (curr+w, v)) return best adj1, adj2 = [[[] for _ in xrange(n)] for _ in xrange(2)] for u, v, w in edges: adj1[u].append((v, w)) adj2[v].append((u, w)) dist1 = dijkstra(adj1, src1) dist2 = dijkstra(adj1, src2) dist3 = dijkstra(adj2, dest) result = min(dist1[i]+dist2[i]+dist3[i] for i in xrange(n)) return result if result != float(\"inf\") else -1 ", "class Solution def numberOfCombinations(self, num): MOD = 10**9+7 def find_longest_common_prefix(num): lcp = [[0]*(len(num)+1) for _ in xrange(len(num)+1)] for i in reversed(xrange(len(lcp)-1)): for j in reversed(xrange(len(lcp[0])-1)): if num[i] == num[j]: lcp[i][j] = lcp[i+1][j+1]+1 return lcp def is_less_or_equal_to_with_same_length(num, lcp, i, j, l): return lcp[i][j] >= l or num[i+lcp[i][j]] < num[j+lcp[i][j]] lcp = find_longest_common_prefix(num) dp = [[0]*len(num) for _ in xrange(len(num))] dp[0][0] = int(num[0] != '0') for i in xrange(1, len(num)): dp[i][i] = dp[i-1][i-1] if num[i] == '0': continue accu = 0 for l in xrange(len(num)-i+1): ni = i+l-1 dp[ni][l-1] = accu if i-l < 0: continue if num[i-l] != '0' and is_less_or_equal_to_with_same_length(num, lcp, i-l, i, l): dp[ni][l-1] = (dp[ni][l-1] + dp[i-1][l-1]) % MOD accu = (accu + dp[i-1][l-1]) % MOD return reduce(lambda total, x: (total+x)%MOD, dp[-1], 0) ", "class Solution def minimumTimeToInitialState(self, word, k): def ceil_divide(a, b): return (a+b-1)//b def z_function(s): z = [0]*len(s) l, r = 0, 0 for i in xrange(1, len(z)): if i <= r: z[i] = min(r-i+1, z[i-l]) while i+z[i] < len(z) and s[z[i]] == s[i+z[i]]: z[i] += 1 if i+z[i]-1 > r: l, r = i, i+z[i]-1 return z z = z_function(word) for i in xrange(k, len(word), k): if z[i] == len(word)-i: return i//k return ceil_divide(len(word), k) ", "class Solution def minimumTimeToInitialState(self, word, k): def ceil_divide(a, b): return (a+b-1)//b for i in xrange(k, len(word), k): if all(word[i+j] == word[j] for j in xrange(len(word)-i)): return i//k return ceil_divide(len(word), k) ", "class Solution def isAlienSorted(self, words, order): lookup = {c: i for i, c in enumerate(order)} for i in xrange(len(words)-1): word1 = words[i] word2 = words[i+1] for k in xrange(min(len(word1), len(word2))): if word1[k] != word2[k]: if lookup[word1[k]] > lookup[word2[k]]: return False break else: if len(word1) > len(word2): return False return True ", "class Solution def countKeyChanges(self, s): return sum(s[i].lower() != s[i+1].lower() for i in xrange(len(s)-1)) ", "class Solution def matrixSumQueries(self, n, queries): lookup = [[False]*n for _ in xrange(2)] cnt = [0]*2 result = 0 for t, i, v in reversed(queries): if lookup[t][i]: continue lookup[t][i] = True cnt[t] += 1 result += v*(n-cnt[t^1]) return result ", "class Solution def maximumSum(self, arr): result, prev, curr = float(\"-inf\"), float(\"-inf\"), float(\"-inf\") for x in arr: curr = max(prev, curr+x, x) result = max(result, curr) prev = max(prev+x, x) return result ", "class Solution def maximumTripletValue(self, nums): NEG_INF = float(\"-inf\") result = 0 mx_diff = mx = NEG_INF for x in nums: if mx_diff != NEG_INF: result = max(result, mx_diff*x) if mx != NEG_INF: mx_diff = max(mx_diff, mx-x) mx = max(mx, x) return result ", "class Solution def countVowels(self, word): VOWELS = set(\"aeiou\") return sum((i-0+1) * ((len(word)-1)-i+1) for i, c in enumerate(word) if c in VOWELS) ", "class Solution def maxAbsValExpr(self, arr1, arr2): result = 0 for c1 in [1, -1]: for c2 in [1, -1]: min_prev = float(\"inf\") for i in xrange(len(arr1)): curr = c1*arr1[i] + c2*arr2[i] + i result = max(result, curr-min_prev) min_prev = min(min_prev, curr) return result ", "class Solution def maxAbsValExpr(self, arr1, arr2): return max(max(c1*arr1[i] + c2*arr2[i] + i for i in xrange(len(arr1))) - min(c1*arr1[i] + c2*arr2[i] + i for i in xrange(len(arr1))) for c1 in [1, -1] for c2 in [1, -1]) ", "class Solution def isArraySpecial(self, nums, queries): prefix = [0]*len(nums) for i in xrange(len(nums)-1): prefix[i+1] = prefix[i]+int(nums[i+1]&1 != nums[i]&1) result = [False]*len(queries) for i, (l, r) in enumerate(queries): result[i] = prefix[r]-prefix[l] == r-l return result ", "class Solution def getMinDistance(self, nums, target, start): for i in xrange(len(nums)): if (start-i >= 0 and nums[start-i] == target) or (start+i < len(nums) and nums[start+i] == target): break return i ", "class Solution def countPaths(self, n, roads): MOD = 10**9+7 def dijkstra(adj, start, target): best = collections.defaultdict(lambda:float(\"inf\")) best[start] = 0 min_heap = [(0, start)] dp = [0]*(len(adj)) dp[0] = 1 while min_heap: curr, u = heapq.heappop(min_heap) if best[u] < curr: continue if u == target: break for v, w in adj[u]: if v in best and best[v] <= curr+w: if best[v] == curr+w: dp[v] = (dp[v]+dp[u])%MOD continue dp[v] = dp[u] best[v] = curr+w heapq.heappush(min_heap, (curr+w, v)) return dp[target] adj = [[] for i in xrange(n)] for u, v, w in roads: adj[u].append((v, w)) adj[v].append((u, w)) return dijkstra(adj, 0, n-1) ", "class Solution def minimumTime(self, grid): DIRECTIONS = ((1, 0), (0, 1), (-1, 0), (0, -1)) def dijkstra(start, target): best = [[float(\"inf\")]*len(grid[0]) for _ in xrange(len(grid))] best[start[0]][start[1]] = 0 min_heap = [(0, start[0], start[1])] while min_heap: curr, i, j = heapq.heappop(min_heap) if best[i][j] < curr: continue if (i, j) == target: break for di, dj in DIRECTIONS: ni, nj = i+di, j+dj if not (0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and best[ni][nj] > max(grid[ni][nj]+int(grid[ni][nj]%2 == best[i][j]%2), curr+1)): continue best[ni][nj] = max(grid[ni][nj]+int(grid[ni][nj]%2 == best[i][j]%2), curr+1) heapq.heappush(min_heap, (best[ni][nj], ni, nj)) return best[target[0]][target[1]] if min(grid[0][1], grid[1][0]) > 1: return -1 return dijkstra((0, 0), (len(grid)-1, len(grid[0])-1)) ", "class Solution def maxUpgrades(self, count, upgrade, sell, money): return [min(c+(m-c*u)//(u+s), c) for c, u, s, m in itertools.izip(count, upgrade, sell, money)] ", "class Solution def shiftingLetters(self, s, shifts): events = [0]*(len(s)+1) for b, e, d in shifts: events[b] += 1 if d else -1 events[e+1] -= 1 if d else -1 result = [] curr = 0 for i in xrange(len(s)): curr += events[i] result.append(chr(ord('a')+(ord(s[i])-ord('a')+curr)%26)) return \"\".join(result) ", "class Solution def findMissingRanges(self, nums, lower, upper): def getRange(lower, upper): if lower == upper: return \"{}\".format(lower) else: return \"{}->{}\".format(lower, upper) ranges = [] pre = lower - 1 for i in xrange(len(nums) + 1): if i == len(nums): cur = upper + 1 else: cur = nums[i] if cur - pre >= 2: ranges.append(getRange(pre + 1, cur - 1)) pre = cur return ranges ", "class Solution def splitListToParts(self, root, k): n = 0 curr = root while curr: curr = curr.next n += 1 width, remainder = divmod(n, k) result = [] curr = root for i in xrange(k): head = curr for j in xrange(width-1+int(i < remainder)): if curr: curr = curr.next if curr: curr.next, curr = None, curr.next result.append(head) return result ", "class Solution def makeTheIntegerZero(self, num1, num2): def popcount(x): result = 0 while x: x &= (x-1) result += 1 return result for i in xrange(1, 60+1): if num1-i*num2 < 0: break if popcount(num1-i*num2) <= i <= num1-i*num2: return i return -1 ", "class Solution def maximalSquare(self, matrix): if not matrix: return 0 m, n = len(matrix), len(matrix[0]) size = [[0 for j in xrange(n)] for i in xrange(2)] max_size = 0 for j in xrange(n): if matrix[0][j] == '1': size[0][j] = 1 max_size = max(max_size, size[0][j]) for i in xrange(1, m): if matrix[i][0] == '1': size[i % 2][0] = 1 else: size[i % 2][0] = 0 for j in xrange(1, n): if matrix[i][j] == '1': size[i % 2][j] = min(size[i % 2][j - 1], size[(i - 1) % 2][j], size[(i - 1) % 2][j - 1]) + 1 max_size = max(max_size, size[i % 2][j]) else: size[i % 2][j] = 0 return max_size * max_size ", "class Solution def maximalSquare(self, matrix): if not matrix: return 0 m, n = len(matrix), len(matrix[0]) size = [[0 for j in xrange(n)] for i in xrange(m)] max_size = 0 for j in xrange(n): if matrix[0][j] == '1': size[0][j] = 1 max_size = max(max_size, size[0][j]) for i in xrange(1, m): if matrix[i][0] == '1': size[i][0] = 1 else: size[i][0] = 0 for j in xrange(1, n): if matrix[i][j] == '1': size[i][j] = min(size[i][j - 1], size[i - 1][j], size[i - 1][j - 1]) + 1 max_size = max(max_size, size[i][j]) else: size[i][j] = 0 return max_size * max_size ", "class Solution def maximalSquare(self, matrix): if not matrix: return 0 H, W = 0, 1 table = [[[0, 0] for j in xrange(len(matrix[0]))] for i in xrange(len(matrix))] for i in reversed(xrange(len(matrix))): for j in reversed(xrange(len(matrix[i]))): if matrix[i][j] == '1': h, w = 1, 1 if i + 1 < len(matrix): h = table[i + 1][j][H] + 1 if j + 1 < len(matrix[i]): w = table[i][j + 1][W] + 1 table[i][j] = [h, w] s = [[0 for j in xrange(len(matrix[0]))] for i in xrange(len(matrix))] max_square_area = 0 for i in reversed(xrange(len(matrix))): for j in reversed(xrange(len(matrix[i]))): side = min(table[i][j][H], table[i][j][W]) if matrix[i][j] == '1': if i + 1 < len(matrix) and j + 1 < len(matrix[i + 1]): side = min(s[i + 1][j + 1] + 1, side) s[i][j] = side max_square_area = max(max_square_area, side * side) return max_square_area ", "class Solution def minimumFlips(self, root, result): INF = float(\"inf\") OP = { 2: lambda x, y: x or y, 3: lambda x, y: x and y, 4: lambda x, y: x^y , 5: lambda x, y: not x if x is not None else not y } def iter_dfs(root, result): ret = collections.defaultdict(lambda: INF) stk = [(1, (root, ret))] while stk: step, args = stk.pop() if step == 1: node, ret = args if not node: ret[None] = 0 continue if node.left == node.right: ret[True] = node.val^1 ret[False] = node.val^0 continue ret1 = collections.defaultdict(lambda: INF) ret2 = collections.defaultdict(lambda: INF) stk.append((2, (node, ret1, ret2, ret))) stk.append((1, (node.right, ret2))) stk.append((1, (node.left, ret1))) elif step == 2: node, ret1, ret2, ret = args for k1, v1 in ret1.iteritems(): for k2, v2 in ret2.iteritems(): ret[OP[node.val](k1, k2)] = min(ret[OP[node.val](k1, k2)], v1+v2) return ret[result] return iter_dfs(root, result) import collections ", "class Solution def minimumFlips(self, root, result): INF = float(\"inf\") OP = { 2: lambda x, y: x or y, 3: lambda x, y: x and y, 4: lambda x, y: x^y , 5: lambda x, y: not x if x is not None else not y } def dfs(node): if not node: return {None: 0} if node.left == node.right: return {True: node.val^1, False: node.val^0} left = dfs(node.left) right = dfs(node.right) dp = collections.defaultdict(lambda: INF) for k1, v1 in left.iteritems(): for k2, v2 in right.iteritems(): dp[OP[node.val](k1, k2)] = min(dp[OP[node.val](k1, k2)], v1+v2) return dp return dfs(root)[result] ", "class Solution def maximumBeauty(self, nums, k): nums.sort() left = 0 for right in xrange(len(nums)): if nums[right]-nums[left] > k*2: left += 1 return right-left+1 ", "class Solution def findNumOfValidWords(self, words, puzzles): L = 7 def search(node, puzzle, start, first, met_first): result = 0 if \"_end\" in node and met_first: result += node[\"_end\"]; for i in xrange(start, len(puzzle)): if puzzle[i] not in node: continue result += search(node[puzzle[i]], puzzle, i+1, first, met_first or (puzzle[i] == first)) return result _trie = lambda: collections.defaultdict(_trie) trie = _trie() for word in words: count = set(word) if len(count) > L: continue word = sorted(count) end = reduce(dict.__getitem__, word, trie) end[\"_end\"] = end[\"_end\"]+1 if \"_end\" in end else 1 result = [] for puzzle in puzzles: first = puzzle[0] result.append(search(trie, sorted(puzzle), 0, first, False)) return result import collections ", "class Solution def findNumOfValidWords(self, words, puzzles): L = 7 lookup = collections.defaultdict(list) for i in xrange(len(puzzles)): bits = [] base = 1 << (ord(puzzles[i][0])-ord('a')) for j in xrange(1, L): bits.append(ord(puzzles[i][j])-ord('a')) for k in xrange(2**len(bits)): bitset = base for j in xrange(len(bits)): if k & (1<<j): bitset |= 1<<bits[j] lookup[bitset].append(i) result = [0]*len(puzzles) for word in words: bitset = 0 for c in word: bitset |= 1<<(ord(c)-ord('a')) if bitset not in lookup: continue for i in lookup[bitset]: result[i] += 1 return result ", "class Solution def maxAscendingSum(self, nums): result = curr = 0 for i in xrange(len(nums)): if not (i and nums[i-1] < nums[i]): curr = 0 curr += nums[i] result = max(result, curr) return result ", "class Solution def reverseBetween(self, head, m, n): diff, dummy, cur = n - m + 1, ListNode(-1), head dummy.next = head last_unswapped = dummy while cur and m > 1: cur, last_unswapped, m = cur.next, cur, m - 1 prev, first_swapped = last_unswapped, cur while cur and diff > 0: cur.next, prev, cur, diff = prev, cur, cur.next, diff - 1 last_unswapped.next, first_swapped.next = prev, cur return dummy.next ", "class Solution def numOfSubarrays(self, arr): MOD = 10**9+7 result, accu = 0, 0 dp = [1, 0] for x in arr: accu ^= x&1 dp[accu] += 1 result = (result + dp[accu^1]) % MOD return result ", "class Solution def mostVisited(self, n, rounds): return range(rounds[0], rounds[-1]+1) or range(1, rounds[-1]+1) + range(rounds[0], n+1) ", "class Solution def maximumInvitations(self, favorite): def find_cycles(adj): result = [] lookup = [False]*len(adj) for u in xrange(len(adj)): cnt = {} while not lookup[u]: lookup[u] = True cnt[u] = len(cnt) u = adj[u] if u in cnt: result.append((u, len(cnt)-cnt[u])) return result def bfs(adj, u, exclude): result = 0 q = [u] while q: result += 1 new_q = [] for u in q: for v in adj[u]: if v == exclude: continue new_q.append(v) q = new_q return result inv_adj = [[] for _ in xrange(len(favorite))] for u, v in enumerate(favorite): inv_adj[v].append(u) cycles = find_cycles(favorite) return max(max([l for _, l in cycles if l > 2] or [0]), sum(bfs(inv_adj, u, favorite[u]) + bfs(inv_adj, favorite[u], u) for u, l in cycles if l == 2)) ", "class Solution def deleteString(self, s): if all(x == s[0] for x in s): return len(s) dp2 = [[0]*(len(s)+1) for i in xrange(2)] dp = [1]*len(s) for i in reversed(xrange(len(s)-1)): for j in xrange(i+1, len(s)): dp2[i%2][j] = dp2[(i+1)%2][j+1]+1 if s[j] == s[i] else 0 if dp2[i%2][j] >= j-i: dp[i] = max(dp[i], dp[j]+1) return dp[0] ", "class Solution def deleteString(self, s): def getPrefix(pattern, start): prefix = [-1]*(len(pattern)-start) j = -1 for i in xrange(1, len(pattern)-start): while j != -1 and pattern[start+j+1] != pattern[start+i]: j = prefix[j] if pattern[start+j+1] == pattern[start+i]: j += 1 prefix[i] = j return prefix if all(x == s[0] for x in s): return len(s) dp = [1]*len(s) for i in reversed(xrange(len(s)-1)): prefix = getPrefix(s, i) for j in xrange(1, len(prefix), 2): if 2*(prefix[j]+1) == j+1: dp[i] = max(dp[i], dp[i+(prefix[j]+1)]+1) return dp[0] ", "class Solution def deleteString(self, s): MOD, P = 10**9+7, (113, 109) def hash(i, j): return [(prefix[idx][j+1]-prefix[idx][i]*power[idx][j-i+1])%MOD for idx in xrange(len(P))] if all(x == s[0] for x in s): return len(s) power = [[1] for _ in xrange(len(P))] prefix = [[0] for _ in xrange(len(P))] for x in s: for idx, p in enumerate(P): power[idx].append((power[idx][-1]*p)%MOD) prefix[idx].append((prefix[idx][-1]*p+(ord(x)-ord('a')))%MOD) dp = [1]*len(s) for i in reversed(xrange(len(s)-1)): for j in xrange(1, (len(s)-i)//2+1): if hash(i, i+j-1) == hash(i+j, i+2*j-1): dp[i] = max(dp[i], dp[i+j]+1) return dp[0] ", "class Solution def distinctSequences(self, n): def gcd(a, b): while b: a, b = b, a%b return a if n == 1: return 6 MOD = 10**9 + 7 dp = [[0]*6 for _ in xrange(6)] for i in xrange(6): for j in xrange(6): if i != j and gcd(i+1, j+1) == 1: dp[i][j] = 1 for _ in xrange(n-2): new_dp = [[0]*6 for _ in xrange(6)] for i in xrange(6): for j in xrange(6): if not dp[i][j]: continue for k in xrange(6): if not dp[j][k]: continue if k != i: new_dp[i][j] = (new_dp[i][j]+dp[j][k]) % MOD dp = new_dp return sum(dp[i][j] for i in xrange(6) for j in xrange(6)) % MOD ", "class Solution def countCornerRectangles(self, grid): rows = [[c for c, val in enumerate(row) if val] for row in grid] result = 0 for i in xrange(len(rows)): lookup = set(rows[i]) for j in xrange(i): count = sum(1 for c in rows[j] if c in lookup) result += count*(count-1)/2 return result ", "class Solution def multiply(self, A, B): m, n, l = len(A), len(A[0]), len(B[0]) res = [[0 for _ in xrange(l)] for _ in xrange(m)] for i in xrange(m): for k in xrange(n): if A[i][k]: for j in xrange(l): res[i][j] += A[i][k] * B[k][j] return res ", "class Solution def modifyString(self, s): s = list(s) for i in xrange(len(s)): if s[i] != '?': continue for c in ('a', 'b', 'c'): if (i == 0 or s[i-1] != c) and (i == len(s)-1 or c != s[i+1]): break s[i] = c return \"\".join(s) ", "class Solution def maxSubarrays(self, nums): result = curr = 0 for x in nums: curr = curr&x if curr else x if not curr: result += 1 return max(result, 1) ", "class Solution def findSubstringInWraproundString(self, p): letters = [0] * 26 result, length = 0, 0 for i in xrange(len(p)): curr = ord(p[i]) - ord('a') if i > 0 and ord(p[i-1]) != (curr-1)%26 + ord('a'): length = 0 length += 1 if length > letters[curr]: result += length - letters[curr] letters[curr] = length return result ", "class Solution def minimumLines(self, points): def gcd(a, b): while b: a, b = b, a % b return a def popcount(x): result = 0 while x: x &= (x-1) result += 1 return result def ceil_divide(a, b): return (a+b-1)//b lookup = collections.defaultdict(set) for i, (x1, y1) in enumerate(points): for j in xrange(i+1, len(points)): x2, y2 = points[j] a, b, c = (y2-y1), -(x2-x1), x1*(y2-y1)-y1*(x2-x1) g = gcd(gcd(a, b), c) a, b, c = a//g, b//g, c//g lookup[(a, b, c)].add((x1, y1)) lookup[(a, b, c)].add((x2, y2)) lines = [l for l, p in lookup.iteritems() if len(p) > 2] assert(len(lines) <= (len(points))//2) result = float(\"inf\") for mask in xrange(1<<len(lines)): covered = set() bit, i = 1, 0 while bit <= mask: if mask&bit: covered.update(lookup[lines[i]]) bit <<= 1 i += 1 result = min(result, popcount(mask) + ceil_divide(len(points)-len(covered), 2)) return result ", "class Solution def minElements(self, nums, limit, goal): return (abs(sum(nums)-goal) + (limit-1))//limit ", "class Solution def maxAverageRatio(self, classes, extraStudents): def profit(a, b): return float(a+1)/(b+1)-float(a)/b max_heap = [(-profit(a, b), a, b) for a, b in classes] heapq.heapify(max_heap) while extraStudents: v, a, b = heapq.heappop(max_heap) a, b = a+1, b+1 heapq.heappush(max_heap, (-profit(a, b), a, b)) extraStudents -= 1 return sum(float(a)/b for v, a, b in max_heap)/len(classes) ", "class Solution def minOperations(self, nums1, nums2): cnt = [0]*2 for x, y in itertools.izip(nums1, nums2): if not (min(x, y) <= min(nums1[-1], nums2[-1]) and max(x, y) <= max(nums1[-1], nums2[-1])): return -1 if not (x <= nums1[-1] and y <= nums2[-1]): cnt[0] += 1 if not (x <= nums2[-1] and y <= nums1[-1]): cnt[1] += 1 return min(cnt) import itertools ", "class Solution def minOperations(self, nums1, nums2): INF = float(\"inf\") def count(mx1, mx2): return sum(1 if y <= mx1 and x <= mx2 else INF for x, y in itertools.izip(nums1, nums2) if not (x <= mx1 and y <= mx2)) result = min(count(nums1[-1], nums2[-1]), count(nums2[-1], nums1[-1])) return result if result != INF else -1 ", "class Solution def minimumAverageDifference(self, nums): total = sum(nums) mn, idx = float(\"inf\"), -1 prefix = 0 for i, x in enumerate(nums): prefix += x a = prefix//(i+1) b = (total-prefix)//(len(nums)-(i+1)) if i+1 < len(nums) else 0 diff = abs(a-b) if diff < mn: mn, idx = diff, i return idx ", "class Solution def mergeInBetween(self, list1, a, b, list2): prev_first, last = None, list1 for i in xrange(b): if i == a-1: prev_first = last last = last.next prev_first.next = list2 while list2.next: list2 = list2.next list2.next = last.next last.next = None return list1 ", "class Solution def maxScore(self, nums): nums.sort(reverse=True) curr = 0 for i, x in enumerate(nums): curr += x if curr <= 0: return i return len(nums) ", "class Solution def minCost(self, s, cost): result = accu = max_cost = 0 for i in xrange(len(s)): if i and s[i] != s[i-1]: result += accu-max_cost accu = max_cost = 0 accu += cost[i] max_cost = max(max_cost, cost[i]) result += accu-max_cost return result ", "class Solution def numWays(self, s): MOD = 10**9+7 ones = s.count('1') if ones % 3: return 0 ones //= 3 if ones == 0: return (len(s)-1)*(len(s)-2)//2 % MOD count = left = right = 0 for c in s: if c == '1': count += 1 if count == ones: left += 1 elif count == 2*ones: right += 1 return left*right % MOD ", "class Solution def oddEvenJumps(self, A): def findNext(idx): result = [None]*len(idx) stack = [] for i in idx: while stack and stack[-1] < i: result[stack.pop()] = i stack.append(i) return result idx = sorted(range(len(A)), key = lambda i: A[i]) next_higher = findNext(idx) idx.sort(key = lambda i: -A[i]) next_lower = findNext(idx) odd, even = [False]*len(A), [False]*len(A) odd[-1], even[-1] = True, True for i in reversed(xrange(len(A)-1)): if next_higher[i]: odd[i] = even[next_higher[i]] if next_lower[i]: even[i] = odd[next_lower[i]] return sum(odd) ", "class Solution def threeConsecutiveOdds(self, arr): count = 0 for x in arr: count = count+1 if x%2 else 0 if count == 3: return True return False ", "class Solution def smallestEvenMultiple(self, n): return n<<(n&1) ", "class Solution def minOrAfterOperations(self, nums, k): result = 0 l = max(nums).bit_length() mask = (1<<l)-1 for i in reversed(xrange(l)): result <<= 1 curr, cnt = mask, 0 for x in nums: curr &= x>>i if curr&~result: cnt += 1 else: curr = mask if cnt > k: result += 1 return result ", "class Solution def maximumXorProduct(self, a, b, n): MOD = 10**9+7 for i in reversed(xrange(n)): base = 1<<i if min(a, b)&base == 0: a, b = a^base, b^base return (a%MOD)*(b%MOD)%MOD ", "class Solution def maxSumRangeQuery(self, nums, requests): def addmod(a, b, mod): a %= mod b %= mod if mod-a <= b: b -= mod return a+b def mulmod(a, b, mod): a %= mod b %= mod if a < b: a, b = b, a result = 0 while b > 0: if b%2 == 1: result = addmod(result, a, mod) a = addmod(a, a, mod) b //= 2 return result MOD = 10**9+7 count = [0]*len(nums) for start, end in requests: count[start] += 1 if end+1 < len(count): count[end+1] -= 1 for i in xrange(1, len(count)): count[i] += count[i-1] nums.sort() count.sort() result = 0 for i, (num, c) in enumerate(itertools.izip(nums, count)): result = (result+num*c)%MOD return result ", "class Solution def missingElement(self, nums, k): def missing_count(nums, x): return (nums[x]-nums[0]+1)-(x-0+1) def check(nums, k, x): return k > missing_count(nums, x) left, right = 0, len(nums)-1 while left <= right: mid = left + (right-left)//2 if not check(nums, k, mid): right = mid-1 else: left = mid+1 assert(check(nums, k, right)) return nums[right] + (k-missing_count(nums, right)) ", "class Solution def minPathCost(self, grid, moveCost): dp = [[0]*len(grid[0]) for _ in xrange(2)] dp[0] = [grid[0][j] for j in xrange(len(grid[0]))] for i in xrange(len(grid)-1): for j in xrange(len(grid[0])): dp[(i+1)%2][j] = min(dp[i%2][k]+moveCost[x][j] for k, x in enumerate(grid[i]))+grid[i+1][j] return min(dp[(len(grid)-1)%2]) ", "class Solution def totalNQueens(self, n): def dfs(row): if row == n: return 1 result = 0 for i in xrange(n): if cols[i] or main_diag[row+i] or anti_diag[row-i+(n-1)]: continue cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = True result += dfs(row+1) cols[i] = main_diag[row+i] = anti_diag[row-i+(n-1)] = False return result result = [] cols, main_diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1) return dfs(0) ", "class Solution def canChange(self, start, target): i = j = 0 while True: while i < len(start) and start[i] == '_': i += 1 while j < len(target) and target[j] == '_': j += 1 if i == len(start) and j == len(target): break if i == len(start) or j == len(target) or start[i] != target[j] or (start[i] == 'L' and i < j) or (start[i] == 'R' and i > j): return False i += 1 j += 1 return True ", "class Solution def isSolvable(self, words, result): def backtracking(words, result, i, j, carry, lookup, used): if j == len(result): return carry == 0 if i != len(words): if j >= len(words[i]) or words[i][j] in lookup: return backtracking(words, result, i+1, j, carry, lookup, used) for val in xrange(10): if val in used or (val == 0 and j == len(words[i])-1): continue lookup[words[i][j]] = val used.add(val) if backtracking(words, result, i+1, j, carry, lookup, used): return True used.remove(val) del lookup[words[i][j]] return False carry, val = divmod(carry + sum(lookup[w[j]] for w in words if j < len(w)), 10) if result[j] in lookup: return val == lookup[result[j]] and backtracking(words, result, 0, j+1, carry, lookup, used) if val in used or (val == 0 and j == len(result)-1): return False lookup[result[j]] = val used.add(val) if backtracking(words, result, 0, j+1, carry, lookup, used): return True used.remove(val) del lookup[result[j]] return False return backtracking([w[::-1] for w in words], result[::-1], 0, 0, 0, {}, set()) ", "class Solution def plusOne(self, digits): for i in reversed(xrange(len(digits))): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits digits[0] = 1 digits.append(0) return digits ", "class Solution def plusOne(self, digits): result = digits[::-1] carry = 1 for i in xrange(len(result)): result[i] += carry carry, result[i] = divmod(result[i], 10) if carry: result.append(carry) return result[::-1] ", "class Solution def minPairSum(self, nums): nums.sort() return max(nums[i]+nums[-1-i] for i in xrange(len(nums)//2)) ", "class Solution def pathSum(self, nums): class Node(object): def __init__(self, num): self.level = num/100 - 1 self.i = (num%100)/10 - 1 self.val = num%10 self.leaf = True def isParent(self, other): return self.level == other.level-1 and self.i == other.i/2 if not nums: return 0 result = 0 q = collections.deque() dummy = Node(10) parent = dummy for num in nums: child = Node(num) while not parent.isParent(child): result += parent.val if parent.leaf else 0 parent = q.popleft() parent.leaf = False child.val += parent.val q.append(child) while q: result += q.pop().val return result ", "class Solution def numSimilarGroups(self, A): def isSimilar(a, b): diff = 0 for x, y in itertools.izip(a, b): if x != y: diff += 1 if diff > 2: return False return diff == 2 N, L = len(A), len(A[0]) union_find = UnionFind(N) if N < L*L: for (i1, word1), (i2, word2) in itertools.combinations(enumerate(A), 2): if isSimilar(word1, word2): union_find.union_set(i1, i2) else: buckets = collections.defaultdict(list) lookup = set() for i in xrange(len(A)): word = list(A[i]) if A[i] not in lookup: buckets[A[i]].append(i) lookup.add(A[i]) for j1, j2 in itertools.combinations(xrange(L), 2): word[j1], word[j2] = word[j2], word[j1] buckets[\"\".join(word)].append(i) word[j1], word[j2] = word[j2], word[j1] for word in A: for i1, i2 in itertools.combinations(buckets[word], 2): union_find.union_set(i1, i2) return union_find.size() ", "class Solution def numIdenticalPairs(self, nums): return sum(c*(c-1)//2 for c in collections.Counter(nums).itervalues()) ", "class Solution def totalHammingDistance(self, nums): result = 0 for i in xrange(32): counts = [0] * 2 for num in nums: counts[(num >> i) & 1] += 1 result += counts[0] * counts[1] return result ", "class Solution def minAbsoluteDifference(self, nums, x): result = float(\"inf\") sl = SortedList() for i in xrange(x, len(nums)): sl.add(nums[i-x]) j = sl.bisect_left(nums[i]) if j-1 >= 0: result = min(result, nums[i]-sl[j-1]) if j < len(sl): result = min(result, sl[j]-nums[i]) return result ", "class Solution def shareCandies(self, candies, k): cnt = collections.Counter(candies[i] for i in xrange(k, len(candies))) result = curr = len(cnt) for i in xrange(k, len(candies)): cnt[candies[i]] -= 1 curr += (cnt[candies[i-k]] == 0) - (cnt[candies[i]] == 0) cnt[candies[i-k]] += 1 result = max(result, curr) return result ", "class Solution def maximumValue(self, strs): return max(int(s) if s.isdigit() else len(s) for s in strs) ", "class Solution def maxAncestorDiff(self, root): result = 0 stack = [(root, 0, float(\"inf\"))] while stack: node, mx, mn = stack.pop() if not node: continue result = max(result, mx-node.val, node.val-mn) mx = max(mx, node.val) mn = min(mn, node.val) stack.append((node.left, mx, mn)) stack.append((node.right, mx, mn)) return result ", "class Solution def maxAncestorDiff(self, root): def maxAncestorDiffHelper(node, mx, mn): if not node: return 0 result = max(mx-node.val, node.val-mn) mx = max(mx, node.val) mn = min(mn, node.val) result = max(result, maxAncestorDiffHelper(node.left, mx, mn)) result = max(result, maxAncestorDiffHelper(node.right, mx, mn)) return result return maxAncestorDiffHelper(root, 0, float(\"inf\")) ", "class Solution def splitBST(self, root, V): if not root: return None, None elif root.val <= V: result = self.splitBST(root.right, V) root.right = result[0] return root, result[1] else: result = self.splitBST(root.left, V) root.left = result[1] return result[0], root ", "class Solution def numRabbits(self, answers): count = collections.Counter(answers) return sum((((k+1)+v-1)//(k+1))*(k+1) for k, v in count.iteritems()) ", "class Solution def minWindow(self, S, T): lookup = [[None for _ in xrange(26)] for _ in xrange(len(S)+1)] find_char_next_pos = [None]*26 for i in reversed(xrange(len(S))): find_char_next_pos[ord(S[i])-ord('a')] = i+1 lookup[i] = list(find_char_next_pos) min_i, min_len = None, float(\"inf\") for i in xrange(len(S)): if S[i] != T[0]: continue start = i for c in T: start = lookup[start][ord(c)-ord('a')] if start == None: break else: if start-i < min_len: min_i, min_len = i, start-i return S[min_i:min_i+min_len] if min_i is not None else \"\" ", "class Solution def minWindow(self, S, T): dp = [[None for _ in xrange(len(S))] for _ in xrange(2)] for j, c in enumerate(S): if c == T[0]: dp[0][j] = j for i in xrange(1, len(T)): prev = None dp[i%2] = [None] * len(S) for j, c in enumerate(S): if prev is not None and c == T[i]: dp[i%2][j] = prev if dp[(i-1)%2][j] is not None: prev = dp[(i-1)%2][j] start, end = 0, len(S) for j, i in enumerate(dp[(len(T)-1)%2]): if i >= 0 and j-i < end-start: start, end = i, j return S[start:end+1] if end < len(S) else \"\" ", "class Solution def countOfAtoms(self, formula): parse = re.findall(r\"([A-Z][a-z]*)(\\d*)|(\\()|(\\))(\\d*)\", formula) stk = [collections.Counter()] for name, m1, left_open, right_open, m2 in parse: if name: stk[-1][name] += int(m1 or 1) if left_open: stk.append(collections.Counter()) if right_open: top = stk.pop() for k, v in top.iteritems(): stk[-1][k] += v * int(m2 or 1) return \"\".join(name + (str(stk[-1][name]) if stk[-1][name] > 1 else '') for name in sorted(stk[-1])) ", "class Solution def isSubtree(self, s, t): def isSame(x, y): if not x and not y: return True if not x or not y: return False return x.val == y.val and isSame(x.left, y.left) and isSame(x.right, y.right) def preOrderTraverse(s, t): return s != None and (isSame(s, t) or preOrderTraverse(s.left, t) or preOrderTraverse(s.right, t)) return preOrderTraverse(s, t) ", "class Solution def smallestFactorization(self, a): if a < 2: return a result, mul = 0, 1 for i in reversed(xrange(2, 10)): while a % i == 0: a /= i result = mul*i + result mul *= 10 return result if a == 1 and result < 2**31 else 0 ", "class Solution def minDifference(self, nums): def nth_element(nums, left, n, right, compare=lambda a, b: a < b): def partition_around_pivot(left, right, pivot_idx, nums, compare): new_pivot_idx = left nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx] for i in xrange(left, right): if compare(nums[i], nums[right]): nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i] new_pivot_idx += 1 nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right] return new_pivot_idx while left <= right: pivot_idx = random.randint(left, right) new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare) if new_pivot_idx == n: return elif new_pivot_idx > n: right = new_pivot_idx - 1 else: left = new_pivot_idx + 1 k = 4 if len(nums) <= k: return 0 nth_element(nums, 0, k, len(nums)-1) nums[:k] = sorted(nums[:k]) nth_element(nums, k, max(k, len(nums)-k), len(nums)-1) nums[-k:] = sorted(nums[-k:]) return min(nums[-k+i]-nums[i] for i in xrange(k)) ", "class Solution def distanceToCycle(self, n, edges): def cycle(parent, v, u): result = [parent[v], v] while u != parent[v]: result.append(u) u = parent[u] return result def iter_dfs(adj): stk = [0] parent = [-2]*len(adj) parent[0] = -1 while stk: u = stk.pop() for v in reversed(adj[u]): if parent[v] != -2: if v == parent[u]: continue return cycle(parent, v, u) parent[v] = u stk.append(v) def bfs(adj, q): result = [-1]*n for x in q: result[x] = 0 d = 1 while q: new_q = [] for u in q: for v in adj[u]: if result[v] != -1: continue result[v] = d new_q.append(v) q = new_q d += 1 return result adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) return bfs(adj, iter_dfs(adj)) ", "class Solution def canBeEqual(self, s1, s2): return all(collections.Counter(s1[j] for j in xrange(i, len(s1), 2)) == collections.Counter(s2[j] for j in xrange(i, len(s2), 2)) for i in xrange(2)) ", "class Solution def canBeEqual(self, s1, s2): return (((s1[0] == s2[0] and s1[2] == s2[2]) or (s1[0] == s2[2] and s1[2] == s2[0])) and ((s1[1] == s2[1] and s1[3] == s2[3]) or (s1[1] == s2[3] and s1[3] == s2[1]))) ", "class Solution def makesquare(self, nums): total_len = sum(nums) if total_len % 4: return False side_len = total_len / 4 fullset = (1 << len(nums)) - 1 used_subsets = [] valid_half_subsets = [0] * (1 << len(nums)) for subset in xrange(fullset+1): subset_total_len = 0 for i in xrange(len(nums)): if subset & (1 << i): subset_total_len += nums[i] if subset_total_len == side_len: for used_subset in used_subsets: if (used_subset & subset) == 0: valid_half_subset = used_subset | subset valid_half_subsets[valid_half_subset] = True if valid_half_subsets[fullset ^ valid_half_subset]: return True used_subsets.append(subset) return False ", "class Solution def containsDuplicate(self, nums): return len(nums) > len(set(nums)) ", "class Solution def deleteNodes(self, head, m, n): head = dummy = ListNode(next=head) while head: for _ in xrange(m): if not head.next: return dummy.next head = head.next prev = head for _ in xrange(n): if not head.next: prev.next = None return dummy.next head = head.next prev.next = head.next return dummy.next ", "class Solution def minCharacters(self, a, b): count1 = collections.Counter(ord(c)-ord('a') for c in a) count2 = collections.Counter(ord(c)-ord('a') for c in b) result = len(a) + len(b) - max((count1+count2).itervalues()) for i in xrange(26-1): if i > 0: count1[i] += count1[i-1] count2[i] += count2[i-1] result = min(result, len(a) - count1[i] + count2[i]) result = min(result, len(b) - count2[i] + count1[i]) return result ", "class Solution def maximumSum(self, nums): def sum_digits(x): result = 0 while x: result += x%10 x //= 10 return result lookup = {} result = -1 for x in nums: k = sum_digits(x) if k not in lookup: lookup[k] = x continue result = max(result, lookup[k]+x) if x > lookup[k]: lookup[k] = x return result ", "class Solution def minHeightShelves(self, books, shelf_width): dp = [float(\"inf\") for _ in xrange(len(books)+1)] dp[0] = 0 for i in xrange(1, len(books)+1): max_width = shelf_width max_height = 0 for j in reversed(xrange(i)): if max_width-books[j][0] < 0: break max_width -= books[j][0] max_height = max(max_height, books[j][1]) dp[i] = min(dp[i], dp[j]+max_height) return dp[len(books)] ", "class Solution def longestNiceSubstring(self, s): lookup = set(list(s)) prev = -1 result = \"\" for i in xrange(len(s)+1): if not (i == len(s) or s[i] not in lookup or s[i].swapcase() not in lookup): continue if prev == -1 and i == len(s): return s tmp = self.longestNiceSubstring(s[prev+1:i]) if len(tmp) > len(result): result = tmp prev = i return result ", "class Solution def findKthNumber(self, n, k): result = 0 cnts = [0] * 10 for i in xrange(1, 10): cnts[i] = cnts[i - 1] * 10 + 1 nums = [] i = n while i: nums.append(i % 10) i /= 10 total, target = n, 0 i = len(nums) - 1 while i >= 0 and k > 0: target = target*10 + nums[i] start = int(i == len(nums)-1) for j in xrange(start, 10): candidate = result*10 + j if candidate < target: num = cnts[i+1] elif candidate > target: num = cnts[i] else: num = total - cnts[i + 1]*(j-start) - cnts[i]*(9-j) if k > num: k -= num else: result = candidate k -= 1 total = num-1 break i -= 1 return result ", "class Solution def findKthNumber(self, n, k): def count(n, prefix): result, number = 0, 1 while prefix <= n: result += number prefix *= 10 number *= 10 result -= max(number/10 - (n - prefix/10 + 1), 0) return result def findKthNumberHelper(n, k, cur, index): if cur: index += 1 if index == k: return (cur, index) i = int(cur == 0) while i <= 9: cur = cur * 10 + i cnt = count(n, cur) if k > cnt + index: index += cnt elif cur <= n: result = findKthNumberHelper(n, k, cur, index) if result[0]: return result i += 1 cur /= 10 return (0, index) return findKthNumberHelper(n, k, 0, 0)[0] ", "class Solution def constructProductMatrix(self, grid): MOD = 12345 right = [1]*(len(grid)*len(grid[0])+1) for i in reversed(xrange(len(grid))): for j in reversed(xrange(len(grid[0]))): right[i*len(grid[0])+j] = (right[(i*len(grid[0])+j)+1]*grid[i][j])%MOD left = 1 for i in xrange(len(grid)): for j in xrange(len(grid[0])): grid[i][j], left = (left*right[(i*len(grid[0])+j)+1])%MOD, (left*grid[i][j])%MOD return grid ", "class Solution def constructProductMatrix(self, grid): MOD = 12345 left = [1]*(len(grid)*len(grid[0])+1) for i in xrange(len(grid)): for j in xrange(len(grid[0])): left[(i*len(grid[0])+j)+1] = (left[i*len(grid[0])+j]*grid[i][j])%MOD right = [1]*(len(grid)*len(grid[0])+1) for i in reversed(xrange(len(grid))): for j in reversed(xrange(len(grid[0]))): right[i*len(grid[0])+j] = (right[(i*len(grid[0])+j)+1]*grid[i][j])%MOD for i in xrange(len(grid)): for j in xrange(len(grid[0])): grid[i][j] = (left[i*len(grid[0])+j]*right[(i*len(grid[0])+j)+1])%MOD return grid ", "class Solution def evaluate(self, s, knowledge): lookup = {k: v for k, v in knowledge} result, curr = [], [] has_pair = False for c in s: if c == '(': has_pair = True elif c == ')': has_pair = False result.append(lookup.get(\"\".join(curr), '?')) curr = [] elif has_pair: curr.append(c) else: result.append(c) return \"\".join(result) ", "class Solution def distinctPrimeFactors(self, nums): result = set() for x in set(nums): for p in PRIMES: if p > x: break if x%p: continue result.add(p) while x%p == 0: x //= p if x != 1: result.add(x) return len(result) ", "class Solution def flatten(self, head): curr = head while curr: if curr.child: curr_next = curr.next curr.child.prev = curr curr.next = curr.child last_child = curr while last_child.next: last_child = last_child.next if curr_next: last_child.next = curr_next curr_next.prev = last_child curr.child = None curr = curr.next return head ", "class Solution def minimumCost(self, nums): def nth_element(nums, n, left=0, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right right = len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 nth_element(nums, 1+(2-1), 1) return nums[0]+nums[1]+nums[2] ", "class Solution def minimumCost(self, nums): def topk(a, k): result = [float(\"inf\")]*k for x in a: for i in xrange(len(result)): if x < result[i]: result[i], x = x, result[i] return result return nums[0]+sum(topk((nums[i] for i in xrange(1, len(nums))), 2)) ", "class Solution def maxSum(self, nums, k): MOD = 10**9+7 l = max(nums).bit_length() cnt = [0]*l for i in xrange(l): for x in nums: if x&(1<<i): cnt[i] += 1 return reduce(lambda x, y: (x+y)%MOD, (sum(1<<i for i in xrange(l) if cnt[i] >= j)**2 for j in xrange(1, k+1))) ", "class Solution def getSmallestString(self, s, k): result = map(lambda x: ord(x)-ord('a'), s) for i in xrange(len(result)): d = min(result[i]-0, 26-result[i]) result[i] = 0 if d <= k else result[i]-k k -= min(d, k) if k == 0: break return \"\".join(map(lambda x: chr(x+ord('a')), result)) ", "class Solution def isReflected(self, points): if not points: return True groups_by_y = collections.defaultdict(set) left, right = float(\"inf\"), float(\"-inf\") for p in points: groups_by_y[p[1]].add(p[0]) left, right = min(left, p[0]), max(right, p[0]) mid = left + right for group in groups_by_y.values(): for x in group: if mid - x not in group: return False return True ", "class Solution def isReflected(self, points): if not points: return True points.sort() points[len(points)/2:] = sorted(points[len(points)/2:], lambda x, y: y[1] - x[1] if x[0] == y[0] else x[0] - y[0]) mid = points[0][0] + points[-1][0] left, right = 0, len(points) - 1 while left <= right: if (mid != points[left][0] + points[right][0]) or (points[left][0] != points[right][0] and points[left][1] != points[right][1]): return False left += 1 right -= 1 return True ", "class Solution def findLeaves(self, root): def findLeavesHelper(node, result): if not node: return -1 level = 1 + max(findLeavesHelper(node.left, result), findLeavesHelper(node.right, result)) if len(result) < level + 1: result.append([]) result[level].append(node.val) return level result = [] findLeavesHelper(root, result) return result ", "class Solution def removeLeafNodes(self, root, target): if not root: return None root.left = self.removeLeafNodes(root.left, target) root.right = self.removeLeafNodes(root.right, target) return None if root.left == root.right and root.val == target else root ", "class Solution def findSolution(self, customfunction, z): result = [] x, y = 1, 1 while customfunction.f(x, y) < z: y += 1 while y > 0: while y > 0 and customfunction.f(x, y) > z: y -= 1 if y > 0 and customfunction.f(x, y) == z: result.append([x, y]) x += 1 return result ", "class Solution def stringIndices(self, wordsContainer, wordsQuery): INF = float(\"INF\") class Trie(object): def __init__(self): self.__nodes = [] self.__mns = [] self.__new_node() def __new_node(self): self.__nodes.append([-1]*26) self.__mns.append((INF, INF)) return len(self.__nodes)-1 def add(self, i, w): curr = 0 self.__mns[curr] = min(self.__mns[curr], (len(w), i)) for c in reversed(w): x = ord(c)-ord('a') if self.__nodes[curr][x] == -1: self.__nodes[curr][x] = self.__new_node() curr = self.__nodes[curr][x] self.__mns[curr] = min(self.__mns[curr], (len(w), i)) def query(self, w): curr = 0 for c in reversed(w): x = ord(c)-ord('a') if self.__nodes[curr][x] == -1: break curr = self.__nodes[curr][x] return self.__mns[curr][1] trie = Trie() for i, w in enumerate(wordsContainer): trie.add(i, w) return [trie.query(w) for w in wordsQuery] ", "class Solution def numBusesToDestination(self, routes, S, T): if S == T: return 0 to_route = collections.defaultdict(set) for i, route in enumerate(routes): for stop in route: to_route[stop].add(i) result = 1 q = [S] lookup = set([S]) while q: next_q = [] for stop in q: for i in to_route[stop]: for next_stop in routes[i]: if next_stop in lookup: continue if next_stop == T: return result next_q.append(next_stop) to_route[next_stop].remove(i) lookup.add(next_stop) q = next_q result += 1 return -1 ", "class Solution def combinationSum4(self, nums, target): dp = [0] * (target+1) dp[0] = 1 nums.sort() for i in xrange(1, target+1): for j in xrange(len(nums)): if nums[j] <= i: dp[i] += dp[i - nums[j]] else: break return dp[target] ", "class Solution def majorityElement(self, nums): def boyer_moore_majority_vote(): result, cnt = None, 0 for x in nums: if not cnt: result = x if x == result: cnt += 1 else: cnt -= 1 return result return boyer_moore_majority_vote() import collections ", "class Solution def majorityElement(self, nums): return collections.Counter(nums).most_common(1)[0][0] import collections ", "class Solution def majorityElement(self, nums): return sorted(collections.Counter(nums).items(), key=lambda a: a[1], reverse=True)[0][0] ", "class Solution def findBottomLeftValue(self, root): def findBottomLeftValueHelper(root, curr_depth, max_depth, bottom_left_value): if not root: return max_depth, bottom_left_value if not root.left and not root.right and curr_depth+1 > max_depth: return curr_depth+1, root.val max_depth, bottom_left_value = findBottomLeftValueHelper(root.left, curr_depth+1, max_depth, bottom_left_value) max_depth, bottom_left_value = findBottomLeftValueHelper(root.right, curr_depth+1, max_depth, bottom_left_value) return max_depth, bottom_left_value result, max_depth = 0, 0 return findBottomLeftValueHelper(root, 0, max_depth, result)[1] import collections ", "class Solution def findBottomLeftValue(self, root): last_node, q = None, collections.deque([root]) while q: last_node = q.popleft() q.extend([n for n in [last_node.right, last_node.left] if n]) return last_node.val ", "class Solution def numberOfSubarrays(self, nums): result = 0 stk = [] for x in nums: while stk and stk[-1][0] < x: stk.pop() if not stk or stk[-1][0] != x: stk.append([x, 0]) stk[-1][1] += 1 result += stk[-1][1] return result ", "class Solution def minFlips(self, target): result, curr = 0, '0' for c in target: if c == curr: continue curr = c result += 1 return result ", "class Solution def kthSmallestPath(self, destination, k): def nCr(n, r): if n < r: return 0 if n-r < r: return nCr(n, n-r) c = 1 for k in xrange(1, r+1): c *= n-k+1 c //= k return c r, c = destination result = [] while r+c: count = nCr(r+(c-1), r) if k <= count: c -= 1 result.append('H') else: k -= count r -= 1 result.append('V') return \"\".join(result) ", "class Solution def goodSubsetofBinaryMatrix(self, grid): lookup = {} for i in xrange(len(grid)): mask = reduce(lambda mask, j: mask|(grid[i][j]<<j), xrange(len(grid[0])), 0) if not mask: return [i] for mask2, j in lookup.iteritems(): if mask2&mask == 0: return [j, i] lookup[mask] = i return [] ", "class Solution def killProcess(self, pid, ppid, kill): def killAll(pid, children, killed): killed.append(pid) for child in children[pid]: killAll(child, children, killed) result = [] children = collections.defaultdict(set) for i in xrange(len(pid)): children[ppid[i]].add(pid[i]) killAll(kill, children, result) return result ", "class Solution def killProcess(self, pid, ppid, kill): def killAll(pid, children, killed): killed.append(pid) for child in children[pid]: killAll(child, children, killed) result = [] children = collections.defaultdict(set) for i in xrange(len(pid)): children[ppid[i]].add(pid[i]) q = collections.deque() q.append(kill) while q: p = q.popleft() result.append(p) for child in children[p]: q.append(child) return result ", "class Solution def longestSquareStreak(self, nums): sorted_nums = sorted(set(nums)) squares = {x for x in sorted_nums if x%2 < 2} result = 0 for x in sorted_nums: square, cnt = x**2, 1 while square in squares: squares.remove(square) cnt += 1 square *= square result = max(result, cnt) return result if result != 1 else -1 ", "class Solution def longestSquareStreak(self, nums): dp = collections.defaultdict(int) nums.sort() result = -1 for x in nums: sqrt_x = int(x**0.5) if sqrt_x**2 == x: dp[x] = dp[sqrt_x]+1 else: dp[x] = 1 result = max(result, dp[x]) return result if result != 1 else -1 ", "class Solution def latestDayToCross(self, row, col, cells): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def index(n, i, j): return i*n+j start, end = row*col, row*col+1 uf = UnionFind(row*col+2) lookup = [[False]*col for _ in xrange(row)] for i in reversed(xrange(len(cells))): r, c = cells[i] r, c = r-1, c-1 for dr, dc in directions: nr, nc = r+dr, c+dc if not (0 <= nr < row and 0 <= nc < col and lookup[nr][nc]): continue uf.union_set(index(col, r, c), index(col, nr, nc)) if r == 0: uf.union_set(start, index(col, r, c)) if r == row-1: uf.union_set(end, index(col, r, c)) if uf.find_set(start) == uf.find_set(end): return i lookup[r][c] = True return -1 ", "class Solution def countPaths(self, n, edges): def linear_sieve_of_eratosthenes(n): primes = [] spf = [-1]*(n+1) for i in xrange(2, n+1): if spf[i] == -1: spf[i] = i primes.append(i) for p in primes: if i*p > n or p > spf[i]: break spf[i*p] = p return spf def is_prime(u): return spf[u] == u def iter_dfs(): result = 0 stk = [(1, (0, -1, [0]*2))] while stk: step, args = stk.pop() if step == 1: u, p, ret = args ret[:] = [1-is_prime(u+1), is_prime(u+1)] stk.append((2, (u, p, ret, 0))) elif step == 2: u, p, ret, i = args if i == len(adj[u]): continue v = adj[u][i] stk.append((2, (u, p, ret, i+1))) if v == p: continue new_ret = [0]*2 stk.append((3, (u, p, new_ret, ret, i))) stk.append((1, (v, u, new_ret))) elif step == 3: u, p, new_ret, ret, i = args result += ret[0]*new_ret[1]+ret[1]*new_ret[0] if is_prime(u+1): ret[1] += new_ret[0] else: ret[0] += new_ret[0] ret[1] += new_ret[1] return result spf = linear_sieve_of_eratosthenes(n) adj = [[] for _ in xrange(n)] for u, v in edges: u, v = u-1, v-1 adj[u].append(v) adj[v].append(u) return iter_dfs() ", "class Solution def countPaths(self, n, edges): def linear_sieve_of_eratosthenes(n): primes = [] spf = [-1]*(n+1) for i in xrange(2, n+1): if spf[i] == -1: spf[i] = i primes.append(i) for p in primes: if i*p > n or p > spf[i]: break spf[i*p] = p return spf def is_prime(u): return spf[u] == u def dfs(u, p): cnt = [1-is_prime(u+1), is_prime(u+1)] for v in adj[u]: if v == p: continue new_cnt = dfs(v, u) result[0] += cnt[0]*new_cnt[1]+cnt[1]*new_cnt[0] if is_prime(u+1): cnt[1] += new_cnt[0] else: cnt[0] += new_cnt[0] cnt[1] += new_cnt[1] return cnt spf = linear_sieve_of_eratosthenes(n) adj = [[] for _ in xrange(n)] for u, v in edges: u, v = u-1, v-1 adj[u].append(v) adj[v].append(u) result = [0] dfs(0, -1) return result[0] class UnionFind(object): def __init__(self, n): self.set = range(n) self.rank = [0]*n self.size = [1]*n def find_set(self, x): stk = [] while self.set[x] != x: stk.append(x) x = self.set[x] while stk: self.set[stk.pop()] = x return x def union_set(self, x, y): x, y = self.find_set(x), self.find_set(y) if x == y: return False if self.rank[x] > self.rank[y]: x, y = y, x self.set[x] = self.set[y] if self.rank[x] == self.rank[y]: self.rank[y] += 1 self.size[y] += self.size[x] return True def total(self, x): return self.size[self.find_set(x)] ", "class Solution def countPaths(self, n, edges): def linear_sieve_of_eratosthenes(n): primes = [] spf = [-1]*(n+1) for i in xrange(2, n+1): if spf[i] == -1: spf[i] = i primes.append(i) for p in primes: if i*p > n or p > spf[i]: break spf[i*p] = p return spf def is_prime(u): return spf[u] == u spf = linear_sieve_of_eratosthenes(n) uf = UnionFind(n) for u, v in edges: u, v = u-1, v-1 if is_prime(u+1) == is_prime(v+1) == False: uf.union_set(u, v) result = 0 cnt = [1]*n for u, v in edges: u, v = u-1, v-1 if is_prime(u+1) == is_prime(v+1): continue if not is_prime(u+1): u, v = v, u result += cnt[u]*uf.total(v) cnt[u] += uf.total(v) return result ", "class Solution def largestInteger(self, num): def count(num): cnt = [0]*10 while num: num, d = divmod(num, 10) cnt[d] += 1 return cnt cnt = count(num) result = 0 digit = [0, 1] base = 1 while num: num, d = divmod(num, 10) while not cnt[digit[d%2]]: digit[d%2] += 2 cnt[digit[d%2]] -= 1 result += digit[d%2]*base base *= 10 return result ", "class Solution def shipWithinDays(self, weights, D): def possible(weights, D, mid): result, curr = 1, 0 for w in weights: if curr+w > mid: result += 1 curr = 0 curr += w return result <= D left, right = max(weights), sum(weights) while left <= right: mid = left + (right-left)//2 if possible(weights, D, mid): right = mid-1 else: left = mid+1 return left ", "class Solution def minimumBoxes(self, n): h = int((6*n)**(1.0/3)) if h*(h+1)*(h+2) > 6*n: h -= 1 n -= h*(h+1)*(h+2)//6 d = int(math.ceil((-1+(1+8*n)**0.5)/2)) return h*(h+1)//2 + d ", "class Solution def longestCommonSubsequence(self, text1, text2): if len(text1) < len(text2): return self.longestCommonSubsequence(text2, text1) dp = [[0 for _ in xrange(len(text2)+1)] for _ in xrange(2)] for i in xrange(1, len(text1)+1): for j in xrange(1, len(text2)+1): dp[i%2][j] = dp[(i-1)%2][j-1]+1 if text1[i-1] == text2[j-1] else max(dp[(i-1)%2][j], dp[i%2][j-1]) return dp[len(text1)%2][len(text2)] ", "class Solution def luckyNumbers (self, matrix): rows = map(min, matrix) cols = map(max, itertools.izip(*matrix)) return [cell for i, row in enumerate(matrix) for j, cell in enumerate(row) if rows[i] == cols[j]] import itertools ", "class Solution def luckyNumbers (self, matrix): return list(set(map(min, matrix)) & set(map(max, itertools.izip(*matrix)))) ", "class Solution def cloneTree(self, root): result = [None] stk = [(1, (root, result))] while stk: step, params = stk.pop() if step == 1: node, ret = params if not node: continue ret[0] = Node(node.val) for child in reversed(node.children): ret1 = [None] stk.append((2, (ret1, ret))) stk.append((1, (child, ret1))) else: ret1, ret = params ret[0].children.append(ret1[0]) return result[0] ", "class Solution def cloneTree(self, root): def dfs(node): if not node: return None copy = Node(node.val) for child in node.children: copy.children.append(dfs(child)) return copy return dfs(root) ", "class Solution def licenseKeyFormatting(self, S, K): result = [] for i in reversed(xrange(len(S))): if S[i] == '-': continue if len(result) % (K + 1) == K: result += '-' result += S[i].upper() return \"\".join(reversed(result)) ", "class Solution def frequenciesOfElements(self, head): curr = dummy = ListNode(0) cnt = 0 while head: cnt += 1 if not head.next or head.next.val != head.val: curr.next = ListNode(cnt) curr = curr.next cnt = 0 head = head.next return dummy.next ", "class Solution def findHighAccessEmployees(self, access_times): LIMIT_COUNT = 2 LIMIT_MINUTE = 60 def to_minute(x): return int(x[:2])*60+int(x[2:]) lookup = collections.defaultdict(list) for x, t in access_times: lookup[x].append(to_minute(t)) result = [] for x, ts in lookup.iteritems(): ts.sort() if not all(ts[i]+LIMIT_MINUTE <= ts[i+LIMIT_COUNT] for i in xrange(len(ts)-LIMIT_COUNT)): result.append(x) return result ", "class Solution def divideArray(self, nums): return all(cnt%2 == 0 for cnt in collections.Counter(nums).itervalues()) ", "class Solution def largestMerge(self, word1, word2): q1 = collections.deque(word1) q2 = collections.deque(word2) result = [] while q1 or q2: if q1 > q2: result.append(q1.popleft()) else: result.append(q2.popleft()) return \"\".join(result) ", "class Solution def repeatLimitedString(self, s, repeatLimit): cnt = collections.Counter(map(lambda x: ord(x)-ord('a'), s)) result = [] top1 = 25 while True: top1 = next((i for i in reversed(xrange(top1+1)) if cnt[i]), -1) if top1 == -1: break c = min(cnt[top1], repeatLimit-int(len(result) > 0 and result[-1] == top1)) cnt[top1] -= c result.extend([top1]*c) top2 = next((j for j in reversed(xrange(top1)) if cnt[j]), -1) if top2 == -1: break cnt[top2] -= 1 result.append(top2) return \"\".join(map(lambda x: chr(x+ord('a')), result)) ", "class Solution def countLargestGroup(self, n): count = collections.Counter() for x in xrange(1, n+1): count[sum(map(int, str(x)))] += 1 max_count = max(count.itervalues()) return sum(v == max_count for v in count.itervalues()) ", "class Solution def interpret(self, command): result, i = [], 0 while i < len(command): if command[i] == 'G': result += [\"G\"] i += 1 elif command[i] == '(' and command[i+1] == ')': result += [\"o\"] i += 2 else: result += [\"al\"] i += 4 return \"\".join(result) ", "class Solution def replaceValueInTree(self, root): q = [(root, root.val)] while q: new_q = [] total = sum(node.val for node, _ in q) for node, x in q: node.val = total-x x = (node.left.val if node.left else 0) + (node.right.val if node.right else 0) if node.left: new_q.append((node.left, x)) if node.right: new_q.append((node.right, x)) q = new_q return root ", "class Solution def findSecretWord(self, wordlist, master): possible = range(len(wordlist)) n = 0 while n < 6: count = [collections.Counter(w[i] for w in wordlist) for i in xrange(6)] guess = max(possible, key=lambda x: sum(count[i][c] for i, c in enumerate(wordlist[x]))) n = master.guess(wordlist[guess]) possible = [j for j in possible if sum(a == b for a, b in itertools.izip(wordlist[guess], wordlist[j])) == n] ", "class Solution def findSecretWord(self, wordlist, master): def solve(H, possible): min_max_group, best_guess = possible, None for guess in possible: groups = [[] for _ in xrange(7)] for j in possible: if j != guess: groups[H[guess][j]].append(j) max_group = max(groups, key=len) if len(max_group) < len(min_max_group): min_max_group, best_guess = max_group, guess return best_guess H = [[sum(a == b for a, b in itertools.izip(wordlist[i], wordlist[j])) for j in xrange(len(wordlist))] for i in xrange(len(wordlist))] possible = range(len(wordlist)) n = 0 while n < 6: guess = solve(H, possible) n = master.guess(wordlist[guess]) possible = [j for j in possible if H[guess][j] == n] ", "class Solution def findSecretWord(self, wordlist, master): def solve(H, possible): min_max_group, best_guess = possible, None for guess in possible: groups = [[] for _ in xrange(7)] for j in possible: if j != guess: groups[H[guess][j]].append(j) max_group = groups[0] if len(max_group) < len(min_max_group): min_max_group, best_guess = max_group, guess return best_guess H = [[sum(a == b for a, b in itertools.izip(wordlist[i], wordlist[j])) for j in xrange(len(wordlist))] for i in xrange(len(wordlist))] possible = range(len(wordlist)) n = 0 while n < 6: guess = solve(H, possible) n = master.guess(wordlist[guess]) possible = [j for j in possible if H[guess][j] == n] ", "class Solution def filterRestaurants(self, restaurants, veganFriendly, maxPrice, maxDistance): result, lookup = [], {} for j, (i, _, v, p, d) in enumerate(restaurants): if v >= veganFriendly and p <= maxPrice and d <= maxDistance: lookup[i] = j result.append(i) result.sort(key=lambda i: (-restaurants[lookup[i]][1], -restaurants[lookup[i]][0])) return result ", "class Solution def appendCharacters(self, s, t): i = -1 for j, c in enumerate(t): for i in xrange(i+1, len(s)): if s[i] == c: break else: return len(t)-j return 0 ", "class Solution def threeSumClosest(self, nums, target): result, min_diff = 0, float(\"inf\") nums.sort() for i in reversed(xrange(2, len(nums))): if i+1 < len(nums) and nums[i] == nums[i+1]: continue left, right = 0, i-1 while left < right: total = nums[left]+nums[right]+nums[i] if total < target: left += 1 elif total > target: right -= 1 else: return target if abs(total-target) < min_diff: min_diff = abs(total-target) result = total return result ", "class Solution def highFive(self, items): min_heaps = collections.defaultdict(list) for i, val in items: heapq.heappush(min_heaps[i], val) if len(min_heaps[i]) > 5: heapq.heappop(min_heaps[i]) return [[i, sum(min_heaps[i]) // len(min_heaps[i])] for i in sorted(min_heaps)] ", "class Solution def digitSum(self, s, k): while len(s) > k: s = \"\".join(map(str, (sum(map(int, s[i:i+k])) for i in xrange(0, len(s), k)))) return s ", "class Solution def isEvenOddTree(self, root): q = [root] is_odd = False while q: new_q = [] prev = None for node in q: if is_odd: if node.val%2 or (prev and prev.val <= node.val): return False else: if not node.val%2 or (prev and prev.val >= node.val): return False if node.left: new_q.append(node.left) if node.right: new_q.append(node.right) prev = node q = new_q is_odd = not is_odd return True ", "class Solution def minDeletionSize(self, A): result = 0 for c in xrange(len(A[0])): for r in xrange(1, len(A)): if A[r-1][c] > A[r][c]: result += 1 break return result import itertools ", "class Solution def minDeletionSize(self, A): result = 0 for col in itertools.izip(*A): if any(col[i] > col[i+1] for i in xrange(len(col)-1)): result += 1 return result ", "class Solution def kthLargestLevelSum(self, root, k): def nth_element(nums, n, left=0, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right right = len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 arr = [] q = [root] while q: new_q = [] for u in q: if u.left: new_q.append(u.left) if u.right: new_q.append(u.right) arr.append(sum(x.val for x in q)) q = new_q if k-1 >= len(arr): return -1 nth_element(arr, k-1, compare=lambda a, b: a > b) return arr[k-1] ", "class Solution def findArray(self, pref): for i in reversed(xrange(1, len(pref))): pref[i] ^= pref[i-1] return pref ", "class Solution def criticalConnections(self, n, connections): def dfs(edges, parent, u, idx, lowlinks, lookup, result): if lookup[u]: return lookup[u] = True curr_idx = lowlinks[u] = idx[0] idx[0] += 1 for v in edges[u]: if v == parent: continue dfs(edges, u, v, idx, lowlinks, lookup, result) lowlinks[u] = min(lowlinks[u], lowlinks[v]) if lowlinks[v] > curr_idx: result.append([u, v]) edges = [[] for _ in xrange(n)] idx, lowlinks, lookup = [0], [0]*n, [False]*n result = [] for u, v in connections: edges[u].append(v) edges[v].append(u) dfs(edges, -1, 0, idx, lowlinks, lookup, result) return result ", "class Solution def bestCoordinate(self, towers, radius): min_x = min(towers, key=lambda x:x[0])[0] max_x = max(towers, key=lambda x:x[0])[0] min_y = min(towers, key=lambda x:x[1])[1] max_y = max(towers, key=lambda x:x[1])[1] max_quality = 0 for x in xrange(min_x, max_x+1): for y in xrange(min_y, max_y+1): q = 0 for nx, ny, nq in towers: d = ((nx-x)**2+(ny-y)**2)**0.5 if d <= radius: q += int(nq/(1+d)) if q > max_quality: max_quality = q result = x, y return result ", "class Solution def countVowelPermutation(self, n): def matrix_expo(A, K): result = [[int(i==j) for j in xrange(len(A))] for i in xrange(len(A))] while K: if K % 2: result = matrix_mult(result, A) A = matrix_mult(A, A) K /= 2 return result def matrix_mult(A, B): ZB = zip(*B) return [[sum(a*b for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A] MOD = 10**9 + 7 T = [[0, 1, 1, 0, 1], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 0, 1, 1, 0]] return sum(map(sum, matrix_expo(T, n-1))) % MOD ", "class Solution def countVowelPermutation(self, n): MOD = 10**9 + 7 a, e, i, o, u = 1, 1, 1, 1, 1 for _ in xrange(1, n): a, e, i, o, u = (e+i+u) % MOD, (a+i) % MOD, (e+o) % MOD, i, (i+o) % MOD return (a+e+i+o+u) % MOD ", "class Solution def floodFill(self, image, sr, sc, newColor): directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] def dfs(image, r, c, newColor, color): if not (0 <= r < len(image) and 0 <= c < len(image[0]) and image[r][c] == color): return image[r][c] = newColor for d in directions: dfs(image, r+d[0], c+d[1], newColor, color) color = image[sr][sc] if color == newColor: return image dfs(image, sr, sc, newColor, color) return image ", "class Solution def maxProfit(self, prices): profit = 0 for i in xrange(len(prices) - 1): profit += max(0, prices[i + 1] - prices[i]) return profit def maxProfit2(self, prices): return sum(map(lambda x: max(prices[x + 1] - prices[x], 0), xrange(len(prices[:-1])))) ", "class Solution def longestSemiRepetitiveSubstring(self, s): result = left = prev = 0 for right in xrange(len(s)): if right-1 >= 0 and s[right-1] == s[right]: left, prev = prev, right result = max(result, right-left+1) return result ", "class Solution def lemonadeChange(self, bills): coins = [20, 10, 5] counts = collections.defaultdict(int) for bill in bills: counts[bill] += 1 change = bill - coins[-1] for coin in coins: if change == 0: break if change >= coin: count = min(counts[coin], change//coin) counts[coin] -= count change -= coin * count if change != 0: return False return True ", "class Solution def lemonadeChange(self, bills): five, ten = 0, 0 for bill in bills: if bill == 5: five += 1 elif bill == 10: if not five: return False five -= 1 ten += 1 else: if ten and five: ten -= 1 five -= 1 elif five >= 3: five -= 3 else: return False return True ", "class Solution def clumsy(self, N): if N <= 2: return N if N <= 4: return N+3 if N % 4 == 0: return N+1 elif N % 4 <= 2: return N+2 return N-1 ", "class Solution def splitPainting(self, segments): counts = collections.defaultdict(int) for s, e, c in segments: counts[s] += c counts[e] -= c points = sorted(x for x in counts.iteritems()) result = [] overlap = prev = 0 for curr, cnt in points: if overlap: result.append([prev, curr, overlap]) overlap += cnt prev = curr return result ", "class Solution def mostVisitedPattern(self, username, timestamp, website): lookup = collections.defaultdict(list) A = zip(timestamp, username, website) A.sort() for t, u, w in A: lookup[u].append(w) count = sum([collections.Counter(set(itertools.combinations(lookup[u], 3))) for u in lookup], collections.Counter()) return list(min(count, key=lambda x: (-count[x], x))) ", "class Solution def sumOfThree(self, num): return [num//3-1, num//3, num//3+1] if num%3 == 0 else [] ", "class Solution def advantageCount(self, A, B): sortedA = sorted(A) sortedB = sorted(B) candidates = {b: [] for b in B} others = [] j = 0 for a in sortedA: if a > sortedB[j]: candidates[sortedB[j]].append(a) j += 1 else: others.append(a) return [candidates[b].pop() if candidates[b] else others.pop() for b in B] ", "class Solution def fourSum(self, nums, target): nums.sort() result = [] for i in xrange(len(nums) - 3): if i and nums[i] == nums[i - 1]: continue for j in xrange(i + 1, len(nums) - 2): if j != i + 1 and nums[j] == nums[j - 1]: continue total = target - nums[i] - nums[j] left, right = j + 1, len(nums) - 1 while left < right: if nums[left] + nums[right] == total: result.append([nums[i], nums[j], nums[left], nums[right]]) right -= 1 left += 1 while left < right and nums[left] == nums[left - 1]: left += 1 while left < right and nums[right] == nums[right + 1]: right -= 1 elif nums[left] + nums[right] > total: right -= 1 else: left += 1 return result ", "class Solution def fourSum(self, nums, target): nums, result, lookup = sorted(nums), [], collections.defaultdict(list) for i in xrange(0, len(nums) - 1): for j in xrange(i + 1, len(nums)): is_duplicated = False for [x, y] in lookup[nums[i] + nums[j]]: if nums[x] == nums[i]: is_duplicated = True break if not is_duplicated: lookup[nums[i] + nums[j]].append([i, j]) ans = {} for c in xrange(2, len(nums)): for d in xrange(c+1, len(nums)): if target - nums[c] - nums[d] in lookup: for [a, b] in lookup[target - nums[c] - nums[d]]: if b < c: quad = [nums[a], nums[b], nums[c], nums[d]] quad_hash = \" \".join(str(quad)) if quad_hash not in ans: ans[quad_hash] = True result.append(quad) return result ", "class Solution def fourSum(self, nums, target): nums, result, lookup = sorted(nums), [], collections.defaultdict(list) for i in xrange(0, len(nums) - 1): for j in xrange(i + 1, len(nums)): lookup[nums[i] + nums[j]].append([i, j]) for i in lookup.keys(): if target - i in lookup: for x in lookup[i]: for y in lookup[target - i]: [a, b], [c, d] = x, y if a is not c and a is not d and b is not c and b is not d: quad = sorted([nums[a], nums[b], nums[c], nums[d]]) if quad not in result: result.append(quad) return sorted(result) ", "class Solution def longestDecomposition(self, text): def compare(text, l, s1, s2): for i in xrange(l): if text[s1+i] != text[s2+i]: return False return True MOD = 10**9+7 D = 26 result = 0 left, right, l, pow_D = 0, 0, 0, 1 for i in xrange(len(text)): left = (D*left + (ord(text[i])-ord('a'))) % MOD right = (pow_D*(ord(text[-1-i])-ord('a')) + right) % MOD l += 1 pow_D = (pow_D*D) % MOD if left == right and compare(text, l, i-l+1, len(text)-1-i): result += 1 left, right, l, pow_D = 0, 0, 0, 1 return result ", "class Solution def boundaryOfBinaryTree(self, root): def leftBoundary(root, nodes): if not root or (not root.left and not root.right): return nodes.append(root.val) if not root.left: leftBoundary(root.right, nodes) else: leftBoundary(root.left, nodes) def rightBoundary(root, nodes): if not root or (not root.left and not root.right): return if not root.right: rightBoundary(root.left, nodes) else: rightBoundary(root.right, nodes) nodes.append(root.val) def leaves(root, nodes): if not root: return if not root.left and not root.right: nodes.append(root.val) return leaves(root.left, nodes) leaves(root.right, nodes) if not root: return [] nodes = [root.val] leftBoundary(root.left, nodes) leaves(root.left, nodes) leaves(root.right, nodes) rightBoundary(root.right, nodes) return nodes ", "class Solution def kInversePairs(self, n, k): M = 1000000007 dp = [[0]*(k+1) for _ in xrange(2)] dp[0][0] = 1 for i in xrange(1, n+1): dp[i%2] = [0]*(k+1) dp[i%2][0] = 1 for j in xrange(1, k+1): dp[i%2][j] = (dp[i%2][j-1] + dp[(i-1)%2][j]) % M if j-i >= 0: dp[i%2][j] = (dp[i%2][j] - dp[(i-1)%2][j-i]) % M return dp[n%2][k] ", "class Solution def camelMatch(self, queries, pattern): def is_matched(query, pattern): i = 0 for c in query: if i < len(pattern) and pattern[i] == c: i += 1 elif c.isupper(): return False return i == len(pattern) result = [] for query in queries: result.append(is_matched(query, pattern)) return result ", "class Solution def findCircleNum(self, M): class UnionFind(object): def __init__(self, n): self.set = range(n) self.count = n def find_set(self, x): if self.set[x] != x: self.set[x] = self.find_set(self.set[x]) return self.set[x] def union_set(self, x, y): x_root, y_root = map(self.find_set, (x, y)) if x_root != y_root: self.set[min(x_root, y_root)] = max(x_root, y_root) self.count -= 1 circles = UnionFind(len(M)) for i in xrange(len(M)): for j in xrange(len(M)): if M[i][j] and i != j: circles.union_set(i, j) return circles.count ", "class Solution def largestPalindrome(self, n): if n == 1: return 9 upper = 10**n-1 for k in xrange(2, upper+1): left = 10**n-k right = int(str(left)[::-1]) d = k**2-right*4 if d < 0: continue if d**0.5 == int(d**0.5) and k%2 == int(d**0.5)%2: return (left*10**n+right)%1337 return -1 ", "class Solution def largestPalindrome(self, n): def divide_ceil(a, b): return (a+b-1)//b if n == 1: return 9 upper, lower = 10**n-1, 10**(n-1) for i in reversed(xrange(lower, upper**2//(10**n)+1)): candidate = int(str(i) + str(i)[::-1]) for y in reversed(xrange(divide_ceil(lower, 11)*11, upper+1, 11)): if candidate//y > upper: break if candidate%y == 0 and lower <= candidate//y: return candidate%1337 return -1 ", "class Solution def categorizeBox(self, length, width, height, mass): bulky = any(x >= 10**4 for x in (length, width, height)) or length*width*height >= 10**9 heavy = mass >= 100 if bulky and heavy: return \"Both\" if bulky: return \"Bulky\" if heavy: return \"Heavy\" return \"Neither\" ", "class Solution def categorizeBox(self, length, width, height, mass): CATEGORIES = [\"Neither\", \"Heavy\", \"Bulky\", \"Both\"] i = 2*(any(x >= 10**4 for x in (length, width, height)) or length*width*height >= 10**9)+int(mass >= 100) return CATEGORIES[i] ", "class Solution def findTheLongestBalancedSubstring(self, s): result = 0 for i in xrange(len(s)): left, right = i+1, i while left-1 >= 0 and right+1 < len(s) and s[left-1] == '0' and s[right+1] == '1': left -= 1 right += 1 result = max(result, right-left+1) return result ", "class Solution def findTheLongestBalancedSubstring(self, s): result = 0 prev, cnt = [0]*2, [0]*2 for c in s: cnt[int(c)] += 1 if cnt[int(c)^1]: prev[int(c)^1], cnt[int(c)^1] = cnt[int(c)^1], 0 result = max(result, 2*min(prev[0], cnt[1])) return result ", "class Solution def longestConsecutive(self, root): self.max_len = 0 def longestConsecutiveHelper(root): if not root: return 0 left_len = longestConsecutiveHelper(root.left) right_len = longestConsecutiveHelper(root.right) cur_len = 1 if root.left and root.left.val == root.val + 1: cur_len = max(cur_len, left_len + 1) if root.right and root.right.val == root.val + 1: cur_len = max(cur_len, right_len + 1) self.max_len = max(self.max_len, cur_len) return cur_len longestConsecutiveHelper(root) return self.max_len ", "class Solution def countRoutes(self, locations, start, finish, fuel): MOD = 10**9+7 s, f = locations[start], locations[finish]; locations.sort() start, finish = bisect.bisect_left(locations, s), bisect.bisect_left(locations, f) left = [[0]*(fuel+1) for _ in xrange(len(locations))] right = [[0]*(fuel+1) for _ in xrange(len(locations))] for f in xrange(1, fuel+1): for j in xrange(len(locations)-1): d = locations[j+1]-locations[j] if f > d: left[j][f] = (right[j+1][f-d] + 2*left[j+1][f-d] % MOD) % MOD; elif f == d: left[j][f] = int(j+1 == start) for j in xrange(1, len(locations)): d = locations[j]-locations[j-1] if f > d: right[j][f] = (left[j-1][f-d] + 2*right[j-1][f-d] % MOD) % MOD elif f == d: right[j][f] = int(j-1 == start) result = int(start == finish) for f in xrange(1, fuel+1): result = ((result + left[finish][f]) % MOD + right[finish][f]) % MOD return result ", "class Solution def countRoutes(self, locations, start, finish, fuel): MOD = 10**9+7 dp = [[0]*(fuel+1) for _ in xrange(len(locations))] dp[start][0] = 1 for f in xrange(fuel+1): for i in xrange(len(locations)): for j in xrange(len(locations)): if i == j: continue d = abs(locations[i]-locations[j]) if f-d < 0: continue dp[i][f] = (dp[i][f]+dp[j][f-d])%MOD return reduce(lambda x, y: (x+y)%MOD, dp[finish]) ", "class Solution def freqAlphabets(self, s): def alpha(num): return chr(ord('a') + int(num)-1) i = 0 result = [] while i < len(s): if i+2 < len(s) and s[i+2] == '#': result.append(alpha(s[i:i+2])) i += 3 else: result.append(alpha(s[i])) i += 1 return \"\".join(result) ", "class Solution def freqAlphabets(self, s): def alpha(num): return chr(ord('a') + int(num)-1) i = len(s)-1 result = [] while i >= 0: if s[i] == '#': result.append(alpha(s[i-2:i])) i -= 3 else: result.append(alpha(s[i])) i -= 1 return \"\".join(reversed(result)) import re ", "class Solution def freqAlphabets(self, s): def alpha(num): return chr(ord('a') + int(num)-1) return \"\".join(alpha(i[:2]) for i in re.findall(r\"\\d\\d#|\\d\", s)) ", "class Solution def pivotIndex(self, nums): total = sum(nums) left_sum = 0 for i, num in enumerate(nums): if left_sum == (total-left_sum-num): return i left_sum += num return -1 ", "class Solution def checkSubarraySum(self, nums, k): count = 0 lookup = {0: -1} for i, num in enumerate(nums): count += num if k: count %= k if count in lookup: if i - lookup[count] > 1: return True else: lookup[count] = i return False ", "class Solution def watchedVideosByFriends(self, watchedVideos, friends, id, level): curr_level, lookup = set([id]), set([id]) for _ in xrange(level): curr_level = set(j for i in curr_level for j in friends[i] if j not in lookup) lookup |= curr_level count = collections.Counter([v for i in curr_level for v in watchedVideos[i]]) return sorted(count.keys(), key=lambda x: (count[x], x)) ", "class Solution def countServers(self, grid): rows, cols = [0]*len(grid), [0]*len(grid[0]) for i in xrange(len(grid)): for j in xrange(len(grid[0])): if grid[i][j]: rows[i] += 1 cols[j] += 1 result = 0 for i in xrange(len(grid)): for j in xrange(len(grid[0])): if grid[i][j] and (rows[i] > 1 or cols[j] > 1): result += 1 return result ", "class Solution def countCollisions(self, directions): result = cnt = 0 smooth = 1 for x in directions: if x == 'R': cnt += 1 elif x == 'S' or (cnt or not smooth): result += cnt+int(x == 'L') cnt = smooth = 0 return result ", "class Solution def maximumMinutes(self, grid): DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)] GRASS, FIRE, WALL, PERSON = range(4) INF = 10**9 def bfs(grid): time = collections.defaultdict(int) d = 0 q = [(r, c, FIRE) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c] == FIRE] q.append((0, 0, PERSON)) while q: new_q = [] for r, c, t in q: for dr, dc in DIRECTIONS: nr, nc = r+dr, c+dc if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] != WALL and ((t == FIRE and grid[nr][nc] != FIRE) or (t == PERSON and (grid[nr][nc] == GRASS or (grid[nr][nc] == FIRE and (nr, nc) == (len(grid)-1, len(grid[0])-1) and d+1 == time[FIRE, nr, nc]))))): continue if grid[nr][nc] != FIRE: grid[nr][nc] = t if (nr, nc) in ((len(grid)-1, len(grid[0])-1), (len(grid)-1, len(grid[0])-2), (len(grid)-2, len(grid[0])-1)): time[t, nr, nc] = d+1 new_q.append((nr, nc, t)) q = new_q d += 1 return time time = bfs(grid) if not time[PERSON, len(grid)-1, len(grid[0])-1]: return -1 if not time[FIRE, len(grid)-1, len(grid[0])-1]: return INF diff = time[FIRE, len(grid)-1, len(grid[0])-1]-time[PERSON, len(grid)-1, len(grid[0])-1] return diff if diff+2 in (time[FIRE, len(grid)-1, len(grid[0])-2]-time[PERSON, len(grid)-1, len(grid[0])-2], time[FIRE, len(grid)-2, len(grid[0])-1]-time[PERSON, len(grid)-2, len(grid[0])-1]) else diff-1 ", "class Solution def maximumMinutes(self, grid): DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)] FIRE, WALL, PERSON = range(1, 4) INF = 10**9 def bfs(grid): time = {FIRE:[[INF]*len(grid[0]) for _ in xrange(len(grid))], PERSON:[[INF]*len(grid[0]) for _ in xrange(len(grid))]} d = 0 q = [(r, c, FIRE) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c] == FIRE] q.append((0, 0, PERSON)) for r, c, t in q: time[t][r][c] = d while q: new_q = [] for r, c, t in q: for dr, dc in DIRECTIONS: nr, nc = r+dr, c+dc if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] != WALL and time[t][nr][nc] == INF and (t == FIRE or d+1 < time[FIRE][nr][nc] or (d+1 == time[FIRE][nr][nc] and (nr, nc) == (len(grid)-1, len(grid[0])-1)))): continue time[t][nr][nc] = d+1 new_q.append((nr, nc, t)) q = new_q d += 1 return time time = bfs(grid) if time[PERSON][-1][-1] == INF: return -1 if time[FIRE][-1][-1] == INF: return INF diff = time[FIRE][-1][-1]-time[PERSON][-1][-1] return diff if diff+2 in (time[FIRE][-1][-2]-time[PERSON][-1][-2], time[FIRE][-2][-1]-time[PERSON][-2][-1]) else diff-1 ", "class Solution def minDistance(self, word1, word2): m, n = len(word1), len(word2) dp = [[0] * (n+1) for _ in xrange(2)] for i in xrange(m): for j in xrange(n): dp[(i+1)%2][j+1] = max(dp[i%2][j+1], dp[(i+1)%2][j], dp[i%2][j] + (word1[i] == word2[j])) return m + n - 2*dp[m%2][n] ", "class Solution def findDistance(self, root, p, q): def iter_dfs(root, p, q): result = 0 dist = [-1] stk = [(1, [root, dist])] while stk: step, params = stk.pop() if step == 1: node, ret = params if not node: continue ret1, ret2 = [-1], [-1] stk.append((2, [node, ret1, ret2, ret])) stk.append((1, [node.right, ret2])) stk.append((1, [node.left, ret1])) elif step == 2: node, ret1, ret2, ret = params if node.val in (p, q): if ret1[0] == ret2[0] == -1: ret[0] = 0 else: result = ret1[0]+1 if ret1[0] != -1 else ret2[0]+1 elif ret1[0] != -1 and ret2[0] != -1: result = ret1[0]+ret2[0]+2 elif ret1[0] != -1: ret[0] = ret1[0]+1 elif ret2[0] != -1: ret[0] = ret2[0]+1 return result return iter_dfs(root, p, q) ", "class Solution def findDistance(self, root, p, q): def dfs(node, p, q, result): if not node: return -1 left = dfs(node.left, p, q, result) right = dfs(node.right, p, q, result) if node.val in (p, q): if left == right == -1: return 0 result[0] = left+1 if left != -1 else right+1 if left != -1 and right != -1: result[0] = left+right+2 elif left != -1: return left+1 elif right != -1: return right+1 return -1 result = [0] dfs(root, p, q, result) return result[0] ", "class Solution def maxFrequency(self, nums, k): left = 0 nums.sort() for right in xrange(len(nums)): k += nums[right] if k < nums[right]*(right-left+1): k -= nums[left] left += 1 return right-left+1 ", "class Solution def areConnected(self, n, threshold, queries): union_find = UnionFind(n) for i in xrange(threshold+1, n+1): for j in xrange(2*i, n+1, i): union_find.union_set(i-1, j-1) return [union_find.find_set(q[0]-1) == union_find.find_set(q[1]-1) for q in queries] ", "class Solution def decompressRLElist(self, nums): return [nums[i+1] for i in xrange(0, len(nums), 2) for _ in xrange(nums[i])] ", "class Solution def decodeAtIndex(self, S, K): i = 0 for c in S: if c.isdigit(): i *= int(c) else: i += 1 for c in reversed(S): K %= i if K == 0 and c.isalpha(): return c if c.isdigit(): i /= int(c) else: i -= 1 ", "class Solution def numKLenSubstrNoRepeats(self, S, K): result, i = 0, 0 lookup = set() for j in xrange(len(S)): while S[j] in lookup: lookup.remove(S[i]) i += 1 lookup.add(S[j]) result += j-i+1 >= K return result ", "class Solution def kthSmallestProduct(self, nums1, nums2, k): def check(nums1, nums2, k, neg_cnt, target): cnt = 0 left, right = 0, len(nums2)-1 direction = reversed if target >= 0 else lambda x: x for i in direction(xrange(neg_cnt)): while left < len(nums2) and nums1[i]*nums2[left] > target: left += 1 cnt += (len(nums2)-1)-left+1 direction = (lambda x: x) if target >= 0 else reversed for i in direction(xrange(neg_cnt, len(nums1))): if nums1[i] == 0: if target >= 0: cnt += len(nums2) continue while right >= 0 and nums1[i]*nums2[right] > target: right -= 1 cnt += right-0+1 return cnt >= k neg_cnt = sum(x < 0 for x in nums1) left = min(nums1[i]*nums2[j] for i in (0, -1) for j in (0, -1)) right = max(nums1[i]*nums2[j] for i in (0, -1) for j in (0, -1)) while left <= right: mid = left + (right-left)//2 if check(nums1, nums2, k, neg_cnt, mid): right = mid-1 else: left = mid+1 return left ", "class Solution def isAdditiveNumber(self, num): def add(a, b): res, carry, val = \"\", 0, 0 for i in xrange(max(len(a), len(b))): val = carry if i < len(a): val += int(a[-(i + 1)]) if i < len(b): val += int(b[-(i + 1)]) carry, val = val / 10, val % 10 res += str(val) if carry: res += str(carry) return res[::-1] for i in xrange(1, len(num)): for j in xrange(i + 1, len(num)): s1, s2 = num[0:i], num[i:j] if (len(s1) > 1 and s1[0] == '0') or (len(s2) > 1 and s2[0] == '0'): continue expected = add(s1, s2) cur = s1 + s2 + expected while len(cur) < len(num): s1, s2, expected = s2, expected, add(s2, expected) cur += expected if cur == num: return True return False ", "class Solution def numRescueBoats(self, people, limit): people.sort() result = 0 left, right = 0, len(people)-1 while left <= right: result += 1 if people[left] + people[right] <= limit: left += 1 right -= 1 return result ", "class Solution def accountBalanceAfterPurchase(self, purchaseAmount): return 100-(purchaseAmount+5)//10*10 ", "class Solution def sumZero(self, n): return [i for i in xrange(-(n//2), n//2+1) if not (i == 0 and n%2 == 0)] ", "class Solution def countLetters(self, S): result = len(S) left = 0 for right in xrange(1, len(S)): if S[right] == S[left]: result += right-left else: left = right return result ", "class Solution def countGood(self, nums, k): result = curr = left = 0 cnt = collections.Counter() for right in xrange(len(nums)): curr += cnt[nums[right]] cnt[nums[right]] += 1 while curr >= k: cnt[nums[left]] -= 1 curr -= cnt[nums[left]] left += 1 result += left return result ", "class Solution def maxSatisfied(self, customers, grumpy, X): result, max_extra, extra = 0, 0, 0 for i in xrange(len(customers)): result += 0 if grumpy[i] else customers[i] extra += customers[i] if grumpy[i] else 0 if i >= X: extra -= customers[i-X] if grumpy[i-X] else 0 max_extra = max(max_extra, extra) return result + max_extra ", "class Solution def minNumber(self, nums1, nums2): common = set(nums1)&set(nums2) if common: return min(common) mn1, mn2 = min(nums1), min(nums2) if mn1 > mn2: mn1, mn2 = mn2, mn1 return 10*mn1+mn2 ", "class Solution def longestAwesome(self, s): ALPHABET_SIZE = 10 result, mask, lookup = 0, 0, [len(s)]*(2**ALPHABET_SIZE) lookup[0] = -1 for i, ch in enumerate(s): mask ^= 2**(ord(ch)-ord('0')) if lookup[mask] == len(s): lookup[mask] = i result = max(result, i - lookup[mask]) for d in xrange(ALPHABET_SIZE): result = max(result, i - lookup[mask^(2**d)]) return result ", "class Solution def countGoodStrings(self, low, high, zero, one): MOD = 10**9+7 result = 0 dp = [0]*(high+1) dp[0] = 1 for i in xrange(1, high+1): if i >= zero: dp[i] = (dp[i]+dp[i-zero])%MOD if i >= one: dp[i] = (dp[i]+dp[i-one])%MOD if i >= low: result = (result+dp[i])%MOD return result ", "class Solution def isGood(self, nums): cnt = [0]*len(nums) for x in nums: if x < len(cnt): cnt[x] += 1 else: return False return all(cnt[x] == 1 for x in xrange(1, len(nums)-1)) ", "class Solution def greatestLetter(self, s): lookup = set(s) result = \"\" for c in s: if c.isupper() and lower(c) in s: if c > result: result = c return result import itertools import string ", "class Solution def greatestLetter(self, s): lookup = set(s) return next((C for c, C in itertools.izip(reversed(string.ascii_lowercase), reversed(string.ascii_uppercase)) if c in lookup and C in lookup), \"\") ", "class Solution def maxLength(self, ribbons, k): def check(ribbons, k, s): return reduce(lambda total,x: total+x//s, ribbons, 0) >= k left, right = 1, sum(ribbons)//k while left <= right: mid = left + (right-left)//2 if not check(ribbons, k, mid): right = mid-1 else: left = mid+1 return right ", "class Solution def longestDupSubstring(self, S): M = 10**9+7 D = 26 def check(S, L): p = pow(D, L, M) curr = reduce(lambda x, y: (D*x+ord(y)-ord('a')) % M, S[:L], 0) lookup = collections.defaultdict(list) lookup[curr].append(L-1) for i in xrange(L, len(S)): curr = ((D*curr) % M + ord(S[i])-ord('a') - ((ord(S[i-L])-ord('a'))*p) % M) % M if curr in lookup: for j in lookup[curr]: if S[j-L+1:j+1] == S[i-L+1:i+1]: return i-L+1 lookup[curr].append(i) return 0 left, right = 1, len(S)-1 while left <= right: mid = left + (right-left)//2 if not check(S, mid): right = mid-1 else: left = mid+1 result = check(S, right) return S[result:result + right] ", "class Solution def sufficientSubset(self, root, limit): if not root: return None if not root.left and not root.right: return None if root.val < limit else root root.left = self.sufficientSubset(root.left, limit-root.val) root.right = self.sufficientSubset(root.right, limit-root.val) if not root.left and not root.right: return None return root ", "class Solution def detectCycle(self, head): fast, slow = head, head while fast and fast.next: fast, slow = fast.next.next, slow.next if fast is slow: fast = head while fast is not slow: fast, slow = fast.next, slow.next return fast return None ", "class Solution def leastBricks(self, wall): widths = collections.defaultdict(int) result = len(wall) for row in wall: width = 0 for i in xrange(len(row)-1): width += row[i] widths[width] += 1 result = min(result, len(wall) - widths[width]) return result ", "class Solution def distributeCandies(self, candies): lookup = set(candies) return min(len(lookup), len(candies)/2) ", "class Solution def fourSumCount(self, A, B, C, D): A_B_sum = collections.Counter(a+b for a in A for b in B) return sum(A_B_sum[-c-d] for c in C for d in D) ", "class Solution def longestStrChain(self, words): words.sort(key=len) dp = collections.defaultdict(int) for w in words: for i in xrange(len(w)): dp[w] = max(dp[w], dp[w[:i]+w[i+1:]]+1) return max(dp.itervalues()) ", "class Solution def averageValue(self, nums): total = cnt = 0 for x in nums: if x%6: continue total += x cnt += 1 return total//cnt if cnt else 0 ", "class Solution def findDuplicate(self, nums): slow = nums[0] fast = nums[nums[0]] while slow != fast: slow = nums[slow] fast = nums[nums[fast]] fast = 0 while slow != fast: slow = nums[slow] fast = nums[fast] return slow ", "class Solution def findDuplicate(self, nums): left, right = 1, len(nums) - 1 while left <= right: mid = left + (right - left) / 2 count = 0 for num in nums: if num <= mid: count += 1 if count > mid: right = mid - 1 else: left = mid + 1 return left ", "class Solution def findDuplicate(self, nums): duplicate = 0 for num in nums: if nums[abs(num) - 1] > 0: nums[abs(num) - 1] *= -1 else: duplicate = abs(num) break for num in nums: if nums[abs(num) - 1] < 0: nums[abs(num) - 1] *= -1 else: break return duplicate ", "class Solution def makeSmallestPalindrome(self, s): return \"\".join(min(s[i], s[~i]) for i in xrange(len(s))) ", "class Solution def getTargetCopy(self, original, cloned, target): def preorder_gen(node): stk = [node] while stk: node = stk.pop() if not node: continue yield node stk.append(node.right) stk.append(node.left) for node1, node2 in itertools.izip(preorder_gen(original), preorder_gen(cloned)): if node1 == target: return node2 ", "class Solution def countBits(self, num): res = [0] for i in xrange(1, num + 1): res.append((i & 1) + res[i >> 1]) return res def countBits2(self, num): s = [0] while len(s) <= num: s.extend(map(lambda x: x + 1, s)) return s[:num + 1] ", "class Solution def findMinimumOperations(self, s1, s2, s3): for i, (a, b, c) in enumerate(itertools.izip(s1, s2, s3)): if not a == b == c: break else: i += 1 return len(s1)+len(s2)+len(s3)-3*i if i else -1 ", "class Solution def bstFromPreorder(self, preorder): def bstFromPreorderHelper(preorder, left, right, index): if index[0] == len(preorder) or preorder[index[0]] < left or preorder[index[0]] > right: return None root = TreeNode(preorder[index[0]]) index[0] += 1 root.left = bstFromPreorderHelper(preorder, left, root.val, index) root.right = bstFromPreorderHelper(preorder, root.val, right, index) return root return bstFromPreorderHelper(preorder, float(\"-inf\"), float(\"inf\"), [0]) ", "class Solution def findSpecialInteger(self, arr): for x in [arr[len(arr)//4], arr[len(arr)//2], arr[len(arr)*3//4]]: if (bisect.bisect_right(arr, x) - bisect.bisect_left(arr, x)) * 4 > len(arr): return x return -1 ", "class Solution def inorderTraversal(self, root): result, curr = [], root while curr: if curr.left is None: result.append(curr.val) curr = curr.right else: node = curr.left while node.right and node.right != curr: node = node.right if node.right is None: node.right = curr curr = curr.left else: result.append(curr.val) node.right = None curr = curr.right return result ", "class Solution def inorderTraversal(self, root): result, stack = [], [(root, False)] while stack: root, is_visited = stack.pop() if root is None: continue if is_visited: result.append(root.val) else: stack.append((root.right, False)) stack.append((root, True)) stack.append((root.left, False)) return result ", "class Solution def countPairs(self, nums, target): nums.sort() result = 0 left, right = 0, len(nums)-1 while left < right: if nums[left]+nums[right] < target: result += right-left left += 1 else: right -= 1 return result ", "class Solution def isSameAfterReversals(self, num): return num == 0 or num%10 ", "class Solution def countGreatEnoughNodes(self, root, k): def merge_at_most_k(a, b): result = [] i = j = 0 while i < len(a) or j < len(b): if j == len(b) or (i < len(a) and a[i] < b[j]): result.append(a[i]) i += 1 else: result.append(b[j]) j += 1 if len(result) == k: break return result def merge_sort(node): if not node: return [] left, right = merge_sort(node.left), merge_sort(node.right) smallest_k = merge_at_most_k(left, right) i = bisect.bisect_left(smallest_k, node.val) if i == k: result[0] += 1 else: smallest_k.insert(i, node.val) if len(smallest_k) == k+1: smallest_k.pop() return smallest_k result = [0] merge_sort(root) return result[0] ", "class Solution def smallestCommonElement(self, mat): intersections = set(mat[0]) for i in xrange(1, len(mat)): intersections &= set(mat[i]) if not intersections: return -1 return min(intersections) import collections ", "class Solution def smallestCommonElement(self, mat): counter = collections.Counter() for row in mat: for c in row: counter[c] += 1 if counter[c] == len(mat): return c return -1 ", "class Solution def zigzagLevelOrder(self, root): if root is None: return [] result, current = [], [root] while current: next_level, vals = [], [] for node in current: vals.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) result.append(vals[::-1] if len(result) % 2 else vals) current = next_level return result ", "class Solution def answerQueries(self, nums, queries): nums.sort() for i in xrange(len(nums)-1): nums[i+1] += nums[i] return [bisect.bisect_right(nums, q) for q in queries] ", "class Solution def checkContradictions(self, equations, values): EPS = 1e-5 uf = UnionFind() return any(not uf.union_set(a, b, k) and abs(uf.query_set(a, b)-k) >= EPS for (a, b), k in itertools.izip(equations, values)) import collections import itertools ", "class Solution def checkContradictions(self, equations, values): def isclose(a, b, rel_tol=1e-09, abs_tol=0.0): return abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol) def iter_dfs(adj, u, lookup): stk = [u] lookup[u] = 1.0 while stk: u = stk.pop() for v, k in adj[u]: if v in lookup: if not isclose(lookup[v], lookup[u]*k): return True continue lookup[v] = lookup[u]*k stk.append(v) return False adj = collections.defaultdict(set) for (a, b), k in itertools.izip(equations, values): adj[a].add((b, 1.0/k)) adj[b].add((a, 1.0*k)) lookup = {} for u in adj.iterkeys(): if u in lookup: continue if iter_dfs(adj, u, lookup): return True return False ", "class Solution def countSmaller(self, nums): def countAndMergeSort(num_idxs, start, end, counts): if end - start <= 0: return mid = start + (end - start) // 2 countAndMergeSort(num_idxs, start, mid, counts) countAndMergeSort(num_idxs, mid + 1, end, counts) r = mid + 1 tmp = [] for i in xrange(start, mid + 1): while r <= end and num_idxs[r][0] < num_idxs[i][0]: tmp.append(num_idxs[r]) r += 1 tmp.append(num_idxs[i]) counts[num_idxs[i][1]] += r - (mid + 1) num_idxs[start:start+len(tmp)] = tmp num_idxs = [] counts = [0] * len(nums) for i, num in enumerate(nums): num_idxs.append((num, i)) countAndMergeSort(num_idxs, 0, len(num_idxs) - 1, counts) return counts ", "class Solution def countSmaller(self, nums): class BIT(object): def __init__(self, n): self.__bit = [0]*(n+1) def add(self, i, val): i += 1 while i < len(self.__bit): self.__bit[i] += val i += (i & -i) def query(self, i): i += 1 ret = 0 while i > 0: ret += self.__bit[i] i -= (i & -i) return ret sorted_nums = sorted(zip(nums, range(len(nums)))) lookup = {i:new_i for new_i, (_, i) in enumerate(sorted_nums)} result, bit = [0]*len(nums), BIT(len(nums)) for i in reversed(xrange(len(nums))): result[i] = bit.query(lookup[i]-1) bit.add(lookup[i], 1) return result ", "class Solution def countSmaller(self, nums): res = [0] * len(nums) bst = self.BST() for i in reversed(xrange(len(nums))): bst.insertNode(nums[i]) res[i] = bst.query(nums[i]) return res class BST(object): class BSTreeNode(object): def __init__(self, val): self.val = val self.count = 0 self.left = self.right = None def __init__(self): self.root = None def insertNode(self, val): node = self.BSTreeNode(val) if not self.root: self.root = node return curr = self.root while curr: if node.val < curr.val: curr.count += 1 if curr.left: curr = curr.left else: curr.left = node break else: if curr.right: curr = curr.right else: curr.right = node break def query(self, val): count = 0 curr = self.root while curr: if val < curr.val: curr = curr.left elif val > curr.val: count += 1 + curr.count curr = curr.right else: return count + curr.count return 0 ", "class Solution def handleQuery(self, nums1, nums2, queries): class SegmentTree(object): def __init__(self, N, build_fn=lambda _: 0, query_fn=lambda x, y: y if x is None else max(x, y), update_fn=lambda x, y: y if x is None else x+y): self.base = N self.H = (N-1).bit_length() self.query_fn = query_fn self.update_fn = update_fn self.tree = [None]*(2*N) self.lazy = [None]*N for i in xrange(self.base, self.base+N): self.tree[i] = build_fn(i-self.base) for i in reversed(xrange(1, self.base)): self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1]) def __apply(self, x, val): self.tree[x] = self.update_fn(self.tree[x], val) if x < self.base: self.lazy[x] = self.update_fn(self.lazy[x], val) def update(self, L, R, h): def pull(x): while x > 1: x >>= 1 self.tree[x] = self.query_fn(self.tree[x<<1], self.tree[(x<<1)+1]) if self.lazy[x] is not None: self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]) if L > R: return L += self.base R += self.base L0, R0 = L, R while L <= R: if L & 1: self.__apply(L, h) L += 1 if R & 1 == 0: self.__apply(R, h) R -= 1 L >>= 1 R >>= 1 pull(L0) pull(R0) def query(self, L, R): def push(x): n = self.H while n: y = x >> n if self.lazy[y] is not None: self.__apply(y<<1, self.lazy[y]) self.__apply((y<<1)+1, self.lazy[y]) self.lazy[y] = None n -= 1 result = None if L > R: return result L += self.base R += self.base push(L) push(R) while L <= R: if L & 1: result = self.query_fn(result, self.tree[L]) L += 1 if R & 1 == 0: result = self.query_fn(result, self.tree[R]) R -= 1 L >>= 1 R >>= 1 return result st = SegmentTree(len(nums1), build_fn=lambda i: (nums1[i], nums1[i]^1), query_fn=lambda x, y: y if x is None else (x[0]+y[0], x[1]+y[1]), update_fn=lambda x, y: y if x is None else (x[1], x[0]) if y == (1, 0) else x) result = [] total = sum(nums2) for t, a, b in queries: if t == 1: st.update(a, b, (1, 0)) elif t == 2: total += st.query(0, len(nums1)-1)[0]*a elif t == 3: result.append(total) return result ", "class Solution def smallestString(self, s): result = list(s) i = next((i for i in xrange(len(s)) if s[i] != 'a'), len(s)) if i == len(s): result[-1] = 'z' else: for i in xrange(i, len(s)): if result[i] == 'a': break result[i] = chr(ord(result[i])-1) return \"\".join(result) ", "class Solution def highestRankedKItems(self, grid, pricing, start, k): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def nth_element(nums, n, left=0, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right right = len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 def get_val(x): return (lookup[x[0]][x[1]], grid[x[0]][x[1]], x[0], x[1]) result = [] q = [start] lookup = [[-1]*len(grid[0]) for _ in xrange(len(grid))] d = lookup[start[0]][start[1]] = 0 while q: if len(result) >= k: if len(result) > k: nth_element(result, k-1, compare=lambda a, b: get_val(a) < get_val(b)) result = result[:k] break new_q = [] for r, c in q: if pricing[0] <= grid[r][c] <= pricing[1]: result.append([r, c]) for dr, dc in directions: nr, nc = r+dr, c+dc if not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] and lookup[nr][nc] == -1): continue lookup[nr][nc] = d+1 new_q.append((nr, nc)) q = new_q d += 1 result.sort(key=lambda x: get_val(x)) return result ", "class Solution def numberOfSubarrays(self, nums, k): def atMost(nums, k): result, left, count = 0, 0, 0 for right, x in enumerate(nums): count += x%2 while count > k: count -= nums[left]%2 left += 1 result += right-left+1 return result return atMost(nums, k) - atMost(nums, k-1) import collections ", "class Solution def numberOfSubarrays(self, nums, k): result = 0 dq = collections.deque([-1]) for i in xrange(len(nums)): if nums[i]%2: dq.append(i) if len(dq) > k+1: dq.popleft() if len(dq) == k+1: result += dq[1]-dq[0] return result ", "class Solution def isInterleave(self, s1, s2, s3): if len(s1) + len(s2) != len(s3): return False if len(s1) > len(s2): return self.isInterleave(s2, s1, s3) match = [False for i in xrange(len(s1) + 1)] match[0] = True for i in xrange(1, len(s1) + 1): match[i] = match[i -1] and s1[i - 1] == s3[i - 1] for j in xrange(1, len(s2) + 1): match[0] = match[0] and s2[j - 1] == s3[j - 1] for i in xrange(1, len(s1) + 1): match[i] = (match[i - 1] and s1[i - 1] == s3[i + j - 1]) or (match[i] and s2[j - 1] == s3[i + j - 1]) return match[-1] ", "class Solution def isInterleave(self, s1, s2, s3): if len(s1) + len(s2) != len(s3): return False match = [[False for i in xrange(len(s2) + 1)] for j in xrange(len(s1) + 1)] match[0][0] = True for i in xrange(1, len(s1) + 1): match[i][0] = match[i - 1][0] and s1[i - 1] == s3[i - 1] for j in xrange(1, len(s2) + 1): match[0][j] = match[0][j - 1] and s2[j - 1] == s3[j - 1] for i in xrange(1, len(s1) + 1): for j in xrange(1, len(s2) + 1): match[i][j] = (match[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (match[i][j - 1] and s2[j - 1] == s3[i + j - 1]) return match[-1][-1] ", "class Solution def isInterleave(self, s1, s2, s3): self.match = {} if len(s1) + len(s2) != len(s3): return False return self.isInterleaveRecu(s1, s2, s3, 0, 0, 0) def isInterleaveRecu(self, s1, s2, s3, a, b, c): if repr([a, b]) in self.match.keys(): return self.match[repr([a, b])] if c == len(s3): return True result = False if a < len(s1) and s1[a] == s3[c]: result = result or self.isInterleaveRecu(s1, s2, s3, a + 1, b, c + 1) if b < len(s2) and s2[b] == s3[c]: result = result or self.isInterleaveRecu(s1, s2, s3, a, b + 1, c + 1) self.match[repr([a, b])] = result return result ", "class Solution def buildMatrix(self, k, rowConditions, colConditions): def topological_sort(conditions): adj = [[] for _ in xrange(k)] in_degree = [0]*k for u, v in conditions: u -= 1 v -= 1 adj[u].append(v) in_degree[v] += 1 result = [] q = [u for u in xrange(k) if not in_degree[u]] while q: new_q = [] for u in q: result.append(u) for v in adj[u]: in_degree[v] -= 1 if in_degree[v]: continue new_q.append(v) q = new_q return result row_order = topological_sort(rowConditions) if len(row_order) != k: return [] col_order = topological_sort(colConditions) if len(col_order) != k: return [] row_idx = {x:i for i, x in enumerate(row_order)} col_idx = {x:i for i, x in enumerate(col_order)} result = [[0]*k for _ in xrange(k)] for i in xrange(k): result[row_idx[i]][col_idx[i]] = i+1 return result ", "class Solution def longestCycle(self, edges): result = -1 lookup = [-1]*len(edges) idx = 0 for i in xrange(len(edges)): if lookup[i] != -1: continue start = idx while i != -1: if lookup[i] != -1: break lookup[i] = idx idx += 1 i = edges[i] if i != -1 and lookup[i] >= start: result = max(result, idx-lookup[i]) return result ", "class Solution def isLongPressedName(self, name, typed): i = 0 for j in xrange(len(typed)): if i < len(name) and name[i] == typed[j]: i += 1 elif j == 0 or typed[j] != typed[j-1]: return False return i == len(name) ", "class Solution def getIntersectionNode(self, headA, headB): curA, curB = headA, headB while curA != curB: curA = curA.next if curA else headB curB = curB.next if curB else headA return curA ", "class Solution def canTraverseAllPairs(self, nums): def prime_factors(x): factors = collections.Counter() for p in PRIMES: if p*p > x: break while x%p == 0: factors[p] += 1 x //= p if x != 1: factors[x] += 1 return factors def bfs(): lookup = [False]*len(nums) lookup[0] = True q = [0] while q: new_q = [] for u in q: for v in adj[u]: if lookup[v]: continue lookup[v] = True new_q.append(v) q = new_q return all(lookup) adj = [[] for _ in xrange(len(nums))] lookup = {} for i, x in enumerate(nums): for p in prime_factors(x): if p not in lookup: lookup[p] = i continue adj[i].append(lookup[p]) adj[lookup[p]].append(i) return bfs() ", "class Solution def minExtraChar(self, s, dictionary): _trie = lambda: collections.defaultdict(_trie) trie = _trie() for word in dictionary: reduce(dict.__getitem__, word, trie).setdefault(\"_end\") dp = [float(\"inf\")]*(len(s)+1) dp[0] = 0 for i in xrange(len(s)): dp[i+1] = min(dp[i+1], dp[i]+1) curr = trie for j in xrange(i, len(s)): if s[j] not in curr: break curr = curr[s[j]] if \"_end\" in curr: dp[j+1] = min(dp[j+1], dp[i]) return dp[-1] ", "class Solution def calculateMinimumHP(self, dungeon): DP = [float(\"inf\") for _ in dungeon[0]] DP[-1] = 1 for i in reversed(xrange(len(dungeon))): DP[-1] = max(DP[-1] - dungeon[i][-1], 1) for j in reversed(xrange(len(dungeon[i]) - 1)): min_HP_on_exit = min(DP[j], DP[j + 1]) DP[j] = max(min_HP_on_exit - dungeon[i][j], 1) return DP[0] ", "class Solution def calculateMinimumHP(self, dungeon): maximum_loses = 0 for rooms in dungeon: for room in rooms: if room < 0: maximum_loses += abs(room) return self.binarySearch(dungeon, maximum_loses) def binarySearch(self, dungeon, maximum_loses): start, end = 1, maximum_loses + 1 result = 0 while start < end: mid = start + (end - start) / 2 if self.DP(dungeon, mid): end = mid else: start = mid + 1 return start def DP(self, dungeon, HP): remain_HP = [0 for _ in dungeon[0]] remain_HP[0] = HP + dungeon[0][0] for j in xrange(1, len(remain_HP)): if remain_HP[j - 1] > 0: remain_HP[j] = max(remain_HP[j - 1] + dungeon[0][j], 0) for i in xrange(1, len(dungeon)): if remain_HP[0] > 0: remain_HP[0] = max(remain_HP[0] + dungeon[i][0], 0) else: remain_HP[0] = 0 for j in xrange(1, len(remain_HP)): remain = 0 if remain_HP[j - 1] > 0: remain = max(remain_HP[j - 1] + dungeon[i][j], remain) if remain_HP[j] > 0: remain = max(remain_HP[j] + dungeon[i][j], remain) remain_HP[j] = remain return remain_HP[-1] > 0 ", "class Solution def sum(self, num1, num2): return num1+num2 ", "class Solution def largestPerimeter(self, nums): nums.sort() prefix = sum(nums) for i in reversed(xrange(2, len(nums))): prefix -= nums[i] if prefix > nums[i]: return prefix+nums[i] return -1 ", "class Solution def maxDivScore(self, nums, divisors): return max(divisors, key=lambda d: (sum(x%d == 0 for x in nums), -d)) ", "class Solution def minCameraCover(self, root): UNCOVERED, COVERED, CAMERA = range(3) def dfs(root, result): left = dfs(root.left, result) if root.left else COVERED right = dfs(root.right, result) if root.right else COVERED if left == UNCOVERED or right == UNCOVERED: result[0] += 1 return CAMERA if left == CAMERA or right == CAMERA: return COVERED return UNCOVERED result = [0] if dfs(root, result) == UNCOVERED: result[0] += 1 return result[0] ", "class Solution def countSubarrays(self, nums): result = l = 1 for i in xrange(1, len(nums)): if nums[i-1] >= nums[i]: l = 0 l += 1 result += l return result ", "class Solution def countSubarrays(self, nums): result = left = 0 for right in xrange(len(nums)): if not (right-1 >= 0 and nums[right-1] < nums[right]): left = right result += right-left+1 return result ", "class Solution def findReplaceString(self, S, indexes, sources, targets): bucket = [None] * len(S) for i in xrange(len(indexes)): if all(indexes[i]+k < len(S) and S[indexes[i]+k] == sources[i][k] for k in xrange(len(sources[i]))): bucket[indexes[i]] = (len(sources[i]), list(targets[i])) result = [] i = 0 while i < len(S): if bucket[i]: result.extend(bucket[i][1]) i += bucket[i][0] else: result.append(S[i]) i += 1 return \"\".join(result) ", "class Solution def findReplaceString(self, S, indexes, sources, targets): for i, s, t in sorted(zip(indexes, sources, targets), reverse=True): if S[i:i+len(s)] == s: S = S[:i] + t + S[i+len(s):] return S ", "class Solution def constructArray(self, n, k): result = [] left, right = 1, n while left <= right: if k % 2: result.append(left) left += 1 else: result.append(right) right -= 1 if k > 1: k -= 1 return result ", "class Solution def hammingDistance(self, x, y): distance = 0 z = x ^ y while z: distance += 1 z &= z - 1 return distance def hammingDistance2(self, x, y): return bin(x ^ y).count('1') ", "class Solution def longestPrefix(self, s): def getPrefix(pattern): prefix = [-1]*len(pattern) j = -1 for i in xrange(1, len(pattern)): while j != -1 and pattern[j+1] != pattern[i]: j = prefix[j] if pattern[j+1] == pattern[i]: j += 1 prefix[i] = j return prefix return s[:getPrefix(s)[-1]+1] ", "class Solution def longestPrefix(self, s): M = 10**9+7 D = 26 def check(l, s): for i in xrange(l): if s[i] != s[len(s)-l+i]: return False return True result, prefix, suffix, power = 0, 0, 0, 1 for i in xrange(len(s)-1): prefix = (prefix*D + (ord(s[i])-ord('a'))) % M suffix = (suffix + (ord(s[len(s)-(i+1)])-ord('a'))*power) % M power = (power*D)%M if prefix == suffix: result = i+1 return s[:result] ", "class Solution def totalFruit(self, tree): count = collections.defaultdict(int) result, i = 0, 0 for j, v in enumerate(tree): count[v] += 1 while len(count) > 2: count[tree[i]] -= 1 if count[tree[i]] == 0: del count[tree[i]] i += 1 result = max(result, j-i+1) return result ", "class Solution def areNumbersAscending(self, s): prev = curr = -1 for i, c in enumerate(s): if c.isdigit(): curr = max(curr, 0)*10+int(c) continue if prev != -1 and curr != -1 and prev >= curr: return False if curr != -1: prev = curr curr = -1 return curr == -1 or prev < curr ", "class Solution def areNumbersAscending(self, s): nums = [int(x) for x in s.split() if x.isdigit()] return all(nums[i] < nums[i+1] for i in xrange(len(nums)-1)) ", "class Solution def isCircularSentence(self, sentence): return sentence[0] == sentence[-1] and all(sentence[i-1] == sentence[i+1]for i in xrange(len(sentence)) if sentence[i] == ' ') ", "class Solution def findLUSlength(self, strs): def isSubsequence(a, b): i = 0 for j in xrange(len(b)): if i >= len(a): break if a[i] == b[j]: i += 1 return i == len(a) strs.sort(key=len, reverse=True) for i in xrange(len(strs)): all_of = True for j in xrange(len(strs)): if len(strs[j]) < len(strs[i]): break if i != j and isSubsequence(strs[i], strs[j]): all_of = False break if all_of: return len(strs[i]) return -1 ", "class Solution def circularArrayLoop(self, nums): def next_index(nums, i): return (i + nums[i]) % len(nums) for i in xrange(len(nums)): if nums[i] == 0: continue slow, fast = i, i while nums[next_index(nums, slow)] * nums[i] > 0 and nums[next_index(nums, fast)] * nums[i] > 0 and nums[next_index(nums, next_index(nums, fast))] * nums[i] > 0: slow = next_index(nums, slow) fast = next_index(nums, next_index(nums, fast)) if slow == fast: if slow == next_index(nums, slow): break return True slow, val = i, nums[i] while nums[slow] * val > 0: tmp = next_index(nums, slow) nums[slow] = 0 slow = tmp return False ", "class Solution def largestComponentSize(self, A): def prime_factors(i): result = [] d = 2 if i%d == 0: while i%d == 0: i //= d result.append(d) d = 3 while d*d <= i: if i%d == 0: while i%d == 0: i //= d result.append(d) d += 2 if i != 1: result.append(i) return result union_find = UnionFind(len(A)) nodesWithCommonFactor = collections.defaultdict(int) for i in xrange(len(A)): for factor in prime_factors(A[i]): if factor not in nodesWithCommonFactor: nodesWithCommonFactor[factor] = i union_find.union_set(nodesWithCommonFactor[factor], i) return max(union_find.size) import collections class UnionFind(object): def __init__(self, n): self.set = range(n) self.size = [1]*n def find_set(self, x): if self.set[x] != x: self.set[x] = self.find_set(self.set[x]) return self.set[x] def union_set(self, x, y): x_root, y_root = map(self.find_set, (x, y)) if x_root == y_root: return False self.set[min(x_root, y_root)] = max(x_root, y_root) self.size[max(x_root, y_root)] += self.size[min(x_root, y_root)] return True ", "class Solution def largestComponentSize(self, A): def prime_factors(x): result = [] p = 2 while p*p <= x: if x%p == 0: while x%p == 0: x //= p result.append(p) p += 1 if x != 1: result.append(x) return result union_find = UnionFind(len(A)) nodesWithCommonFactor = collections.defaultdict(int) for i in xrange(len(A)): for factor in prime_factors(A[i]): if factor not in nodesWithCommonFactor: nodesWithCommonFactor[factor] = i union_find.union_set(nodesWithCommonFactor[factor], i) return max(union_find.size) ", "class Solution def getImportance(self, employees, id): if employees[id-1] is None: return 0 result = employees[id-1].importance for id in employees[id-1].subordinates: result += self.getImportance(employees, id) return result ", "class Solution def getImportance(self, employees, id): result, q = 0, collections.deque([id]) while q: curr = q.popleft() employee = employees[curr-1] result += employee.importance for id in employee.subordinates: q.append(id) return result ", "class Solution def bagOfTokensScore(self, tokens, P): tokens.sort() result, points = 0, 0 left, right = 0, len(tokens)-1 while left <= right: if P >= tokens[left]: P -= tokens[left] left += 1 points += 1 result = max(result, points) elif points > 0: points -= 1 P += tokens[right] right -= 1 else: break return result ", "class Solution def countPrefixSuffixPairs(self, words): _trie = lambda: collections.defaultdict(_trie) trie = _trie() result = 0 for w in words: curr = trie for i in xrange(len(w)): curr = curr[w[i], w[~i]] result += curr[\"_cnt\"] if \"_cnt\" in curr else 0 curr[\"_cnt\"] = curr[\"_cnt\"]+1 if \"_cnt\" in curr else 1 return result ", "class Solution def flipMatchVoyage(self, root, voyage): def dfs(root, voyage, i, result): if not root: return True if root.val != voyage[i[0]]: return False i[0] += 1 if root.left and root.left.val != voyage[i[0]]: result.append(root.val) return dfs(root.right, voyage, i, result) and dfs(root.left, voyage, i, result) return dfs(root.left, voyage, i, result) and dfs(root.right, voyage, i, result) result = [] return result if dfs(root, voyage, [0], result) else [-1] ", "class Solution def numberOfMatches(self, n): return n-1 ", "class Solution def buildArray(self, target, n): result, curr = [], 1 for t in target: result.extend([\"Push\", \"Pop\"]*(t-curr)) result.append(\"Push\") curr = t+1 return result ", "class Solution def encode(self, num): result = [] while num: result.append('0' if num%2 else '1') num = (num-1)//2 return \"\".join(reversed(result)) ", "class Solution def gcdOfStrings(self, str1, str2): def check(s, common): i = 0 for c in s: if c != common[i]: return False i = (i+1)%len(common) return True def gcd(a, b): while b: a, b = b, a % b return a if not str1 or not str2: return \"\" c = gcd(len(str1), len(str2)) result = str1[:c] return result if check(str1, result) and check(str2, result) else \"\" ", "class Solution def equalPairs(self, grid): cnt1 = collections.Counter(tuple(row) for row in grid) cnt2 = collections.Counter(tuple(col) for col in itertools.izip(*grid)) return sum(cnt1[k]*cnt2[k] for k in cnt1.iterkeys() if k in cnt2) ", "class Solution def entityParser(self, text): patterns = [\"&quot;\", \"&apos;\", \"&amp;\", \"&gt;\", \"&lt;\", \"&frasl;\"] chars = [\"\\\"\", \"'\", \"&\", \">\", \"<\", \"/\"] trie = AhoTrie(patterns) positions = [] for i in xrange(len(text)): for j in trie.step(text[i]): positions.append([i-len(patterns[j])+1, j]) result = [] i, j = 0, 0 while i != len(text): if j == len(positions) or i != positions[j][0]: result.append(text[i]) i += 1 else: result.append(chars[positions[j][1]]) i += len(patterns[positions[j][1]]) j += 1 return \"\".join(result) ", "class Solution def entityParser(self, text): patterns = [\"&quot;\", \"&apos;\", \"&amp;\", \"&gt;\", \"&lt;\", \"&frasl;\"] chars = [\"\\\"\", \"'\", \"&\", \">\", \"<\", \"/\"] result = [] i, j = 0, 0 while i != len(text): if text[i] != '&': result.append(text[i]) i += 1 else: for j, pattern in enumerate(patterns): if pattern == text[i:i+len(pattern)]: result.append(chars[j]) i += len(pattern) break else: result.append(text[i]) i += 1 return \"\".join(result) ", "class Solution def maxA(self, N): if N < 7: return N if N == 10: return 20 n = N // 5 + 1 n3 = 5*n - N - 1 n4 = n - n3 return 3**n3 * 4**n4 ", "class Solution def maxA(self, N): if N < 7: return N dp = range(N+1) for i in xrange(7, N+1): dp[i % 6] = max(dp[(i-4) % 6]*3, dp[(i-5) % 6]*4) return dp[N % 6] ", "class Solution def largestCombination(self, candidates): cnt = [] base, mx = 1, max(candidates) while base <= mx: cnt.append(sum(x&base > 0 for x in candidates)) base <<= 1 return max(cnt) ", "class Solution def subsequenceSumOr(self, nums): result = prefix = 0 for x in nums: prefix += x result |= x|prefix return result ", "class Solution def subsequenceSumOr(self, nums): result = cnt = 0 for i in xrange(64): cnt >>= 1 for x in nums: cnt += (x>>i)&1 if cnt: result |= 1<<i return result ", "class Solution def valueAfterKSeconds(self, n, k): MOD = 10**9+7 fact, inv, inv_fact = [[1]*2 for _ in xrange(3)] def nCr(n, k): if not (0 <= k <= n): return 0 while len(inv) <= n: fact.append(fact[-1]*len(inv) % MOD) inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) inv_fact.append(inv_fact[-1]*inv[-1] % MOD) return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD return nCr(n+k-1, k) ", "class Solution def valueAfterKSeconds(self, n, k): MOD = 10**9+7 prefix = [1]*n for _ in range(k): for i in xrange(1, n): prefix[i] = (prefix[i]+prefix[i-1])%MOD return prefix[-1] ", "class Solution def countNodes(self, root): def height(root): h = -1 while root: h += 1 root = root.left return h result, h = 0, height(root) while root: if height(root.right) == h-1: result += 2**h root = root.right else: result += 2**(h-1) root = root.left h -= 1 return result ", "class Solution def countNodes(self, root): def check(node, n): base = 1 while base <= n: base <<= 1 base >>= 2 while base: if (n & base) == 0: node = node.left else: node = node.right base >>= 1 return bool(node) if not root: return 0 node, level = root, 0 while node.left: node = node.left level += 1 left, right = 2**level, 2**(level+1)-1 while left <= right: mid = left+(right-left)//2 if not check(root, mid): right = mid-1 else: left = mid+1 return right ", "class Solution def countPairs(self, deliciousness): def floor_log2_x(x): return x.bit_length()-1 MOD = 10**9+7 max_pow = floor_log2_x(max(deliciousness))+1 cnt = collections.Counter() result = 0 for d in deliciousness: p = 1 for i in xrange(max_pow+1): result = (result+cnt[p-d])%MOD p <<= 1 cnt[d] += 1 return result ", "class Solution def countTestedDevices(self, batteryPercentages): result = 0 for x in batteryPercentages: if x > result: result += 1 return result ", "class Solution def countKDifference(self, nums, k): lookup = collections.defaultdict(int) result = 0 for x in nums: if x-k in lookup: result += lookup[x-k] if x+k in lookup: result += lookup[x+k] lookup[x] += 1 return result ", "class Solution def fallingSquares(self, positions): result = [] pos = [-1] heights = [0] maxH = 0 for left, side in positions: l = bisect.bisect_right(pos, left) r = bisect.bisect_left(pos, left+side) high = max(heights[l-1:r] or [0]) + side pos[l:r] = [left, left+side] heights[l:r] = [high, heights[r-1]] maxH = max(maxH, high) result.append(maxH) return result class SegmentTree(object): def __init__(self, N, query_fn=min, update_fn=lambda x, y: y, default_val=float(\"inf\")): self.N = N self.H = (N-1).bit_length() self.query_fn = query_fn self.update_fn = update_fn self.default_val = default_val self.tree = [default_val] * (2 * N) self.lazy = [None] * N def __apply(self, x, val): self.tree[x] = self.update_fn(self.tree[x], val) if x < self.N: self.lazy[x] = self.update_fn(self.lazy[x], val) def update(self, L, R, h): def pull(x): while x > 1: x //= 2 self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2 + 1]) if self.lazy[x] is not None: self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]) L += self.N R += self.N L0, R0 = L, R while L <= R: if L & 1: self.__apply(L, h) L += 1 if R & 1 == 0: self.__apply(R, h) R -= 1 L //= 2 R //= 2 pull(L0) pull(R0) def query(self, L, R): def push(x): n = 2**self.H while n != 1: y = x // n if self.lazy[y] is not None: self.__apply(y*2, self.lazy[y]) self.__apply(y*2 + 1, self.lazy[y]) self.lazy[y] = None n //= 2 result = self.default_val if L > R: return result L += self.N R += self.N push(L) push(R) while L <= R: if L & 1: result = self.query_fn(result, self.tree[L]) L += 1 if R & 1 == 0: result = self.query_fn(result, self.tree[R]) R -= 1 L //= 2 R //= 2 return result def data(self): showList = [] for i in xrange(self.N): showList.append(self.query(i, i)) return showList class SegmentTree2(object): def __init__(self, nums, query_fn=min, update_fn=lambda x, y: y, default_val=float(\"inf\")): N = len(nums) self.__original_length = N self.__tree_length = 2**(N.bit_length() + (N&(N-1) != 0))-1 self.__query_fn = query_fn self.__update_fn = update_fn self.__default_val = default_val self.__tree = [default_val for _ in range(self.__tree_length)] self.__lazy = [None for _ in range(self.__tree_length)] self.__constructTree(nums, 0, self.__original_length-1, 0) def update(self, i, j, val): self.__updateTree(val, i, j, 0, self.__original_length-1, 0) def query(self, i, j): return self.__queryRange(i, j, 0, self.__original_length-1, 0) def __constructTree(self, nums, left, right, idx): if left > right: return if left == right: self.__tree[idx] = self.__update_fn(self.__tree[idx], nums[left]) return mid = left + (right-left)//2 self.__constructTree(nums, left, mid, idx*2 + 1) self.__constructTree(nums, mid+1, right, idx*2 + 2) self.__tree[idx] = self.__query_fn(self.__tree[idx*2 + 1], self.__tree[idx*2 + 2]) def __apply(self, left, right, idx, val): self.__tree[idx] = self.__update_fn(self.__tree[idx], val) if left != right: self.__lazy[idx*2 + 1] = self.__update_fn(self.__lazy[idx*2 + 1], val) self.__lazy[idx*2 + 2] = self.__update_fn(self.__lazy[idx*2 + 2], val) def __updateTree(self, val, range_left, range_right, left, right, idx): if left > right: return if self.__lazy[idx] is not None: self.__apply(left, right, idx, self.__lazy[idx]) self.__lazy[idx] = None if range_left > right or range_right < left: return if range_left <= left and right <= range_right: self.__apply(left, right, idx, val) return mid = left + (right-left)//2 self.__updateTree(val, range_left, range_right, left, mid, idx*2 + 1) self.__updateTree(val, range_left, range_right, mid+1, right, idx*2 + 2) self.__tree[idx] = self.__query_fn(self.__tree[idx*2 + 1], self.__tree[idx*2 + 2]) def __queryRange(self, range_left, range_right, left, right, idx): if left > right: return self.__default_val if self.__lazy[idx] is not None: self.__apply(left, right, idx, self.__lazy[idx]) self.__lazy[idx] = None if right < range_left or left > range_right: return self.__default_val if range_left <= left and right <= range_right: return self.__tree[idx] mid = left + (right-left)//2 return self.__query_fn(self.__queryRange(range_left, range_right, left, mid, idx*2 + 1), self.__queryRange(range_left, range_right, mid + 1, right, idx*2 + 2)) ", "class Solution def fallingSquares(self, positions): index = set() for left, size in positions: index.add(left) index.add(left+size-1) index = sorted(list(index)) tree = SegmentTree(len(index), max, max, 0) max_height = 0 result = [] for left, size in positions: L, R = bisect.bisect_left(index, left), bisect.bisect_left(index, left+size-1) h = tree.query(L, R) + size tree.update(L, R, h) max_height = max(max_height, h) result.append(max_height) return result ", "class Solution def fallingSquares(self, positions): def query(heights, left, right, B, blocks, blocks_read): result = 0 while left % B and left <= right: result = max(result, heights[left], blocks[left//B]) left += 1 while right % B != B-1 and left <= right: result = max(result, heights[right], blocks[right//B]) right -= 1 while left <= right: result = max(result, blocks[left//B], blocks_read[left//B]) left += B return result def update(heights, left, right, B, blocks, blocks_read, h): while left % B and left <= right: heights[left] = max(heights[left], h) blocks_read[left//B] = max(blocks_read[left//B], h) left += 1 while right % B != B-1 and left <= right: heights[right] = max(heights[right], h) blocks_read[right//B] = max(blocks_read[right//B], h) right -= 1 while left <= right: blocks[left//B] = max(blocks[left//B], h) left += B index = set() for left, size in positions: index.add(left) index.add(left+size-1) index = sorted(list(index)) W = len(index) B = int(W**.5) heights = [0] * W blocks = [0] * (B+2) blocks_read = [0] * (B+2) max_height = 0 result = [] for left, size in positions: L, R = bisect.bisect_left(index, left), bisect.bisect_left(index, left+size-1) h = query(heights, L, R, B, blocks, blocks_read) + size update(heights, L, R, B, blocks, blocks_read, h) max_height = max(max_height, h) result.append(max_height) return result ", "class Solution def fallingSquares(self, positions): heights = [0] * len(positions) for i in xrange(len(positions)): left_i, size_i = positions[i] right_i = left_i + size_i heights[i] += size_i for j in xrange(i+1, len(positions)): left_j, size_j = positions[j] right_j = left_j + size_j if left_j < right_i and left_i < right_j: heights[j] = max(heights[j], heights[i]) result = [] for height in heights: result.append(max(result[-1], height) if result else height) return result ", "class Solution def countSteppingNumbers(self, low, high): MOD = 10**9+7 def f(s): dp = [[0]*10 for _ in xrange(2)] for j in xrange(1, ord(s[0])-ord('0')+1): dp[0][j] = 1 prefix = True for i in xrange(1, len(s)): for j in xrange(10): dp[i%2][j] = int(j != 0) if j-1 >= 0: dp[i%2][j] = (dp[i%2][j]+(dp[(i-1)%2][j-1]-int(prefix and (ord(s[i-1])-ord('0')) == j-1 and j > (ord(s[i])-ord('0')))))%MOD if j+1 < 10: dp[i%2][j] = (dp[i%2][j]+(dp[(i-1)%2][j+1]-int(prefix and (ord(s[i-1])-ord('0')) == j+1 and j > (ord(s[i])-ord('0')))))%MOD if abs(ord(s[i])-ord(s[i-1])) != 1: prefix = False return reduce(lambda x, y: (x+y)%MOD, dp[(len(s)-1)%2]) return (f(high)-f(str(int(low)-1)))%MOD ", "class Solution def checkIfCanBreak(self, s1, s2): def is_break(count1, count2): curr1, curr2 = 0, 0 for c in string.ascii_lowercase: curr1 += count1[c] curr2 += count2[c] if curr1 < curr2: return False return True count1, count2 = collections.Counter(s1), collections.Counter(s2) return is_break(count1, count2) or is_break(count2, count1) import itertools ", "class Solution def checkIfCanBreak(self, s1, s2): return not {1, -1}.issubset(set(cmp(a, b) for a, b in itertools.izip(sorted(s1), sorted(s2)))) import itertools ", "class Solution def checkIfCanBreak(self, s1, s2): s1, s2 = sorted(s1), sorted(s2) return all(a >= b for a, b in itertools.izip(s1, s2)) or all(a <= b for a, b in itertools.izip(s1, s2)) ", "class Solution def countWords(self, words1, words2): cnt = collections.Counter(words1) for c in words2: if cnt[c] < 2: cnt[c] -= 1 return sum(v == 0 for v in cnt.itervalues()) ", "class Solution def countOdds(self, low, high): return (high+1)//2 - ((low-1)+1)//2 ", "class Solution def maxIncreaseKeepingSkyline(self, grid): row_maxes = [max(row) for row in grid] col_maxes = [max(col) for col in itertools.izip(*grid)] return sum(min(row_maxes[r], col_maxes[c])-val for r, row in enumerate(grid) for c, val in enumerate(row)) ", "class Solution def maxOperations(self, nums, k): count = collections.Counter() result = 0 for x in nums: if k-x in count and count[k-x]: count[k-x] -= 1 result += 1 else: count[x] += 1 return result ", "class Solution def longestObstacleCourseAtEachPosition(self, obstacles): result, stk = [], [] for x in obstacles: i = bisect.bisect_right(stk, x) result.append(i+1) if i == len(stk): stk.append(0) stk[i] = x return result class SegmentTree(object): def __init__(self, N, build_fn=lambda x, y: [y]*(2*x), query_fn=lambda x, y: y if x is None else max(x, y), update_fn=lambda x, y: y, default_val=0): self.N = N self.H = (N-1).bit_length() self.query_fn = query_fn self.update_fn = update_fn self.default_val = default_val self.tree = build_fn(N, default_val) self.lazy = [None]*N def __apply(self, x, val): self.tree[x] = self.update_fn(self.tree[x], val) if x < self.N: self.lazy[x] = self.update_fn(self.lazy[x], val) def update(self, L, R, h): def pull(x): while x > 1: x //= 2 self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1]) if self.lazy[x] is not None: self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]) L += self.N R += self.N L0, R0 = L, R while L <= R: if L & 1: self.__apply(L, h) L += 1 if R & 1 == 0: self.__apply(R, h) R -= 1 L //= 2 R //= 2 pull(L0) pull(R0) def query(self, L, R): def push(x): n = 2**self.H while n != 1: y = x // n if self.lazy[y] is not None: self.__apply(y*2, self.lazy[y]) self.__apply(y*2 + 1, self.lazy[y]) self.lazy[y] = None n //= 2 result = None if L > R: return result L += self.N R += self.N push(L) push(R) while L <= R: if L & 1: result = self.query_fn(result, self.tree[L]) L += 1 if R & 1 == 0: result = self.query_fn(result, self.tree[R]) R -= 1 L //= 2 R //= 2 return result def __str__(self): showList = [] for i in xrange(self.N): showList.append(self.query(i, i)) return \",\".join(map(str, showList)) class Solution2_TLE(object): def longestObstacleCourseAtEachPosition(self, obstacles): sorted_obstacles = sorted(set(obstacles)) lookup = {x:i for i, x in enumerate(sorted_obstacles)} segment_tree = SegmentTree(len(lookup)) result = [] for x in obstacles: cnt = segment_tree.query(0, lookup[x])+1 result.append(cnt) segment_tree.update(lookup[x], lookup[x], cnt) return result ", "class Solution def hasAlternatingBits(self, n): n, curr = divmod(n, 2) while n > 0: if curr == n % 2: return False n, curr = divmod(n, 2) return True ", "class Solution def copyRandomBinaryTree(self, root): def iter_dfs(node, callback): result = None stk = [node] while stk: node = stk.pop() if not node: continue left_node, copy = callback(node) if not result: result = copy stk.append(node.right) stk.append(left_node) return result def merge(node): copy = NodeCopy(node.val) node.left, copy.left = copy, node.left return copy.left, copy def clone(node): copy = node.left node.left.random = node.random.left if node.random else None node.left.right = node.right.left if node.right else None return copy.left, copy def split(node): copy = node.left node.left, copy.left = copy.left, copy.left.left if copy.left else None return node.left, copy iter_dfs(root, merge) iter_dfs(root, clone) return iter_dfs(root, split) class Solution_Recu(object): def copyRandomBinaryTree(self, root): def dfs(node, callback): if not node: return None left_node, copy = callback(node) dfs(left_node, callback) dfs(node.right, callback) return copy def merge(node): copy = NodeCopy(node.val) node.left, copy.left = copy, node.left return copy.left, copy def clone(node): copy = node.left node.left.random = node.random.left if node.random else None node.left.right = node.right.left if node.right else None return copy.left, copy def split(node): copy = node.left node.left, copy.left = copy.left, copy.left.left if copy.left else None return node.left, copy dfs(root, merge) dfs(root, clone) return dfs(root, split) import collections ", "class Solution def copyRandomBinaryTree(self, root): lookup = collections.defaultdict(lambda: NodeCopy()) lookup[None] = None stk = [root] while stk: node = stk.pop() if not node: continue lookup[node].val = node.val lookup[node].left = lookup[node.left] lookup[node].right = lookup[node.right] lookup[node].random = lookup[node.random] stk.append(node.right) stk.append(node.left) return lookup[root] import collections class Solution2_Recu(object): def copyRandomBinaryTree(self, root): def dfs(node, lookup): if not node: return lookup[node].val = node.val lookup[node].left = lookup[node.left] lookup[node].right = lookup[node.right] lookup[node].random = lookup[node.random] dfs(node.left, lookup) dfs(node.right, lookup) lookup = collections.defaultdict(lambda: NodeCopy()) lookup[None] = None dfs(root, lookup) return lookup[root] ", "class Solution def maxLengthBetweenEqualCharacters(self, s): result, lookup = -1, {} for i, c in enumerate(s): result = max(result, i-lookup.setdefault(c, i)-1) return result ", "class Solution def isPossible(self, n, edges): adj = [set() for _ in xrange(n)] for u, v in edges: adj[u-1].add(v-1) adj[v-1].add(u-1) odds = [u for u in xrange(n) if len(adj[u])%2] if len(odds) == 0: return True if len(odds) == 2: return any(odds[0] not in adj[u] and odds[1] not in adj[u] for u in range(n)) if len(odds) == 4: return ((odds[0] not in adj[odds[1]] and odds[2] not in adj[odds[3]]) or (odds[0] not in adj[odds[2]] and odds[1] not in adj[odds[3]]) or (odds[0] not in adj[odds[3]] and odds[1] not in adj[odds[2]])) return False ", "class Solution def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2): x1 -= x_center y1 -= y_center x2 -= x_center y2 -= y_center x = x1 if x1 > 0 else x2 if x2 < 0 else 0 y = y1 if y1 > 0 else y2 if y2 < 0 else 0 return x**2 + y**2 <= radius**2 ", "class Solution def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2): x1 -= x_center y1 -= y_center x2 -= x_center y2 -= y_center x = min(abs(x1), abs(x2)) if x1*x2 > 0 else 0 y = min(abs(y1), abs(y2)) if y1*y2 > 0 else 0 return x**2 + y**2 <= radius**2 ", "class Solution def xorAllNums(self, nums1, nums2): return (reduce(operator.xor, nums1) if len(nums2)%2 else 0) ^ (reduce(operator.xor, nums2) if len(nums1)%2 else 0) ", "class Solution def closestNode(self, n, edges, query): adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v), adj[v].append(u) pairs = collections.defaultdict(set) for start, end, node in query: pairs[start].add(end), pairs[end].add(start) pairs[start].add(node), pairs[node].add(start) pairs[end].add(node), pairs[node].add(end) tree_infos = TreeInfos(adj, pairs) return [max((tree_infos.lca[min(x, y), max(x, y)] for x, y in ((start, end), (start, node), (end, node))), key=lambda x: tree_infos.D[x]) for start, end, node in query] from functools import partial class TreeInfos2(object): def __init__(self, children): def preprocess(curr, parent): D[curr] = 1 if parent == -1 else D[parent]+1 if parent != -1: P[curr].append(parent) i = 0 while i < len(P[curr]) and i < len(P[P[curr][i]]): P[curr].append(P[P[curr][i]][i]) i += 1 C[0] += 1 L[curr] = C[0] def divide(curr, parent): stk.append(partial(postprocess, curr)) for i in reversed(xrange(len(children[curr]))): child = children[curr][i] if child == parent: continue stk.append(partial(divide, child, curr)) stk.append(partial(preprocess, curr, parent)) def postprocess(curr): R[curr] = C[0] N = len(children) L, R, D, P, C = [0]*N, [0]*N, [0]*N, [[] for _ in xrange(N)], [-1] stk = [] stk.append(partial(divide, 0, -1)) while stk: stk.pop()() assert(C[0] == N-1) self.L, self.R, self.D, self.P = L, R, D, P def is_ancestor(self, a, b): return self.L[a] <= self.L[b] <= self.R[b] <= self.R[a] def lca(self, a, b): if self.D[a] > self.D[b]: a, b = b, a if self.is_ancestor(a, b): return a for i in reversed(xrange(len(self.P[a]))): if i < len(self.P[a]) and not self.is_ancestor(self.P[a][i], b): a = self.P[a][i] return self.P[a][0] ", "class Solution def closestNode(self, n, edges, query): adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v), adj[v].append(u) tree_infos = TreeInfos2(adj) return [max((tree_infos.lca(x, y) for x, y in ((start, end), (start, node), (end, node))), key=lambda x: tree_infos.D[x]) for start, end, node in query] from functools import partial class TreeInfos3(object): def __init__(self, children): def preprocess(curr, parent): D[curr] = 1 if parent == -1 else D[parent]+1 P[curr] = parent def divide(curr, parent): for i in reversed(xrange(len(children[curr]))): child = children[curr][i] if child == parent: continue stk.append(partial(divide, child, curr)) stk.append(partial(preprocess, curr, parent)) N = len(children) D, P = [0]*N, [0]*N stk = [] stk.append(partial(divide, 0, -1)) while stk: stk.pop()() self.D, self.P = D, P def lca(self, a, b): while self.D[a] > self.D[b]: a = self.P[a] while self.D[a] < self.D[b]: b = self.P[b] while a != b: a, b = self.P[a], self.P[b] return a ", "class Solution def closestNode(self, n, edges, query): adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v), adj[v].append(u) tree_infos = TreeInfos3(adj) return [max((tree_infos.lca(x, y) for x, y in ((start, end), (start, node), (end, node))), key=lambda x: tree_infos.D[x]) for start, end, node in query] ", "class Solution def closestNode(self, n, edges, query): def bfs(adj, root): dist = [len(adj)]*len(adj) q = [root] dist[root] = 0 d = 0 while q: new_q = [] for u in q: for v in adj[u]: if d+1 >= dist[v]: continue dist[v] = d+1 new_q.append(v) q = new_q d += 1 return dist adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v), adj[v].append(u) dist = [bfs(adj, i) for i in xrange(n)] result = [] for start, end, node in query: x = end while start != end: if dist[node][start] < dist[node][x]: x = start start = next(u for u in adj[start] if dist[u][end] < dist[start][end]) result.append(x) return result ", "class Solution def closestNode(self, n, edges, query): def bfs(adj, root): dist = [len(adj)]*len(adj) q = [root] dist[root] = 0 d = 0 while q: new_q = [] for u in q: for v in adj[u]: if d+1 >= dist[v]: continue dist[v] = d+1 new_q.append(v) q = new_q d += 1 return dist adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v), adj[v].append(u) dist = [bfs(adj, i) for i in xrange(n)] return [max((i for i in xrange(n) if dist[start][node]+dist[node][end]-2*dist[node][i] == dist[start][i]+dist[i][end]), key=lambda x: dist[node][x]) for start, end, node in query] ", "class Solution def maxTurbulenceSize(self, A): result = 1 start = 0 for i in xrange(1, len(A)): if i == len(A)-1 or cmp(A[i-1], A[i]) * cmp(A[i], A[i+1]) != -1: result = max(result, i-start+1) start = i return result ", "class Solution def getCollisionTimes(self, cars): stk = [] result = [-1.0]*len(cars) for i in reversed(xrange(len(cars))): p, s = cars[i] while stk and (cars[stk[-1]][1] >= s or 0 < result[stk[-1]] <= float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])): stk.pop() if stk: result[i] = float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1]) stk.append(i) return result ", "class Solution def increasingBST(self, root): def increasingBSTHelper(root, tail): if not root: return tail result = increasingBSTHelper(root.left, root) root.left = None root.right = increasingBSTHelper(root.right, tail) return result return increasingBSTHelper(root, None) ", "class Solution def numRookCaptures(self, board): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] r, c = None, None for i in xrange(8): if r is not None: break for j in xrange(8): if board[i][j] == 'R': r, c = i, j break result = 0 for d in directions: nr, nc = r+d[0], c+d[1] while 0 <= nr < 8 and 0 <= nc < 8: if board[nr][nc] == 'p': result += 1 if board[nr][nc] != '.': break nr, nc= nr+d[0], nc+d[1] return result ", "class Solution def findWords(self, words): rows = [set(['q', 'w', 'e', 'r', 't', 'y','u', 'i', 'o', 'p']), set(['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l']), set(['z', 'x', 'c', 'v', 'b' ,'n', 'm'])] result = [] for word in words: k = 0 for i in xrange(len(rows)): if word[0].lower() in rows[i]: k = i break for c in word: if c.lower() not in rows[k]: break else: result.append(word) return result ", "class Solution def findWords(self, words): keyboard_rows = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm'] single_row_words = [] for word in words: for row in keyboard_rows: if all(letter in row for letter in word.lower()): single_row_words.append(word) return single_row_words ", "class Solution def countFairPairs(self, nums, lower, upper): def count(x): cnt = 0 left, right = 0, len(nums)-1 while left < right: if nums[left]+nums[right] <= x: cnt += right-left left += 1 else: right -= 1 return cnt nums.sort() return count(upper)-count(lower-1) ", "class Solution def countPairs(self, n, edges): def bfs(adj, u, lookup): q = [u] lookup[u] = 1 result = 1 while q: new_q = [] for u in q: for v in adj[u]: if lookup[v]: continue lookup[v] = 1 result += 1 new_q.append(v) q = new_q return result adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) lookup = [0]*n result = 0 for u in xrange(n): if lookup[u]: continue cnt = bfs(adj, u, lookup) result += cnt*(n-cnt) n -= cnt return result ", "class Solution def gameOfLife(self, board): m = len(board) n = len(board[0]) if m else 0 for i in xrange(m): for j in xrange(n): count = 0 for I in xrange(max(i-1, 0), min(i+2, m)): for J in xrange(max(j-1, 0), min(j+2, n)): count += board[I][J] & 1 if (count == 4 and board[i][j]) or count == 3: board[i][j] |= 2 for i in xrange(m): for j in xrange(n): board[i][j] >>= 1 ", "class Solution def longestPalindrome(self, words): cnt = collections.Counter(words) result = remain = 0 for x, c in cnt.iteritems(): if x == x[::-1]: result += c//2 remain |= c%2 elif x < x[::-1] and x[::-1] in cnt: result += min(c, cnt[x[::-1]]) return result*4+remain*2 ", "class Solution def longestLine(self, M): if not M: return 0 result = 0 dp = [[[0] * 4 for _ in xrange(len(M[0]))] for _ in xrange(2)] for i in xrange(len(M)): for j in xrange(len(M[0])): dp[i % 2][j][:] = [0] * 4 if M[i][j] == 1: dp[i % 2][j][0] = dp[i % 2][j - 1][0]+1 if j > 0 else 1 dp[i % 2][j][1] = dp[(i-1) % 2][j][1]+1 if i > 0 else 1 dp[i % 2][j][2] = dp[(i-1) % 2][j-1][2]+1 if (i > 0 and j > 0) else 1 dp[i % 2][j][3] = dp[(i-1) % 2][j+1][3]+1 if (i > 0 and j < len(M[0])-1) else 1 result = max(result, max(dp[i % 2][j])) return result ", "class Solution def countConsistentStrings(self, allowed, words): lookup = [False]*26 for c in allowed: lookup[ord(c)-ord('a')] = True result = len(words) for word in words: for c in word: if not lookup[ord(c)-ord('a')]: result -= 1 break return result ", "class Solution def maxDiff(self, num): digits = str(num) for b in digits: if b < '9': break if digits[0] != '1': a = digits[0] else: for a in digits: if a > '1': break return int(digits.replace(b, '9')) - int(digits.replace(a, '1' if digits[0] != '1' else '0')) ", "class Solution def calcEquation(self, equations, values, queries): union_find = UnionFind() for (a, b), k in itertools.izip(equations, values): union_find.union_set(a, b, k) return [union_find.query_set(a, b) for a, b in queries] import collections import itertools ", "class Solution def calcEquation(self, equations, values, queries): adj = collections.defaultdict(dict) for (a, b), k in itertools.izip(equations, values): adj[a][b] = k adj[b][a] = 1.0/k def bfs(adj, a, b, lookup): if a not in adj or b not in adj: return -1.0 if (a, b) in lookup: return lookup[a, b] visited = {a} q = collections.deque([(a, 1.0)]) while q: u, val = q.popleft() if u == b: lookup[a, b] = val return val for v, k in adj[u].iteritems(): if v in visited: continue visited.add(v) q.append((v, val*k)) lookup[a, b] = -1.0 return -1.0 lookup = {} return [bfs(adj, a, b, lookup) for a, b in queries] import collections import itertools ", "class Solution def calcEquation(self, equations, values, queries): adj = collections.defaultdict(dict) for (a, b), k in itertools.izip(equations, values): adj[a][a] = adj[b][b] = 1.0 adj[a][b] = k adj[b][a] = 1.0/k for k in adj: for i in adj[k]: for j in adj[k]: adj[i][j] = adj[i][k]*adj[k][j] return [adj[a].get(b, -1.0) for a, b in queries] import collections ", "class Solution def calcEquation(self, equations, values, query): def check(up, down, lookup, visited): if up in lookup and down in lookup[up]: return (True, lookup[up][down]) for k, v in lookup[up].iteritems(): if k not in visited: visited.add(k) tmp = check(k, down, lookup, visited) if tmp[0]: return (True, v * tmp[1]) return (False, 0) lookup = collections.defaultdict(dict) for i, e in enumerate(equations): lookup[e[0]][e[1]] = values[i] if values[i]: lookup[e[1]][e[0]] = 1.0 / values[i] result = [] for q in query: visited = set() tmp = check(q[0], q[1], lookup, visited) result.append(tmp[1] if tmp[0] else -1) return result ", "class Solution def restoreMatrix(self, rowSum, colSum): matrix = [[0]*len(colSum) for _ in xrange(len(rowSum))] i = j = 0 while i < len(matrix) and j < len(matrix[0]): matrix[i][j] = min(rowSum[i], colSum[j]) rowSum[i] -= matrix[i][j] colSum[j] -= matrix[i][j] if not rowSum[i]: i += 1 if not colSum[j]: j += 1 return matrix ", "class Solution def restoreMatrix(self, rowSum, colSum): matrix = [[0]*len(colSum) for _ in xrange(len(rowSum))] for i in xrange(len(matrix)): for j in xrange(len(matrix[i])): matrix[i][j] = min(rowSum[i], colSum[j]) rowSum[i] -= matrix[i][j] colSum[j] -= matrix[i][j] return matrix ", "class Solution def countPairs(self, nums, k): def gcd(x, y): while y: x, y = y, x%y return x idxs = collections.defaultdict(list) for i, x in enumerate(nums): idxs[x].append(i) result = 0 for idx in idxs.itervalues(): gcds = collections.Counter() for i in idx: gcd_i = gcd(i, k) result += sum(cnt for gcd_j, cnt in gcds.iteritems() if gcd_i*gcd_j%k == 0) gcds[gcd_i] += 1 return result import collections ", "class Solution def countPairs(self, nums, k): def gcd(x, y): while y: x, y = y, x%y return x cnts = collections.defaultdict(collections.Counter) for i, x in enumerate(nums): cnts[x][gcd(i, k)] += 1 result = 0 for cnt in cnts.itervalues(): for x in cnt.iterkeys(): for y in cnt.iterkeys(): if x > y or x*y%k: continue result += cnt[x]*cnt[y] if x != y else cnt[x]*(cnt[x]-1)//2 return result import collections ", "class Solution def countPairs(self, nums, k): idxs = collections.defaultdict(list) for i, x in enumerate(nums): idxs[x].append(i) return sum(idx[i]*idx[j]%k == 0 for idx in idxs.itervalues() for i in xrange(len(idx)) for j in xrange(i+1, len(idx))) ", "class Solution def countMatches(self, items, ruleKey, ruleValue): rule = {\"type\":0, \"color\":1, \"name\":2} return sum(item[rule[ruleKey]] == ruleValue for item in items) ", "class Solution def checkEqualTree(self, root): def getSumHelper(node, lookup): if not node: return 0 total = node.val + getSumHelper(node.left, lookup) + getSumHelper(node.right, lookup) lookup[total] += 1 return total lookup = collections.defaultdict(int) total = getSumHelper(root, lookup) if total == 0: return lookup[total] > 1 return total%2 == 0 and (total/2) in lookup ", "class Solution def countElements(self, nums): mn = min(nums) mx = max(nums) return sum(mn < x < mx for x in nums) ", "class Solution def largestNumber(self, num): num = [str(x) for x in num] num.sort(cmp=lambda x, y: cmp(y + x, x + y)) largest = ''.join(num) return largest.lstrip('0') or '0' ", "class Solution def checkStrings(self, s1, s2): return all(collections.Counter(s1[j] for j in xrange(i, len(s1), 2)) == collections.Counter(s2[j] for j in xrange(i, len(s2), 2)) for i in xrange(2)) ", "class Solution def dividePlayers(self, skill): target = sum(skill)//(len(skill)//2) cnt = collections.Counter(skill) result = 0 for k, v in cnt.iteritems(): if target-k not in cnt or cnt[target-k] != cnt[k]: return -1 result += k*(target-k)*v return result//2 ", "class Solution def distanceBetweenBusStops(self, distance, start, destination): if start > destination: start, destination = destination, start s_to_d = sum(itertools.islice(distance, start, destination)) d_to_s = sum(itertools.islice(distance, 0, start)) + sum(itertools.islice(distance, destination, len(distance))) return min(s_to_d, d_to_s) ", "class Solution def longestIdealString(self, s, k): dp = [0]*26 for c in s: x = ord(c)-ord('a') dp[x] = max(dp[i] for i in xrange(max(x-k, 0), min(x+k+1, 26)))+1 return max(dp) ", "class Solution def avoidFlood(self, rains): lookup = collections.defaultdict(list) i = len(rains)-1 for lake in reversed(rains): lookup[lake].append(i) i -= 1 result, min_heap = [], [] for i, lake in enumerate(rains): if lake: if len(lookup[lake]) >= 2: lookup[lake].pop() heapq.heappush(min_heap, lookup[lake][-1]) result.append(-1) elif min_heap: j = heapq.heappop(min_heap) if j < i: return [] result.append(rains[j]) else: result.append(1) return result if not min_heap else [] ", "class Solution def carPooling(self, trips, capacity): line = [x for num, start, end in trips for x in [[start, num], [end, -num]]] line.sort() for _, num in line: capacity -= num if capacity < 0: return False return True ", "class Solution def deleteDuplicateFolder(self, paths): def mark(node, lookup, node_ids): id_pairs = [] for subfolder_id, child in node.iteritems(): if child == \"_del\": continue id_pairs.append((subfolder_id, mark(child, lookup, node_ids))) id_pairs.sort() node_id = node_ids[tuple(id_pairs)] if node_id: if node_id in lookup: lookup[node_id][\"_del\"] node[\"_del\"] else: lookup[node_id] = node return node_id def sweep(node, id_folders, path, result): if path: result.append([id_folders[i] for i in path]) for subfolder_id, child in node.iteritems(): if \"_del\" in child: continue path.append(subfolder_id) sweep(child, id_folders, path, result) path.pop() _trie = lambda: collections.defaultdict(_trie) trie = _trie() folder_ids = collections.defaultdict() folder_ids.default_factory = folder_ids.__len__ id_folders = {} for path in paths: node = trie for folder in path: if folder_ids[folder] not in id_folders: id_folders[folder_ids[folder]] = folder node = node[folder_ids[folder]] node_ids = collections.defaultdict() node_ids.default_factory = node_ids.__len__ mark(trie, {}, node_ids) result = [] sweep(trie, id_folders, [], result) return result import collections ", "class Solution def deleteDuplicateFolder(self, paths): def mark(node, lookup): serialized_tree = \"(\" + \"\".join(subfolder + mark(child, lookup) for subfolder, child in sorted(node.iteritems()) if child != \"_del\") + \")\" if serialized_tree != \"()\": if serialized_tree in lookup: lookup[serialized_tree][\"_del\"] node[\"_del\"] else: lookup[serialized_tree] = node return serialized_tree def sweep(node, path, result): if path: result.append(path[:]) for subfolder, child in node.iteritems(): if \"_del\" in child: continue path.append(subfolder) sweep(child, path, result) path.pop() _trie = lambda: collections.defaultdict(_trie) trie = _trie() for path in paths: reduce(dict.__getitem__, path, trie) mark(trie, {}) result = [] sweep(trie, [], result) return result ", "class Solution def angleClock(self, hour, minutes): angle1 = (hour % 12 * 60.0 + minutes) / 720.0 angle2 = minutes / 60.0 diff = abs(angle1-angle2) return min(diff, 1.0-diff) * 360.0 ", "class Solution def findLonelyPixel(self, picture): rows, cols = [0] * len(picture), [0] * len(picture[0]) for i in xrange(len(picture)): for j in xrange(len(picture[0])): if picture[i][j] == 'B': rows[i] += 1 cols[j] += 1 result = 0 for i in xrange(len(picture)): if rows[i] == 1: for j in xrange(len(picture[0])): result += picture[i][j] == 'B' and cols[j] == 1 return result ", "class Solution def findLonelyPixel(self, picture): return sum(col.count('B') == 1 == picture[col.index('B')].count('B') for col in zip(*picture)) ", "class Solution def lowestCommonAncestor(self, root, nodes): def iter_dfs(root, lookup): result = [0] stk = [(1, (root, result))] while stk: step, args = stk.pop() if step == 1: node, ret = args if not node or node in lookup: ret[0] = node continue ret1, ret2 = [None], [None] stk.append((2, (node, ret1, ret2, ret))) stk.append((1, (node.right, ret2))) stk.append((1, (node.left, ret1))) elif step == 2: node, ret1, ret2, ret = args if ret1[0] and ret2[0]: ret[0] = node else: ret[0] = ret1[0] or ret2[0] return result[0] return iter_dfs(root, set(nodes)) ", "class Solution def lowestCommonAncestor(self, root, nodes): def dfs(node, lookup): if not node or node in lookup: return node left, right = dfs(node.left, lookup), dfs(node.right, lookup) if left and right: return node return left or right return dfs(root, set(nodes)) ", "class Solution def findPattern(self, board, pattern): def check(i, j): lookup = [-1]*26 lookup2 = [False]*10 for r in xrange(len(pattern)): for c in xrange(len(pattern[0])): y = board[i+r][j+c] if pattern[r][c].isdigit(): if int(pattern[r][c]) != y: return False continue x = ord(pattern[r][c])-ord('a') if lookup[x] == -1: if lookup2[y]: return False lookup2[y] = True lookup[x] = y continue if lookup[x] != y: return False return True return next(([i, j] for i in xrange(len(board)-len(pattern)+1) for j in xrange(len(board[0])-len(pattern[0])+1) if check(i, j)), [-1, -1]) ", "class Solution def distanceLimitedPathsExist(self, n, edgeList, queries): for i, q in enumerate(queries): q.append(i) edgeList.sort(key=lambda x: x[2]) queries.sort(key=lambda x: x[2]) union_find = UnionFind(n) result = [False]*len(queries) curr = 0 for u, v, w, i in queries: while curr < len(edgeList) and edgeList[curr][2] < w: union_find.union_set(edgeList[curr][0], edgeList[curr][1]) curr += 1 result[i] = union_find.find_set(u) == union_find.find_set(v) return result ", "class Solution def getAverages(self, nums, k): total, l = 0, 2*k+1 result = [-1]*len(nums) for i in xrange(len(nums)): total += nums[i] if i-l >= 0: total -= nums[i-l] if i >= l-1: result[i-k] = total//l return result ", "class Solution def countQuadruplets(self, nums): result = 0 lookup = collections.defaultdict(int) lookup[nums[-1]] = 1 for c in reversed(xrange(2, len(nums)-1)): for b in xrange(1, c): for a in xrange(b): if nums[a]+nums[b]+nums[c] in lookup: result += lookup[nums[a]+nums[b]+nums[c]] lookup[nums[c]] += 1 return result import collections ", "class Solution def countQuadruplets(self, nums): lookup = collections.defaultdict(list) for d in xrange(3, len(nums)): for c in xrange(2, d): lookup[nums[d]-nums[c]].append(c) return sum(sum(b < c for c in lookup[nums[a]+nums[b]]) for b in xrange(1, len(nums)-2) for a in xrange(b)) ", "class Solution def findRotation(self, mat, target): checks = [lambda i, j: mat[i][j] == target[i][j], lambda i, j: mat[i][j] == target[j][-1-i], lambda i, j: mat[i][j] == target[-1-i][-1-j], lambda i, j: mat[i][j] == target[-1-j][i]] traverse = lambda check: all(check(i, j) for i in xrange(len(mat)) for j in xrange(len(mat[0]))) return any(traverse(check) for check in checks) ", "class Solution def maximumSumOfHeights(self, maxHeights): left = [0]*len(maxHeights) stk = [-1] curr = 0 for i in xrange(len(maxHeights)): while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]: j = stk.pop() curr -= (j-stk[-1])*maxHeights[j] curr += (i-stk[-1])*maxHeights[i] stk.append(i) left[i] = curr stk = [len(maxHeights)] result = right = curr = 0 for i in reversed(xrange(len(maxHeights))): while stk[-1] != stk[0] and maxHeights[stk[-1]] >= maxHeights[i]: j = stk.pop() curr -= (stk[-1]-j)*maxHeights[j] curr += (stk[-1]-i)*maxHeights[i] stk.append(i) right = curr result = max(result, left[i]+right-maxHeights[i]) return result ", "class Solution def countUnguarded(self, m, n, guards, walls): DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)] GREEN, RED, BLOCK = range(3) grid = [[GREEN]*n for _ in xrange(m)] for r, c in itertools.chain(guards, walls): grid[r][c] = BLOCK for r, c in guards: for dr, dc in DIRECTIONS: nr, nc = r+dr, c+dc while 0 <= nr < m and 0 <= nc < n and grid[nr][nc] != BLOCK: grid[nr][nc] = RED nr, nc = nr+dr, nc+dc return sum(grid[r][c] == GREEN for r in xrange(m) for c in xrange(n)) ", "class Solution def eliminateMaximum(self, dist, speed): for i in xrange(len(dist)): dist[i] = (dist[i]-1)//speed[i] dist.sort() result = 0 for i in xrange(len(dist)): if result > dist[i]: break result += 1 return result ", "class Solution def isCousins(self, root, x, y): def dfs(root, x, depth, parent): if not root: return False if root.val == x: return True depth[0] += 1 prev_parent, parent[0] = parent[0], root if dfs(root.left, x, depth, parent): return True parent[0] = root if dfs(root.right, x, depth, parent): return True parent[0] = prev_parent depth[0] -= 1 return False depth_x, depth_y = [0], [0] parent_x, parent_y = [None], [None] return dfs(root, x, depth_x, parent_x) and dfs(root, y, depth_y, parent_y) and depth_x[0] == depth_y[0] and parent_x[0] != parent_y[0] ", "class Solution def toHexspeak(self, num): lookup = {0:'O', 1:'I'} for i in xrange(6): lookup[10+i] = chr(ord('A')+i) result = [] n = int(num) while n: n, r = divmod(n, 16) if r not in lookup: return \"ERROR\" result.append(lookup[r]) return \"\".join(reversed(result)) ", "class Solution def toHexspeak(self, num): result = hex(int(num)).upper()[2:].replace('0', 'O').replace('1', 'I') return result if all(c in \"ABCDEFOI\" for c in result) else \"ERROR\" ", "class Solution def similarPairs(self, words): cnt = collections.Counter() result = 0 for w in words: mask = reduce(lambda total, x: total|x, itertools.imap(lambda c: 1<<(ord(c)-ord('a')), w)) result += cnt[mask] cnt[mask] += 1 return result ", "class Solution def numSubarraysWithSum(self, A, S): result = 0 left, right, sum_left, sum_right = 0, 0, 0, 0 for i, a in enumerate(A): sum_left += a while left < i and sum_left > S: sum_left -= A[left] left += 1 sum_right += a while right < i and (sum_right > S or (sum_right == S and not A[right])): sum_right -= A[right] right += 1 if sum_left == S: result += right-left+1 return result ", "class Solution def minimalKSum(self, nums, k): result = k*(k+1)//2 curr = k+1 for x in sorted(set(nums)): if x < curr: result += curr-x curr += 1 return result ", "class Solution def minimalKSum(self, nums, k): result = prev = 0 nums.append(float(\"inf\")) for x in sorted(set(nums)): if not k: break cnt = min((x-1)-prev, k) k -= cnt result += ((prev+1)+(prev+cnt))*cnt//2 prev = x return result ", "class Solution def findLucky(self, arr): count = collections.Counter(arr) result = -1 for k, v in count.iteritems(): if k == v: result = max(result, k) return result ", "class Solution def fractionToDecimal(self, numerator, denominator): result = \"\" if (numerator > 0 and denominator < 0) or (numerator < 0 and denominator > 0): result = \"-\" dvd, dvs = abs(numerator), abs(denominator) result += str(dvd / dvs) dvd %= dvs if dvd > 0: result += \".\" lookup = {} while dvd and dvd not in lookup: lookup[dvd] = len(result) dvd *= 10 result += str(dvd / dvs) dvd %= dvs if dvd in lookup: result = result[:lookup[dvd]] + \"(\" + result[lookup[dvd]:] + \")\" return result ", "class Solution def unhappyFriends(self, n, preferences, pairs): friends = [[0]*n for _ in xrange(n)] for i in xrange(len(preferences)): for j in xrange(len(preferences[i])): friends[i][preferences[i][j]] = j pairing = [0]*n for i, j in pairs: pairing[i], pairing[j] = j, i return sum(any(friends[i][j] < friends[i][pairing[i]] and friends[j][i] < friends[j][pairing[j]] for j in xrange(len(friends[i])) if j != i and j != pairing[i]) for i in xrange(len(friends))) ", "class Solution def minimumLevel(self, root): q = [root] d = 1 result = ((float(\"inf\"), float(\"inf\"))) while q: new_q = [] total = 0 for u in q: if u.left: new_q.append(u.left) if u.right: new_q.append(u.right) total += u.val result = min(result, (total, d)) q = new_q d += 1 return result[-1] ", "class Solution def findLHS(self, nums): lookup = collections.defaultdict(int) result = 0 for num in nums: lookup[num] += 1 for diff in [-1, 1]: if (num + diff) in lookup: result = max(result, lookup[num] + lookup[num + diff]) return result ", "class Solution def minimumCost(self, nums, k, dist): def get_top(heap, total): while abs(heap[0][1]) < i-(1+dist): heapq.heappop(heap) total[0] -= 1 return heap[0] def lazy_delete(heap, total): total[0] += 1 if total[0] <= len(heap)-total[0]: return heap[:] = [x for x in heap if abs(x[1]) > i-(1+dist)] heapq.heapify(heap) total[0] = 0 max_heap, min_heap = [], [] total1, total2 = [0], [0] mn, curr = float(\"inf\"), 0 for i in xrange(1, len(nums)): heapq.heappush(max_heap, (-nums[i], i)) curr += nums[i] if i > k-1: x, idx = get_top(max_heap, total1) heapq.heappop(max_heap) curr -= -x heapq.heappush(min_heap, (-x, -idx)) if i > 1+dist: x, idx = get_top(min_heap, total2) if (x, idx) <= (nums[i-(1+dist)], -(i-(1+dist))): lazy_delete(min_heap, total2) else: lazy_delete(max_heap, total1) heapq.heappop(min_heap) curr -= nums[i-(1+dist)]-x heapq.heappush(max_heap, (-x, -idx)) if i >= k-1: mn = min(mn, curr) return nums[0]+mn import heapq import collections ", "class Solution def minimumCost(self, nums, k, dist): def get_top(heap, cnt, total): while heap[0] in cnt: x = heapq.heappop(heap) cnt[x] -= 1 if cnt[x] == 0: del cnt[x] total[0] -= 1 return heap[0] def lazy_delete(heap, cnt, total, x): cnt[x] += 1 total[0] += 1 if total[0] <= len(heap)-total[0]: return new_heap = [] for x in heap: if x not in cnt: new_heap.append(x) continue cnt[x] -= 1 if cnt[x] == 0: del cnt[x] total[0] = 0 heapq.heapify(new_heap) heap[:] = new_heap max_heap, min_heap = [], [] cnt1, cnt2 = collections.Counter(), collections.Counter() total1, total2 = [0], [0] mn, curr = float(\"inf\"), 0 for i in xrange(1, len(nums)): heapq.heappush(max_heap, -nums[i]) curr += nums[i] if (len(max_heap)-total1[0]) > k-1: x = get_top(max_heap, cnt1, total1) curr -= -x heapq.heappush(min_heap, -heapq.heappop(max_heap)) if (len(max_heap)-total1[0])+(len(min_heap)-total2[0]) > 1+dist: x = get_top(min_heap, cnt2, total2) if x <= nums[i-(1+dist)]: lazy_delete(min_heap, cnt2, total2, nums[i-(1+dist)]) else: lazy_delete(max_heap, cnt1, total1, -nums[i-(1+dist)]) heapq.heappop(min_heap) curr -= nums[i-(1+dist)]-x heapq.heappush(max_heap, -x) if len(max_heap)-total1[0] == k-1: mn = min(mn, curr) return nums[0]+mn from sortedcontainers import SortedList ", "class Solution def minimumCost(self, nums, k, dist): sl1, sl2 = SortedList(), SortedList() mn, curr = float(\"inf\"), 0 for i in xrange(1, len(nums)): sl1.add(nums[i]) curr += nums[i] if len(sl1) > k-1: curr -= sl1[-1] sl2.add(sl1.pop()) if len(sl1)+len(sl2) > 1+dist: if sl2[0] <= nums[i-(1+dist)]: sl2.remove(nums[i-(1+dist)]) else: sl1.remove(nums[i-(1+dist)]) curr -= nums[i-(1+dist)]-sl2[0] sl1.add(sl2.pop(0)) if len(sl1) == k-1: mn = min(mn, curr) return nums[0]+mn from sortedcontainers import SortedList ", "class Solution def minimumCost(self, nums, k, dist): sl = SortedList(nums[1:1+(1+dist)]) mn = curr = sum(sl[:k-1]) for i in xrange(1+(1+dist), len(nums)): sl.add(nums[i]) curr += min(nums[i]-sl[k-1], 0) curr -= min(nums[i-(1+dist)]-sl[k-1], 0) sl.remove(nums[i-(1+dist)]) mn = min(mn, curr) return nums[0]+mn ", "class Solution def lengthOfLongestSubstring(self, s): result, left = 0, 0 lookup = {} for right in xrange(len(s)): if s[right] in lookup: left = max(left, lookup[s[right]]+1) lookup[s[right]] = right result = max(result, right-left+1) return result ", "class Solution def incremovableSubarrayCount(self, nums): for j in reversed(xrange(1, len(nums))): if not nums[j-1] < nums[j]: break else: return (len(nums)+1)*len(nums)//2 result = len(nums)-j+1 for i in xrange(len(nums)-1): while j < len(nums) and not (nums[i] < nums[j]): j += 1 result += len(nums)-j+1 if not (nums[i] < nums[i+1]): break return result ", "class Solution def getLastMoment(self, n, left, right): return max(max(left or [0]), n-min(right or [n])) ", "class Solution def dominantIndex(self, nums): m = max(nums) if all(m >= 2*x for x in nums if x != m): return nums.index(m) return -1 ", "class Solution def getGoodIndices(self, variables, target): return [i for i, (a, b, c, m) in enumerate(variables) if pow(pow(a, b, 10), c, m) == target] ", "class Solution def minOperations(self, s1, s2, x): parity = curr = prev = 0 j = -1 for i in xrange(len(s1)): if s1[i] == s2[i]: continue curr, prev = min(curr+x, prev+(i-j)*2 if j != -1 else float(\"inf\")), curr j = i parity ^= 1 return curr//2 if parity == 0 else -1 ", "class Solution def countQuadruples(self, firstString, secondString): lookup1 = [-1]*26 for i in reversed(xrange(len(firstString))): lookup1[ord(firstString[i])-ord('a')] = i lookup2 = [-1]*26 for i in xrange(len(secondString)): lookup2[ord(secondString[i])-ord('a')] = i result, diff = 0, float(\"inf\") for i in xrange(26): if lookup1[i] == -1 or lookup2[i] == -1: continue if lookup1[i]-lookup2[i] < diff: diff = lookup1[i]-lookup2[i] result = 0 result += int(lookup1[i]-lookup2[i] == diff) return result ", "class Solution def distinctNumbers(self, nums, k): result = [] count = collections.Counter() for i, num in enumerate(nums): count[num] += 1 if i >= k: count[nums[i-k]] -= 1 if not count[nums[i-k]]: del count[nums[i-k]] if i+1 >= k: result.append(len(count)) return result ", "class Solution def lowestCommonAncestor(self, root, p, q): def iter_dfs(node, p, q): result = None stk = [(1, (node, [0]))] while stk: step, params = stk.pop() if step == 1: node, ret = params if not node: continue ret1, ret2 = [0], [0] stk.append((2, (node, ret1, ret2, ret))) stk.append((1, (node.right, ret2))) stk.append((1, (node.left, ret1))) elif step == 2: node, ret1, ret2, ret = params curr = int(node == p or node == q) if curr+ret1[0]+ret2[0] == 2 and not result: result = node ret[0] = curr+ret1[0]+ret2[0] return result return iter_dfs(root, p, q) ", "class Solution def lowestCommonAncestor(self, root, p, q): def dfs(node, p, q, result): if not node: return 0 left = dfs(node.left, p, q, result) right = dfs(node.right, p, q, result) curr = int(node == p or node == q) if curr+left+right == 2 and not result[0]: result[0] = node return curr+left+right result = [0] dfs(root, p, q, result) return result[0] ", "class Solution def cherryPickup(self, grid): n = len(grid) dp = [[-1 for _ in xrange(n)] for _ in xrange(n)] dp[0][0] = grid[0][0] max_len = 2 * (n-1) directions = [(0, 0), (-1, 0), (0, -1), (-1, -1)] for k in xrange(1, max_len+1): for i in reversed(xrange(max(0, k-n+1), min(k+1, n))): for j in reversed(xrange(i, min(k+1, n))): if grid[i][k-i] == -1 or grid[j][k-j] == -1: dp[i][j] = -1 continue cnt = grid[i][k-i] if i != j: cnt += grid[j][k-j] max_cnt = -1 for direction in directions: ii, jj = i+direction[0], j+direction[1] if ii >= 0 and jj >= 0 and dp[ii][jj] >= 0: max_cnt = max(max_cnt, dp[ii][jj]+cnt) dp[i][j] = max_cnt return max(dp[n-1][n-1], 0) ", "class Solution def longestSubsequenceRepeatedK(self, s, k): def check(s, k, curr): if not curr: return True i = 0 for c in s: if c != curr[i]: continue i += 1 if i != len(curr): continue i = 0 k -= 1 if not k: return True return False def backtracking(s, k, curr, cnts, result): if not check(s, k, curr): return if len(curr) > len(result): result[:] = curr for c in reversed(string.ascii_lowercase): if cnts[c] < k: continue cnts[c] -= k curr.append(c) backtracking(s, k, curr, cnts, result) curr.pop() cnts[c] += k cnts = collections.Counter(s) new_s = [] for c in s: if cnts[c] < k: continue new_s.append(c) result =[] backtracking(new_s, k, [], cnts, result) return \"\".join(result) ", "class Solution def checkValidGrid(self, grid): if grid[0][0]: return False lookup = [None]*(len(grid)*len(grid[0])) for i in xrange(len(grid)): for j in xrange(len(grid[0])): lookup[grid[i][j]] = (i, j) return all(sorted([abs(lookup[i+1][0]-lookup[i][0]), abs(lookup[i+1][1]-lookup[i][1])]) == [1, 2] for i in xrange(len(lookup)-1)) ", "class Solution def checkValidGrid(self, grid): lookup = {grid[i][j]:(i, j) for i in xrange(len(grid)) for j in xrange(len(grid[0]))} return grid[0][0] == 0 and all(sorted([abs(lookup[i+1][0]-lookup[i][0]), abs(lookup[i+1][1]-lookup[i][1])]) == [1, 2] for i in xrange(len(lookup)-1)) ", "class Solution def fizzBuzz(self, n): result = [] for i in xrange(1, n+1): if i % 15 == 0: result.append(\"FizzBuzz\") elif i % 5 == 0: result.append(\"Buzz\") elif i % 3 == 0: result.append(\"Fizz\") else: result.append(str(i)) return result def fizzBuzz2(self, n): l = [str(x) for x in range(n + 1)] l3 = range(0, n + 1, 3) l5 = range(0, n + 1, 5) for i in l3: l[i] = 'Fizz' for i in l5: if l[i] == 'Fizz': l[i] += 'Buzz' else: l[i] = 'Buzz' return l[1:] def fizzBuzz3(self, n): return ['Fizz' * (not i % 3) + 'Buzz' * (not i % 5) or str(i) for i in range(1, n + 1)] def fizzBuzz4(self, n): return ['FizzBuzz'[i % -3 & -4:i % -5 & 8 ^ 12] or repr(i) for i in range(1, n + 1)] ", "class Solution def findDelayedArrivalTime(self, arrivalTime, delayedTime): return (arrivalTime + delayedTime)%24 ", "class Solution def collectTheCoins(self, coins, edges): DISTANCE = 2 adj = [set() for _ in xrange(len(coins))] for u, v in edges: adj[u].add(v) adj[v].add(u) n = len(coins) q = [] for u in xrange(len(coins)): while len(adj[u]) == 1 and not coins[u]: v = adj[u].pop() adj[v].remove(u) n -= 1 u = v q = [u for u in xrange(len(coins)) if len(adj[u]) == 1] for _ in xrange(DISTANCE): new_q = [] for u in q: if not adj[u]: assert(n == 1) break v = adj[u].pop() adj[v].remove(u) n -= 1 if len(adj[v]) == 1: new_q.append(v) q = new_q return (n-1)*2 ", "class Solution def highestPeak(self, isWater): directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] q = [] for r, row in enumerate(isWater): for c, cell in enumerate(row): row[c] -= 1 if not cell: continue q.append((r, c)) while q: new_q = [] for r, c in q: for dr, dc in directions: nr, nc = r+dr, c+dc if not (0 <= nr < len(isWater) and 0 <= nc < len(isWater[0]) and isWater[nr][nc] == -1): continue isWater[nr][nc] = isWater[r][c]+1 q.append((nr, nc)) q = new_q return isWater ", "class Solution def highestPeak(self, isWater): directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] q, heights = [], [[-1]*len(isWater[0]) for _ in xrange(len(isWater))] for r, row in enumerate(isWater): for c, cell in enumerate(row): if not cell: continue heights[r][c] = 0 q.append((r, c)) while q: new_q = [] for r, c in q: for dr, dc in directions: nr, nc = r+dr, c+dc if not (0 <= nr < len(isWater) and 0 <= nc < len(isWater[0]) and heights[nr][nc] == -1): continue heights[nr][nc] = heights[r][c]+1 q.append((nr, nc)) q = new_q return heights ", "class Solution def minCapability(self, nums, k): def check(x): cnt = i = 0 while i < len(nums): if nums[i] <= x: cnt += 1 i += 2 else: i += 1 return cnt >= k sorted_nums = sorted(set(nums)) left, right = 0, len(sorted_nums)-1 while left <= right: mid = left + (right-left)//2 if check(sorted_nums[mid]): right = mid-1 else: left = mid+1 return sorted_nums[left] ", "class Solution def minCapability(self, nums, k): def check(x): cnt = i = 0 while i < len(nums): if nums[i] <= x: cnt += 1 i += 2 else: i += 1 return cnt >= k left, right = min(nums), max(nums) while left <= right: mid = left + (right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left ", "class Solution def findOriginalArray(self, changed): if len(changed)%2: return [] cnts = collections.Counter(changed) for x in sorted(cnts.iterkeys()): if cnts[x] > cnts[2*x]: return [] cnts[2*x] -= cnts[x] if x else cnts[x]//2 return list(cnts.elements()) ", "class Solution def construct2DArray(self, original, m, n): return [original[i:i+n] for i in xrange(0, len(original), n)] if len(original) == m*n else [] ", "class Solution def characterReplacement(self, s, k): result, max_count = 0, 0 count = collections.Counter() for i in xrange(len(s)): count[s[i]] += 1 max_count = max(max_count, count[s[i]]) if result - max_count >= k: count[s[i-result]] -= 1 else: result += 1 return result ", "class Solution def eventualSafeNodes(self, graph): WHITE, GRAY, BLACK = range(3) def dfs(graph, node, lookup): if lookup[node] != WHITE: return lookup[node] == BLACK lookup[node] = GRAY if any(not dfs(graph, child, lookup) for child in graph[node]): return False lookup[node] = BLACK return True lookup = [WHITE]*len(graph) return filter(lambda node: dfs(graph, node, lookup), xrange(len(graph))) ", "class Solution def findMaxValueOfEquation(self, points, k): result = float(\"-inf\") dq = collections.deque() for i, (x, y) in enumerate(points): while dq and points[dq[0]][0] < x-k: dq.popleft() if dq: result = max(result, (points[dq[0]][1]-points[dq[0]][0])+y+x) while dq and points[dq[-1]][1]-points[dq[-1]][0] <= y-x: dq.pop() dq.append(i) return result ", "class Solution def maxDistance(self, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] q = collections.deque([(i, j) for i in xrange(len(grid)) for j in xrange(len(grid[0])) if grid[i][j] == 1]) if len(q) == len(grid)*len(grid[0]): return -1 level = -1 while q: next_q = collections.deque() while q: x, y = q.popleft() for dx, dy in directions: nx, ny = x+dx, y+dy if not (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 0): continue next_q.append((nx, ny)) grid[nx][ny] = 1 q = next_q level += 1 return level ", "class Solution def evalRPN(self, tokens): numerals, operators = [], {\"+\": operator.add, \"-\": operator.sub, \"*\": operator.mul, \"/\": operator.div} for token in tokens: if token not in operators: numerals.append(int(token)) else: y, x = numerals.pop(), numerals.pop() numerals.append(int(operators[token](x * 1.0, y))) return numerals.pop() ", "class Solution def divisorSubstrings(self, num, k): result = curr = 0 s = map(int, str(num)) base = 10**(k-1) for i, x in enumerate(s): if i-k >= 0: curr -= s[i-k]*base curr = curr*10+x if i+1 >= k: result += int(curr and num%curr == 0) return result ", "class Solution def recoverArray(self, n, sums): sums.sort() shift, l = 0, len(sums) result = [] for _ in xrange(n): new_shift = sums[0]-sums[1] assert(new_shift <= 0) has_zero, j, k = False, 0, 0 for i in xrange(l): if k < j and sums[k] == sums[i]: k += 1 else: if shift == sums[i]-new_shift: has_zero = True sums[j] = sums[i]-new_shift j += 1 if has_zero: result.append(new_shift) else: result.append(-new_shift) shift -= new_shift l //= 2 return result import collections ", "class Solution def recoverArray(self, n, sums): min_sum, max_sum = min(sums), max(sums) dp = [0]*(max_sum-min_sum+1) for x in sums: dp[x-min_sum] += 1 sorted_sums = [x for x in xrange(min_sum, max_sum+1) if dp[x-min_sum]] shift = 0 result = [] for _ in xrange(n): new_dp = [0]*(max_sum-min_sum+1) new_sorted_sums = [] new_shift = sorted_sums[0]-sorted_sums[1] if dp[sorted_sums[0]-min_sum] == 1 else 0 assert(new_shift <= 0) for x in sorted_sums: if not dp[x-min_sum]: continue dp[(x-new_shift)-min_sum] -= dp[x-min_sum] if new_shift else dp[x-min_sum]//2 new_dp[(x-new_shift)-min_sum] = dp[x-min_sum] new_sorted_sums.append(x-new_shift) dp = new_dp sorted_sums = new_sorted_sums if dp[shift-min_sum]: result.append(new_shift) else: result.append(-new_shift) shift -= new_shift return result import collections import operator ", "class Solution def recoverArray(self, n, sums): dp = {k: v for k, v in collections.Counter(sums).iteritems()} total = reduce(operator.ior, dp.itervalues(), 0) basis = total&-total if basis > 1: for k in dp.iterkeys(): dp[k] //= basis sorted_sums = sorted(dp.iterkeys()) shift = 0 result = [0]*(basis.bit_length()-1) for _ in xrange(n-len(result)): new_dp = {} new_sorted_sums = [] new_shift = sorted_sums[0]-sorted_sums[1] assert(new_shift < 0) for x in sorted_sums: if not dp[x]: continue dp[x-new_shift] -= dp[x] new_dp[x-new_shift] = dp[x] new_sorted_sums.append(x-new_shift) dp = new_dp sorted_sums = new_sorted_sums if shift in dp: result.append(new_shift) else: result.append(-new_shift) shift -= new_shift return result import collections ", "class Solution def recoverArray(self, n, sums): dp = {k: v for k, v in collections.Counter(sums).iteritems()} sorted_sums = sorted(dp.iterkeys()) shift = 0 result = [] for _ in xrange(n): new_dp = {} new_sorted_sums = [] new_shift = sorted_sums[0]-sorted_sums[1] if dp[sorted_sums[0]] == 1 else 0 assert(new_shift <= 0) for x in sorted_sums: if not dp[x]: continue dp[x-new_shift] -= dp[x] if new_shift else dp[x]//2 new_dp[x-new_shift] = dp[x] new_sorted_sums.append(x-new_shift) dp = new_dp sorted_sums = new_sorted_sums if shift in dp: result.append(new_shift) else: result.append(-new_shift) shift -= new_shift return result import collections ", "class Solution def recoverArray(self, n, sums): dp = OrderedDict(sorted(collections.Counter(sums).iteritems())) shift = 0 result = [] for _ in xrange(n): new_dp = OrderedDict() it = iter(dp) min_sum = next(it) new_shift = min_sum-next(it) if dp[min_sum] == 1 else 0 assert(new_shift <= 0) for x in dp.iterkeys(): if not dp[x]: continue dp[x-new_shift] -= dp[x] if new_shift else dp[x]//2 new_dp[x-new_shift] = dp[x] dp = new_dp if shift in dp: result.append(new_shift) else: result.append(-new_shift) shift -= new_shift return result ", "class Solution def prefixCount(self, words, pref): return sum(x.startswith(pref) for x in words) ", "class Solution def check(self, nums): count = 0 for i in xrange(len(nums)): if nums[i] > nums[(i+1)%len(nums)]: count += 1 if count > 1: return False return True ", "class Solution def countSubranges(self, nums1, nums2): MOD = 10**9+7 result = 0 dp = collections.Counter() for x, y in itertools.izip(nums1, nums2): new_dp = collections.Counter() new_dp[x] += 1 new_dp[-y] += 1 for v, c in dp.iteritems(): new_dp[v+x] = (new_dp[v+x]+c)%MOD new_dp[v-y] = (new_dp[v-y]+c)%MOD dp = new_dp result = (result+dp[0])%MOD return result ", "class Solution def isThereAPath(self, grid): if (len(grid)+len(grid[0])-1)%2: return False dp_left = [[float(\"inf\")]*(len(grid[0])+1) for _ in xrange(2)] dp_left[0][1] = dp_left[1][0] = 0 dp_right = [[float(\"-inf\")]*(len(grid[0])+1) for _ in xrange(2)] dp_right[0][1] = dp_right[1][0] = 0 for i in xrange(len(grid)): for j in xrange(len(grid[0])): dp_left[(i+1)%2][j+1] = min(dp_left[i%2][j+1], dp_left[(i+1)%2][j])+grid[i][j] dp_right[(i+1)%2][j+1] = max(dp_right[i%2][j+1], dp_right[(i+1)%2][j])+grid[i][j] return dp_left[len(grid)%2][-1] <= (len(grid)+len(grid[0])-1)//2 <= dp_right[len(grid)%2][-1] ", "class Solution def possiblyEquals(self, s1, s2): def general_possible_numbers(s): dp = [set() for _ in xrange(len(s))] for i in xrange(len(s)): curr, basis = 0, 1 for j in reversed(xrange(i+1)): curr += int(s[j])*basis basis *= 10 if s[j] == '0': continue if j == 0: dp[i].add(curr) else: dp[i].update(x+curr for x in dp[j-1]) return dp[-1] def optimized_possible_numbers(s): assert(len(s) <= 3) result = {int(s)} if len(s) >= 2: if s[1] != '0': result.add(int(s[:1])+int(s[1:])) if len(s) >= 3: if s[2] != '0': result.add(int(s[:2])+int(s[2:])) if s[1] != '0': result.add(int(s[0:1])+int(s[1:2])+int(s[2:])) return result def memoization(s1, s2, i, j, k, lookup): if (i, j, k) not in lookup: if i == len(s1) and j == len(s2): lookup[(i, j, k)] = (k == 0) elif i != len(s1) and s1[i].isdigit(): lookup[(i, j, k)] = False for ni in xrange(i+1, len(s1)+1): if ni == len(s1) or not s1[ni].isdigit(): break for x in optimized_possible_numbers(s1[i:ni]): if memoization(s1, s2, ni, j, k+x, lookup): lookup[(i, j, k)] = True break elif j != len(s2) and s2[j].isdigit(): lookup[(i, j, k)] = False for nj in xrange(j+1, len(s2)+1): if nj == len(s2) or not s2[nj].isdigit(): break for x in optimized_possible_numbers(s2[j:nj]): if memoization(s1, s2, i, nj, k-x, lookup): lookup[(i, j, k)] = True break elif k < 0: lookup[(i, j, k)] = memoization(s1, s2, i+1, j, k+1, lookup) if i != len(s1) else False elif k > 0: lookup[(i, j, k)] = memoization(s1, s2, i, j+1, k-1, lookup) if j != len(s2) else False else: lookup[(i, j, k)] = memoization(s1, s2, i+1, j+1, k, lookup) if i != len(s1) and j != len(s2) and s1[i] == s2[j] else False return lookup[(i, j, k)] return memoization(s1, s2, 0, 0, 0, {}) ", "class Solution def possiblyEquals(self, s1, s2): def memoization(s1, s2, i, j, k, lookup): if (i, j, k) not in lookup: if i == len(s1) and j == len(s2): lookup[(i, j, k)] = (k == 0) elif i != len(s1) and s1[i].isdigit(): lookup[(i, j, k)] = False for ni in xrange(i+1, len(s1)+1): if (ni == len(s1) or s1[ni] != '0') and memoization(s1, s2, ni, j, k+int(s1[i:ni]), lookup): lookup[(i, j, k)] = True break if ni == len(s1) or not s1[ni].isdigit(): break elif j != len(s2) and s2[j].isdigit(): lookup[(i, j, k)] = False for nj in xrange(j+1, len(s2)+1): if (nj == len(s2) or s2[nj] != '0') and memoization(s1, s2, i, nj, k-int(s2[j:nj]), lookup): lookup[(i, j, k)] = True break if nj == len(s2) or not s2[nj].isdigit(): break elif k < 0: lookup[(i, j, k)] = memoization(s1, s2, i+1, j, k+1, lookup) if i != len(s1) else False elif k > 0: lookup[(i, j, k)] = memoization(s1, s2, i, j+1, k-1, lookup) if j != len(s2) else False else: lookup[(i, j, k)] = memoization(s1, s2, i+1, j+1, k, lookup) if i != len(s1) and j != len(s2) and s1[i] == s2[j] else False return lookup[(i, j, k)] return memoization(s1, s2, 0, 0, 0, {}) ", "class Solution def possiblyEquals(self, s1, s2): MAX_DIGIT_LEN = 3 w = 1+MAX_DIGIT_LEN dp = [[set() for _ in xrange(len(s2)+1)] for _ in xrange(w)] dp[0][0].add(0) for i in xrange(len(s1)+1): if i: dp[(i-1)%w] = [set() for _ in xrange(len(s2)+1)] if i != len(s1) and s1[i] == '0': continue for j in xrange(len(s2)+1): for k in dp[i%w][j]: if i != len(s1) and j != len(s2) and s1[i] == s2[j] and k == 0: dp[(i+1)%w][j+1].add(k) if k <= 0 and i != len(s1): if not s1[i].isdigit(): if k: dp[(i+1)%w][j].add(k+1) elif s1[i] != '0': curr = 0 for ni in xrange(i, len(s1)): if not s1[ni].isdigit(): break curr = curr*10 + int(s1[ni]) dp[(ni+1)%w][j].add(k+curr) if k >= 0 and j != len(s2): if not s2[j].isdigit(): if k: dp[i%w][j+1].add(k-1) elif s2[j] != '0': curr = 0 for nj in xrange(j, len(s2)): if not s2[nj].isdigit(): break curr = curr*10 + int(s2[nj]) dp[i%w][nj+1].add(k-curr) return 0 in dp[len(s1)%w][len(s2)] ", "class Solution def addSpaces(self, s, spaces): prev = len(s) s = list(s) s.extend([None]*len(spaces)) for i in reversed(xrange(len(spaces))): for j in reversed(xrange(spaces[i], prev)): s[j+1+i] = s[j] s[spaces[i]+i] = ' ' prev = spaces[i] return \"\".join(s) ", "class Solution def maxJumps(self, arr, d): def dp(arr, d, i, left, right, lookup): if lookup[i]: return lookup[i] lookup[i] = 1 for j in itertools.chain(left[i], right[i]): lookup[i] = max(lookup[i], dp(arr, d, j, left, right, lookup)+1) return lookup[i] left, decreasing_dq = [[] for _ in xrange(len(arr))], collections.deque() for i in xrange(len(arr)): if decreasing_dq and i - decreasing_dq[0] == d+1: decreasing_dq.popleft() while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]: if left[i] and arr[left[i][-1]] != arr[decreasing_dq[-1]]: left[i] = [] left[i].append(decreasing_dq.pop()) decreasing_dq.append(i) right, decreasing_dq = [[] for _ in xrange(len(arr))], collections.deque() for i in reversed(xrange(len(arr))): if decreasing_dq and decreasing_dq[0] - i == d+1: decreasing_dq.popleft() while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]: if right[i] and arr[right[i][-1]] != arr[decreasing_dq[-1]]: right[i] = [] right[i].append(decreasing_dq.pop()) decreasing_dq.append(i) lookup = [0]*len(arr) return max(itertools.imap(lambda x: dp(arr, d, x, left, right, lookup), xrange(len(arr)))) ", "class Solution def maxJumps(self, arr, d): left, decreasing_stk = [[] for _ in xrange(len(arr))], [] for i in xrange(len(arr)): while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]: if i - decreasing_stk[-1] <= d: if left[i] and arr[left[i][-1]] != arr[decreasing_stk[-1]]: left[i] = [] left[i].append(decreasing_stk[-1]) decreasing_stk.pop() decreasing_stk.append(i) right, decreasing_stk = [[] for _ in xrange(len(arr))], [] for i in reversed(xrange(len(arr))): while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]: if decreasing_stk[-1] - i <= d: if right[i] and arr[right[i][-1]] != arr[decreasing_stk[-1]]: right[i] = [] right[i].append(decreasing_stk[-1]) decreasing_stk.pop() decreasing_stk.append(i) dp = [0]*len(arr) for a, i in sorted([a, i] for i, a in enumerate(arr)): dp[i] = 1 for j in itertools.chain(left[i], right[i]): dp[i] = max(dp[i], dp[j]+1) return max(dp) class SegmentTree(object): def __init__(self, N, build_fn=lambda x, y: [y]*(2*x), query_fn=max, update_fn=lambda x, y: y, default_val=0): self.N = N self.H = (N-1).bit_length() self.query_fn = query_fn self.update_fn = update_fn self.default_val = default_val self.tree = build_fn(N, default_val) self.lazy = [None]*N def __apply(self, x, val): self.tree[x] = self.update_fn(self.tree[x], val) if x < self.N: self.lazy[x] = self.update_fn(self.lazy[x], val) def update(self, L, R, h): def pull(x): while x > 1: x //= 2 self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1]) if self.lazy[x] is not None: self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]) L += self.N R += self.N L0, R0 = L, R while L <= R: if L & 1: self.__apply(L, h) L += 1 if R & 1 == 0: self.__apply(R, h) R -= 1 L //= 2 R //= 2 pull(L0) pull(R0) def query(self, L, R): def push(x): n = 2**self.H while n != 1: y = x // n if self.lazy[y] is not None: self.__apply(y*2, self.lazy[y]) self.__apply(y*2 + 1, self.lazy[y]) self.lazy[y] = None n //= 2 result = self.default_val if L > R: return result L += self.N R += self.N push(L) push(R) while L <= R: if L & 1: result = self.query_fn(result, self.tree[L]) L += 1 if R & 1 == 0: result = self.query_fn(result, self.tree[R]) R -= 1 L //= 2 R //= 2 return result def __str__(self): showList = [] for i in xrange(self.N): showList.append(self.query(i, i)) return \",\".join(map(str, showList)) ", "class Solution def maxJumps(self, arr, d): left, decreasing_stk = range(len(arr)), [] for i in xrange(len(arr)): while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]: if i - decreasing_stk[-1] <= d: left[i] = decreasing_stk[-1] decreasing_stk.pop() decreasing_stk.append(i) right, decreasing_stk = range(len(arr)), [] for i in reversed(xrange(len(arr))): while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]: if decreasing_stk[-1] - i <= d: right[i] = decreasing_stk[-1] decreasing_stk.pop() decreasing_stk.append(i) segment_tree = SegmentTree(len(arr)) for _, i in sorted([x, i] for i, x in enumerate(arr)): segment_tree.update(i, i, segment_tree.query(left[i], right[i]) + 1) return segment_tree.query(0, len(arr)-1) ", "class Solution def addOperators(self, num, target): result, expr = [], [] val, i = 0, 0 val_str = \"\" while i < len(num): val = val * 10 + ord(num[i]) - ord('0') val_str += num[i] if str(val) != val_str: break expr.append(val_str) self.addOperatorsDFS(num, target, i + 1, 0, val, expr, result) expr.pop() i += 1 return result def addOperatorsDFS(self, num, target, pos, operand1, operand2, expr, result): if pos == len(num) and operand1 + operand2 == target: result.append(\"\".join(expr)) else: val, i = 0, pos val_str = \"\" while i < len(num): val = val * 10 + ord(num[i]) - ord('0') val_str += num[i] if str(val) != val_str: break expr.append(\"+\" + val_str) self.addOperatorsDFS(num, target, i + 1, operand1 + operand2, val, expr, result) expr.pop() expr.append(\"-\" + val_str) self.addOperatorsDFS(num, target, i + 1, operand1 + operand2, -val, expr, result) expr.pop() expr.append(\"*\" + val_str) self.addOperatorsDFS(num, target, i + 1, operand1, operand2 * val, expr, result) expr.pop() i += 1 ", "class Solution def arrayNesting(self, nums): result = 0 for num in nums: if num is not None: start, count = num, 0 while nums[start] is not None: temp = start start = nums[start] nums[temp] = None count += 1 result = max(result, count) return result ", "class Solution def isSumEqual(self, firstWord, secondWord, targetWord): def stoi(s): result = 0 for c in s: result = result*10 + ord(c)-ord('a') return result return stoi(firstWord) + stoi(secondWord) == stoi(targetWord) ", "class Solution def subStrHash(self, s, power, modulo, k, hashValue): h, idx = 0, -1 pw = pow(power, k-1, modulo) for i in reversed(xrange(len(s))): if i+k < len(s): h = (h-(ord(s[i+k])-ord('a')+1)*pw)%modulo h = (h*power+(ord(s[i])-ord('a')+1))%modulo if h == hashValue: idx = i return s[idx:idx+k] ", "class Solution def heightOfTree(self, root): result = -1 stk = [(root, 0)] while stk: u, d = stk.pop() result = max(result, d) if u.right and u.right.left != u: stk.append((u.right, d+1)) if u.left and u.left.right != u: stk.append((u.left, d+1)) return result ", "class Solution def heightOfTree(self, root): result = -1 q = [root] while q: new_q = [] for u in q: if u.left and u.left.right != u: new_q.append(u.left) if u.right and u.right.left != u: new_q.append(u.right) q = new_q result += 1 return result ", "class Solution def sumFourDivisors(self, nums): result = 0 for num in nums: facs, i = [], 1 while i*i <= num: if num % i: i+= 1 continue facs.append(i) if i != num//i: facs.append(num//i) if len(facs) > 4: break i += 1 if len(facs) == 4: result += sum(facs) return result import itertools ", "class Solution def sumFourDivisors(self, nums): def factorize(x): result = [] d = 2 while d*d <= x: e = 0 while x%d == 0: x //= d e += 1 if e: result.append([d, e]) d += 1 if d == 2 else 2 if x > 1: result.append([x, 1]) return result result = 0 for facs in itertools.imap(factorize, nums): if len(facs) == 1 and facs[0][1] == 3: p = facs[0][0] result += (p**4-1)//(p-1) elif len(facs) == 2 and facs[0][1] == facs[1][1] == 1: p, q = facs[0][0], facs[1][0] result += (1 + p) * (1 + q) return result ", "class Solution def threeSumMulti(self, A, target): count = collections.Counter(A) result = 0 for i, j in itertools.combinations_with_replacement(count, 2): k = target - i - j if i == j == k: result += count[i] * (count[i]-1) * (count[i]-2) // 6 elif i == j != k: result += count[i] * (count[i]-1) // 2 * count[k] elif max(i, j) < k: result += count[i] * count[j] * count[k] return result % (10**9 + 7) ", "class Solution def countPairs(self, n, edges, queries): degree = [0]*(n+1) shared = collections.Counter((min(n1, n2), max(n1, n2)) for n1, n2 in edges) for u, v in edges: degree[u] += 1 degree[v] += 1 cnt = [0]*(2*(max(degree[1:])+1)) count = collections.Counter(degree[1:]) for i, j in itertools.product(count, count): if i < j: cnt[i+j] += count[i]*count[j] elif i == j: cnt[i+j] += count[i]*(count[i]-1)//2 for (i, j), shared_degree in shared.iteritems(): cnt[degree[i]+degree[j]] -= 1 cnt[degree[i]+degree[j]-shared_degree] += 1 for i in reversed(xrange(len(cnt)-1)): cnt[i] += cnt[i+1] return [cnt[q+1] if q+1 < len(cnt) else 0 for q in queries] import collections ", "class Solution def countPairs(self, n, edges, queries): degree = [0]*(n+1) shared = collections.Counter((min(n1, n2), max(n1, n2)) for n1, n2 in edges) for n1, n2 in edges: degree[n1] += 1 degree[n2] += 1 sorted_degree = sorted(degree) result = [] for k, q in enumerate(queries): left, right = 1, n cnt = 0 while left < right: if q < sorted_degree[left]+sorted_degree[right]: cnt += right-left right -= 1 else: left += 1 for (i, j), shared_degree in shared.iteritems(): if degree[i]+degree[j]-shared_degree <= q < degree[i]+degree[j]: cnt -= 1 result.append(cnt) return result ", "class Solution def getXORSum(self, arr1, arr2): return reduce(operator.xor, arr1) & reduce(operator.xor, arr2) ", "class Solution def inorderSuccessor(self, node): if not node: return None if node.right: node = node.right while node.left: node = node.left return node while node.parent and node.parent.right is node: node = node.parent return node.parent ", "class Solution def findWinningPlayer(self, skills, k): result = cnt = 0 for i in range(1, len(skills)): if skills[result] < skills[i]: result = i cnt = 0 cnt += 1 if cnt == k: return result return result ", "class Solution def maxDepthBST(self, order): depths = sortedcontainers.SortedDict({float(\"-inf\"):0, float(\"inf\"):0}) values_view = depths.values() result = 0 for x in order: i = depths.bisect_right(x) depths[x] = max(values_view[i-1:i+1])+1 result = max(result, depths[x]) return result ", "class Solution def sumOfPowers(self, nums, k): MOD = 10**9+7 nums.sort() result = prev = 0 for mn in sorted({nums[j]-nums[i] for i in xrange(len(nums)) for j in xrange(i+1, len(nums))}, reverse=True): dp = [[0]*(k+1) for _ in xrange(len(nums)+1)] dp[0][0] = 1 j = 0 for i in xrange(len(nums)): j = next((j for j in xrange(j, len(nums)) if nums[i]-nums[j] < mn), len(nums)) for l in xrange(1, k+1): dp[i+1][l] = (dp[i+1][l]+dp[(j-1)+1][l-1])%MOD for l in xrange(k+1): dp[i+1][l] = (dp[i+1][l]+dp[i][l])%MOD cnt = (dp[-1][k]-prev)%MOD result = (result+mn*cnt)%MOD prev = dp[-1][k] return result import collections ", "class Solution def sumOfPowers(self, nums, k): MOD = 10**9+7 nums.sort() dp = [[collections.defaultdict(int) for _ in xrange(len(nums)+1)] for _ in xrange(len(nums))] for i in xrange(len(nums)): for j in xrange(max(k-(len(nums)-i+1)-1, 0), i): diff = nums[i]-nums[j] dp[i][2][diff] += 1 for l in xrange(max(k-(len(nums)-i+1), 0), i+1): for mn, cnt in dp[j][l].iteritems(): dp[i][l+1][min(diff, mn)] = (dp[i][l+1][min(diff, mn)]+cnt)%MOD return reduce(lambda accu, x: (accu+x)%MOD, ((mn*cnt)%MOD for i in xrange(k-1, len(dp)) for mn, cnt in dp[i][k].iteritems())) ", "class Solution def goodDaysToRobBank(self, security, time): right = [0] for i in reversed(xrange(1, len(security))): right.append(right[-1]+1 if security[i] >= security[i-1] else 0) right.reverse() result = [] left = 0 for i in xrange(len(security)): if left >= time and right[i] >= time: result.append(i) if i+1 < len(security): left = left+1 if security[i] >= security[i+1] else 0 return result ", "class Solution def isAcronym(self, words, s): return len(words) == len(s) and all(w[0] == c for w, c in itertools.izip(words, s)) ", "class Solution def displayTable(self, orders): table_count = collections.defaultdict(collections.Counter) for _, table, food in orders: table_count[int(table)][food] += 1 foods = sorted({food for _, _, food in orders}) result = [[\"Table\"]] result[0].extend(foods) for table in sorted(table_count): result.append([str(table)]) result[-1].extend(str(table_count[table][food]) for food in foods) return result ", "class Solution def outerTrees(self, points): points = sorted(set(tuple(x) for x in points)) if len(points) <= 1: return points def cross(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) lower = [] for p in points: while len(lower) >= 2 and cross(lower[-2], lower[-1], p) < 0: lower.pop() lower.append(p) upper = [] for p in reversed(points): while len(upper) >= 2 and cross(upper[-2], upper[-1], p) < 0: upper.pop() upper.append(p) result = lower[:-1] + upper[:-1] return result if result[1] != result[-1] else result[:len(result)//2+1] ", "class Solution def corpFlightBookings(self, bookings, n): result = [0]*(n+1) for i, j, k in bookings: result[i-1] += k result[j] -= k for i in xrange(1, len(result)): result[i] += result[i-1] result.pop() return result ", "class Solution def brightestPosition(self, lights): count = collections.Counter() for i, r in lights: count[i-r] += 1 count[i+r+1] -= 1 result = None max_cnt = cnt = 0 for i, c in sorted(count.iteritems()): cnt += c if cnt > max_cnt: max_cnt, result = cnt, i return result ", "class Solution def readBinaryWatch(self, num): def bit_count(bits): count = 0 while bits: bits &= bits-1 count += 1 return count return ['%d:%02d' % (h, m) for h in xrange(12) for m in xrange(60) if bit_count(h) + bit_count(m) == num] def readBinaryWatch2(self, num): return ['{0}:{1}'.format(str(h), str(m).zfill(2)) for h in range(12) for m in range(60) if (bin(h) + bin(m)).count('1') == num] ", "class Solution def longestArithSeqLength(self, A): dp = collections.defaultdict(int) for i in xrange(len(A)-1): for j in xrange(i+1, len(A)): v = A[j]-A[i] dp[v, j] = max(dp[v, j], dp[v, i]+1) return max(dp.values())+1 ", "class Solution def gcdSort(self, nums): def modified_sieve_of_eratosthenes(n, lookup, uf): if n < 2: return is_prime = [True]*(n+1) for i in xrange(2, len(is_prime)): if not is_prime[i]: continue for j in xrange(i+i, len(is_prime), i): is_prime[j] = False if j in lookup: uf.union_set(i-1, j-1) max_num = max(nums) uf = UnionFind(max_num) modified_sieve_of_eratosthenes(max_num, set(nums), uf) return all(uf.find_set(a-1) == uf.find_set(b-1) for a, b in itertools.izip(nums, sorted(nums))) ", "class Solution def findKthPositive(self, arr, k): def check(arr, k, x): return arr[x]-(x+1) < k left, right = 0, len(arr)-1 while left <= right: mid = left + (right-left)//2 if not check(arr, k, mid): right = mid-1 else: left = mid+1 return right+1+k ", "class Solution def elementInNums(self, nums, queries): result = [] for t, i in queries: t %= 2*len(nums) if t+i < len(nums): result.append(nums[t+i]) elif i < t-len(nums): result.append(nums[i]) else: result.append(-1) return result ", "class Solution def countPrefixSuffixPairs(self, words): _trie = lambda: collections.defaultdict(_trie) trie = _trie() result = 0 for w in words: curr = trie for i in xrange(len(w)): curr = curr[w[i], w[~i]] result += curr[\"_cnt\"] if \"_cnt\" in curr else 0 curr[\"_cnt\"] = curr[\"_cnt\"]+1 if \"_cnt\" in curr else 1 return result ", "class Solution def countPrefixSuffixPairs(self, words): def check(i, j): return words[j].startswith(words[i]) and words[j].endswith(words[i]) return sum(check(i, j) for i in xrange(len(words)) for j in xrange(i+1, len(words))) ", "class Solution def treeQueries(self, root, queries): def iter_dfs(root): top = collections.defaultdict(lambda: [0]*2) depth, height = {}, {} stk = [(1, (root, 0))] while stk: step, (curr, d) = stk.pop() if step == 1: if not curr: continue stk.append((2, (curr, d))) stk.append((1, (curr.right, d+1))) stk.append((1, (curr.left, d+1))) elif step == 2: h = 1+max((height[curr.left.val] if curr.left else 0), (height[curr.right.val] if curr.right else 0)) if h > top[d][0]: top[d][0], top[d][1] = h, top[d][0] elif h > top[d][1]: top[d][1] = h depth[curr.val], height[curr.val] = d, h return top, depth, height top, depth, height = iter_dfs(root) return [(depth[q]-1)+(top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries] import collections ", "class Solution def treeQueries(self, root, queries): def dfs(curr, d): if not curr: return 0 h = 1+max(dfs(curr.left, d+1), dfs(curr.right, d+1)) if h > top[d][0]: top[d][0], top[d][1] = h, top[d][0] elif h > top[d][1]: top[d][1] = h depth[curr.val], height[curr.val] = d, h return h top = collections.defaultdict(lambda: [0]*2) depth, height = {}, {} dfs(root, 0) return [(depth[q]-1)+(top[depth[q]][0] if height[q] != top[depth[q]][0] else top[depth[q]][1]) for q in queries] ", "class Solution def monkeyMove(self, n): MOD = 10**9+7 return (pow(2, n, MOD)-2)%MOD ", "class Solution def rob(self, nums): last, now = 0, 0 for i in nums: last, now = now, max(last + i, now) return now ", "class Solution def checkDistances(self, s, distance): for i in xrange(len(s)): if i+distance[ord(s[i])-ord('a')]+1 >= len(s) or s[i+distance[ord(s[i])-ord('a')]+1] != s[i]: return False distance[ord(s[i])-ord('a')] = -1 return True ", "class Solution def cellsInRange(self, s): return [chr(x)+chr(y) for x in xrange(ord(s[0]), ord(s[3])+1) for y in xrange(ord(s[1]), ord(s[4])+1)] ", "class Solution def largestValsFromLabels(self, values, labels, num_wanted, use_limit): counts = collections.defaultdict(int) val_labs = zip(values,labels) val_labs.sort(reverse=True) result = 0 for val, lab in val_labs: if counts[lab] >= use_limit: continue result += val counts[lab] += 1 num_wanted -= 1 if num_wanted == 0: break return result ", "class Solution def differenceOfSums(self, n, m): def arithmetic_progression_sum(a, d, l): return (a+(a+(l-1)*d))*l//2 return arithmetic_progression_sum(1, 1, n) - 2*arithmetic_progression_sum(m, m, n//m) ", "class Solution def differenceOfSums(self, n, m): return (n+1)*n//2 - 2*(((n//m+1)*(n//m)//2)*m) ", "class Solution def convertBST(self, root): def convertBSTHelper(root, cur_sum): if not root: return cur_sum if root.right: cur_sum = convertBSTHelper(root.right, cur_sum) cur_sum += root.val root.val = cur_sum if root.left: cur_sum = convertBSTHelper(root.left, cur_sum) return cur_sum convertBSTHelper(root, 0) return root ", "class Solution def subarraysWithMoreZerosThanOnes(self, nums): MOD = 10**9+7 lookup = collections.defaultdict(int) lookup[0] = 1 result = total = same = more = 0 for x in nums: total += 1 if x == 1 else -1 new_same = lookup[total] new_more = (same+more+1)%MOD if x == 1 else (more-new_same)%MOD lookup[total] += 1 result = (result+new_more)%MOD same, more = new_same, new_more return result ", "class Solution def subarraysWithMoreZerosThanOnes(self, nums): MOD = 10**9+7 lookup = {0:-1} dp = [0]*len(nums) result = total = 0 for i, x in enumerate(nums): total += 1 if x == 1 else -1 if total not in lookup: if total > 0: dp[i] = i+1 else: j = lookup[total] if j != -1: dp[i] = dp[j] if x > 0: dp[i] += (i-1)-j lookup[total] = i result = (result+dp[i])%MOD return result ", "class Solution def flipBinaryTree(self, root, leaf): curr, parent = leaf, None while True: child = curr.parent curr.parent = parent if curr.left == parent: curr.left = None else: curr.right = None if curr == root: break if curr.left: curr.right = curr.left curr.left = child curr, parent = child, curr return leaf ", "class Solution def smallestDivisor(self, nums, threshold): def check(A, d, threshold): return sum((i-1)//d+1 for i in nums) <= threshold left, right = 1, max(nums) while left <= right: mid = left + (right-left)//2 if check(nums, mid, threshold): right = mid-1 else: left = mid+1 return left ", "class Solution def smallestBeautifulString(self, s, k): def check(i): return (i-1 < 0 or arr[i-1] != arr[i]) and (i-2 < 0 or arr[i-2] != arr[i]) arr = map(lambda x: ord(x)-ord('a'), s) for i in reversed(xrange(len(arr))): arr[i] += 1 while not check(i): arr[i] += 1 if arr[i] < k: break else: return \"\" for j in xrange(i+1, len(arr)): arr[j] = 0 while not check(j): arr[j] += 1 return \"\".join(map(lambda x: chr(ord('a')+x), arr)) ", "class Solution def capitalizeTitle(self, title): title = list(title) j = 0 for i in xrange(len(title)+1): if i < len(title) and title[i] != ' ': title[i] = title[i].lower() continue if i-j > 2: title[j] = title[j].upper() j = i+1 return \"\".join(title) ", "class Solution def findKthSmallest(self, coins, k): def gcd(a, b): while b: a, b = b, a%b return a def lcm(a, b): return a//gcd(a, b)*b def check(target): return sum((-1 if (i+1)&1 else +1)*(target//l) for i in xrange(1, len(coins)+1) for l in lookup[i]) >= k def binary_search(left, right, check): while left <= right: mid = left+(right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left lookup = [[] for _ in xrange(len(coins)+1)] for i in xrange(1, len(coins)+1): for comb in itertools.combinations(coins, i): lookup[i].append(reduce(lcm, comb)) mn = min(coins) l = 1 for i in xrange(1, 25+1): l = lcm(l, i) return binary_search(mn, k*mn, check) ", "class Solution def findKthSmallest(self, coins, k): def popcount(x): return bin(x).count('1') def gcd(a, b): while b: a, b = b, a%b return a def lcm(a, b): return a//gcd(a, b)*b def check(target): return sum((-1 if (i+1)&1 else +1)*(target//l) for i in xrange(1, len(coins)+1) for l in lookup[i]) >= k def binary_search(left, right, check): while left <= right: mid = left+(right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left lookup = [[] for _ in xrange(len(coins)+1)] for mask in xrange(1, 1<<len(coins)): lookup[popcount(mask)].append(reduce(lcm, (coins[i] for i in xrange(len(coins)) if mask&(1<<i)))) mn = min(coins) return binary_search(mn, k*mn, check) ", "class Solution def findDisappearedNumbers(self, nums): for i in xrange(len(nums)): if nums[abs(nums[i]) - 1] > 0: nums[abs(nums[i]) - 1] *= -1 result = [] for i in xrange(len(nums)): if nums[i] > 0: result.append(i+1) else: nums[i] *= -1 return result def findDisappearedNumbers2(self, nums): return list(set(range(1, len(nums) + 1)) - set(nums)) def findDisappearedNumbers3(self, nums): for i in range(len(nums)): index = abs(nums[i]) - 1 nums[index] = - abs(nums[index]) return [i + 1 for i in range(len(nums)) if nums[i] > 0] ", "class Solution def complexNumberMultiply(self, a, b): ra, ia = map(int, a[:-1].split('+')) rb, ib = map(int, b[:-1].split('+')) return '%d+%di' % (ra * rb - ia * ib, ra * ib + ia * rb) ", "class Solution def onesMinusZeros(self, grid): rows = [sum(grid[i][j] for j in xrange(len(grid[0]))) for i in xrange(len(grid))] cols = [sum(grid[i][j] for i in xrange(len(grid))) for j in xrange(len(grid[0]))] return [[rows[i]+cols[j]-(len(grid)-rows[i])-(len(grid[0])-cols[j]) for j in xrange(len(grid[0]))] for i in xrange(len(grid))] ", "class Solution def encode(self, s): def encode_substr(dp, s, i, j): temp = s[i:j+1] pos = (temp + temp).find(temp, 1) if pos >= len(temp): return temp return str(len(temp)/pos) + '[' + dp[i][i + pos - 1] + ']' dp = [[\"\" for _ in xrange(len(s))] for _ in xrange(len(s))] for length in xrange(1, len(s)+1): for i in xrange(len(s)+1-length): j = i+length-1 dp[i][j] = s[i:i+length] for k in xrange(i, j): if len(dp[i][k]) + len(dp[k+1][j]) < len(dp[i][j]): dp[i][j] = dp[i][k] + dp[k+1][j] encoded_string = encode_substr(dp, s, i, j) if len(encoded_string) < len(dp[i][j]): dp[i][j] = encoded_string return dp[0][len(s) - 1] ", "class Solution def findRotateSteps(self, ring, key): lookup = collections.defaultdict(list) for i in xrange(len(ring)): lookup[ring[i]].append(i) dp = [[0] * len(ring) for _ in xrange(2)] prev = [0] for i in xrange(1, len(key)+1): dp[i%2] = [float(\"inf\")] * len(ring) for j in lookup[key[i-1]]: for k in prev: dp[i%2][j] = min(dp[i%2][j], min((k+len(ring)-j) % len(ring), (j+len(ring)-k) % len(ring)) + dp[(i-1) % 2][k]) prev = lookup[key[i-1]] return min(dp[len(key)%2]) + len(key) ", "class Solution def decodeString(self, s): n, curr, nums, strs = 0, [], [], [] for c in s: if c.isdigit(): n = n*10 + ord(c)-ord('0') elif c.isalpha(): curr.append(c) elif c == '[': nums.append(n) strs.append(curr) n, curr = 0, [] elif c == ']': strs[-1].extend(curr*nums.pop()) curr = strs.pop() return \"\".join(curr) ", "class Solution def strStr(self, haystack, needle): if not needle: return 0 return self.KMP(haystack, needle) def KMP(self, text, pattern): prefix = self.getPrefix(pattern) j = -1 for i in xrange(len(text)): while j > -1 and pattern[j + 1] != text[i]: j = prefix[j] if pattern[j + 1] == text[i]: j += 1 if j == len(pattern) - 1: return i - j return -1 def getPrefix(self, pattern): prefix = [-1] * len(pattern) j = -1 for i in xrange(1, len(pattern)): while j > -1 and pattern[j + 1] != pattern[i]: j = prefix[j] if pattern[j + 1] == pattern[i]: j += 1 prefix[i] = j return prefix ", "class Solution def strStr(self, haystack, needle): for i in xrange(len(haystack) - len(needle) + 1): if haystack[i : i + len(needle)] == needle: return i return -1 ", "class Solution def expressiveWords(self, S, words): def RLE(S): return itertools.izip(*[(k, len(list(grp))) for k, grp in itertools.groupby(S)]) R, count = RLE(S) result = 0 for word in words: R2, count2 = RLE(word) if R2 != R: continue result += all(c1 >= max(c2, 3) or c1 == c2 for c1, c2 in itertools.izip(count, count2)) return result ", "class Solution def largestPerimeter(self, A): A.sort() for i in reversed(xrange(len(A) - 2)): if A[i] + A[i+1] > A[i+2]: return A[i] + A[i+1] + A[i+2] return 0 ", "class Solution def minimumTime(self, jobs, workers): def ceil_divide(a, b): return (a+(b-1))//b jobs.sort() workers.sort() return max(ceil_divide(j, w) for j, w in itertools.izip(jobs, workers)) ", "class Solution def findMaxConsecutiveOnes(self, nums): result, local_max = 0, 0 for n in nums: local_max = (local_max + 1 if n else 0) result = max(result, local_max) return result ", "class Solution def findContentChildren(self, g, s): g.sort() s.sort() result, i = 0, 0 for j in xrange(len(s)): if i == len(g): break if s[j] >= g[i]: result += 1 i += 1 return result ", "class Solution def countHighestScoreNodes(self, parents): def iter_dfs(adj): result = [0]*2 stk = [(1, (0, [0]))] while stk: step, args = stk.pop() if step == 1: i, ret = args cnts = [[0] for _ in xrange(len(adj[i]))] stk.append((2, (cnts, ret))) for j, child in enumerate(adj[i]): stk.append((1, (child, cnts[j]))) elif step == 2: cnts, ret = args ret[0] = sum(cnt[0] for cnt in cnts)+1 score = max((len(adj)-ret[0]), 1)*reduce(lambda x, y: x*y[0], cnts, 1) if score > result[0]: result[:] = [score, 1] elif score == result[0]: result[1] += 1 return result[1] adj = [[] for _ in xrange(len(parents))] for i in xrange(1, len(parents)): adj[parents[i]].append(i) return iter_dfs(adj) ", "class Solution def countHighestScoreNodes(self, parents): def dfs(adj, i, result): cnts = [dfs(adj, child, result) for child in adj[i]] total = sum(cnts)+1 score = max((len(adj)-total), 1)*reduce(lambda x, y: x*y, cnts, 1) if score > result[0]: result[:] = [score, 1] elif score == result[0]: result[1] += 1 return total adj = [[] for _ in xrange(len(parents))] for i in xrange(1, len(parents)): adj[parents[i]].append(i) result = [0]*2 dfs(adj, 0, result) return result[1] ", "class Solution def lastStoneWeight(self, stones): max_heap = [-x for x in stones] heapq.heapify(max_heap) for i in xrange(len(stones)-1): x, y = -heapq.heappop(max_heap), -heapq.heappop(max_heap) heapq.heappush(max_heap, -abs(x-y)) return -max_heap[0] ", "class Solution def isPrefixString(self, s, words): i = j = 0 for c in s: if i == len(words) or words[i][j] != c: return False j += 1 if j == len(words[i]): i += 1 j = 0 return j == 0 ", "class Solution def isPrefixString(self, s, words): i = 0 for word in words: for c in word: if i == len(s) or s[i] != c: return False i += 1 if i == len(s): return True return False ", "class Solution def numberOfPairs(self, points): points.sort(key=lambda x: (x[0], -x[1])) result = 0 for i in xrange(len(points)): y = float(\"-inf\") for j in xrange(i+1, len(points)): if points[i][1] < points[j][1]: continue if points[j][1] > y: y = points[j][1] result += 1 return result ", "class Solution def numberOfPairs(self, points): points.sort(key=lambda x: (x[0], -x[1])) return sum(all(not points[i][1] >= points[k][1] >= points[j][1] for k in xrange(i+1, j)) for i in xrange(len(points)) for j in xrange(i+1, len(points)) if points[i][1] >= points[j][1]) ", "class Solution def delNodes(self, root, to_delete): def delNodesHelper(to_delete_set, root, is_root, result): if not root: return None is_deleted = root.val in to_delete_set if is_root and not is_deleted: result.append(root) root.left = delNodesHelper(to_delete_set, root.left, is_deleted, result) root.right = delNodesHelper(to_delete_set, root.right, is_deleted, result) return None if is_deleted else root result = [] to_delete_set = set(to_delete) delNodesHelper(to_delete_set, root, True, result) return result ", "class Solution def intersect(self, nums1, nums2): if len(nums1) > len(nums2): return self.intersect(nums2, nums1) lookup = collections.defaultdict(int) for i in nums1: lookup[i] += 1 res = [] for i in nums2: if lookup[i] > 0: res += i, lookup[i] -= 1 return res def intersect2(self, nums1, nums2): c = collections.Counter(nums1) & collections.Counter(nums2) intersect = [] for i in c: intersect.extend([i] * c[i]) return intersect ", "class Solution def intersect(self, nums1, nums2): if len(nums1) > len(nums2): return self.intersect(nums2, nums1) def binary_search(compare, nums, left, right, target): while left < right: mid = left + (right - left) / 2 if compare(nums[mid], target): right = mid else: left = mid + 1 return left nums1.sort(), nums2.sort() res = [] left = 0 for i in nums1: left = binary_search(lambda x, y: x >= y, nums2, left, len(nums2), i) if left != len(nums2) and nums2[left] == i: res += i, left += 1 return res ", "class Solution def intersect(self, nums1, nums2): nums1.sort(), nums2.sort() res = [] it1, it2 = 0, 0 while it1 < len(nums1) and it2 < len(nums2): if nums1[it1] < nums2[it2]: it1 += 1 elif nums1[it1] > nums2[it2]: it2 += 1 else: res += nums1[it1], it1 += 1 it2 += 1 return res ", "class Solution def intersect(self, nums1, nums2): nums1.sort(), nums2.sort() res = [] it1, it2 = 0, 0 while it1 < len(nums1) and it2 < len(nums2): if nums1[it1] < nums2[it2]: it1 += 1 elif nums1[it1] > nums2[it2]: it2 += 1 else: res += nums1[it1], it1 += 1 it2 += 1 return res ", "class Solution def maxNumberOfApples(self, arr): LIMIT = 5000 arr.sort() result, total = 0, 0 for x in arr: if total+x > LIMIT: break total += x result += 1 return result ", "class Solution def countDistinct(self, nums, k, p): _trie = lambda: collections.defaultdict(_trie) trie = _trie() result = 0 for i in xrange(len(nums)): cnt = 0 curr = trie for j in xrange(i, len(nums)): cnt += (nums[j]%p == 0) if cnt > k: break if nums[j] not in curr: result += 1 curr = curr[nums[j]] return result import collections ", "class Solution def countDistinct(self, nums, k, p): MOD, P = 10**9+7, 113 def check(nums, lookup, l, i): return all(any(nums[i+k] != nums[j+k] for k in xrange(l)) for j in lookup) result = 0 cnt, h = [0]*len(nums), [0]*len(nums) for l in xrange(1, len(nums)+1): lookup = collections.defaultdict(list) for i in xrange(len(nums)-l+1): cnt[i] += (nums[i+l-1]%p == 0) if cnt[i] > k: continue h[i] = (h[i]*P+nums[i+l-1])%MOD if not check(nums, lookup[h[i]], l, i): continue lookup[h[i]].append(i) result += 1 return result ", "class Solution def countDistinct(self, nums, k, p): MOD, P = 10**9+7, 200 result = 0 cnt, h = [0]*len(nums), [0]*len(nums) for l in xrange(1, len(nums)+1): lookup = set() for i in xrange(len(nums)-l+1): cnt[i] += (nums[i+l-1]%p == 0) if cnt[i] > k: continue h[i] = (h[i]*P+nums[i+l-1])%MOD lookup.add(h[i]) result += len(lookup) return result ", "class Solution def countVowelStrings(self, n): def nCr(n, r): if n-r < r: return nCr(n, n-r) c = 1 for k in xrange(1, r+1): c *= n-k+1 c //= k return c return nCr(n+4, 4) ", "class Solution def targetIndices(self, nums, target): less = sum(x < target for x in nums) return range(less, less+sum(x == target for x in nums)) ", "class Solution def lengthLongestPath(self, input): def split_iter(s, tok): start = 0 for i in xrange(len(s)): if s[i] == tok: yield s[start:i] start = i + 1 yield s[start:] max_len = 0 path_len = {0: 0} for line in split_iter(input, '\\n'): name = line.lstrip('\\t') depth = len(line) - len(name) if '.' in name: max_len = max(max_len, path_len[depth] + len(name)) else: path_len[depth + 1] = path_len[depth] + len(name) + 1 return max_len ", "class Solution def maximumTime(self, time): result = list(time) for i, c in enumerate(time): if c != \"?\": continue if i == 0: result[i] = '2' if result[i+1] in \"?0123\" else '1' elif i == 1: result[i] = '3' if result[0] == '2' else '9' elif i == 3: result[i] = '5' elif i == 4: result[i] = '9' return \"\".join(result) ", "class Solution def largestSquareArea(self, bottomLeft, topRight): result = 0 for i in xrange(len(bottomLeft)): for j in xrange(i+1, len(bottomLeft)): max_x = max(bottomLeft[i][0], bottomLeft[j][0]) min_x = min(topRight[i][0], topRight[j][0]) max_y = max(bottomLeft[i][1], bottomLeft[j][1]) min_y = min(topRight[i][1], topRight[j][1]) result = max(result, min(min_x-max_x, min_y-max_y)) return result**2 ", "class Solution def largestSquareArea(self, bottomLeft, topRight): return max(max(min(min(topRight[i][0], topRight[j][0])-max(bottomLeft[i][0], bottomLeft[j][0]), min(topRight[i][1], topRight[j][1])-max(bottomLeft[i][1], bottomLeft[j][1])) for i in xrange(len(bottomLeft)) for j in xrange(i+1, len(bottomLeft))), 0)**2 ", "class Solution def correctBinaryTree(self, root): q = {root:None} while q: new_q = {} for node, parent in q.iteritems(): if node.right in q: if parent.left == node: parent.left = None else: parent.right = None return root if node.left: new_q[node.left] = node if node.right: new_q[node.right] = node q = new_q ", "class Solution def maxJump(self, stones): return stones[1]-stones[0] if len(stones) == 2 else max(stones[i+2]-stones[i] for i in xrange(len(stones)-2)) ", "class Solution def minDeletionSize(self, A): result = 0 unsorted = set(range(len(A)-1)) for j in xrange(len(A[0])): if any(A[i][j] > A[i+1][j] for i in unsorted): result += 1 else: unsorted -= set(i for i in unsorted if A[i][j] < A[i+1][j]) return result ", "class Solution def minDeletionSize(self, A): result = 0 is_sorted = [False]*(len(A)-1) for j in xrange(len(A[0])): tmp = is_sorted[:] for i in xrange(len(A)-1): if A[i][j] > A[i+1][j] and tmp[i] == False: result += 1 break if A[i][j] < A[i+1][j]: tmp[i] = True else: is_sorted = tmp return result ", "class Solution def maxPathSum(self, root): def iter_dfs(node): result = float(\"-inf\") max_sum = [0] stk = [(1, [node, max_sum])] while stk: step, params = stk.pop() if step == 1: node, ret = params if not node: continue ret1, ret2 = [0], [0] stk.append((2, [node, ret1, ret2, ret])) stk.append((1, [node.right, ret2])) stk.append((1, [node.left, ret1])) elif step == 2: node, ret1, ret2, ret = params result = max(result, node.val+max(ret1[0], 0)+max(ret2[0], 0)) ret[0] = node.val+max(ret1[0], ret2[0], 0) return result return iter_dfs(root) ", "class Solution def maxPathSum(self, root): def dfs(node): if not node: return (float(\"-inf\"), 0) max_left, curr_left = dfs(node.left) max_right, curr_right = dfs(node.right) return (max(max_left, max_right, node.val+max(curr_left, 0)+max(curr_right, 0)), node.val+max(curr_left, curr_right, 0)) return dfs(root)[0] ", "class Solution def numberOfSequence(self, n, sick): MOD = 10**9+7 def nCr(n, k): while len(INV) <= n: FACT.append(FACT[-1]*len(INV) % MOD) INV.append(INV[MOD%len(INV)]*(MOD-MOD//len(INV)) % MOD) INV_FACT.append(INV_FACT[-1]*INV[-1] % MOD) return (FACT[n]*INV_FACT[n-k] % MOD) * INV_FACT[k] % MOD result = 1 total = cnt = 0 for i in xrange(len(sick)+1): l = (sick[i] if i < len(sick) else n)-(sick[i-1] if i-1 >= 0 else -1)-1 if i not in (0, len(sick)): cnt += max(l-1, 0) total += l result = (result*nCr(total, l))%MOD result = (result*pow(2, cnt, MOD))%MOD return result ", "class Solution def levelOrder(self, root): if root is None: return [] result, current = [], [root] while current: next_level, vals = [], [] for node in current: vals.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current = next_level result.append(vals) return result ", "class Solution def binaryTreePaths(self, root): result, path = [], [] self.binaryTreePathsRecu(root, path, result) return result def binaryTreePathsRecu(self, node, path, result): if node is None: return if node.left is node.right is None: ans = \"\" for n in path: ans += str(n.val) + \"->\" result.append(ans + str(node.val)) if node.left: path.append(node) self.binaryTreePathsRecu(node.left, path, result) path.pop() if node.right: path.append(node) self.binaryTreePathsRecu(node.right, path, result) path.pop() ", "class Solution def waysToDistribute(self, n, k): MOD = 10**9+7 dp = [1]*k for i in xrange(1, n): for j in reversed(xrange(1, min(i, k))): dp[j] = ((j+1)*dp[j] + dp[j-1]) % MOD return dp[k-1] ", "class Solution def distinctSubseqII(self, S): MOD = 10**9+7 result, dp = 0, [0]*26 for c in S: result, dp[ord(c)-ord('a')] = (result+((result+1)-dp[ord(c)-ord('a')]))%MOD, (result+1)%MOD return result ", "class Solution def findMaximumLength(self, nums): dp = prefix = left = 0 stk = [(0, 0, 0)] for right in xrange(len(nums)): prefix += nums[right] while left+1 < len(stk) and stk[left+1][0] <= prefix: left += 1 last, dp = prefix-stk[left][1], stk[left][2]+1 while stk and stk[-1][0] >= last+prefix: stk.pop() stk.append((last+prefix, prefix, dp)) left = min(left, len(stk)-1) return dp import collections ", "class Solution def findMaximumLength(self, nums): dp = prefix = prev_prefix = prev_dp = 0 dq = collections.deque() for right in xrange(len(nums)): prefix += nums[right] while dq and dq[0][0] <= prefix: _, prev_prefix, prev_dp = dq.popleft() last, dp = prefix-prev_prefix, prev_dp+1 while dq and dq[-1][0] >= last+prefix: dq.pop() dq.append((last+prefix, prefix, dp)) return dp import bisect ", "class Solution def findMaximumLength(self, nums): dp = prefix = left = 0 stk = [(0, 0, 0)] for right in xrange(len(nums)): prefix += nums[right] left = bisect.bisect_left(stk, (prefix+1, 0, 0))-1 last, dp = prefix-stk[left][1], stk[left][2]+1 while stk and stk[-1][0] >= last+prefix: stk.pop() stk.append((last+prefix, prefix, dp)) return dp import bisect ", "class Solution def findMaximumLength(self, nums): prefix = [0]*(len(nums)+1) for i in xrange(len(nums)): prefix[i+1] = prefix[i]+nums[i] dp = [float(\"inf\")]*(len(nums)+1) dp[0] = 0 prev = [-1]*(len(nums)+1) left = -1 for right in xrange(len(nums)): left = max(left, prev[right]) dp[right+1] = dp[left+1]+1 next_right = bisect.bisect_left(prefix, prefix[right+1]+(prefix[right+1]-prefix[left+1]))-1 prev[next_right] = right return dp[-1] ", "class Solution def kConcatenationMaxSum(self, arr, k): def max_sub_k_array(arr, k): result, curr = float(\"-inf\"), float(\"-inf\") for _ in xrange(k): for x in arr: curr = max(curr+x, x) result = max(result, curr) return result MOD = 10**9+7 if k == 1: return max(max_sub_k_array(arr, 1), 0) % MOD return (max(max_sub_k_array(arr, 2), 0) + (k-2)*max(sum(arr), 0)) % MOD ", "class Solution def getDecimalValue(self, head): result = 0 while head: result = result*2 + head.val head = head.next return result ", "class Solution def cherryPickup(self, grid): dp = [[[float(\"-inf\")]*(len(grid[0])+2) for _ in xrange(len(grid[0])+2)] for _ in xrange(2)] dp[0][1][len(grid[0])] = grid[0][0] + grid[0][len(grid[0])-1] for i in xrange(1, len(grid)): for j in xrange(1, len(grid[0])+1): for k in xrange(1, len(grid[0])+1): dp[i%2][j][k] = max(dp[(i-1)%2][j+d1][k+d2] for d1 in xrange(-1, 2) for d2 in xrange(-1, 2)) + ((grid[i][j-1]+grid[i][k-1]) if j != k else grid[i][j-1]) return max(itertools.imap(max, *dp[(len(grid)-1)%2])) import itertools ", "class Solution def cherryPickup(self, grid): dp = [[[float(\"-inf\")]*len(grid[0]) for _ in xrange(len(grid[0]))] for _ in xrange(2)] dp[0][0][len(grid[0])-1] = grid[0][0] + grid[0][len(grid[0])-1] for i in xrange(1, len(grid)): for j in xrange(len(grid[0])): for k in xrange(len(grid[0])): dp[i%2][j][k] = max(dp[(i-1)%2][j+d1][k+d2] for d1 in xrange(-1, 2) for d2 in xrange(-1, 2) if 0 <= j+d1 < len(grid[0]) and 0 <= k+d2 < len(grid[0])) + ((grid[i][j]+grid[i][k]) if j != k else grid[i][j]) return max(itertools.imap(max, *dp[(len(grid)-1)%2])) ", "class Solution def isIdealPermutation(self, A): return all(abs(v-i) <= 1 for i,v in enumerate(A)) ", "class Solution def minSteps(self, n): result = 0 p = 2 while p**2 <= n: while n % p == 0: result += p n //= p p += 1 if n > 1: result += n return result ", "class Solution def checkString(self, s): return \"ba\" not in s ", "class Solution def queryResults(self, limit, queries): result = [0]*len(queries) lookup = {} cnt = collections.Counter() for i, (x, y) in enumerate(queries): if x in lookup: cnt[lookup[x]] -= 1 if not cnt[lookup[x]]: del cnt[lookup[x]] lookup[x] = y cnt[lookup[x]] += 1 result[i] = len(cnt) return result ", "class Solution def minGroups(self, intervals): events = collections.Counter() for l, r in intervals: events[l] += 1 events[r+1] -= 1 result = curr = 0 for t in sorted(events.iterkeys()): curr += events[t] result = max(result, curr) return result ", "class Solution def maximumDetonation(self, bombs): adj = [[] for _ in xrange(len(bombs))] for i, (xi, yi, ri) in enumerate(bombs): for j, (xj, yj, _) in enumerate(bombs): if j == i: continue if (xi-xj)**2+(yi-yj)**2 <= ri**2: adj[i].append(j) result = 0 for i in xrange(len(bombs)): q = [i] lookup = {i} while q: new_q = [] for u in q: for v in adj[u]: if v in lookup: continue lookup.add(v) new_q.append(v) q = new_q result = max(result, len(lookup)) if result == len(bombs): break return result ", "class Solution def maximumDetonation(self, bombs): adj = [[] for _ in xrange(len(bombs))] for i, (xi, yi, ri) in enumerate(bombs): for j, (xj, yj, _) in enumerate(bombs): if j == i: continue if (xi-xj)**2+(yi-yj)**2 <= ri**2: adj[i].append(j) result = 0 for i in xrange(len(bombs)): stk = [i] lookup = {i} while stk: u = stk.pop() for v in adj[u]: if v in lookup: continue lookup.add(v) stk.append(v) result = max(result, len(lookup)) if result == len(bombs): break return result ", "class Solution def numFriendRequests(self, ages): def request(a, b): return 0.5*a+7 < b <= a c = collections.Counter(ages) return sum(int(request(a, b)) * c[a]*(c[b]-int(a == b)) for a in c for b in c) ", "class Solution def smallestNumber(self, pattern): result = [] for i in xrange(len(pattern)+1): if not (i == len(pattern) or pattern[i] == 'I'): continue for x in reversed(range(len(result)+1, (i+1)+1)): result.append(x) return \"\".join(map(str, result)) ", "class Solution def integerBreak(self, n): if n < 4: return n - 1 res = 0 if n % 3 == 0: res = 3 ** (n // 3) elif n % 3 == 2: res = 3 ** (n // 3) * 2 else: res = 3 ** (n // 3 - 1) * 4 return res ", "class Solution def integerBreak(self, n): if n < 4: return n - 1 res = [0, 1, 2, 3] for i in xrange(4, n + 1): res[i % 4] = max(res[(i - 2) % 4] * 2, res[(i - 3) % 4] * 3) return res[n % 4] ", "class Solution def flatten(self, root): self.flattenRecu(root, None) def flattenRecu(self, root, list_head): if root: list_head = self.flattenRecu(root.right, list_head) list_head = self.flattenRecu(root.left, list_head) root.right = list_head root.left = None return root else: return list_head ", "class Solution list_head = None def flatten(self, root): if root: self.flatten(root.right) self.flatten(root.left) root.right = self.list_head root.left = None self.list_head = root ", "class Solution def isItPossible(self, word1, word2): cnt1 = collections.Counter(word1) cnt2 = collections.Counter(word2) for i in cnt1.iterkeys(): for j in cnt2.iterkeys(): if i == j: if len(cnt1) == len(cnt2): return True else: new_c1, new_c2 = len(cnt1), len(cnt2) if cnt1[i] == 1: new_c1 -= 1 if j not in cnt1: new_c1 += 1 if cnt2[j] == 1: new_c2 -= 1 if i not in cnt2: new_c2 += 1 if new_c1 == new_c2: return True return False ", "class Solution def makePrefSumNonNegative(self, nums): result = prefix = 0 min_heap = [] for x in nums: heapq.heappush(min_heap, x) prefix += x if prefix < 0: prefix -= heapq.heappop(min_heap) result += 1 return result ", "class Solution def closestRoom(self, rooms, queries): def find_closest(ids, r): result, min_dist = -1, float(\"inf\") i = ids.bisect_right(r) if i-1 >= 0 and abs(ids[i-1]-r) < min_dist: min_dist = abs(ids[i-1]-r) result = ids[i-1] if i < len(ids) and abs(ids[i]-r) < min_dist: min_dist = abs(ids[i]-r) result = ids[i] return result rooms.sort(key=lambda x: x[1], reverse=True) for i, q in enumerate(queries): q.append(i) queries.sort(key=lambda x: x[1], reverse=True) ids = SortedList() i = 0 result = [-1]*len(queries) for r, s, idx in queries: while i < len(rooms) and rooms[i][1] >= s: ids.add(rooms[i][0]) i += 1 result[idx] = find_closest(ids, r) return result from sortedcontainers import SortedList ", "class Solution def closestRoom(self, rooms, queries): def find_closest(ids, r): result, min_dist = -1, float(\"inf\") i = ids.bisect_right(r) if i-1 >= 0 and abs(ids[i-1]-r) < min_dist: min_dist = abs(ids[i-1]-r) result = ids[i-1] if i < len(ids) and abs(ids[i]-r) < min_dist: min_dist = abs(ids[i]-r) result = ids[i] return result rooms.sort(key=lambda x: x[1]) for i, q in enumerate(queries): q.append(i) queries.sort(key=lambda x: x[1]) ids = SortedList(i for i, _ in rooms) i = 0 result = [-1]*len(queries) for r, s, idx in queries: while i < len(rooms) and rooms[i][1] < s: ids.remove(rooms[i][0]) i += 1 result[idx] = find_closest(ids, r) return result ", "class Solution def countPairs(self, nums, low, high): def count(nums, x): result = 0 dp = collections.Counter(nums) while x: if x&1: result += sum(dp[(x^1)^k]*dp[k] for k in dp.iterkeys())//2 dp = collections.Counter({k>>1: dp[k]+dp[k^1] for k in dp.iterkeys()}) x >>= 1 return result return count(nums, high+1)-count(nums, low) class Trie(object): def __init__(self): self.__root = {} def insert(self, num): node = self.__root for i in reversed(xrange(32)): curr = (num>>i) & 1 if curr not in node: node[curr] = {\"_count\":0} node = node[curr] node[\"_count\"] += 1 def query(self, num, limit): node, result = self.__root, 0 for i in reversed(xrange(32)): curr = (num>>i) & 1 bit = (limit>>i) & 1 if bit: if curr in node: result += node[0^curr][\"_count\"] if bit^curr not in node: break node = node[bit^curr] return result ", "class Solution def countPairs(self, nums, low, high): result = 0 trie = Trie() for x in nums: result += trie.query(x, high+1)-trie.query(x, low) trie.insert(x) return result ", "class Solution def shortestPathWithHops(self, n, edges, s, d, k): def modified_dijkstra(): best = [[float(\"inf\")]*(k+1) for _ in xrange(len(adj))] best[s][0] = 0 min_heap = [(best[s][0], s, 0)] while min_heap: curr, u, cnt = heapq.heappop(min_heap) if curr > best[u][cnt]: continue if u == d: return curr for v, w in adj[u]: if curr+w < best[v][cnt]: best[v][cnt] = curr+w heapq.heappush(min_heap, (best[v][cnt], v, cnt)) if cnt+1 <= k and curr < best[v][cnt+1]: best[v][cnt+1] = curr heapq.heappush(min_heap, (best[v][cnt+1], v, cnt+1)) return -1 adj = [[] for _ in xrange(n)] for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) return modified_dijkstra() ", "class Solution def numberOfSpecialChars(self, word): lookup1 = [False]*26 lookup2 = [False]*26 for x in word: if x.islower(): lookup1[ord(x)-ord('a')] = True else: lookup2[ord(x)-ord('A')] = True return sum(x == y == True for x, y in itertools.izip(lookup1, lookup2)) ", "class Solution def threeSum(self, nums): result = [] nums.sort() for i in reversed(xrange(2, len(nums))): if i+1 < len(nums) and nums[i] == nums[i+1]: continue target = -nums[i] left, right = 0, i-1 while left < right: if nums[left]+nums[right] < target: left += 1 elif nums[left]+nums[right] > target: right -= 1 else: result.append([nums[left], nums[right], nums[i]]) left += 1 right -= 1 while left < right and nums[left] == nums[left-1]: left += 1 while left < right and nums[right] == nums[right+1]: right -= 1 return result ", "class Solution def threeSum(self, nums): nums, result, i = sorted(nums), [], 0 while i < len(nums) - 2: if i == 0 or nums[i] != nums[i - 1]: j, k = i + 1, len(nums) - 1 while j < k: if nums[i] + nums[j] + nums[k] < 0: j += 1 elif nums[i] + nums[j] + nums[k] > 0: k -= 1 else: result.append([nums[i], nums[j], nums[k]]) j, k = j + 1, k - 1 while j < k and nums[j] == nums[j - 1]: j += 1 while j < k and nums[k] == nums[k + 1]: k -= 1 i += 1 return result ", "class Solution def constructRectangle(self, area): w = int(math.sqrt(area)) while area % w: w -= 1 return [area // w, w] ", "class Solution def countSquares(self, matrix): for i in xrange(1, len(matrix)): for j in xrange(1, len(matrix[0])): if not matrix[i][j]: continue l = min(matrix[i-1][j], matrix[i][j-1]) matrix[i][j] = l+1 if matrix[i-l][j-l] else l return sum(x for row in matrix for x in row) ", "class Solution def canVisitAllRooms(self, rooms): lookup = set([0]) stack = [0] while stack: node = stack.pop() for nei in rooms[node]: if nei not in lookup: lookup.add(nei) if len(lookup) == len(rooms): return True stack.append(nei) return len(lookup) == len(rooms) ", "class Solution def longestZigZag(self, root): def dfs(node, result): if not node: return [-1, -1] left, right = dfs(node.left, result), dfs(node.right, result) result[0] = max(result[0], left[1]+1, right[0]+1) return [left[1]+1, right[0]+1] result = [0] dfs(root, result) return result[0] ", "class Solution def scheduleCourse(self, courses): courses.sort(key=lambda t_end: t_end[1]) max_heap = [] now = 0 for t, end in courses: now += t heapq.heappush(max_heap, -t) if now > end: now += heapq.heappop(max_heap) return len(max_heap) ", "class Solution def leftMostColumnWithOne(self, binaryMatrix): m, n = binaryMatrix.dimensions() r, c = 0, n-1 while r < m and c >= 0: if not binaryMatrix.get(r, c): r += 1 else: c -= 1 return c+1 if c+1 != n else -1 ", "class Solution def countCompleteSubstrings(self, word, k): result = valid = 0 cnt = [0]*26 for c in xrange(1, len(set(word))+1): left = 0 for right in xrange(len(word)): cnt[ord(word[right])-ord('a')] += 1 curr = cnt[ord(word[right])-ord('a')] valid += 1 if curr == k else -1 if curr == k+1 else 0 if right-left+1 == c*k+1: curr = cnt[ord(word[left])-ord('a')] valid -= 1 if curr == k else -1 if curr == k+1 else 0 cnt[ord(word[left])-ord('a')] -= 1 left += 1 if valid == c: result += 1 if right+1 == len(word) or abs(ord(word[right+1])-ord(word[right])) > 2: while left < right+1: curr = cnt[ord(word[left])-ord('a')] valid -= 1 if curr == k else -1 if curr == k+1 else 0 cnt[ord(word[left])-ord('a')] -= 1 left += 1 return result ", "class Solution def maxChunksToSorted(self, arr): result, increasing_stk = 0, [] for num in arr: max_num = num if not increasing_stk else max(increasing_stk[-1], num) while increasing_stk and increasing_stk[-1] > num: increasing_stk.pop() increasing_stk.append(max_num) return len(increasing_stk) ", "class Solution def maxChunksToSorted(self, arr): def compare(i1, i2): return arr[i1]-arr[i2] if arr[i1] != arr[i2] else i1-i2 idxs = [i for i in xrange(len(arr))] result, max_i = 0, 0 for i, v in enumerate(sorted(idxs, cmp=compare)): max_i = max(max_i, v) if max_i == i: result += 1 return result ", "class Solution def distinctIntegers(self, n): return n-1 if n >= 2 else 1 ", "class Solution def makeFancyString(self, s): s = list(s) cnt = j = 0 for i, c in enumerate(s): cnt = cnt+1 if i >= 1 and c == s[i-1] else 1 if cnt < 3: s[j] = c j += 1 s[:] = s[:j] return \"\".join(s) ", "class Solution def integerReplacement(self, n): result = 0 while n != 1: b = n & 3 if n == 3: n -= 1 elif b == 3: n += 1 elif b == 1: n -= 1 else: n /= 2 result += 1 return result ", "class Solution def integerReplacement(self, n): if n < 4: return [0, 0, 1, 2][n] if n % 4 in (0, 2): return self.integerReplacement(n / 2) + 1 elif n % 4 == 1: return self.integerReplacement((n - 1) / 4) + 3 else: return self.integerReplacement((n + 1) / 4) + 3 ", "class Solution def getWordsInLongestSubsequence(self, n, words, groups): return [words[i] for i in xrange(n) if i == 0 or groups[i-1] != groups[i]] ", "class Solution def maxDotProduct(self, nums1, nums2): if len(nums1) < len(nums2): return self.maxDotProduct(nums2, nums1) dp = [[0]*len(nums2) for i in xrange(2)] for i in xrange(len(nums1)): for j in xrange(len(nums2)): dp[i%2][j] = nums1[i]*nums2[j] if i and j: dp[i%2][j] += max(dp[(i-1)%2][j-1], 0) if i: dp[i%2][j] = max(dp[i%2][j], dp[(i-1)%2][j]) if j: dp[i%2][j] = max(dp[i%2][j], dp[i%2][j-1]) return dp[(len(nums1)-1)%2][-1] ", "class Solution def findMaxK(self, nums): lookup = set(nums) return max([x for x in lookup if x > 0 and -x in lookup] or [-1]) ", "class Solution def intersection(self, nums1, nums2): if len(nums1) > len(nums2): return self.intersection(nums2, nums1) lookup = set() for i in nums1: lookup.add(i) res = [] for i in nums2: if i in lookup: res += i, lookup.discard(i) return res def intersection2(self, nums1, nums2): return list(set(nums1) & set(nums2)) ", "class Solution def intersection(self, nums1, nums2): if len(nums1) > len(nums2): return self.intersection(nums2, nums1) def binary_search(compare, nums, left, right, target): while left < right: mid = left + (right - left) / 2 if compare(nums[mid], target): right = mid else: left = mid + 1 return left nums1.sort(), nums2.sort() res = [] left = 0 for i in nums1: left = binary_search(lambda x, y: x >= y, nums2, left, len(nums2), i) if left != len(nums2) and nums2[left] == i: res += i, left = binary_search(lambda x, y: x > y, nums2, left, len(nums2), i) return res ", "class Solution def intersection(self, nums1, nums2): nums1.sort(), nums2.sort() res = [] it1, it2 = 0, 0 while it1 < len(nums1) and it2 < len(nums2): if nums1[it1] < nums2[it2]: it1 += 1 elif nums1[it1] > nums2[it2]: it2 += 1 else: if not res or res[-1] != nums1[it1]: res += nums1[it1], it1 += 1 it2 += 1 return res ", "class Solution def kLengthApart(self, nums, k): prev = -k-1 for i in xrange(len(nums)): if not nums[i]: continue if i-prev <= k: return False prev = i return True ", "class Solution def countKSubsequencesWithMaxBeauty(self, s, k): MOD = 10**9+7 fact, inv, inv_fact = [[1]*2 for _ in xrange(3)] def nCr(n, k): if not (0 <= k <= n): return 0 while len(inv) <= n: fact.append(fact[-1]*len(inv) % MOD) inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) inv_fact.append(inv_fact[-1]*inv[-1] % MOD) return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 cnt = collections.Counter(s) if len(cnt) < k: return 0 freqs = cnt.values() nth_element(freqs, k-1, lambda a, b: a > b) n = freqs.count(freqs[k-1]) r = sum(freqs[i] == freqs[k-1] for i in xrange(k)) return reduce(lambda a, b: a*b%MOD, (freqs[i] for i in xrange(k)), 1)*nCr(n, r)%MOD ", "class Solution def canWin(self, s): g, g_final = [0], 0 for p in itertools.imap(len, re.split('-+', s)): while len(g) <= p: g += min(set(xrange(p)) - {x^y for x, y in itertools.izip(g[:len(g)/2], g[-2:-len(g)/2-2:-1])}), g_final ^= g[p] return g_final > 0 ", "class Solution def canWin(self, s): lookup = {} def canWinHelper(consecutives): consecutives = tuple(sorted(c for c in consecutives if c >= 2)) if consecutives not in lookup: lookup[consecutives] = any(not canWinHelper(consecutives[:i] + (j, c-2-j) + consecutives[i+1:]) for i, c in enumerate(consecutives) for j in xrange(c - 1)) return lookup[consecutives] return canWinHelper(map(len, re.findall(r'\\+\\++', s))) ", "class Solution def canWin(self, s): i, n = 0, len(s) - 1 is_win = False while not is_win and i < n: if s[i] == '+': while not is_win and i < n and s[i+1] == '+': is_win = not self.canWin(s[:i] + '--' + s[i+2:]) i += 1 i += 1 return is_win ", "class Solution def smallestDistancePair(self, nums, k): def possible(guess, nums, k): count, left = 0, 0 for right, num in enumerate(nums): while num-nums[left] > guess: left += 1 count += right-left return count >= k nums.sort() left, right = 0, nums[-1]-nums[0]+1 while left < right: mid = left + (right-left)/2 if possible(mid, nums, k): right = mid else: left = mid+1 return left ", "class Solution def createBinaryTree(self, descriptions): nodes = {} children = set() for p, c, l in descriptions: parent = nodes.setdefault(p, TreeNode(p)) child = nodes.setdefault(c, TreeNode(c)) if l: parent.left = child else: parent.right = child children.add(c) return nodes[next(p for p in nodes.iterkeys() if p not in children)] ", "class Solution def resultArray(self, nums): sl1, sl2 = SortedList([nums[0]]), SortedList([nums[1]]) a, b = [nums[0]], [nums[1]] for i in xrange(2, len(nums)): cnt1 = len(sl1)-sl1.bisect_right(nums[i]) cnt2 = len(sl2)-sl2.bisect_right(nums[i]) if cnt1 > cnt2 or (cnt1 == cnt2 and len(a) <= len(b)): sl1.add(nums[i]) a.append(nums[i]) else: sl2.add(nums[i]) b.append(nums[i]) return a+b ", "class Solution def subarrayBitwiseORs(self, A): result, curr = set(), {0} for i in A: curr = {i} | {i | j for j in curr} result |= curr return len(result) ", "class Solution def largestUniqueNumber(self, A): A.append(-1) return max(k for k,v in collections.Counter(A).items() if v == 1) ", "class Solution def convertToTitle(self, n): result = [] while n: result += chr((n-1)%26 + ord('A')) n = (n-1)//26 result.reverse() return \"\".join(result) ", "class Solution def maxNonDecreasingLength(self, nums1, nums2): result = 1 dp = [1]*2 for i in xrange(len(nums1)-1): dp = [max((dp[0]+1 if nums1[i] <= nums1[i+1] else 1), (dp[1]+1 if nums2[i] <= nums1[i+1] else 1)), max((dp[0]+1 if nums1[i] <= nums2[i+1] else 1), (dp[1]+1 if nums2[i] <= nums2[i+1] else 1))] result = max(result, max(dp)) return result ", "class Solution def maxOutput(self, n, edges, price): def iter_dfs(): result = 0 stk = [(1, (0, -1, [price[0], 0]))] while stk: step, args = stk.pop() if step == 1: u, p, ret = args stk.append((2, (u, p, ret, 0))) elif step == 2: u, p, ret, i = args if i == len(adj[u]): continue stk.append((2, (u, p, ret, i+1))) v = adj[u][i] if v == p: continue new_ret = [price[v], 0] stk.append((3, (u, new_ret, ret))) stk.append((1, (v, u, new_ret))) elif step == 3: u, new_ret, ret = args result = max(result, ret[0]+new_ret[1], ret[1]+new_ret[0]) ret[0] = max(ret[0], new_ret[0]+price[u]) ret[1] = max(ret[1], new_ret[1]+price[u]) return result adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) return iter_dfs() ", "class Solution def maxOutput(self, n, edges, price): def dfs(u, p): dp = [price[u], 0] for v in adj[u]: if v == p: continue new_dp = dfs(v, u) result[0] = max(result[0], dp[0]+new_dp[1], dp[1]+new_dp[0]) dp[0] = max(dp[0], new_dp[0]+price[u]) dp[1] = max(dp[1], new_dp[1]+price[u]) return dp result = [0] adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) dfs(0, -1) return result[0] ", "class Solution def maxOutput(self, n, edges, price): def iter_dfs(): dp = [0]*n stk = [(1, 0, -1)] while stk: step, u, p = stk.pop() if step == 1: stk.append((2, u, p)) for v in adj[u]: if v == p: continue stk.append((1, v, u)) elif step == 2: dp[u] = price[u] for v in adj[u]: if v == p: continue dp[u] = max(dp[u], dp[v]+price[u]) return dp def iter_dfs2(): result = 0 stk = [(0, -1, 0)] while stk: u, p, curr = stk.pop() result = max(result, curr, dp[u]-price[u]) top2 = [[curr, p], [0, -1]] for v in adj[u]: if v == p: continue curr = [dp[v], v] for i in xrange(len(top2)): if curr > top2[i]: top2[i], curr = curr, top2[i] for v in adj[u]: if v == p: continue stk.append((v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u])) return result adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) dp = iter_dfs() return iter_dfs2() ", "class Solution def maxOutput(self, n, edges, price): def dfs(u, p): dp[u] = price[u] for v in adj[u]: if v == p: continue dp[u] = max(dp[u], dfs(v, u)+price[u]) return dp[u] def dfs2(u, p, curr): result[0] = max(result[0], curr, dp[u]-price[u]) top2 = [[curr, p], [0, -1]] for v in adj[u]: if v == p: continue curr = [dp[v], v] for i in xrange(len(top2)): if curr > top2[i]: top2[i], curr = curr, top2[i] for v in adj[u]: if v == p: continue dfs2(v, u, (top2[0][0] if top2[0][1] != v else top2[1][0])+price[u]) result = [0] dp = [0]*n adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) adj[v].append(u) dfs(0, -1) dfs2(0, -1, 0) return result[0] ", "class Solution def largestLocal(self, grid): def find_max(i, j): return max(grid[ni][nj] for ni in xrange(i, i+3) for nj in xrange(j, j+3)) return [[find_max(i, j) for j in xrange(len(grid[0])-2)] for i in xrange(len(grid)-2)] ", "class Solution def minCost(self, nums, x): def accumulate(a): for i in xrange(len(a)-1): a[i+1] += a[i] return a i = min(xrange(len(nums)), key=lambda x: nums[x]) nums = nums[i:]+nums[:i] left, right = [-1]*len(nums), [len(nums)]*len(nums) stk = [] for i in xrange(len(nums)): while stk and nums[stk[-1]] > nums[i]: right[stk.pop()] = i if stk: left[i] = stk[-1] stk.append(i) diff2 = [0]*(len(nums)+1) diff2[0] = (+1)*sum(nums) diff2[1] = x diff2[-1] += (-1)*nums[0] for i in xrange(1, len(nums)): l, r = i-left[i], right[i]-i diff2[min(l, r)] += (-1)*nums[i] diff2[max(l, r)] += (-1)*nums[i] diff2[l+r] += (+1)*nums[i] return min(accumulate(accumulate(diff2))) import collections ", "class Solution def minCost(self, nums, x): def cost(k): w = k+1 result = x*k dq = collections.deque() for i in xrange(len(nums)+w-1): if dq and i-dq[0] == w: dq.popleft() while dq and nums[dq[-1]%len(nums)] >= nums[i%len(nums)]: dq.pop() dq.append(i) if i >= w-1: result += nums[dq[0]%len(nums)] return result def check(x): return cost(x) <= cost(x+1) left, right = 0, len(nums) while left <= right: mid = left + (right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return cost(left) ", "class Solution def minCost(self, nums, x): result = [x*k for k in xrange(len(nums)+1)] for i in xrange(len(nums)): curr = nums[i] for k in xrange(len(result)): curr = min(curr, nums[(i+k)%len(nums)]) result[k] += curr return min(result) ", "class Solution def lengthOfLIS(self, nums, k): sorted_nums = sorted({x-1 for x in nums}) num_to_idx = {x:i for i, x in enumerate(sorted_nums)} st = SegmentTree(len(num_to_idx)) for x in nums: x -= 1 st.update(num_to_idx[x], st.query(bisect.bisect_left(sorted_nums, x-k), num_to_idx[x]-1)+1) return st.tree[1] ", "class Solution def findPeakElement(self, nums): left, right = 0, len(nums) - 1 while left < right: mid = left + (right - left) / 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left ", "class Solution def largestSubmatrix(self, matrix): for c in xrange(len(matrix[0])): h = 0 for r in xrange(len(matrix)): h = h+1 if matrix[r][c] == 1 else 0 matrix[r][c] = h result = 0 for row in matrix: row.sort() for c in xrange(len(row)): result = max(result, (len(row)-c) * row[c]) return result ", "class Solution def diameterOfBinaryTree(self, root): def iter_dfs(node): result = 0 stk = [(1, [node, [0]])] while stk: step, params = stk.pop() if step == 1: node, ret = params if not node: continue ret1, ret2 = [0], [0] stk.append((2, [node, ret1, ret2, ret])) stk.append((1, [node.right, ret2])) stk.append((1, [node.left, ret1])) elif step == 2: node, ret1, ret2, ret = params result = max(result, ret1[0]+ret2[0]) ret[0] = 1+max(ret1[0], ret2[0]) return result return iter_dfs(root) ", "class Solution def diameterOfBinaryTree(self, root): def dfs(root): if not root: return 0, 0 left_d, left_h = dfs(root.left) right_d, right_h = dfs(root.right) return max(left_d, right_d, left_h+right_h), 1+max(left_h, right_h) return dfs(root)[0] ", "class Solution def numberOfGoodPartitions(self, nums): MOD = 10**9+7 lookup = {x:i for i, x in enumerate(nums)} result = 1 right = cnt = 0 for left, x in enumerate(nums): if left == right+1: cnt += 1 right = max(right, lookup[x]) return pow(2, cnt, MOD) ", "class Solution def maxProfit(self, prices, fee): cash, hold = 0, -prices[0] for i in xrange(1, len(prices)): cash = max(cash, hold+prices[i]-fee) hold = max(hold, cash-prices[i]) return cash ", "class Solution def countWays(self, ranges): MOD = 10**9+7 ranges.sort() cnt = 0 curr = float(\"-inf\") for l, r in ranges: if l > curr: cnt += 1 curr = max(curr, r) return pow(2, cnt, MOD) ", "class Solution def numTeams(self, rating): result = 0 for i in xrange(1, len(rating)-1): less, greater = [0]*2, [0]*2 for j in xrange(len(rating)): if rating[i] > rating[j]: less[i < j] += 1 if rating[i] < rating[j]: greater[i < j] += 1 result += less[0]*greater[1] + greater[0]*less[1] return result ", "class Solution def firstMissingPositive(self, A): i = 0 while i < len(A): if A[i] > 0 and A[i] - 1 < len(A) and A[i] != A[A[i]-1]: A[A[i]-1], A[i] = A[i], A[A[i]-1] else: i += 1 for i, integer in enumerate(A): if integer != i + 1: return i + 1 return len(A) + 1 ", "class Solution def numberOfChild(self, n, k): q, r = divmod(k, n-1) return r if q&1 == 0 else (n-1)-r ", "class Solution def numberOfChild(self, n, k): r = k%(2*(n-1)) return r if r <= n-1 else (n-1)-(r-(n-1)) ", "class Solution def largestMagicSquare(self, grid): def get_sum(prefix, a, b): return prefix[b+1]-prefix[a] def check(grid, prefix_row, prefix_col, l, i, j): diag, anti_diag = 0, 0 for d in xrange(l): diag += grid[i+d][j+d] anti_diag += grid[i+d][j+l-1-d] if diag != anti_diag: return False for ni in xrange(i, i+l): if diag != get_sum(prefix_row[ni], j, j+l-1): return False for nj in xrange(j, j+l): if diag != get_sum(prefix_col[nj], i, i+l-1): return False return True prefix_row = [[0]*(len(grid[0])+1) for _ in xrange(len(grid))] prefix_col = [[0]*(len(grid)+1) for _ in xrange(len(grid[0]))] for i in xrange(len(grid)): for j in xrange(len(grid[0])): prefix_row[i][j+1] = prefix_row[i][j] + grid[i][j] prefix_col[j][i+1] = prefix_col[j][i] + grid[i][j] for l in reversed(xrange(1, min(len(grid), len(grid[0]))+1)): for i in xrange(len(grid)-(l-1)): for j in xrange(len(grid[0])-(l-1)): if check(grid, prefix_row, prefix_col, l, i, j): return l return 1 ", "class Solution def minimumSum(self, n, k): def arithmetic_progression_sum(a, d, n): return (a+(a+(n-1)*d))*n//2 a = min(k//2, n) b = n-a return arithmetic_progression_sum(1, 1, a)+arithmetic_progression_sum(k, 1, b) ", "class Solution def countSymmetricIntegers(self, low, high): def check(x): if LOOKUP[x-1] == -1: digits = map(int, str(x)) if len(digits)%2: LOOKUP[x-1] = 0 else: LOOKUP[x-1] = int(sum(digits[i] for i in xrange(len(digits)//2)) == sum(digits[i] for i in xrange(len(digits)//2, len(digits)))) return LOOKUP[x-1] return sum(check(x) for x in xrange(low, high+1)) ", "class Solution def totalMoney(self, n): def arithmetic_sequence_sum(a, d, n): return (2*a + (n-1)*d) * n //2 cost, day = 1, 7 first_week_cost = arithmetic_sequence_sum(cost, cost, day) week, remain_day = divmod(n, day) return arithmetic_sequence_sum(first_week_cost, cost*day, week) + arithmetic_sequence_sum(cost*(week+1), cost, remain_day) ", "class Solution def longestCommonSubpath(self, n, paths): def RabinKarp(arr, x): hashes = tuple([reduce(lambda h,x: (h*p+x)%MOD, (arr[i] for i in xrange(x)), 0) for p in P]) powers = [pow(p, x, MOD) for p in P] lookup = {hashes} for i in xrange(x, len(arr)): hashes = tuple([(hashes[j]*P[j] - arr[i-x]*powers[j] + arr[i])%MOD for j in xrange(len(P))]) lookup.add(hashes) return lookup def check(paths, x): intersect = RabinKarp(paths[0], x) for i in xrange(1, len(paths)): intersect = set.intersection(intersect, RabinKarp(paths[i], x)) if not intersect: return False return True MOD, P = 10**9+7, (113, 109) left, right = 1, min(len(p) for p in paths) while left <= right: mid = left + (right-left)//2 if not check(paths, mid): right = mid-1 else: left = mid+1 return right ", "class Solution def longestCommonSubpath(self, n, paths): def RabinKarp(arr, x): h = reduce(lambda h,x: (h*P+x)%MOD, (arr[i] for i in xrange(x)), 0) power = pow(P, x, MOD) lookup = {h} for i in xrange(x, len(arr)): h = (h*P - arr[i-x]*power + arr[i])%MOD lookup.add(h) return lookup def check(paths, x): intersect = RabinKarp(paths[0], x) for i in xrange(1, len(paths)): intersect = set.intersection(intersect, RabinKarp(paths[i], x)) if not intersect: return False return True MOD, P = 10**11+19, max(x for p in paths for x in p)+1 left, right = 1, min(len(p) for p in paths) while left <= right: mid = left + (right-left)//2 if not check(paths, mid): right = mid-1 else: left = mid+1 return right ", "class Solution def hasTrailingZeros(self, nums): return sum(x%2 == 0 for x in nums) >= 2 ", "class Solution def minSwapsCouples(self, row): N = len(row)//2 couples = [[] for _ in xrange(N)] for seat, num in enumerate(row): couples[num//2].append(seat//2) adj = [[] for _ in xrange(N)] for couch1, couch2 in couples: adj[couch1].append(couch2) adj[couch2].append(couch1) result = 0 for couch in xrange(N): if not adj[couch]: continue couch1, couch2 = couch, adj[couch].pop() while couch2 != couch: result += 1 adj[couch2].remove(couch1) couch1, couch2 = couch2, adj[couch2].pop() return result ", "class Solution def countNumbersWithUniqueDigits(self, n): if n == 0: return 1 result = cnt = 1 for i in xrange(n-1): cnt *= 9-i result += cnt return 1+9*result ", "class Solution def countNumbersWithUniqueDigits(self, n): fact = [1]*2 def nPr(n, k): while len(fact) <= n: fact.append(fact[-1]*len(fact)) return fact[n]//fact[n-k] return 1+9*sum(nPr(9, i) for i in xrange(n)) ", "class Solution def findTheString(self, lcp): result = [-1]*len(lcp) curr = 0 for i in xrange(len(lcp)): if result[i] != -1: continue if curr == 26: return \"\" for j in xrange(i, len(lcp[0])): if lcp[i][j]: result[j] = curr curr += 1 for i in reversed(xrange(len(lcp))): for j in reversed(xrange(len(lcp[0]))): if lcp[i][j] != ((lcp[i+1][j+1]+1 if i+1 < len(lcp) and j+1 < len(lcp[0]) else 1) if result[i] == result[j] else 0): return '' return \"\".join(map(lambda x: chr(ord('a')+x), result)) ", "class Solution def kthGrammar(self, N, K): def bitCount(n): result = 0 while n: n &= n - 1 result += 1 return result return bitCount(K-1) % 2 ", "class Solution def isSubPath(self, head, root): def getPrefix(head): pattern, prefix = [head.val], [-1] j = -1 node = head.next while node: while j+1 and pattern[j+1] != node.val: j = prefix[j] if pattern[j+1] == node.val: j += 1 pattern.append(node.val) prefix.append(j) node = node.next return pattern, prefix def dfs(pattern, prefix, root, j): if not root: return False while j+1 and pattern[j+1] != root.val: j = prefix[j] if pattern[j+1] == root.val: j += 1 if j+1 == len(pattern): return True return dfs(pattern, prefix, root.left, j) or dfs(pattern, prefix, root.right, j) if not head: return True pattern, prefix = getPrefix(head) return dfs(pattern, prefix, root, -1) ", "class Solution def isSubPath(self, head, root): def dfs(head, root): if not head: return True if not root: return False return root.val == head.val and (dfs(head.next, root.left) or dfs(head.next, root.right)) if not head: return True if not root: return False return dfs(head, root) or self.isSubPath(head, root.left) or self.isSubPath(head, root.right) ", "class Solution def longestEqualSubarray(self, nums, k): cnt = collections.Counter() result = left = 0 for right in xrange(len(nums)): cnt[nums[right]] += 1 result = max(result, cnt[nums[right]]) if right-left+1 > result+k: cnt[nums[left]] -= 1 left += 1 return result ", "class Solution def lastVisitedIntegers(self, words): PREV = \"prev\" result, stk = [], [] i = -1 for x in words: if x == PREV: result.append(stk[i] if i >= 0 else -1) i -= 1 continue stk.append(int(x)) i = len(stk)-1 return result ", "class Solution def canReorderDoubled(self, A): count = collections.Counter(A) for x in sorted(count, key=abs): if count[x] > count[2*x]: return False count[2*x] -= count[x] return True ", "class Solution def largestSumOfAverages(self, A, K): accum_sum = [A[0]] for i in xrange(1, len(A)): accum_sum.append(A[i]+accum_sum[-1]) dp = [[0]*len(A) for _ in xrange(2)] for k in xrange(1, K+1): for i in xrange(k-1, len(A)): if k == 1: dp[k % 2][i] = float(accum_sum[i])/(i+1) else: for j in xrange(k-2, i): dp[k % 2][i] = max(dp[k % 2][i], dp[(k-1) % 2][j] + float(accum_sum[i]-accum_sum[j])/(i-j)) return dp[K % 2][-1] ", "class Solution def earliestSecondToMarkIndices(self, nums, changeIndices): def check(t): lookup = [-1]*len(nums) for i in xrange(t): lookup[changeIndices[i]-1] = i if -1 in lookup: return False cnt = 0 for i in xrange(t): if i != lookup[changeIndices[i]-1]: cnt += 1 continue cnt -= nums[changeIndices[i]-1] if cnt < 0: return False return True left, right = sum(nums)+len(nums), len(changeIndices) while left <= right: mid = left+(right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left if left <= len(changeIndices) else -1 ", "class Solution def kthDistinct(self, arr, k): count = collections.Counter(arr) arr = [x for x in arr if count[x] == 1] return arr[k-1] if k-1 < len(arr) else \"\" ", "class Solution def intersection(self, nums): MAX_NUM = 1000 cnt = [0]*(MAX_NUM+1) for num in nums: for x in num: cnt[x] += 1 return [i for i in xrange(1, MAX_NUM+1) if cnt[i] == len(nums)] ", "class Solution def intersection(self, nums): result = set(nums[0]) for i in xrange(1, len(nums)): result = set(x for x in nums[i] if x in result) return [i for i in xrange(min(result), max(result)+1) if i in result] if result else [] ", "class Solution def intersection(self, nums): result = set(nums[0]) for i in xrange(1, len(nums)): result = set(x for x in nums[i] if x in result) return sorted(result) ", "class Solution def countTriples(self, n): lookup = set() for i in xrange(1, n+1): lookup.add(i**2) result = 0 for i in xrange(1, n+1): for j in xrange(1, n+1): result += int(i**2+j**2 in lookup) return result ", "class Solution def findPrefixScore(self, nums): curr = 0 for i in xrange(len(nums)): curr = max(curr, nums[i]) nums[i] += (nums[i-1] if i-1 >= 0 else 0)+curr return nums ", "class Solution def minimizeConcatenatedLength(self, words): dp = [[float(\"-inf\")]*26 for _ in xrange(2)] dp[0][ord(words[0][-1])-ord('a')] = dp[1][ord(words[0][0])-ord('a')] = 0 for i in xrange(1, len(words)): new_dp = [[float(\"-inf\")]*26 for _ in xrange(2)] for right in xrange(2): for c in xrange(26): if dp[right][c] == float(\"-inf\"): continue l = c if right else ord(words[i-1][0])-ord('a') r = c if not right else ord(words[i-1][-1])-ord('a') new_dp[0][r] = max(new_dp[0][r], dp[right][c]+int(ord(words[i][-1])-ord('a') == l)) new_dp[1][l] = max(new_dp[1][l], dp[right][c]+int(r == ord(words[i][0])-ord('a'))) dp = new_dp return sum(len(w) for w in words)-max(dp[right][c] for right in xrange(2) for c in xrange(26)) ", "class Solution def calculate(self, s): def compute(operands, operators): right, left = operands.pop(), operands.pop() operands.append(ops[operators.pop()](left, right)) ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div} precedence = {'+':0, '-':0, '*':1, '/':1} operands, operators, operand = [], [], 0 for i in xrange(len(s)): if s[i].isdigit(): operand = operand*10 + int(s[i]) if i == len(s)-1 or not s[i+1].isdigit(): operands.append(operand) operand = 0 elif s[i] == '(': operators.append(s[i]) elif s[i] == ')': while operators[-1] != '(': compute(operands, operators) operators.pop() elif s[i] in precedence: while operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[s[i]]: compute(operands, operators) operators.append(s[i]) while operators: compute(operands, operators) return operands[-1] ", "class Solution def calculate(self, s): operands, operators = [], [] operand = \"\" for i in reversed(xrange(len(s))): if s[i].isdigit(): operand += s[i] if i == 0 or not s[i-1].isdigit(): operands.append(int(operand[::-1])) operand = \"\" elif s[i] == ')' or s[i] == '*' or s[i] == '/': operators.append(s[i]) elif s[i] == '+' or s[i] == '-': while operators and (operators[-1] == '*' or operators[-1] == '/'): self.compute(operands, operators) operators.append(s[i]) elif s[i] == '(': while operators[-1] != ')': self.compute(operands, operators) operators.pop() while operators: self.compute(operands, operators) return operands[-1] def compute(self, operands, operators): left, right = operands.pop(), operands.pop() op = operators.pop() if op == '+': operands.append(left + right) elif op == '-': operands.append(left - right) elif op == '*': operands.append(left * right) elif op == '/': operands.append(left / right) ", "class Solution def finalPrices(self, prices): stk = [] for i, p in enumerate(prices): while stk and prices[stk[-1]] >= p: prices[stk.pop()] -= p stk.append(i) return prices ", "class Solution def distMoney(self, money, children): if money < children*1: return -1 money -= children*1 q, r = divmod(money, 7) return min(q, children) - int(q > children or (q == children and r != 0) or (q == children-1 and r == 3)) ", "class Solution def distMoney(self, money, children): if money < children*1: return -1 money -= children*1 q, r = divmod(money, 7) if q > children: return children-1 if q == children: return q-int(r != 0) if q == children-1: return q-int(r == 3) return q ", "class Solution def removeAnagrams(self, words): result = [] prev = None for x in words: cnt = collections.Counter(x) if prev and prev == cnt: continue prev = cnt result.append(x) return result import collections ", "class Solution def removeAnagrams(self, words): result = [] prev = None for x in words: s = sorted(x) if prev and prev == s: continue prev = s result.append(x) return result import collections ", "class Solution def removeAnagrams(self, words): return [words[i] for i in xrange(len(words)) if i == 0 or sorted(words[i-1]) != sorted(words[i])] ", "class Solution def isSubsequence(self, s, t): if not s: return True i = 0 for c in t: if c == s[i]: i += 1 if i == len(s): break return i == len(s) ", "class Solution def rotateGrid(self, grid, k): def get_index(m, n, l): if l < m-1: return l, 0 if l < (m-1)+(n-1): return m-1, l-(m-1) if l < (m-1)+(n-1)+(m-1): return (m-1)-(l-((m-1)+(n-1))), n-1 return 0, (n-1)-(l-((m-1)+(n-1)+(m-1))) m, n = len(grid), len(grid[0]) for i in xrange(min(m, n)//2): total = 2*((m-1)+(n-1)) nk = k%total num_cycles = fractions.gcd(total, nk) cycle_len = total//num_cycles for offset in xrange(num_cycles): r, c = get_index(m, n, offset) for j in xrange(1, cycle_len): nr, nc = get_index(m, n, (offset+j*nk)%total) grid[i+nr][i+nc], grid[i+r][i+c] = grid[i+r][i+c], grid[i+nr][i+nc] m, n = m-2, n-2 return grid ", "class Solution def rotateGrid(self, grid, k): def get_index(m, n, l): if l < m-1: return l, 0 if l < (m-1)+(n-1): return m-1, l-(m-1) if l < (m-1)+(n-1)+(m-1): return (m-1)-(l-((m-1)+(n-1))), n-1 return 0, (n-1)-(l-((m-1)+(n-1)+(m-1))) def reverse(grid, m, n, i, left, right): while left < right: lr, lc = get_index(m, n, left) rr, rc = get_index(m, n, right) grid[i+lr][i+lc], grid[i+rr][i+rc] = grid[i+rr][i+rc], grid[i+lr][i+lc] left += 1 right -= 1 m, n = len(grid), len(grid[0]) for i in xrange(min(m, n)//2): total = 2*((m-1)+(n-1)) nk = k%total reverse(grid, m, n, i, 0, total-1) reverse(grid, m, n, i, 0, nk-1) reverse(grid, m, n, i, nk, total-1) m, n = m-2, n-2 return grid ", "class Solution def findRoot(self, tree): root = 0 for node in tree: root ^= id(node) for child in node.children: root ^= id(child) for node in tree: if id(node) == root: return node return None ", "class Solution def findRoot(self, tree): root = 0 for node in tree: root ^= node.val for child in node.children: root ^= child.val for node in tree: if node.val == root: return node return None ", "class Solution def findRoot(self, tree): root = 0 for node in tree: root += node.val-sum(child.val for child in node.children) for node in tree: if node.val == root: return node return None ", "class Solution def nodesBetweenCriticalPoints(self, head): first = last = -1 result = float(\"inf\") i, prev, head = 0, head.val, head.next while head.next: if max(prev, head.next.val) < head.val or min(prev, head.next.val) > head.val: if first == -1: first = i if last != -1: result = min(result, i-last) last = i i += 1 prev = head.val head = head.next return [result, last-first] if last != first else [-1, -1] ", "class Solution def addTwoNumbers(self, l1, l2): stk1, stk2 = [], [] while l1: stk1.append(l1.val) l1 = l1.next while l2: stk2.append(l2.val) l2 = l2.next prev, head = None, None sum = 0 while stk1 or stk2: sum /= 10 if stk1: sum += stk1.pop() if stk2: sum += stk2.pop() head = ListNode(sum % 10) head.next = prev prev = head if sum >= 10: head = ListNode(sum / 10) head.next = prev return head ", "class Solution def maxFrequencyElements(self, nums): cnt = collections.Counter(nums) mx = max(cnt.itervalues()) return sum(v for v in cnt.itervalues() if v == mx) ", "class Solution def canMakeArithmeticProgression(self, arr): m = min(arr) d = (max(arr)-m)//(len(arr)-1) if not d: return True i = 0 while i < len(arr): if arr[i] == m+i*d: i += 1 else: j, r = divmod(arr[i]-m, d) if r or j >= len(arr) or arr[i] == arr[j]: return False arr[i], arr[j] = arr[j], arr[i] return True ", "class Solution def bulbSwitch(self, n): return int(math.sqrt(n)) ", "class Solution def flipgame(self, fronts, backs): same = {n for i, n in enumerate(fronts) if n == backs[i]} result = float(\"inf\") for n in itertools.chain(fronts, backs): if n not in same: result = min(result, n) return result if result < float(\"inf\") else 0 ", "class Solution def canMakeSquare(self, grid): N, W = 3, 2 return any(max(collections.Counter(grid[i+h][j+w] for h in xrange(W) for w in xrange(W)).itervalues()) >= W**2-1 for i in xrange(N-W+1) for j in xrange(N-W+1)) ", "class Solution def largestOverlap(self, A, B): count = [0] * (2*len(A)-1)**2 for i, row in enumerate(A): for j, v in enumerate(row): if not v: continue for i2, row2 in enumerate(B): for j2, v2 in enumerate(row2): if not v2: continue count[(len(A)-1+i-i2)*(2*len(A)-1) + len(A)-1+j-j2] += 1 return max(count) ", "class Solution def longestPalindrome(self, s): def preProcess(s): if not s: return ['^', '$'] T = ['^'] for c in s: T += ['#', c] T += ['#', '$'] return T T = preProcess(s) P = [0] * len(T) center, right = 0, 0 for i in xrange(1, len(T) - 1): i_mirror = 2 * center - i if right > i: P[i] = min(right - i, P[i_mirror]) else: P[i] = 0 while T[i + 1 + P[i]] == T[i - 1 - P[i]]: P[i] += 1 if i + P[i] > right: center, right = i, i + P[i] max_i = 0 for i in xrange(1, len(T) - 1): if P[i] > P[max_i]: max_i = i start = (max_i - 1 - P[max_i]) // 2 return s[start : start + P[max_i]] ", "class Solution def longestPalindrome(self, s): def expand(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return (right-left+1)-2 left, right = -1, -2 for i in xrange(len(s)): l = max(expand(s, i, i), expand(s, i, i+1)) if l > right-left+1: right = i+l//2 left = right-l+1 return s[left:right+1] if left >= 0 else \"\" ", "class Solution def cutOffTree(self, forest): def dot(p1, p2): return p1[0]*p2[0]+p1[1]*p2[1] def minStep(p1, p2): min_steps = abs(p1[0]-p2[0])+abs(p1[1]-p2[1]) closer, detour = [p1], [] lookup = set() while True: if not closer: if not detour: return -1 min_steps += 2 closer, detour = detour, closer i, j = closer.pop() if (i, j) == p2: return min_steps if (i, j) not in lookup: lookup.add((i, j)) for I, J in (i+1, j), (i-1, j), (i, j+1), (i, j-1): if 0 <= I < m and 0 <= J < n and forest[I][J] and (I, J) not in lookup: is_closer = dot((I-i, J-j), (p2[0]-i, p2[1]-j)) > 0 (closer if is_closer else detour).append((I, J)) return min_steps m, n = len(forest), len(forest[0]) min_heap = [] for i in xrange(m): for j in xrange(n): if forest[i][j] > 1: heapq.heappush(min_heap, (forest[i][j], (i, j))) start = (0, 0) result = 0 while min_heap: tree = heapq.heappop(min_heap) step = minStep(start, tree[1]) if step < 0: return -1 result += step start = tree[1] return result class Solution_TLE(object): def cutOffTree(self, forest): def minStep(p1, p2): min_steps = 0 lookup = {p1} q = collections.deque([p1]) while q: size = len(q) for _ in xrange(size): (i, j) = q.popleft() if (i, j) == p2: return min_steps for i, j in (i+1, j), (i-1, j), (i, j+1), (i, j-1): if not (0 <= i < m and 0 <= j < n and forest[i][j] and (i, j) not in lookup): continue q.append((i, j)) lookup.add((i, j)) min_steps += 1 return -1 m, n = len(forest), len(forest[0]) min_heap = [] for i in xrange(m): for j in xrange(n): if forest[i][j] > 1: heapq.heappush(min_heap, (forest[i][j], (i, j))) start = (0, 0) result = 0 while min_heap: tree = heapq.heappop(min_heap) step = minStep(start, tree[1]) if step < 0: return -1 result += step start = tree[1] return result ", "class Solution def fib(self, N): def matrix_expo(A, K): result = [[int(i==j) for j in xrange(len(A))] for i in xrange(len(A))] while K: if K % 2: result = matrix_mult(result, A) A = matrix_mult(A, A) K /= 2 return result def matrix_mult(A, B): ZB = zip(*B) return [[sum(a*b for a, b in itertools.izip(row, col)) for col in ZB] for row in A] T = [[1, 1], [1, 0]] return matrix_mult([[1, 0]], matrix_expo(T, N))[0][1] ", "class Solution def fib(self, N): prev, current = 0, 1 for i in xrange(N): prev, current = current, prev + current, return prev ", "class Solution def getHint(self, secret, guess): A, B = 0, 0 lookup = defaultdict(int) for s, g in izip(secret, guess): if s == g: A += 1 else: B += int(lookup[s] < 0) + int(lookup[g] > 0) lookup[s] += 1 lookup[g] -= 1 return \"%dA%dB\" % (A, B) ", "class Solution def getHint(self, secret, guess): A = sum(imap(operator.eq, secret, guess)) B = sum((Counter(secret) & Counter(guess)).values()) - A return \"%dA%dB\" % (A, B) ", "class Solution def clearStars(self, s): result = list(s) lookup = [[] for _ in range(26)] for i, x in enumerate(s): if x != '*': lookup[ord(x)-ord('a')].append(i) continue for stk in lookup: if not stk: continue result[stk.pop()] = '*' break return \"\".join(x for x in result if x != '*') ", "class Solution def tree2str(self, t): if not t: return \"\" s = str(t.val) if t.left or t.right: s += \"(\" + self.tree2str(t.left) + \")\" if t.right: s += \"(\" + self.tree2str(t.right) + \")\" return s ", "class Solution def vowelStrings(self, words, queries): VOWELS = {'a', 'e', 'i', 'o', 'u'} prefix = [0]*(len(words)+1) for i, w in enumerate(words): prefix[i+1] = prefix[i]+int(w[0] in VOWELS and w[-1] in VOWELS) return [prefix[r+1]-prefix[l] for l, r in queries] ", "class Solution def defangIPaddr(self, address): result = [] for c in address: if c == '.': result.append(\"[.]\") else: result.append(c) return \"\".join(result) ", "class Solution def isPreorder(self, nodes): stk = [nodes[0][0]] for i in xrange(1, len(nodes)): while stk and stk[-1] != nodes[i][1]: stk.pop() if not stk: return False stk.append(nodes[i][0]) return True ", "class Solution def convertToBase7(self, num): if num < 0: return '-' + self.convertToBase7(-num) result = '' while num: result = str(num % 7) + result num //= 7 return result if result else '0' ", "class Solution def convertToBase7(self, num): if num < 0: return '-' + self.convertToBase7(-num) if num < 7: return str(num) return self.convertToBase7(num // 7) + str(num % 7) ", "class Solution def countSubgraphsForEachDiameter(self, n, edges): def dfs(n, adj, curr, parent, lookup, count, dp): for child in adj[curr]: if child == parent or lookup[child]: continue dfs(n, adj, child, curr, lookup, count, dp) dp[curr][0][0] = 1 for child in adj[curr]: if child == parent or lookup[child]: continue new_dp_curr = [row[:] for row in dp[curr]] for curr_d in xrange(count[curr]): for curr_max_d in xrange(curr_d, min(2*curr_d+1, count[curr])): if not dp[curr][curr_d][curr_max_d]: continue for child_d in xrange(count[child]): for child_max_d in xrange(child_d, min(2*child_d+1, count[child])): new_dp_curr[max(curr_d, child_d+1)][max(curr_max_d, child_max_d, curr_d+child_d+1)] += dp[curr][curr_d][curr_max_d]*dp[child][child_d][child_max_d] count[curr] += count[child] dp[curr] = new_dp_curr adj = collections.defaultdict(list) for u, v in edges: u -= 1 v -= 1 adj[u].append(v) adj[v].append(u) lookup, result = [0]*n, [0]*(n-1) for i in xrange(n): dp = [[[0]*n for _ in xrange(n)] for _ in xrange(n)] count = [1]*n dfs(n, adj, i, -1, lookup, count, dp) lookup[i] = 1 for d in xrange(1, n): for max_d in xrange(d, min(2*d+1, n)): result[max_d-1] += dp[i][d][max_d] return result import collections import math ", "class Solution def countSubgraphsForEachDiameter(self, n, edges): def popcount(mask): count = 0 while mask: mask &= mask-1 count += 1 return count def bfs(adj, mask, start): q = collections.deque([(start, 0)]) lookup = 1<<start count = popcount(mask)-1 u, d = None, None while q: u, d = q.popleft() for v in adj[u]: if not (mask&(1<<v)) or (lookup&(1<<v)): continue lookup |= 1<<v count -= 1 q.append((v, d+1)) return count == 0, u, d def max_distance(n, edges, adj, mask): is_valid, farthest, _ = bfs(adj, mask, int(math.log(mask&-mask, 2))) return bfs(adj, mask, farthest)[-1] if is_valid else 0 adj = collections.defaultdict(list) for u, v in edges: u -= 1 v -= 1 adj[u].append(v) adj[v].append(u) result = [0]*(n-1) for mask in xrange(1, 2**n): max_d = max_distance(n, edges, adj, mask) if max_d-1 >= 0: result[max_d-1] += 1 return result ", "class Solution def maxProfit(self, prices): hold1, hold2 = float(\"-inf\"), float(\"-inf\") release1, release2 = 0, 0 for i in prices: release1 = max(release1, hold1 + i) hold1 = max(hold1, -i) release2 = max(release2, hold2 + i) hold2 = max(hold2, release1 - i) return release2 ", "class Solution def maxProfit(self, prices): def maxAtMostKPairsProfit(prices, k): max_buy = [float(\"-inf\") for _ in xrange(k + 1)] max_sell = [0 for _ in xrange(k + 1)] for i in xrange(len(prices)): for j in xrange(1, k + 1): max_buy[j] = max(max_buy[j], max_sell[j-1] - prices[i]) max_sell[j] = max(max_sell[j], max_buy[j] + prices[i]) return max_sell[k] return maxAtMostKPairsProfit(prices, 2) ", "class Solution def maxProfit(self, prices): min_price, max_profit_from_left, max_profits_from_left = float(\"inf\"), 0, [] for price in prices: min_price = min(min_price, price) max_profit_from_left = max(max_profit_from_left, price - min_price) max_profits_from_left.append(max_profit_from_left) max_price, max_profit_from_right, max_profits_from_right = 0, 0, [] for i in reversed(range(len(prices))): max_price = max(max_price, prices[i]) max_profit_from_right = max(max_profit_from_right, max_price - prices[i]) max_profits_from_right.insert(0, max_profit_from_right) max_profit = 0 for i in range(len(prices)): max_profit = max(max_profit, max_profits_from_left[i] + max_profits_from_right[i]) return max_profit ", "class Solution def longestContinuousSubstring(self, s): result = l = 0 for i in xrange(len(s)): l += 1 if i+1 == len(s) or ord(s[i])+1 != ord(s[i+1]): result = max(result, l) l = 0 return result ", "class Solution def copyRandomList(self, head): current = head while current: copied = Node(current.val) copied.next = current.next current.next = copied current = copied.next current = head while current: if current.random: current.next.random = current.random.next current = current.next.next dummy = Node(0) copied_current, current = dummy, head while current: copied_current.next = current.next current.next = current.next.next copied_current, current = copied_current.next, current.next return dummy.next ", "class Solution def copyRandomList(self, head): dummy = Node(0) current, prev, copies = head, dummy, {} while current: copied = Node(current.val) copies[current] = copied prev.next = copied prev, current = prev.next, current.next current = head while current: if current.random: copies[current].random = copies[current.random] current = current.next return dummy.next from collections import defaultdict ", "class Solution def copyRandomList(self, head): clone = defaultdict(lambda: Node(0)) clone[None] = None cur = head while cur: clone[cur].val = cur.val clone[cur].next = clone[cur.next] clone[cur].random = clone[cur.random] cur = cur.next return clone[head] ", "class Solution def longestDiverseString(self, a, b, c): max_heap = [] if a: heapq.heappush(max_heap, (-a, 'a')) if b: heapq.heappush(max_heap, (-b, 'b')) if c: heapq.heappush(max_heap, (-c, 'c')) result = [] while max_heap: count1, c1 = heapq.heappop(max_heap) if len(result) >= 2 and result[-1] == result[-2] == c1: if not max_heap: return \"\".join(result) count2, c2 = heapq.heappop(max_heap) result.append(c2) count2 += 1 if count2: heapq.heappush(max_heap, (count2, c2)) heapq.heappush(max_heap, (count1, c1)) continue result.append(c1) count1 += 1 if count1 != 0: heapq.heappush(max_heap, (count1, c1)) return \"\".join(result) ", "class Solution def longestDiverseString(self, a, b, c): choices = [[a, 'a'], [b, 'b'], [c, 'c']] result = [] for _ in xrange(a+b+c): choices.sort(reverse=True) for i, (x, c) in enumerate(choices): if x and result[-2:] != [c, c]: result.append(c) choices[i][0] -= 1 break else: break return \"\".join(result) ", "class Solution def findCenter(self, edges): return edges[0][edges[0][1] in edges[1]] ", "class Solution def countOperationsToEmptyArray(self, nums): idxs = range(len(nums)) idxs.sort(key=lambda x: nums[x]) return len(idxs)+sum(len(idxs)-(i+1) for i in xrange(len(idxs)-1) if idxs[i] > idxs[i+1]) ", "class Solution def countOperationsToEmptyArray(self, nums): class BIT(object): def __init__(self, n): self.__bit = [0]*(n+1) def add(self, i, val): i += 1 while i < len(self.__bit): self.__bit[i] += val i += (i & -i) def query(self, i): i += 1 ret = 0 while i > 0: ret += self.__bit[i] i -= (i & -i) return ret bit = BIT(len(nums)) idxs = range(len(nums)) idxs.sort(key=lambda x: nums[x]) result = len(nums) prev = -1 for i in idxs: if prev == -1: result += i elif prev < i: result += (i-prev)-(bit.query(i)-bit.query(prev-1)) else: result += ((len(nums)-1)-bit.query(len(nums)-1))-((prev-i)-(bit.query(prev)-bit.query(i-1))) bit.add(i, 1) prev = i return result ", "class Solution def calculate(self, s): def compute(operands, operators): right, left = operands.pop(), operands.pop() operands.append(ops[operators.pop()](left, right)) ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div} precedence = {'+':0, '-':0, '*':1, '/':1} operands, operators, operand = [], [], 0 for i in xrange(len(s)): if s[i].isdigit(): operand = operand*10 + int(s[i]) if i == len(s)-1 or not s[i+1].isdigit(): operands.append(operand) operand = 0 elif s[i] == '(': operators.append(s[i]) elif s[i] == ')': while operators[-1] != '(': compute(operands, operators) operators.pop() elif s[i] in precedence: while operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[s[i]]: compute(operands, operators) operators.append(s[i]) while operators: compute(operands, operators) return operands[-1] ", "class Solution def calculate(self, s): operands, operators = [], [] operand = \"\" for i in reversed(xrange(len(s))): if s[i].isdigit(): operand += s[i] if i == 0 or not s[i-1].isdigit(): operands.append(int(operand[::-1])) operand = \"\" elif s[i] == ')' or s[i] == '*' or s[i] == '/': operators.append(s[i]) elif s[i] == '+' or s[i] == '-': while operators and (operators[-1] == '*' or operators[-1] == '/'): self.compute(operands, operators) operators.append(s[i]) elif s[i] == '(': while operators[-1] != ')': self.compute(operands, operators) operators.pop() while operators: self.compute(operands, operators) return operands[-1] def compute(self, operands, operators): left, right = operands.pop(), operands.pop() op = operators.pop() if op == '+': operands.append(left + right) elif op == '-': operands.append(left - right) elif op == '*': operands.append(left * right) elif op == '/': operands.append(left / right) ", "class Solution def countSubstrings(self, s, c): n = s.count(c) return (n+1)*n//2 ", "class Solution def areAlmostEqual(self, s1, s2): diff = [] for a, b in itertools.izip(s1, s2): if a == b: continue if len(diff) == 2: return False diff.append([a, b] if not diff else [b, a]) return not diff or (len(diff) == 2 and diff[0] == diff[1]) ", "class Solution def minimumAddedInteger(self, nums1, nums2): def check(cnt2, cnt1): return all(cnt1.get(k, 0)-v >= 0 for k, v in cnt2.iteritems()) mx = max(nums2) cnt2 = collections.Counter(nums2) return next(d for d in [mx-x for x in heapq.nlargest(3, nums1)] if check(cnt2, collections.Counter(x+d for x in nums1))) import collections ", "class Solution def minimumAddedInteger(self, nums1, nums2): def check(cnt2, cnt1): return all(cnt1.get(k, 0)-v >= 0 for k, v in cnt2.iteritems()) def topk(a, k): result = [float(\"-inf\")]*k for x in a: for i in xrange(len(result)): if x > result[i]: result[i], x = x, result[i] return result mx = max(nums2) cnt2 = collections.Counter(nums2) return next(d for d in [mx-x for x in topk(nums1, 3)] if check(cnt2, collections.Counter(x+d for x in nums1))) ", "class Solution def minimumAddedInteger(self, nums1, nums2): nums1.sort() nums2.sort() for i in xrange(3): d = nums2[-1]-nums1[~i] cnt = 0 for j in xrange(len(nums2)): while j+cnt < len(nums1) and nums1[j+cnt]+d != nums2[j]: cnt += 1 if cnt <= 2: return d return -1 ", "class Solution def countAlternatingSubarrays(self, nums): result = curr = 0 for i in xrange(len(nums)): if i-1 >= 0 and nums[i-1] == nums[i]: curr = 0 curr += 1 result += curr return result ", "class Solution def bstToGst(self, root): def bstToGstHelper(root, prev): if not root: return root bstToGstHelper(root.right, prev) root.val += prev[0] prev[0] = root.val bstToGstHelper(root.left, prev) return root prev = [0] return bstToGstHelper(root, prev) ", "class Solution def deleteAndEarn(self, nums): vals = [0] * 10001 for num in nums: vals[num] += num val_i, val_i_1 = vals[0], 0 for i in xrange(1, len(vals)): val_i_1, val_i_2 = val_i, val_i_1 val_i = max(vals[i] + val_i_2, val_i_1) return val_i ", "class Solution def countBadPairs(self, nums): result = len(nums)*(len(nums)-1)//2 cnt = collections.Counter() for i, x in enumerate(nums): result -= cnt[x-i] cnt[x-i] += 1 return result ", "class Solution def __init__(self): self.__cache = [] def rand10(self): def generate(cache): n = 32 curr = sum((rand7()-1) * (7**i) for i in xrange(n)) rang = 7**n while curr < rang//10*10: cache.append(curr%10+1) curr /= 10 rang /= 10 while not self.__cache: generate(self.__cache) return self.__cache.pop() ", "class Solution def rand10(self): while True: x = (rand7()-1)*7 + (rand7()-1) if x < 40: return x%10 + 1 ", "class Solution def findRightInterval(self, intervals): sorted_intervals = sorted((interval.start, i) for i, interval in enumerate(intervals)) result = [] for interval in intervals: idx = bisect.bisect_left(sorted_intervals, (interval.end,)) result.append(sorted_intervals[idx][1] if idx < len(sorted_intervals) else -1) return result ", "class Solution def fairCandySwap(self, A, B): diff = (sum(A)-sum(B))//2 setA = set(A) for b in set(B): if diff+b in setA: return [diff+b, b] return [] ", "class Solution def closeStrings(self, word1, word2): if len(word1) != len(word2): return False cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2) return set(cnt1.iterkeys()) == set(cnt2.iterkeys()) and collections.Counter(cnt1.itervalues()) == collections.Counter(cnt2.itervalues()) ", "class Solution def decrypt(self, code, k): result = [0]*len(code) if k == 0: return result left, right = 1, k if k < 0: k = -k left, right = len(code)-k, len(code)-1 total = sum(code[i] for i in xrange(left, right+1)) for i in xrange(len(code)): result[i] = total total -= code[left%len(code)] total += code[(right+1)%len(code)] left += 1 right += 1 return result ", "class Solution def countSubMultisets(self, nums, l, r): MOD = 10**9+7 cnt = collections.Counter(nums) dp = [0]*(r+1) dp[0] = 1 for x, c in cnt.iteritems(): for i in reversed(xrange(max(r-x+1, 1), r+1)): curr = reduce(lambda x, y: (x+y)%MOD, (dp[i-x*j] for j in xrange(min(c, i//x+1)))) for j in reversed(xrange((i-1)%x+1, i+1, x)): curr = (curr+(dp[j-x*c] if j-x*c >= 0 else 0)-dp[j])%MOD dp[j] = (dp[j]+curr)%MOD return (reduce(lambda x, y: (x+y)%MOD, (dp[i] for i in range(l, r+1)))*(cnt[0]+1))%MOD ", "class Solution def __init__(self, radius, x_center, y_center): self.__radius = radius self.__x_center = x_center self.__y_center = y_center def randPoint(self): r = (self.__radius) * math.sqrt(random.uniform(0, 1)) theta = (2*math.pi) * random.uniform(0, 1) return (r*math.cos(theta) + self.__x_center, r*math.sin(theta) + self.__y_center) ", "class Solution def confusingNumberII(self, n): lookup = {\"0\":\"0\", \"1\":\"1\", \"6\":\"9\", \"8\":\"8\", \"9\":\"6\"} centers = {\"0\":\"0\", \"1\":\"1\", \"8\":\"8\"} def totalCount(n): s = str(n) total = 0 p = len(lookup)**(len(s)-1) for i in xrange(len(s)+1): if i == len(s): total += 1 break smaller = sum(int(c < s[i]) for c in lookup.iterkeys()) total += smaller * p if s[i] not in lookup: break p //= len(lookup) return total-1 def validCountInLessLength(n): s = str(n) valid = 0 total = len(centers) for i in xrange(1, len(s), 2): if i == 1: valid += len({c for c in centers.iterkeys() if c != '0'}) else: valid += total * (len(lookup)-1) total *= len(lookup) total = 1 for i in xrange(2, len(s), 2): valid += total * (len(lookup)-1) total *= len(lookup) return valid def validCountInFullLength(n): s = str(n) half_s = s[:(len(s)+1)//2] total = 0 choices = centers if (len(s) % 2) else lookup p = int(len(lookup)**(len(half_s)-2) * len(choices)) for i in xrange(len(half_s)): if i == len(half_s)-1: total += sum(int(c < half_s[i]) for c in choices.iterkeys() if i != 0 or c != '0') if half_s[i] not in choices: break tmp = list(half_s)+[lookup[half_s[i]] for i in reversed(xrange(len(half_s)-(len(s) % 2)))] total += 0 < int(\"\".join(tmp)) <= n break smaller = sum(int(c < half_s[i]) for c in lookup.iterkeys() if i != 0 or c != '0') total += smaller * p if half_s[i] not in lookup: break p //= len(lookup) return total return totalCount(n) - validCountInLessLength(n) - validCountInFullLength(n) ", "class Solution def confusingNumberII(self, n): lookup = {\"0\":\"0\", \"1\":\"1\", \"6\":\"9\", \"8\":\"8\", \"9\":\"6\"} centers = {\"0\":\"0\", \"1\":\"1\", \"8\":\"8\"} def totalCount(n): s = str(n) total = 0 p = len(lookup)**(len(s)-1) for i in xrange(len(s)+1): if i == len(s): total += 1 break smaller = sum(int(c < s[i]) for c in lookup.iterkeys()) total += smaller * p if s[i] not in lookup: break p //= len(lookup) return total def validCountInLessLength(n): s = str(n) valid = 0 total = len(centers) for i in xrange(1, len(s), 2): if i == 1: valid += len(centers) else: valid += total * (len(lookup)-1) total *= len(lookup) total = 1 for i in xrange(2, len(s), 2): valid += total * (len(lookup)-1) total *= len(lookup) return valid def validCountInFullLength(n): s = str(n) half_s = s[:(len(s)+1)//2] total = 0 choices = centers if (len(s) % 2) else lookup p = int(len(lookup)**(len(half_s)-2) * len(choices)) for i in xrange(len(half_s)): if i == len(half_s)-1: total += sum(int(c < half_s[i]) for c in choices.iterkeys() if len(s) != 2 or c != '0') if half_s[i] not in choices: break tmp = list(half_s)+[lookup[half_s[i]] for i in reversed(xrange(len(half_s)-(len(s) % 2)))] total += int(\"\".join(tmp)) <= n break smaller = sum(int(c < half_s[i]) for c in lookup.iterkeys() if i != 0 or c != '0') total += smaller * p if half_s[i] not in lookup: break p //= len(lookup) return total def f(n): return totalCount(n) - validCountInLessLength(n) - validCountInFullLength(n) return f(n) - f(0) ", "class Solution def longestUnivaluePath(self, root): result = [0] def dfs(node): if not node: return 0 left, right = dfs(node.left), dfs(node.right) left = (left+1) if node.left and node.left.val == node.val else 0 right = (right+1) if node.right and node.right.val == node.val else 0 result[0] = max(result[0], left+right) return max(left, right) dfs(root) return result[0] ", "class Solution def findCelebrity(self, n): candidate = 0 for i in xrange(1, n): if knows(candidate, i): candidate = i for i in xrange(n): candidate_knows_i = knows(candidate, i) i_knows_candidate = knows(i, candidate) if i != candidate and (candidate_knows_i or not i_knows_candidate): return -1 return candidate ", "class Solution def compareVersion(self, version1, version2): n1, n2 = len(version1), len(version2) i, j = 0, 0 while i < n1 or j < n2: v1, v2 = 0, 0 while i < n1 and version1[i] != '.': v1 = v1 * 10 + int(version1[i]) i += 1 while j < n2 and version2[j] != '.': v2 = v2 * 10 + int(version2[j]) j += 1 if v1 != v2: return 1 if v1 > v2 else -1 i += 1 j += 1 return 0 ", "class Solution def compareVersion(self, version1, version2): v1, v2 = version1.split(\".\"), version2.split(\".\") if len(v1) > len(v2): v2 += ['0' for _ in xrange(len(v1) - len(v2))] elif len(v1) < len(v2): v1 += ['0' for _ in xrange(len(v2) - len(v1))] i = 0 while i < len(v1): if int(v1[i]) > int(v2[i]): return 1 elif int(v1[i]) < int(v2[i]): return -1 else: i += 1 return 0 def compareVersion2(self, version1, version2): v1 = [int(x) for x in version1.split('.')] v2 = [int(x) for x in version2.split('.')] while len(v1) != len(v2): if len(v1) > len(v2): v2.append(0) else: v1.append(0) return cmp(v1, v2) def compareVersion3(self, version1, version2): splits = (map(int, v.split('.')) for v in (version1, version2)) return cmp(*zip(*itertools.izip_longest(*splits, fillvalue=0))) def compareVersion4(self, version1, version2): main1, _, rest1 = ('0' + version1).partition('.') main2, _, rest2 = ('0' + version2).partition('.') return cmp(int(main1), int(main2)) or len(rest1 + rest2) and self.compareVersion4(rest1, rest2) ", "class Solution def insert(self, head, insertVal): def insertAfter(node, val): node.next = Node(val, node.next) if not head: node = Node(insertVal, None) node.next = node return node curr = head while True: if curr.val < curr.next.val: if curr.val <= insertVal and insertVal <= curr.next.val: insertAfter(curr, insertVal) break elif curr.val > curr.next.val: if curr.val <= insertVal or insertVal <= curr.next.val: insertAfter(curr, insertVal) break else: if curr.next == head: insertAfter(curr, insertVal) break curr = curr.next return head ", "class Solution def largestMultipleOfThree(self, digits): lookup = {0: [], 1: [(1,), (4,), (7,), (2, 2), (5, 2), (5, 5), (8, 2), (8, 5), (8, 8)], 2: [(2,), (5,), (8,), (1, 1), (4, 1), (4, 4), (7, 1), (7, 4), (7, 7)]} count = collections.Counter(digits) for deletes in lookup[sum(digits)%3]: delete_count = collections.Counter(deletes) if all(count[k] >= v for k, v in delete_count.iteritems()): for k, v in delete_count.iteritems(): count[k] -= v break result = \"\".join(str(d)*count[d] for d in reversed(xrange(10))) return \"0\" if result and result[0] == '0' else result ", "class Solution def largestMultipleOfThree(self, digits): def candidates_gen(r): if r == 0: return for i in xrange(10): yield [i] for i in xrange(10): for j in xrange(i+1): yield [i, j] count, r = collections.Counter(digits), sum(digits)%3 for deletes in candidates_gen(r): delete_count = collections.Counter(deletes) if sum(deletes)%3 == r and all(count[k] >= v for k, v in delete_count.iteritems()): for k, v in delete_count.iteritems(): count[k] -= v break result = \"\".join(str(d)*count[d] for d in reversed(xrange(10))) return \"0\" if result and result[0] == '0' else result ", "class Solution def hitBricks(self, grid, hits): def index(C, r, c): return r*C+c directions = [(0, -1), (0, 1), (-1, 0), (1, 0)] R, C = len(grid), len(grid[0]) hit_grid = [row[:] for row in grid] for i, j in hits: hit_grid[i][j] = 0 union_find = UnionFind(R*C) for r, row in enumerate(hit_grid): for c, val in enumerate(row): if not val: continue if r == 0: union_find.union_set(index(C, r, c), R*C) if r and hit_grid[r-1][c]: union_find.union_set(index(C, r, c), index(C, r-1, c)) if c and hit_grid[r][c-1]: union_find.union_set(index(C, r, c), index(C, r, c-1)) result = [] for r, c in reversed(hits): prev_roof = union_find.top() if grid[r][c] == 0: result.append(0) continue for d in directions: nr, nc = (r+d[0], c+d[1]) if 0 <= nr < R and 0 <= nc < C and hit_grid[nr][nc]: union_find.union_set(index(C, r, c), index(C, nr, nc)) if r == 0: union_find.union_set(index(C, r, c), R*C) hit_grid[r][c] = 1 result.append(max(0, union_find.top()-prev_roof-1)) return result[::-1] ", "class Solution def knightProbability(self, N, K, r, c): directions = [[ 1, 2], [ 1, -2], [ 2, 1], [ 2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]] dp = [[[1 for _ in xrange(N)] for _ in xrange(N)] for _ in xrange(2)] for step in xrange(1, K+1): for i in xrange(N): for j in xrange(N): dp[step%2][i][j] = 0 for direction in directions: rr, cc = i+direction[0], j+direction[1] if 0 <= cc < N and 0 <= rr < N: dp[step%2][i][j] += 0.125 * dp[(step-1)%2][rr][cc] return dp[K%2][r][c] ", "class Solution def continuousSubarrays(self, nums): result = left = 0 mn, mx = float(\"inf\"), float(\"-inf\") for right in xrange(len(nums)): if mn <= nums[right] <= mx: mn, mx = max(mn, nums[right]-2), min(mx, nums[right]+2) else: mn, mx = nums[right]-2, nums[right]+2 for left in reversed(xrange(right)): if not mn <= nums[left] <= mx: break mn, mx = max(mn, nums[left]-2), min(mx, nums[left]+2) else: left = -1 left += 1 result += right-left+1 return result import collections ", "class Solution def continuousSubarrays(self, nums): mn, mx = collections.deque(), collections.deque() result = left = 0 for right in xrange(len(nums)): while mn and nums[mn[-1]] > nums[right]: mn.pop() mn.append(right) while mx and nums[mx[-1]] < nums[right]: mx.pop() mx.append(right) while not nums[right]-nums[mn[0]] <= 2: left = max(left, mn.popleft()+1) while not nums[mx[0]]-nums[right] <= 2: left = max(left, mx.popleft()+1) result += right-left+1 return result from sortedcontainers import SortedDict ", "class Solution def continuousSubarrays(self, nums): result = left = 0; lookup = SortedDict() for right in xrange(len(nums)): lookup[nums[right]] = right to_del = [] for x, i in lookup.items(): if nums[right]-x <= 2: break left = max(left, i+1) to_del.append(x) for x, i in reversed(lookup.items()): if x-nums[right] <= 2: break left = max(left, i+1) to_del.append(x) for x in to_del: del lookup[x] result += right-left+1; return result; ", "class Solution def deleteNode(self, root, key): if not root: return root if root.val > key: root.left = self.deleteNode(root.left, key) elif root.val < key: root.right = self.deleteNode(root.right, key) else: if not root.left: right = root.right del root return right elif not root.right: left = root.left del root return left else: successor = root.right while successor.left: successor = successor.left root.val = successor.val root.right = self.deleteNode(root.right, successor.val) return root ", "class Solution def findChampion(self, grid): return next(u for u in xrange(len(grid)) if sum(grid[u]) == len(grid)-1) ", "class Solution def alertNames(self, keyName, keyTime): THRESHOLD = 3 name_to_times = collections.defaultdict(list) for name, hour_minute in itertools.izip(keyName, keyTime): hour, minute = map(int, hour_minute.split(':')) name_to_times[name].append(hour*60 + minute) names = [] for name, times in name_to_times.iteritems(): times.sort() left = 0 for right, time in enumerate(times): while time-times[left] > 60: left += 1 if right-left+1 >= THRESHOLD: names.append(name) break names.sort() return names ", "class Solution def assignBikes(self, workers, bikes): def manhattan(p1, p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) dp = [[float(\"inf\")]*((1<<len(bikes))) for _ in xrange(2)] dp[0][0] = 0 for i in xrange(len(workers)): dp[(i+1)%2] = [float(\"inf\")] * ((1<<len(bikes))) for j in xrange(len(bikes)): for taken in xrange((1<<len(bikes))): if taken & (1<<j): continue dp[(i+1)%2][taken|(1<<j)] = min(dp[(i+1)%2][taken|(1<<j)], dp[i%2][taken] + manhattan(workers[i], bikes[j])) return min(dp[len(workers)%2]) import heapq ", "class Solution def assignBikes(self, workers, bikes): def manhattan(p1, p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) min_heap = [(0, 0, 0)] lookup = set() while min_heap: cost, i, taken = heapq.heappop(min_heap) if (i, taken) in lookup: continue lookup.add((i, taken)) if i == len(workers): return cost for j in xrange(len(bikes)): if taken & (1<<j): continue heapq.heappush(min_heap, (cost+manhattan(workers[i], bikes[j]), i+1, taken|(1<<j))) ", "class Solution def findMin(self, nums): left, right = 0, len(nums) - 1 while left < right: mid = left + (right - left) / 2 if nums[mid] == nums[right]: right -= 1 elif nums[mid] < nums[right]: right = mid else: left = mid + 1 return nums[left] ", "class Solution def findMin(self, nums): left, right = 0, len(nums) - 1 while left < right and nums[left] >= nums[right]: mid = left + (right - left) / 2 if nums[mid] == nums[left]: left += 1 elif nums[mid] < nums[left]: right = mid else: left = mid + 1 return nums[left] ", "class Solution def makeSubKSumEqual(self, arr, k): def gcd(a, b): while b: a, b = b, a%b return a def nth_element(nums, n, left=0, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right right = len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 l = gcd(k, len(arr)) result = 0 for i in xrange(l): vals = [arr[j] for j in xrange(i, len(arr), l)] nth_element(vals, len(vals)//2) result += sum(abs(v-vals[len(vals)//2]) for v in vals) return result ", "class Solution def deleteTreeNodes(self, nodes, parent, value): def dfs(value, children, x): total, count = value[x], 1 for y in children[x]: t, c = dfs(value, children, y) total += t count += c if t else 0 return total, count if total else 0 children = collections.defaultdict(list) for i, p in enumerate(parent): if i: children[p].append(i) return dfs(value, children, 0)[1] ", "class Solution def deleteTreeNodes(self, nodes, parent, value): result = [1]*nodes for i in reversed(xrange(1, nodes)): value[parent[i]] += value[i] result[parent[i]] += result[i] if value[i] else 0 return result[0] ", "class Solution def mostCompetitive(self, nums, k): stk = [] for i, x in enumerate(nums): while stk and stk[-1] > x and len(stk)+(len(nums)-i) > k: stk.pop() if len(stk) < k: stk.append(x) return stk ", "class Solution def maxSubstringLength(self, s): def check(left, right): for x in idxs: if not x or x[-1] < left or x[0] > right or (left <= x[0] and x[-1] <= right): continue i = bisect.bisect_left(x, left) if i != len(x) and x[i] <= right: return False return True idxs = [[] for _ in xrange(26)] for i, x in enumerate(s): idxs[ord(x)-ord('a')].append(i) result = -1 for x in idxs: if not x: continue left = x[0] for y in idxs: if not y: continue right = y[-1] if left <= right and result < right-left+1 != len(s) and check(left, right): result = right-left+1 return result import bisect ", "class Solution def maxSubstringLength(self, s): def check(left, right): for x in idxs: if not x: continue l = bisect.bisect_left(x, left) r = bisect.bisect_right(x, right)-1 if not (r-l+1 == len(x) or r-l+1 == 0): return False return True idxs = [[] for _ in xrange(26)] for i, x in enumerate(s): idxs[ord(x)-ord('a')].append(i) result = -1 for x in idxs: if not x: continue left = x[0] for y in idxs: if not y: continue right = y[-1] if left <= right and right-left+1 != len(s) and check(left, right): result = max(result, right-left+1) return result ", "class Solution def maxSubstringLength(self, s): def update(x, d, distinct, valid): x = ord(x)-ord('a') if cnt2[x] == cnt[x]: valid -= 1 if cnt2[x] == 0: distinct += 1 cnt2[x] += d if cnt2[x] == 0: distinct -= 1 if cnt2[x] == cnt[x]: valid += 1 return distinct, valid cnt = [0]*26 for x in s: cnt[ord(x)-ord('a')] += 1 result = -1 for l in xrange(1, sum(x != 0 for x in cnt)): cnt2 = [0]*26 left = distinct = valid = 0 for right in xrange(len(s)): distinct, valid = update(s[right], +1, distinct, valid) while distinct == l+1: distinct, valid = update(s[left], -1, distinct, valid) left += 1 if valid == l: result = max(result, right-left+1) return result ", "class Solution def maxSubstringLength(self, s): def check(l, r): return all(l <= left[ord(s[i])-ord('a')] and right[ord(s[i])-ord('a')] <= r for i in xrange(l, r+1)) left, right = [-1]*26, [-1]*26 for i, x in enumerate(s): x = ord(x)-ord('a') if left[x] == -1: left[x] = i right[x] = i result = -1 for l in left: if l == -1: continue for r in right: if r == -1: continue if l <= r and result < r-l+1 != len(s) and check(l, r): result = r-l+1 return result ", "class Solution def numberOfPairs(self, nums1, nums2, k): cnt = [0]*(max(nums1)+1) for x, c in collections.Counter(k*x for x in nums2).iteritems(): for i in xrange(1, (len(cnt)-1)//x+1): cnt[i*x] += c return sum(cnt[x] for x in nums1) ", "class Solution def numberOfPairs(self, nums1, nums2, k): return sum(x%(k*y) == 0 for x in nums1 for y in nums2) ", "class Solution def findClosestElements(self, arr, k, x): i = bisect.bisect_left(arr, x) left, right = i-1, i while k: if right >= len(arr) or (left >= 0 and abs(arr[left]-x) <= abs(arr[right]-x)): left -= 1 else: right += 1 k -= 1 return arr[left+1:right] ", "class Solution def minOperations(self, logs): result = 0 for log in logs: if log == \"../\": if result > 0: result -= 1 elif log != \"./\": result += 1 return result ", "class Solution def longestSubstring(self, s, k): def longestSubstringHelper(s, k, start, end): count = [0] * 26 for i in xrange(start, end): count[ord(s[i]) - ord('a')] += 1 max_len = 0 i = start while i < end: while i < end and count[ord(s[i]) - ord('a')] < k: i += 1 j = i while j < end and count[ord(s[j]) - ord('a')] >= k: j += 1 if i == start and j == end: return end - start max_len = max(max_len, longestSubstringHelper(s, k, i, j)) i = j return max_len return longestSubstringHelper(s, k, 0, len(s)) ", "class Solution def minOperations(self, initial, target): def binary_search_right(left, right, check): while left <= right: mid = left+(right-left)//2 if not check( mid): right = mid-1 else: left = mid+1 return right def rolling_hash(s, l, lookup, check): MOD, P = 10**9+7, 113 h = 0 pw = pow(P, l-1, MOD) for i in range(len(s)): h = (h*P+(ord(s[i])-ord('a')))%MOD if i < l-1: continue if not check: lookup.add(h) elif h in lookup: return True h = (h-(ord(s[i-(l-1)])-ord('a'))*pw)%MOD return False def check(l): lookup = set() rolling_hash(target, l, lookup, False) return rolling_hash(initial, l, lookup, True) if len(initial) < len(target): initial, target = target, initial return len(initial)+len(target)-2*binary_search_right(1, min(len(initial), min(target)), check) ", "class Solution def minOperations(self, initial, target): result = 0 for k in range(2): for i in xrange(k, len(initial)): curr = 0 for j in xrange(min(len(initial)-i, len(target))): curr = curr+1 if initial[i+j] == target[j] else 0 result = max(result, curr) initial, target = target, initial return len(initial)+len(target)-2*result ", "class Solution def minOperations(self, initial, target): if len(initial) < len(target): initial, target = target, initial result = 0 dp = [0]*(len(target)+1) for i in xrange(len(initial)): for j in reversed(xrange(len(target))): dp[j+1] = dp[j]+1 if initial[i] == target[j] else 0 result = max(result, max(dp)) return len(initial)+len(target)-2*result ", "class Solution def checkArithmeticSubarrays(self, nums, l, r): def is_arith(n): mx, mn, lookup = max(n), min(n), set(n) if mx == mn: return True d, r = divmod(mx-mn, len(n)-1) if r: return False return all(i in lookup for i in xrange(mn, mx, d)) result = [] for left, right in itertools.izip(l, r): result.append(is_arith(nums[left:right+1])) return result ", "class Solution def leftRigthDifference(self, nums): total = sum(nums) result = [] curr = 0 for x in nums: curr += x result.append(abs((curr-x)-(total-curr))) return result ", "class Solution def goodIndices(self, nums, k): left = [1]*len(nums) for i in xrange(1, len(nums)-1): if nums[i] <= nums[i-1]: left[i] = left[i-1]+1 right = [1]*len(nums) for i in reversed(xrange(1, len(nums)-1)): if nums[i] <= nums[i+1]: right[i] = right[i+1]+1 return [i for i in xrange(k, len(nums)-k) if min(left[i-1], right[i+1]) >= k] ", "class Solution def findDerangement(self, n): M = 1000000007 mul, total = 1, 0 for i in reversed(xrange(n+1)): total = (total + M + (1 if i % 2 == 0 else -1) * mul) % M mul = (mul * i) % M return total ", "class Solution def countSubIslands(self, grid1, grid2): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(grid1, grid2, i, j): if not (0 <= i < len(grid2) and 0 <= j < len(grid2[0]) and grid2[i][j] == 1): return 1 grid2[i][j] = 0 result = grid1[i][j] for di, dj in directions: result &= dfs(grid1, grid2, i+di, j+dj) return result return sum(dfs(grid1, grid2, i, j) for i in xrange(len(grid2)) for j in xrange(len(grid2[0])) if grid2[i][j]) ", "class Solution def kthSmallest(self, mat, k): def kSmallestPairs(nums1, nums2, k): result, min_heap = [], [] for c in xrange(min(len(nums1), k)): heapq.heappush(min_heap, (nums1[c]+nums2[0], 0)) c += 1 while len(result) != k and min_heap: total, c = heapq.heappop(min_heap) result.append(total) if c+1 == len(nums2): continue heapq.heappush(min_heap, (total-nums2[c]+nums2[c+1], c+1)) return result result = mat[0] for r in xrange(1, len(mat)): result = kSmallestPairs(result, mat[r], k) return result[k-1] ", "class Solution def kthSmallest(self, mat, k): def countArraysHaveSumLessOrEqual(mat, k, r, target): if target < 0: return 0 if r == len(mat): return 1 result = 0 for c in xrange(len(mat[0])): cnt = countArraysHaveSumLessOrEqual(mat, k-result, r+1, target-mat[r][c]) if not cnt: break result += cnt if result > k: break return result max_num = max(x for row in mat for x in row) left, right = len(mat), len(mat)*max_num while left <= right: mid = left + (right-left)//2 cnt = countArraysHaveSumLessOrEqual(mat, k, 0, mid) if cnt >= k: right = mid-1 else: left = mid+1 return left ", "class Solution def rangeAddQueries(self, n, queries): result = [[0]*n for _ in xrange(n)] for r1, c1, r2, c2 in queries: result[r1][c1] += 1 if c2+1 < len(result[0]): result[r1][c2+1] -= 1 if r2+1 < len(result): result[r2+1][c1] -= 1 if r2+1 < len(result) and c2+1 < len(result[0]): result[r2+1][c2+1] += 1 for r in xrange(len(result)): for c in xrange(len(result[0])-1): result[r][c+1] += result[r][c] for r in xrange(len(result)-1): for c in xrange(len(result[0])): result[r+1][c] += result[r][c] return result ", "class Solution def isMajorityElement(self, nums, target): if len(nums) % 2: if nums[len(nums)//2] != target: return False else: if not (nums[len(nums)//2-1] == nums[len(nums)//2] == target): return False left = bisect.bisect_left(nums, target) right= bisect.bisect_right(nums, target) return (right-left)*2 > len(nums) ", "class Solution def validTree(self, n, edges): if len(edges) != n - 1: return False neighbors = collections.defaultdict(list) for u, v in edges: neighbors[u].append(v) neighbors[v].append(u) q = collections.deque([0]) visited = set([0]) while q: curr = q.popleft() for node in neighbors[curr]: if node not in visited: visited.add(node) q.append(node) return len(visited) == n ", "class Solution def validTree(self, n, edges): visited_from = [-1] * n neighbors = collections.defaultdict(list) for u, v in edges: neighbors[u].append(v) neighbors[v].append(u) q = collections.deque([0]) visited = set([0]) while q: i = q.popleft() for node in neighbors[i]: if node != visited_from[i]: if node in visited: return False else: visited.add(node) visited_from[node] = i q.append(node) return len(visited) == n ", "class Solution def maximumNumberOfStringPairs(self, words): result = 0 cnt = collections.Counter() for w in words: result += cnt[w[::-1]] cnt[w] += 1 return result ", "class Solution def kthSmallest(self, matrix, k): kth_smallest = 0 min_heap = [] def push(i, j): if len(matrix) > len(matrix[0]): if i < len(matrix[0]) and j < len(matrix): heappush(min_heap, [matrix[j][i], i, j]) else: if i < len(matrix) and j < len(matrix[0]): heappush(min_heap, [matrix[i][j], i, j]) push(0, 0) while min_heap and k > 0: kth_smallest, i, j = heappop(min_heap) push(i, j + 1) if j == 0: push(i + 1, 0) k -= 1 return kth_smallest ", "class Solution def largestPalindromic(self, num): cnt = collections.Counter(num) result = [] for i in reversed(xrange(10)): if not cnt[str(i)]//2 or (i == 0 and not result): continue for _ in xrange(cnt[str(i)]//2): result.append(str(i)) result.append(max([k for k, v in cnt.iteritems() if v%2] or [\"\"])) for i in reversed(xrange(len(result)-1)): result.append(result[i]) return \"\".join(result) or \"0\" ", "class Solution def groupStrings(self, words): uf = UnionFind(len(words)) lookup = {} for i, x in enumerate(words): mask = reduce(lambda x, y: x|(1<<(ord(y)-ord('a'))), x, 0) if mask not in lookup: lookup[mask] = i uf.union_set(i, lookup[mask]) bit = 1 while bit <= mask: if mask&bit: if mask^bit not in lookup: lookup[mask^bit] = i uf.union_set(i, lookup[mask^bit]) bit <<= 1 return [uf.total, max(uf.size)] ", "class Solution def champagneTower(self, poured, query_row, query_glass): result = [poured] + [0] * query_row for i in xrange(1, query_row+1): for j in reversed(xrange(i+1)): result[j] = max(result[j]-1, 0)/2.0 + max(result[j-1]-1, 0)/2.0 return min(result[query_glass], 1) ", "class Solution def decode(self, encoded): curr = 0 for i in xrange(1, (len(encoded)+1) + 1): curr ^= i if i < len(encoded) and i%2 == 1: curr ^= encoded[i] result = [curr] for x in encoded: result.append(result[-1]^x) return result ", "class Solution def invertTree(self, root): if root is not None: nodes = Queue() nodes.push(root) while not nodes.empty(): node = nodes.pop() node.left, node.right = node.right, node.left if node.left is not None: nodes.push(node.left) if node.right is not None: nodes.push(node.right) return root ", "class Solution def invertTree(self, root): if root is not None: nodes = [] nodes.append(root) while nodes: node = nodes.pop() node.left, node.right = node.right, node.left if node.left is not None: nodes.append(node.left) if node.right is not None: nodes.append(node.right) return root ", "class Solution def invertTree(self, root): if root is not None: root.left, root.right = self.invertTree(root.right), self.invertTree(root.left) return root ", "class Solution def twoEggDrop(self, n): return int(math.ceil((-1+(1+8*n)**0.5)/2)) ", "class Solution def twoEggDrop(self, n): K = 2 dp = [[float(\"inf\") for j in xrange(n+1)] for _ in xrange(2)] dp[1] = [j for j in xrange(n+1)] for i in xrange(2, K+1): dp[i%2][0] = 0 for j in xrange(1, n+1): for k in xrange(1, j+1): dp[i%2][j] = min(dp[i%2][j], 1+max(dp[(i-1)%2][k-1], dp[i%2][j-k])) return dp[K%2][n] ", "class Solution def longestConsecutive(self, root): def longestConsecutiveHelper(root): if not root: return 0, 0 left_len = longestConsecutiveHelper(root.left) right_len = longestConsecutiveHelper(root.right) cur_inc_len, cur_dec_len = 1, 1 if root.left: if root.left.val == root.val + 1: cur_inc_len = max(cur_inc_len, left_len[0] + 1) elif root.left.val == root.val - 1: cur_dec_len = max(cur_dec_len, left_len[1] + 1) if root.right: if root.right.val == root.val + 1: cur_inc_len = max(cur_inc_len, right_len[0] + 1) elif root.right.val == root.val - 1: cur_dec_len = max(cur_dec_len, right_len[1] + 1) self.max_len = max(self.max_len, cur_dec_len + cur_inc_len - 1) return cur_inc_len, cur_dec_len self.max_len = 0 longestConsecutiveHelper(root) return self.max_len ", "class Solution def __init__(self, head): self.__head = head def getRandom(self): reservoir = -1 curr, n = self.__head, 0 while curr: reservoir = curr.val if randint(1, n+1) == 1 else reservoir curr, n = curr.next, n+1 return reservoir ", "class Solution def digitCount(self, num): cnt = collections.Counter(num) return all(cnt[str(i)] == int(x) for i, x in enumerate(num)) ", "class Solution def rearrangeArray(self, nums): def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 def reversedTriPartitionWithVI(nums, val): def idx(i, N): return (1 + 2 * (i)) % N N = len(nums)//2 * 2 + 1 i, j, n = 0, 0, len(nums) - 1 while j <= n: if nums[idx(j, N)] > val: nums[idx(i, N)], nums[idx(j, N)] = nums[idx(j, N)], nums[idx(i, N)] i += 1 j += 1 elif nums[idx(j, N)] < val: nums[idx(j, N)], nums[idx(n, N)] = nums[idx(n, N)], nums[idx(j, N)] n -= 1 else: j += 1 mid = (len(nums)-1)//2 nth_element(nums, mid) reversedTriPartitionWithVI(nums, nums[mid]) return nums ", "class Solution def rearrangeArray(self, nums): nums.sort() mid = (len(nums)-1)//2 nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1] return nums ", "class Solution def bitwiseComplement(self, N): mask = 1 while N > mask: mask = mask*2+1 return mask-N ", "class Solution def resultGrid(self, image, threshold): def check(i, j): return (all(abs(image[ni][nj]-image[ni+1][nj]) <= threshold for ni in xrange(i-1, i+1) for nj in xrange(j-1, j+2)) and all(abs(image[ni][nj]-image[ni][nj+1]) <= threshold for ni in xrange(i-1, i+2) for nj in xrange(j-1, j+1))) result = [[0]*len(image[0]) for _ in xrange(len(image))] cnt = [[0]*len(image[0]) for _ in xrange(len(image))] for i in xrange(1, len(image)-1): for j in xrange(1, len(image[0])-1): if not check(i, j): continue total = sum(image[ni][nj] for ni in xrange(i-1, i+2) for nj in xrange(j-1, j+2))//9 for ni in xrange(i-1, i+2): for nj in xrange(j-1, j+2): cnt[ni][nj] += 1 result[ni][nj] += total for i in xrange(len(image)): for j in xrange(len(image[0])): if cnt[i][j]: result[i][j] //= cnt[i][j] else: result[i][j] = image[i][j] return result ", "class Solution def guessNumber(self, n): left, right = 1, n while left <= right: mid = left + (right - left) / 2 if guess(mid) <= 0: right = mid - 1 else: left = mid + 1 return left ", "class Solution def countEven(self, num): def parity(x): result = 0 while x: result += x%10 x //= 10 return result%2 return (num-parity(num))//2 ", "class Solution def countEven(self, num): def parity(x): result = 0 while x: result += x%10 x //= 10 return result%2 return sum(parity(x) == 0 for x in xrange(1, num+1)) ", "class Solution def countEven(self, num): return sum(sum(map(int, str(x)))%2 == 0 for x in xrange(1, num+1)) ", "class Solution def canIWin(self, maxChoosableInteger, desiredTotal): def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup): if visited in lookup: return lookup[visited] mask = 1 for i in xrange(maxChoosableInteger): if visited & mask == 0: if i + 1 >= desiredTotal or not canIWinHelper(maxChoosableInteger, desiredTotal - (i + 1), visited | mask, lookup): lookup[visited] = True return True mask <<= 1 lookup[visited] = False return False if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal: return False return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {}) ", "class Solution def customSortString(self, S, T): counter, s = collections.Counter(T), set(S) result = [c*counter[c] for c in S] result.extend([c*counter for c, counter in counter.iteritems() if c not in s]) return \"\".join(result) ", "class Solution def canPlaceFlowers(self, flowerbed, n): for i in xrange(len(flowerbed)): if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and (i == len(flowerbed)-1 or flowerbed[i+1] == 0): flowerbed[i] = 1 n -= 1 if n <= 0: return True return False ", "class Solution def maxResult(self, nums, k): score = 0 dq = collections.deque() for i, num in enumerate(nums): if dq and dq[0][0] == i-k-1: dq.popleft() score = num if not dq else dq[0][1]+num while dq and dq[-1][1] <= score: dq.pop() dq.append((i, score)) return score ", "class Solution def nimGame(self, piles): return reduce(operator.xor, piles, 0) ", "class Solution def numFactoredBinaryTrees(self, A): M = 10**9 + 7 A.sort() dp = {} for i in xrange(len(A)): dp[A[i]] = 1 for j in xrange(i): if A[i] % A[j] == 0 and A[i] // A[j] in dp: dp[A[i]] += dp[A[j]] * dp[A[i] // A[j]] dp[A[i]] %= M return sum(dp.values()) % M ", "class Solution def maxSum(self, nums): def max_digit(x): result = 0 while x: x, r = divmod(x, 10) result = max(result, r) return result result = -1 lookup = {} for x in nums: mx = max_digit(x) if mx not in lookup: lookup[mx] = x continue result = max(result, lookup[mx]+x) lookup[mx] = max(lookup[mx], x) return result ", "class Solution def averageOfLevels(self, root): result = [] q = [root] while q: total, count = 0, 0 next_q = [] for n in q: total += n.val count += 1 if n.left: next_q.append(n.left) if n.right: next_q.append(n.right) q = next_q result.append(float(total) / count) return result ", "class Solution def findMin(self, nums): left, right = 0, len(nums) target = nums[-1] while left < right: mid = left + (right - left) / 2 if nums[mid] <= target: right = mid else: left = mid + 1 return nums[left] ", "class Solution def findMin(self, nums): left, right = 0, len(nums) - 1 while left < right and nums[left] >= nums[right]: mid = left + (right - left) / 2 if nums[mid] < nums[left]: right = mid else: left = mid + 1 return nums[left] ", "class Solution def findPairs(self, nums, k): if k < 0: return 0 result, lookup = set(), set() for num in nums: if num-k in lookup: result.add(num-k) if num+k in lookup: result.add(num) lookup.add(num) return len(result) ", "class Solution def findTilt(self, root): def postOrderTraverse(root, tilt): if not root: return 0, tilt left, tilt = postOrderTraverse(root.left, tilt) right, tilt = postOrderTraverse(root.right, tilt) tilt += abs(left-right) return left+right+root.val, tilt return postOrderTraverse(root, 0)[1] ", "class Solution def getAncestors(self, n, edges): def iter_dfs(adj, i, result): lookup = [False]*len(adj) stk = [i] while stk: u = stk.pop() for v in reversed(adj[u]): if lookup[v]: continue lookup[v] = True stk.append(v) result[v].append(i) adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) result = [[] for _ in xrange(n)] for u in xrange(n): iter_dfs(adj, u, result) return result ", "class Solution def getAncestors(self, n, edges): def bfs(adj, i, result): lookup = [False]*len(adj) q = [i] lookup[i] = True while q: new_q = [] for u in q: for v in adj[u]: if lookup[v]: continue lookup[v] = True new_q.append(v) result[i].append(v) q = new_q result[i].sort() adj = [[] for _ in xrange(n)] for u, v in edges: adj[v].append(u) result = [[] for _ in xrange(n)] for u in xrange(n): bfs(adj, u, result) return result ", "class Solution def getAncestors(self, n, edges): result = [set() for _ in xrange(n)] in_degree = [0]*n adj = [[] for _ in xrange(n)] for u, v in edges: adj[u].append(v) in_degree[v] += 1 result[v].add(u) q = [u for u, d in enumerate(in_degree) if not d] while q: new_q = [] for u in q: for v in adj[u]: result[v].update(result[u]) in_degree[v] -= 1 if not in_degree[v]: new_q.append(v) q = new_q return [sorted(s) for s in result] ", "class Solution def checkEquivalence(self, root1, root2): def add_counter(counter, prev, d, val): if val.isalpha(): counter[ord(val)-ord('a')] += d if prev[0] == '+' else -d prev[0] = val def morris_inorder_traversal(root, cb): curr = root while curr: if curr.left is None: cb(curr.val) curr = curr.right else: node = curr.left while node.right and node.right != curr: node = node.right if node.right is None: node.right = curr curr = curr.left else: cb(curr.val) node.right = None curr = curr.right counter = collections.defaultdict(int) morris_inorder_traversal(root1, functools.partial(add_counter, counter, ['+'], 1)) morris_inorder_traversal(root2, functools.partial(add_counter, counter, ['+'], -1)) return all(v == 0 for v in counter.itervalues()) import collections import functools ", "class Solution def checkEquivalence(self, root1, root2): def add_counter(counter, prev, d, val): if val.isalpha(): counter[ord(val)-ord('a')] += d if prev[0] == '+' else -d prev[0] = val def inorder_traversal(root, cb): def traverseLeft(node, stk): while node: stk.append(node) node = node.left stk = [] traverseLeft(root, stk) while stk: curr = stk.pop() cb(curr.val) traverseLeft(curr.right, stk) counter = collections.defaultdict(int) inorder_traversal(root1, functools.partial(add_counter, counter, ['+'], 1)) inorder_traversal(root2, functools.partial(add_counter, counter, ['+'], -1)) return all(v == 0 for v in counter.itervalues()) ", "class Solution def lastRemaining(self, n): start, step, direction = 1, 2, 1 while n > 1: start += direction * (step * (n//2) - step//2) n //= 2 step *= 2 direction *= -1 return start ", "class Solution def circularGameLosers(self, n, k): lookup = [False]*n idx = 0 for i in xrange(n): if lookup[idx]: break lookup[idx] = True idx = (idx+(i+1)*k)%n return [i+1 for i in xrange(n) if not lookup[i]] ", "class Solution def lengthOfLastWord(self, s): length = 0 for i in reversed(s): if i == ' ': if length: break else: length += 1 return length ", "class Solution def lengthOfLastWord(self, s): return len(s.strip().split(\" \")[-1]) ", "class Solution def minSubarray(self, nums, p): residue = sum(nums) % p if not residue: return 0 result = len(nums) curr, lookup = 0, {0: -1} for i, num in enumerate(nums): curr = (curr+num) % p lookup[curr] = i if (curr-residue) % p in lookup: result = min(result, i-lookup[(curr-residue)%p]) return result if result < len(nums) else -1 ", "class Solution def letterCasePermutation(self, S): result = [[]] for c in S: if c.isalpha(): for i in xrange(len(result)): result.append(result[i][:]) result[i].append(c.lower()) result[-1].append(c.upper()) else: for s in result: s.append(c) return map(\"\".join, result) ", "class Solution def closestPrimes(self, left, right): i = bisect.bisect_left(PRIMES, left) j = bisect.bisect_right(PRIMES, right)-1 return ST.query(i, j-1)[1] if i <= j-1 else [-1]*2 ", "class Solution def canFormArray(self, arr, pieces): lookup = {x[0]: i for i, x in enumerate(pieces)} i = 0 while i < len(arr): if arr[i] not in lookup: return False for c in pieces[lookup[arr[i]]]: if i == len(arr) or arr[i] != c: return False i += 1 return True ", "class Solution def minimumPossibleSum(self, n, target): def arithmetic_progression_sum(a, d, n): return (a+(a+(n-1)*d))*n//2 a = min(target//2, n) b = n-a return arithmetic_progression_sum(1, 1, a)+arithmetic_progression_sum(target, 1, b) ", "class Solution def evaluateTree(self, root): INF = float(\"inf\") OP = { 2: lambda x, y: x or y, 3: lambda x, y: x and y } def iter_dfs(root): ret = [0] stk = [(1, (root, ret))] while stk: step, args = stk.pop() if step == 1: node, ret = args if node.left == node.right: ret[0] = node.val continue ret1, ret2 = [0], [0] stk.append((2, (node, ret1, ret2, ret))) stk.append((1, (node.right, ret2))) stk.append((1, (node.left, ret1))) elif step == 2: node, ret1, ret2, ret = args ret[0] = OP[node.val](ret1[0], ret2[0]) return ret[0] return iter_dfs(root) ", "class Solution def evaluateTree(self, root): INF = float(\"inf\") OP = { 2: lambda x, y: x or y, 3: lambda x, y: x and y, } def dfs(node): if node.left == node.right: return node.val return OP[node.val](dfs(node.left), dfs(node.right)) return dfs(root) ", "class Solution def findSubarrays(self, nums): lookup = set() for i in xrange(len(nums)-1): if nums[i]+nums[i+1] in lookup: return True lookup.add(nums[i]+nums[i+1]) return False ", "class Solution def climbStairs(self, n): def matrix_expo(A, K): result = [[int(i==j) for j in xrange(len(A))] for i in xrange(len(A))] while K: if K % 2: result = matrix_mult(result, A) A = matrix_mult(A, A) K /= 2 return result def matrix_mult(A, B): ZB = zip(*B) return [[sum(a*b for a, b in itertools.izip(row, col)) for col in ZB] for row in A] T = [[1, 1], [1, 0]] return matrix_mult([[1, 0]], matrix_expo(T, n))[0][0] ", "class Solution def climbStairs(self, n): prev, current = 0, 1 for i in xrange(n): prev, current = current, prev + current, return current ", "class Solution def lastSubstring(self, s): left, right, l = 0, 1, 0 while right+l < len(s): if s[left+l] == s[right+l]: l += 1 continue if s[left+l] > s[right+l]: right += l+1 else: left = max(right, left+l+1) right = left+1 l = 0 return s[left:] import collections ", "class Solution def lastSubstring(self, s): count = collections.defaultdict(list) for i in xrange(len(s)): count[s[i]].append(i) max_c = max(count.iterkeys()) starts = {} for i in count[max_c]: starts[i] = i+1 while len(starts)-1 > 0: lookup = set() next_count = collections.defaultdict(list) for start, end in starts.iteritems(): if end == len(s): lookup.add(start) continue next_count[s[end]].append(start) if end in starts: lookup.add(end) next_starts = {} max_c = max(next_count.iterkeys()) for start in next_count[max_c]: if start not in lookup: next_starts[start] = starts[start]+1 starts = next_starts return s[next(starts.iterkeys()):] ", "class Solution def firstUniqChar(self, s): lookup = defaultdict(int) candidtates = set() for i, c in enumerate(s): if lookup[c]: candidtates.discard(lookup[c]) else: lookup[c] = i+1 candidtates.add(i+1) return min(candidtates)-1 if candidtates else -1 ", "class Solution def canReach(self, s, minJump, maxJump): dp = [False]*len(s) dp[0] = True cnt = 0 for i in xrange(1, len(s)): if i >= minJump: cnt += dp[i-minJump] if i > maxJump: cnt -= dp[i-maxJump-1] dp[i] = cnt > 0 and s[i] == '0' return dp[-1] import collections ", "class Solution def canReach(self, s, minJump, maxJump): q = collections.deque([0]) reachable = 0 while q: i = q.popleft() for j in xrange(max(i+minJump, reachable+1), min(i+maxJump+1, len(s))): if s[j] != '0': continue q.append(j) reachable = i+maxJump return i == len(s)-1 ", "class Solution def findMode(self, root): def inorder(root, prev, cnt, max_cnt, result): if not root: return prev, cnt, max_cnt prev, cnt, max_cnt = inorder(root.left, prev, cnt, max_cnt, result) if prev: if root.val == prev.val: cnt += 1 else: cnt = 1 if cnt > max_cnt: max_cnt = cnt del result[:] result.append(root.val) elif cnt == max_cnt: result.append(root.val) return inorder(root.right, root, cnt, max_cnt, result) if not root: return [] result = [] inorder(root, None, 1, 0, result) return result ", "class Solution def flipLights(self, n, m): if m == 0: return 1 if n == 1: return 2 if m == 1 and n == 2: return 3 if m == 1 or n == 2: return 4 if m == 2: return 7 return 8 ", "class Solution def accountsMerge(self, accounts): union_find = UnionFind() email_to_name = {} email_to_id = {} for account in accounts: name = account[0] for i in xrange(1, len(account)): if account[i] not in email_to_id: email_to_name[account[i]] = name email_to_id[account[i]] = union_find.get_id() union_find.union_set(email_to_id[account[1]], email_to_id[account[i]]) result = collections.defaultdict(list) for email in email_to_name.keys(): result[union_find.find_set(email_to_id[email])].append(email) for emails in result.values(): emails.sort() return [[email_to_name[emails[0]]] + emails for emails in result.values()] ", "class Solution def isReachableAtTime(self, sx, sy, fx, fy, t): diff1, diff2 = abs(sx-fx), abs(sy-fy) mn = min(diff1, diff2)+abs(diff1-diff2) return t >= mn if mn else t != 1 ", "class Solution def canFinish(self, numCourses, prerequisites): adj = collections.defaultdict(list) in_degree = collections.Counter() for u, v in prerequisites: in_degree[u] += 1 adj[v].append(u) result = [] q = [u for u in xrange(numCourses) if u not in in_degree] while q: new_q = [] for u in q: result.append(u) for v in adj[u]: in_degree[v] -= 1 if in_degree[v] == 0: new_q.append(v) q = new_q return len(result) == numCourses import collections ", "class Solution def canFinish(self, numCourses, prerequisites): adj = collections.defaultdict(list) in_degree = collections.Counter() for u, v in prerequisites: in_degree[u] += 1 adj[v].append(u) result = [] stk = [u for u in xrange(numCourses) if u not in in_degree] while stk: u = stk.pop() result.append(u) for v in adj[u]: in_degree[v] -= 1 if in_degree[v] == 0: stk.append(v) return len(result) == numCourses ", "class Solution def theMaximumAchievableX(self, num, t): return num+2*t ", "class Solution def checkZeroOnes(self, s): max_cnt = [0]*2 cnt = 0 for i in xrange(len(s)+1): if i == len(s) or (i >= 1 and s[i] != s[i-1]): max_cnt[int(s[i-1])] = max(max_cnt[int(s[i-1])], cnt) cnt = 0 cnt += 1 return max_cnt[0] < max_cnt[1] ", "class Solution def canSortArray(self, nums): def popcount(x): return bin(x).count(\"1\") left = mx = 0 for right in xrange(len(nums)): if right+1 != len(nums) and popcount(nums[right+1]) == popcount(nums[right]): continue if mx > min(nums[i] for i in xrange(left, right+1)): return False mx = max(nums[i] for i in xrange(left, right+1)) left = right+1 return True import itertools ", "class Solution def canSortArray(self, nums): def popcount(x): return bin(x).count(\"1\") def pairwise(it): a, b = tee(it) next(b, None) return itertools.izip(a, b) return all(max(a) <= min(b) for a, b in pairwise(list(it) for key, it in groupby(nums, popcount))) ", "class Solution def canSortArray(self, nums): def popcount(x): return bin(x).count(\"1\") left = 0 for right in xrange(len(nums)): if right+1 != len(nums) and popcount(nums[right+1]) == popcount(nums[right]): continue nums[left:right+1] = sorted(nums[left:right+1]) left = right+1 return all(nums[i] <= nums[i+1] for i in xrange(len(nums)-1)) ", "class Solution def findAllPeople(self, n, meetings, firstPerson): meetings.sort(key=lambda x: x[2]) result = {0, firstPerson} adj = collections.defaultdict(list) for i, (x, y, _) in enumerate(meetings): adj[x].append(y) adj[y].append(x) if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]: continue q = [i for i in adj.iterkeys() if i in result] while q: new_q = [] for u in q: for v in adj[u]: if v in result: continue result.add(v) new_q.append(v) q = new_q adj = collections.defaultdict(list) return list(result) import collections ", "class Solution def findAllPeople(self, n, meetings, firstPerson): meetings.sort(key=lambda x: x[2]) result = {0, firstPerson} adj = collections.defaultdict(list) for i, (x, y, _) in enumerate(meetings): adj[x].append(y) adj[y].append(x) if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]: continue stk = [i for i in adj.iterkeys() if i in result] while stk: u = stk.pop() for v in adj[u]: if v in result: continue result.add(v) stk.append(v) adj = collections.defaultdict(list) return list(result) class UnionFind(object): def __init__(self, n): self.set = range(n) self.rank = [0]*n def find_set(self, x): stk = [] while self.set[x] != x: stk.append(x) x = self.set[x] while stk: self.set[stk.pop()] = x return x def union_set(self, x, y): x, y = self.find_set(x), self.find_set(y) if x == y: return False if self.rank[x] > self.rank[y]: x, y = y, x self.set[x] = self.set[y] if self.rank[x] == self.rank[y]: self.rank[y] += 1 return True def reset(self, x): self.set[x] = x self.rank[x] = 0 ", "class Solution def findAllPeople(self, n, meetings, firstPerson): meetings.sort(key=lambda x: x[2]) uf = UnionFind(n) uf.union_set(0, firstPerson) group = set() for i, (x, y, _) in enumerate(meetings): group.add(x) group.add(y) uf.union_set(x, y) if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]: continue while group: x = group.pop() if uf.find_set(x) != uf.find_set(0): uf.reset(x) return [i for i in xrange(n) if uf.find_set(i) == uf.find_set(0)] ", "class Solution def numberOfArithmeticSlices(self, A): res, i = 0, 0 while i+2 < len(A): start = i while i+2 < len(A) and A[i+2] + A[i] == 2*A[i+1]: res += i - start + 1 i += 1 i += 1 return res ", "class Solution def maxProfit(self, prices): max_profit, min_price = 0, float(\"inf\") for price in prices: min_price = min(min_price, price) max_profit = max(max_profit, price - min_price) return max_profit ", "class Solution def generateAbbreviations(self, word): def generateAbbreviationsHelper(word, i, cur, res): if i == len(word): res.append(\"\".join(cur)) return cur.append(word[i]) generateAbbreviationsHelper(word, i + 1, cur, res) cur.pop() if not cur or not cur[-1][-1].isdigit(): for l in xrange(1, len(word) - i + 1): cur.append(str(l)) generateAbbreviationsHelper(word, i + l, cur, res) cur.pop() res, cur = [], [] generateAbbreviationsHelper(word, 0, cur, res) return res ", "class Solution def divisibilityArray(self, word, m): result = [] curr = 0 for c in word: curr = (curr*10+(ord(c)-ord('0')))%m result.append(int(curr == 0)) return result ", "class Solution def largestRectangleArea(self, heights): stk, result = [-1], 0 for i in xrange(len(heights)+1): while stk[-1] != -1 and (i == len(heights) or heights[stk[-1]] >= heights[i]): result = max(result, heights[stk.pop()]*((i-1)-stk[-1])) stk.append(i) return result ", "class Solution def distributeCookies(self, cookies, k): total = [0]*(1<<len(cookies)) for mask in xrange(1<<len(cookies)): total[mask] = sum(cookies[i] for i in xrange(len(cookies)) if mask&(1<<i)) dp = [[float(\"inf\")]*(1<<len(cookies)) for _ in xrange(2)] dp[0][0] = 0 for i in xrange(k): for mask in xrange(1<<len(cookies)): submask = mask while submask: dp[(i+1)%2][mask] = min(dp[(i+1)%2][mask], max(total[submask], dp[i%2][mask^submask])) submask = (submask-1)&mask return dp[k%2][-1] ", "class Solution def maxEqualRowsAfterFlips(self, matrix): count = collections.Counter(tuple(x^row[0] for x in row) for row in matrix) return max(count.itervalues()) ", "class Solution def kthPalindrome(self, queries, intLength): def reverse(x): result = 0 while x: result = result*10+x%10 x //= 10 return result def f(l, x): x = 10**((l-1)//2)+(x-1) if x > 10**((l+1)//2)-1: return -1 return x*10**(l//2)+reverse(x//10 if l%2 else x) return [f(intLength, x) for x in queries] ", "class Solution def kthPalindrome(self, queries, intLength): def f(l, x): if 10**((l-1)//2)+(x-1) > 10**((l+1)//2)-1: return -1 s = str(10**((l-1)//2)+(x-1)) return int(s+s[::-1][l%2:]) return [f(intLength, x) for x in queries] ", "class Solution def leadsToDestination(self, n, edges, source, destination): UNVISITED, VISITING, DONE = range(3) def dfs(children, node, destination, status): if status[node] == DONE: return True if status[node] == VISITING: return False status[node] = VISITING if node not in children and node != destination: return False if node in children: for child in children[node]: if not dfs(children, child, destination, status): return False status[node] = DONE return True children = collections.defaultdict(list) for parent, child in edges: children[parent].append(child) return dfs(children, source, destination, [0]*n) ", "class Solution def minFlipsMonoIncr(self, S): flip0, flip1 = 0, 0 for c in S: flip0 += int(c == '1') flip1 = min(flip0, flip1 + int(c == '0')) return flip1 ", "class Solution def isOneBitCharacter(self, bits): parity = 0 for i in reversed(xrange(len(bits)-1)): if bits[i] == 0: break parity ^= bits[i] return parity == 0 ", "class Solution def differenceOfSum(self, nums): def total(x): result = 0 while x: result += x%10 x //= 10 return result return abs(sum(nums)-sum(total(x) for x in nums)) ", "class Solution def findLatestTime(self, s): result = list(s) if result[0] == '?': result[0] = '1' if result[1] == '?' or result[1] <= '1' else '0' if result[1] == '?': result[1] = '1' if result[0] == '1' else '9' if result[3] == '?': result[3] = '5' if result[4] == '?': result[4] = '9' return \"\".join(result) ", "class Solution def triangularSum(self, nums): def exp_mod(p, mod): result = [p] while result[-1]*p%10 != result[0]: result.append(result[-1]*p%10) return [result[-1]]+result[:-1] def inv_mod(x, mod): y = x while y*x%10 != 1: y = y*x%10 return y def factor_p(x, p, cnt, diff): if x == 0: return x, cnt while x%p == 0: x //= p cnt += diff return x, cnt EXP = {p:exp_mod(p, 10) for p in (2, 5)} INV = {i:inv_mod(i, 10) for i in xrange(1, 10) if i%2 and i%5} result = 0 nCr = 1 cnt = {2:0, 5:0} for i in xrange(len(nums)): if not cnt[2] and not cnt[5]: result = (result + nCr*nums[i])%10 elif cnt[2] and not cnt[5]: result = (result + nCr*EXP[2][cnt[2]%len(EXP[2])]*nums[i])%10 elif not cnt[2] and cnt[5]: result = (result + nCr*EXP[5][cnt[5]%len(EXP[5])]*nums[i])%10 mul, cnt[2] = factor_p((len(nums)-1)-i, 2, cnt[2], 1) mul, cnt[5] = factor_p(mul, 5, cnt[5], 1) div, cnt[2] = factor_p(i+1, 2, cnt[2], -1) div, cnt[5] = factor_p(div, 5, cnt[5], -1) nCr = nCr*mul%10 nCr = nCr*INV[div%10]%10 return result ", "class Solution def triangularSum(self, nums): result = 0 nCr = 1 for i in xrange(len(nums)): result = (result+nCr*nums[i])%10 nCr *= (len(nums)-1)-i nCr //= i+1 return result ", "class Solution def triangularSum(self, nums): for i in reversed(xrange(len(nums))): for j in xrange(i): nums[j] = (nums[j]+nums[j+1])%10 return nums[0] ", "class Solution def isHappy(self, n): lookup = {} while n != 1 and n not in lookup: lookup[n] = True n = self.nextNumber(n) return n == 1 def nextNumber(self, n): new = 0 for char in str(n): new += int(char)**2 return new ", "class Solution def canBeEqual(self, target, arr): return collections.Counter(target) == collections.Counter(arr) ", "class Solution def canBeEqual(self, target, arr): target.sort(), arr.sort() return target == arr ", "class Solution def canConstruct(self, s, k): count = collections.Counter(s) odd = sum(v%2 for v in count.itervalues()) return odd <= k <= len(s) ", "class Solution def queryString(self, S, N): return all(bin(i)[2:] in S for i in reversed(xrange(N//2, N+1))) ", "class Solution def canSplitArray(self, nums, m): return len(nums) <= 2 or any(nums[i]+nums[i+1] >= m for i in xrange(len(nums)-1)) ", "class Solution def magicalString(self, n): def gen(): for c in 1, 2, 2: yield c for i, c in enumerate(gen()): if i > 1: for _ in xrange(c): yield i % 2 + 1 return sum(c & 1 for c in itertools.islice(gen(), n)) ", "class Solution def lexicalOrder(self, n): result = [] i = 1 while len(result) < n: k = 0 while i * 10**k <= n: result.append(i * 10**k) k += 1 num = result[-1] + 1 while num <= n and num % 10: result.append(num) num += 1 if not num % 10: num -= 1 else: num /= 10 while num % 10 == 9: num /= 10 i = num+1 return result ", "class Solution def findMaxConsecutiveOnes(self, nums): result, prev, curr = 0, 0, 0 for n in nums: if n == 0: result = max(result, prev+curr+1) prev, curr = curr, 0 else: curr += 1 return min(max(result, prev+curr+1), len(nums)) ", "class Solution def areSimilar(self, mat, k): return all(row[i] == row[(i+k)%len(row)]for row in mat for i in xrange(len(row))) ", "class Solution def distinctDifferenceArray(self, nums): result = [0]*len(nums) lookup = set() for i in xrange(len(nums)): lookup.add(nums[i]) result[i] = len(lookup) lookup.clear() for i in reversed(xrange(len(nums))): result[i] -= len(lookup) lookup.add(nums[i]) return result ", "class Solution def canDistribute(self, nums, quantity): def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 count = collections.Counter(nums) total = (1<<len(quantity))-1 requirement = [0]*(total+1) for mask in xrange(len(requirement)): base = 1 for i in xrange(len(quantity)): if mask&base: requirement[mask] += quantity[i]; base <<= 1 dp = [[0]*(total+1) for _ in xrange(2)] dp[0][0] = 1 i = 0 cnts = count.values() if len(quantity) < len(cnts): nth_element(cnts, len(quantity)-1, lambda a, b: a > b) cnts = cnts[:len(quantity)] for cnt in cnts: dp[(i+1)%2] = [0]*(total+1) for mask in reversed(xrange(total+1)): dp[(i+1)%2][mask] |= dp[i%2][mask] submask = mask while submask > 0: if requirement[submask] <= cnt and dp[i%2][mask^submask]: dp[(i+1)%2][mask] = 1 submask = (submask-1)&mask i += 1 return dp[len(cnts)%2][total] ", "class Solution def houseCount(self, street, k): for _ in xrange(k): street.closeDoor() street.moveRight() for result in xrange(k+1): if street.isDoorOpen(): break street.openDoor() street.moveRight() return result ", "class Solution def countWays(self, nums): cnt = [0]*(len(nums)+1) for x in nums: cnt[x] += 1 result = prefix = 0 for i in xrange(len(nums)+1): if prefix == i and cnt[i] == 0: result += 1 prefix += cnt[i] return result ", "class Solution def countWays(self, nums): nums.sort() return sum((i == 0 or nums[i-1] < i) and (i == len(nums) or nums[i] > i) for i in xrange(len(nums)+1)) ", "class Solution def findDuplicate(self, paths): files = collections.defaultdict(list) for path in paths: s = path.split(\" \") for i in xrange(1,len(s)): file_name = s[0] + \"/\" + s[i][0:s[i].find(\"(\")] file_content = s[i][s[i].find(\"(\")+1:s[i].find(\")\")] files[file_content].append(file_name) result = [] for file_content, file_names in files.iteritems(): if len(file_names)>1: result.append(file_names) return result ", "class Solution def hIndex(self, citations): n = len(citations) count = [0] * (n + 1) for x in citations: if x >= n: count[n] += 1 else: count[x] += 1 h = 0 for i in reversed(xrange(0, n + 1)): h += count[i] if h >= i: return i return h ", "class Solution def hIndex(self, citations): citations.sort(reverse=True) h = 0 for x in citations: if x >= h + 1: h += 1 else: break return h ", "class Solution def hIndex(self, citations): return sum(x >= i + 1 for i, x in enumerate(sorted(citations, reverse=True))) ", "class Solution def isConvex(self, points): def det(A): return A[0][0]*A[1][1] - A[0][1]*A[1][0] n, prev, curr = len(points), 0, None for i in xrange(len(points)): A = [[points[(i+j) % n][0] - points[i][0], points[(i+j) % n][1] - points[i][1]] for j in (1, 2)] curr = det(A) if curr: if curr * prev < 0: return False prev = curr return True ", "class Solution def gridGame(self, grid): result = float(\"inf\") left, right = 0, sum(grid[0]) for a, b in itertools.izip(grid[0], grid[1]): right -= a result = min(result, max(left, right)) left += b return result ", "class Solution def maximumLengthOfRanges(self, nums): result = [0]*len(nums) stk = [-1] nums.append(float(\"inf\")) for i, x in enumerate(nums): while stk[-1] != -1 and nums[stk[-1]] < x: j = stk.pop() result[j] = (i-1)-stk[-1] stk.append(i) return result ", "class Solution def maxSubsequence(self, nums, k): def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 partition = nums[:] nth_element(partition, k-1, compare=lambda a, b: a > b) cnt = sum(partition[i] == partition[k-1] for i in xrange(k)) result = [] for x in nums: if x > partition[k-1]: result.append(x) elif x == partition[k-1] and cnt > 0: cnt -= 1 result.append(x) return result ", "class Solution def judgePoint24(self, nums): if len(nums) == 1: return abs(nums[0]-24) < 1e-6 ops = [add, sub, mul, truediv] for i in xrange(len(nums)): for j in xrange(len(nums)): if i == j: continue next_nums = [nums[k] for k in xrange(len(nums)) if i != k != j] for op in ops: if ((op is add or op is mul) and j > i) or (op == truediv and nums[j] == 0): continue next_nums.append(op(nums[i], nums[j])) if self.judgePoint24(next_nums): return True next_nums.pop() return False ", "class Solution def judgePoint24(self, nums): def dfs(nums): if len(nums) == 1: return nums[0] == 24 ops = [add, sub, mul, truediv] for i in xrange(len(nums)): for j in xrange(len(nums)): if i == j: continue next_nums = [nums[k] for k in xrange(len(nums)) if i != k != j] for op in ops: if ((op is add or op is mul) and j > i) or (op == truediv and nums[j] == 0): continue next_nums.append(op(nums[i], nums[j])) if dfs(next_nums): return True next_nums.pop() return False return dfs(map(Fraction, nums)) ", "class Solution def differenceOfDistinctValues(self, grid): def update(i, j): lookup = set() for k in xrange(min(len(grid)-i, len(grid[0])-j)): result[i+k][j+k] = len(lookup) lookup.add(grid[i+k][j+k]) lookup.clear() for k in reversed(xrange(min(len(grid)-i, len(grid[0])-j))): result[i+k][j+k] = abs(result[i+k][j+k]-len(lookup)) lookup.add(grid[i+k][j+k]) result = [[0]*len(grid[0]) for _ in xrange(len(grid))] for j in xrange(len(grid[0])): update(0, j) for i in xrange(1, len(grid)): update(i, 0) return result ", "class Solution def minCost(self, nums, costs): stk1, stk2 = [], [] dp = [float(\"inf\")]*len(nums) dp[0] = 0 for i in xrange(len(nums)): while stk1 and nums[stk1[-1]] <= nums[i]: dp[i] = min(dp[i], dp[stk1.pop()]+costs[i]) stk1.append(i) while stk2 and nums[stk2[-1]] > nums[i]: dp[i] = min(dp[i], dp[stk2.pop()]+costs[i]) stk2.append(i) return dp[-1] ", "class Solution def leastOpsExpressTarget(self, x, target): pos, neg, k = 0, 0, 0 while target: target, r = divmod(target, x) if k: pos, neg = min(r*k + pos, (r+1)*k + neg), min((x-r)*k + pos, (x-r-1)*k + neg) else: pos, neg = r*2, (x-r)*2 k += 1 return min(pos, k+neg) - 1 ", "class Solution def averageHeightOfBuildings(self, buildings): points = [] for x, y, h in buildings: points.append((x, 1, h)) points.append((y, -1, h)) points.sort() result = [] total = cnt = 0 prev = -1 for curr, c, h in points: if cnt and curr != prev: if result and result[-1][1] == prev and result[-1][2] == total//cnt: result[-1][1] = curr else: result.append([prev, curr, total//cnt]) total += h*c cnt += c prev = curr return result import collections ", "class Solution def averageHeightOfBuildings(self, buildings): count = collections.defaultdict(lambda: (0, 0)) for x, y, h in buildings: count[x] = (count[x][0]+1, count[x][1]+h) count[y] = (count[y][0]-1, count[y][1]-h) result = [] total = cnt = 0 prev = -1 for curr, (c, h) in sorted(count.iteritems()): if cnt: if result and result[-1][1] == prev and result[-1][2] == total//cnt: result[-1][1] = curr else: result.append([prev, curr, total//cnt]) total += h cnt += c prev = curr return result ", "class Solution def waysToFillArray(self, queries): MOD = 10**9+7 fact, inv, inv_fact = [[1]*2 for _ in xrange(3)] def nCr(n, k): while len(inv) <= n: fact.append(fact[-1]*len(inv) % MOD) inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD) inv_fact.append(inv_fact[-1]*inv[-1] % MOD) return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD def linear_sieve_of_eratosthenes(n): primes = [] spf = [-1]*(n+1) for i in xrange(2, n+1): if spf[i] == -1: spf[i] = i primes.append(i) for p in primes: if i*p > n or p > spf[i]: break spf[i*p] = p return primes def prime_factors(x): factors = collections.Counter() for p in primes: if p*p > x: break while x%p == 0: factors[p] += 1 x //= p if x != 1: factors[x] += 1 return factors primes = linear_sieve_of_eratosthenes(int(max(k for _, k in queries)**0.5)) result = [] for n, k in queries: total = 1 for c in prime_factors(k).itervalues(): total *= nCr(n+c-1, c) result.append(total % MOD) return result ", "class Solution def arrayStringsAreEqual(self, word1, word2): idx1 = idx2 = arr_idx1 = arr_idx2 = 0 while arr_idx1 < len(word1) and arr_idx2 < len(word2): if word1[arr_idx1][idx1] != word2[arr_idx2][idx2]: break idx1 += 1 if idx1 == len(word1[arr_idx1]): idx1 = 0 arr_idx1 += 1 idx2 += 1 if idx2 == len(word2[arr_idx2]): idx2 = 0 arr_idx2 += 1 return arr_idx1 == len(word1) and arr_idx2 == len(word2) ", "class Solution def digArtifacts(self, n, artifacts, dig): lookup = set(map(tuple, dig)) return sum(all((i, j) in lookup for i in xrange(r1, r2+1) for j in xrange(c1, c2+1)) for r1, c1, r2, c2 in artifacts) ", "class Solution def digArtifacts(self, n, artifacts, dig): lookup = {(i, j):idx for idx, (r1, c1, r2, c2) in enumerate(artifacts) for i in xrange(r1, r2+1) for j in xrange(c1, c2+1)} cnt = [(r2-r1+1)*(c2-c1+1) for r1, c1, r2, c2 in artifacts] result = 0 for i, j in dig: if (i, j) not in lookup: continue cnt[lookup[i, j]] -= 1 if not cnt[lookup[i, j]]: result += 1 return result ", "class Solution def returnToBoundaryCount(self, nums): result = curr = 0 for x in nums: curr += x if curr == 0: result += 1 return result ", "class Solution def averageOfSubtree(self, root): def iter_dfs(root): result = 0 stk = [(1, (root, [0]*2))] while stk: step, args = stk.pop() if step == 1: node, ret = args if not node: continue ret1, ret2 = [0]*2, [0]*2 stk.append((2, (node, ret1, ret2, ret))) stk.append((1, (node.right, ret2))) stk.append((1, (node.left, ret1))) elif step == 2: node, ret1, ret2, ret = args ret[0] = ret1[0]+ret2[0]+node.val ret[1] = ret1[1]+ret2[1]+1 result += int(ret[0]//ret[1] == node.val) return result return iter_dfs(root) ", "class Solution def averageOfSubtree(self, root): def dfs(node): if not node: return [0]*3 left = dfs(node.left) right = dfs(node.right) return [left[0]+right[0]+node.val, left[1]+right[1]+1, left[2]+right[2]+int((left[0]+right[0]+node.val)//(left[1]+right[1]+1) == node.val)] return dfs(root)[2] ", "class Solution def haveConflict(self, event1, event2): return max(event1[0], event2[0]) <= min(event1[1], event2[1]) ", "class Solution def maxScoreSightseeingPair(self, A): result, curr = 0, 0 for x in A: result = max(result, curr+x) curr = max(curr, x)-1 return result ", "class Solution def getMinDistSum(self, positions): EPS = 1e-6 def norm(p1, p2): return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)**0.5 def geometry_median(positions, median): numerator, denominator = [0.0, 0.0], 0.0 for p in positions: l = norm(median, p) if not l: continue numerator[0] += p[0]/l numerator[1] += p[1]/l denominator += 1/l if denominator == 0.0: return True, None return False, [numerator[0]/denominator, numerator[1]/denominator] median = [float(sum(p[0] for p in positions))/len(positions), float(sum(p[1] for p in positions))/len(positions)] prev_median = [float(\"-inf\"), float(\"-inf\")] while norm(median, prev_median)*len(positions) > EPS: stopped, new_median = geometry_median(positions, median) if stopped: break median, prev_median = new_median, median return sum(norm(median, p) for p in positions) ", "class Solution def getMinDistSum(self, positions): DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)] EPS = 1e-6 def dist(positions, p): return sum(((p[0]-x)**2 + (p[1]-y)**2)**0.5 for x, y in positions) median = [0.0, 0.0] median[0] = float(sum(x for x, _ in positions))/len(positions) median[1] = float(sum(y for _, y in positions))/len(positions) result = dist(positions, median) delta = float(max(max(positions, key=lambda x: x[0])[0], max(positions, key=lambda x: x[1])[1])) - float(min(min(positions, key=lambda x: x[0])[0], min(positions, key=lambda x: x[1])[1])) while delta > EPS: for dx, dy in DIRECTIONS: new_median = [median[0] + delta*dx, median[1] + delta*dy] nd = dist(positions, new_median) if nd < result: result = nd median = new_median break else: delta /= 2.0 return result ", "class Solution def closestToTarget(self, arr, target): count = BitCount(max(arr).bit_length()) result, left = float(\"inf\"), 0 for right in xrange(len(arr)): count += arr[right] while left <= right: f = count.bit_and() result = min(result, abs(f-target)) if f >= target: break count -= arr[left] left += 1 return result ", "class Solution def minimumDifference(self, nums, k): count = BitCount(max(nums).bit_length()) result, left = float(\"inf\"), 0 for right in xrange(len(nums)): count += nums[right] while left <= right: f = count.bit_and() result = min(result, abs(f-k)) if f >= k: break count -= nums[left] left += 1 return result ", "class Solution def minimumDifference(self, nums, k): result, dp = float(\"inf\"), set() for x in nums: dp = {x}|{f&x for f in dp} for f in dp: result = min(result, abs(f-k)) return result ", "class Solution def numberOfSpecialChars(self, word): lookup1 = [len(word)]*26 lookup2 = [-1]*26 for i, x in enumerate(word): if x.islower(): lookup1[ord(x)-ord('a')] = i elif lookup2[ord(x)-ord('A')] == -1: lookup2[ord(x)-ord('A')] = i return sum(x < y for x, y in itertools.izip(lookup1, lookup2)) ", "class Solution def containsPattern(self, arr, m, k): cnt = 0 for i in xrange(len(arr)-m): if arr[i] != arr[i+m]: cnt = 0 continue cnt += 1 if cnt == (k-1)*m: return True return False ", "class Solution def largestOddNumber(self, num): for i in reversed(xrange(len(num))): if int(num[i])%2: return num[:i+1] return \"\" ", "class Solution def squareIsWhite(self, coordinates): return (ord(coordinates[0])-ord('a'))%2 != (ord(coordinates[1])-ord('1'))%2 ", "class Solution def applyOperations(self, nums): for i in xrange(len(nums)-1): if nums[i] == nums[i+1]: nums[i], nums[i+1] = 2*nums[i], 0 i = 0 for x in nums: if not x: continue nums[i] = x i += 1 for i in xrange(i, len(nums)): nums[i] = 0 return nums ", "class Solution def assignBikes(self, workers, bikes): def manhattan(p1, p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) distances = [[] for _ in xrange(len(workers))] for i in xrange(len(workers)): for j in xrange(len(bikes)): distances[i].append((manhattan(workers[i], bikes[j]), i, j)) distances[i].sort(reverse = True) result = [None] * len(workers) lookup = set() min_heap = [] for i in xrange(len(workers)): heapq.heappush(min_heap, distances[i].pop()) while len(lookup) < len(workers): _, worker, bike = heapq.heappop(min_heap) if bike not in lookup: result[worker] = bike lookup.add(bike) else: heapq.heappush(min_heap, distances[worker].pop()) return result ", "class Solution def longestSubsequence(self, arr, difference): result = 1 lookup = collections.defaultdict(int) for i in xrange(len(arr)): lookup[arr[i]] = lookup[arr[i]-difference] + 1 result = max(result, lookup[arr[i]]) return result ", "class Solution def change(self, amount, coins): dp = [0] * (amount+1) dp[0] = 1 for coin in coins: for i in xrange(coin, amount+1): dp[i] += dp[i-coin] return dp[amount] ", "class Solution def maxSum(self, nums1, nums2): MOD = 10**9+7 i, j = 0, 0 result, sum1, sum2 = 0, 0, 0, while i != len(nums1) or j != len(nums2): if i != len(nums1) and (j == len(nums2) or nums1[i] < nums2[j]): sum1 += nums1[i] i += 1 elif j != len(nums2) and (i == len(nums1) or nums1[i] > nums2[j]): sum2 += nums2[j] j += 1 else: result = (result + (max(sum1, sum2) + nums1[i])) % MOD sum1, sum2 = 0, 0 i += 1 j += 1 return (result + max(sum1, sum2)) % MOD ", "class Solution def deleteMiddle(self, head): dummy = ListNode() dummy.next = head slow = fast = dummy while fast.next and fast.next.next: slow, fast = slow.next, fast.next.next slow.next = slow.next.next return dummy.next ", "class Solution def arrayPairSum(self, nums): LEFT, RIGHT = -10000, 10000 lookup = [0] * (RIGHT-LEFT+1) for num in nums: lookup[num-LEFT] += 1 r, result = 0, 0 for i in xrange(LEFT, RIGHT+1): result += (lookup[i-LEFT] + 1 - r) / 2 * i r = (lookup[i-LEFT] + r) % 2 return result ", "class Solution def arrayPairSum(self, nums): nums.sort() result = 0 for i in xrange(0, len(nums), 2): result += nums[i] return result ", "class Solution def arrayPairSum(self, nums): nums = sorted(nums) return sum([nums[i] for i in range(0, len(nums), 2)]) ", "class Solution def countServers(self, n, logs, x, queries): logs.sort(key=lambda x:x[1]) result = [0]*len(queries) cnt = [0]*n curr = left = right = 0 for t, i in sorted((t, i) for i, t in enumerate(queries)): while right < len(logs) and logs[right][1] <= t: if cnt[logs[right][0]-1] == 0: curr += 1 cnt[logs[right][0]-1] += 1 right += 1 while left < right and logs[left][1] < t-x: cnt[logs[left][0]-1] -= 1 if cnt[logs[left][0]-1] == 0: curr -= 1 left += 1 result[i] = n-curr return result ", "class Solution def countServers(self, n, logs, x, queries): events = [] for sid, t in logs: events.append((t, +1, sid-1)) events.append((t+x+1, -1, sid-1)) events.append((float(\"inf\"), 0, 0)) events.sort() events2 = [] for i, t in enumerate(queries): events2.append((t, i)) events2.sort(reverse=True) result = [0]*len(queries) cnt = [0]*n curr = 0 for t, c, i in events: while events2 and events2[-1][0] < t: result[events2.pop()[1]] += n-curr if cnt[i] == 0: curr += 1 cnt[i] += c if cnt[i] == 0: curr -= 1 return result ", "class Solution def closestKValues(self, root, target, k): def nextNode(stack, child1, child2): if stack: if child2(stack): stack.append(child2(stack)) while child1(stack): stack.append(child1(stack)) else: child = stack.pop() while stack and child is child2(stack): child = stack.pop() backward = lambda stack: stack[-1].left forward = lambda stack: stack[-1].right stack = [] while root: stack.append(root) root = root.left if target < root.val else root.right dist = lambda node: abs(node.val - target) forward_stack = stack[:stack.index(min(stack, key=dist))+1] backward_stack = list(forward_stack) nextNode(backward_stack, backward, forward) result = [] for _ in xrange(k): if forward_stack and (not backward_stack or dist(forward_stack[-1]) < dist(backward_stack[-1])): result.append(forward_stack[-1].val) nextNode(forward_stack, forward, backward) elif backward_stack and (not forward_stack or dist(backward_stack[-1]) <= dist(forward_stack[-1])): result.append(backward_stack[-1].val) nextNode(backward_stack, backward, forward) return result ", "class Solution def closestKValues(self, root, target, k): class BSTIterator: def __init__(self, stack, child1, child2): self.stack = list(stack) self.cur = self.stack.pop() self.child1 = child1 self.child2 = child2 def next(self): node = None if self.cur and self.child1(self.cur): self.stack.append(self.cur) node = self.child1(self.cur) while self.child2(node): self.stack.append(node) node = self.child2(node) elif self.stack: prev = self.cur node = self.stack.pop() while node: if self.child2(node) is prev: break else: prev = node node = self.stack.pop() if self.stack else None self.cur = node return node stack = [] while root: stack.append(root) root = root.left if target < root.val else root.right dist = lambda node: abs(node.val - target) if node else float(\"inf\") stack = stack[:stack.index(min(stack, key=dist))+1] backward = lambda node: node.left forward = lambda node: node.right smaller_it, larger_it = BSTIterator(stack, backward, forward), BSTIterator(stack, forward, backward) smaller_node, larger_node = smaller_it.next(), larger_it.next() result = [stack[-1].val] for _ in xrange(k - 1): if dist(smaller_node) < dist(larger_node): result.append(smaller_node.val) smaller_node = smaller_it.next() else: result.append(larger_node.val) larger_node = larger_it.next() return result ", "class Solution def numberOfSpecialSubstrings(self, s): result = left = 0 lookup = [-1]*26 for right in xrange(len(s)): if lookup[ord(s[right])-ord('a')] >= left: left = lookup[ord(s[right])-ord('a')]+1 lookup[ord(s[right])-ord('a')] = right result += (right-left+1) return result ", "class Solution def numberOfSpecialSubstrings(self, s): result = left = 0 lookup = [False]*26 for right in xrange(len(s)): while lookup[ord(s[right])-ord('a')]: lookup[ord(s[left])-ord('a')] = False left += 1 lookup[ord(s[right])-ord('a')] = True result += (right-left+1) return result ", "class Solution def longestSubarray(self, nums, limit): max_dq, min_dq = collections.deque(), collections.deque() left = 0 for right, num in enumerate(nums): while max_dq and nums[max_dq[-1]] <= num: max_dq.pop() max_dq.append(right) while min_dq and nums[min_dq[-1]] >= num: min_dq.pop() min_dq.append(right) if nums[max_dq[0]]-nums[min_dq[0]] > limit: if max_dq[0] == left: max_dq.popleft() if min_dq[0] == left: min_dq.popleft() left += 1 return len(nums)-left import collections ", "class Solution def longestSubarray(self, nums, limit): max_dq, min_dq = collections.deque(), collections.deque() result, left = 0, 0 for right, num in enumerate(nums): while max_dq and nums[max_dq[-1]] <= num: max_dq.pop() max_dq.append(right) while min_dq and nums[min_dq[-1]] >= num: min_dq.pop() min_dq.append(right) while nums[max_dq[0]]-nums[min_dq[0]] > limit: if max_dq[0] == left: max_dq.popleft() if min_dq[0] == left: min_dq.popleft() left += 1 result = max(result, right-left+1) return result ", "class Solution def findLengthOfLCIS(self, nums): result, count = 0, 0 for i in xrange(len(nums)): if i == 0 or nums[i-1] < nums[i]: count += 1 result = max(result, count) else: count = 1 return result ", "class Solution def candy(self, ratings): candies = [1 for _ in xrange(len(ratings))] for i in xrange(1, len(ratings)): if ratings[i] > ratings[i - 1]: candies[i] = candies[i - 1] + 1 for i in reversed(xrange(1, len(ratings))): if ratings[i - 1] > ratings[i] and candies[i - 1] <= candies[i]: candies[i - 1] = candies[i] + 1 return sum(candies) ", "class Solution def kthLargestValue(self, matrix, k): def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = random.randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 vals = [] for r in xrange(len(matrix)): curr = 0 for c in xrange(len(matrix[0])): curr = curr^matrix[r][c] if r == 0: matrix[r][c] = curr else: matrix[r][c] = curr^matrix[r-1][c] vals.append(matrix[r][c]) nth_element(vals, k-1, compare=lambda a, b: a > b) return vals[k-1] ", "class Solution def isBalanced(self, root): def getHeight(root): if root is None: return 0 left_height, right_height = getHeight(root.left), getHeight(root.right) if left_height < 0 or right_height < 0 or abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return (getHeight(root) >= 0) ", "class Solution def findTheDistanceValue(self, arr1, arr2, d): arr2.sort() result, i, j = 0, 0, 0 for x in arr1: j = bisect.bisect_left(arr2, x) left = arr2[j-1] if j-1 >= 0 else float(\"-inf\") right = arr2[j] if j < len(arr2) else float(\"inf\") result += left+d < x < right-d return result ", "class Solution def findTheDistanceValue(self, arr1, arr2, d): arr1.sort(), arr2.sort() result, i, j = 0, 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i]-arr2[j] > d: j += 1 continue result += arr2[j]-arr1[i] > d i += 1 return result+len(arr1)-i ", "class Solution def checkXMatrix(self, grid): return all((i-j == 0 or i+j == len(grid)-1) == (grid[i][j] != 0) for i in xrange(len(grid)) for j in xrange(len(grid[0]))) ", "class Solution def calculateTax(self, brackets, income): result = prev = 0 for u, p in brackets: result += max((min(u, income)-prev)*p/100.0, 0.0) prev = u return result ", "class Solution def largestDivisibleSubset(self, nums): if not nums: return [] nums.sort() dp = [1] * len(nums) prev = [-1] * len(nums) largest_idx = 0 for i in xrange(len(nums)): for j in xrange(i): if nums[i] % nums[j] == 0: if dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 prev[i] = j if dp[largest_idx] < dp[i]: largest_idx = i result = [] i = largest_idx while i != -1: result.append(nums[i]) i = prev[i] return result[::-1] ", "class Solution def getAllElements(self, root1, root2): def inorder_gen(root): result, stack = [], [(root, False)] while stack: root, is_visited = stack.pop() if root is None: continue if is_visited: yield root.val else: stack.append((root.right, False)) stack.append((root, True)) stack.append((root.left, False)) yield None result = [] left_gen, right_gen = inorder_gen(root1), inorder_gen(root2) left, right = next(left_gen), next(right_gen) while left is not None or right is not None: if right is None or (left is not None and left < right): result.append(left) left = next(left_gen) else: result.append(right) right = next(right_gen) return result ", "class Solution def distributeCoins(self, root): def dfs(root, result): if not root: return 0 left, right = dfs(root.left, result), dfs(root.right, result) result[0] += abs(left) + abs(right) return root.val + left + right - 1 result = [0] dfs(root, result) return result[0] ", "class Solution def divide(self, dividend, divisor): result, dvd, dvs = 0, abs(dividend), abs(divisor) while dvd >= dvs: inc = dvs i = 0 while dvd >= inc: dvd -= inc result += 1 << i inc <<= 1 i += 1 if dividend > 0 and divisor < 0 or dividend < 0 and divisor > 0: return -result else: return result def divide2(self, dividend, divisor): positive = (dividend < 0) is (divisor < 0) dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend >= divisor: temp, i = divisor, 1 while dividend >= temp: dividend -= temp res += i i <<= 1 temp <<= 1 if not positive: res = -res return min(max(-2147483648, res), 2147483647) ", "class Solution def countBattleships(self, board): if not board or not board[0]: return 0 cnt = 0 for i in xrange(len(board)): for j in xrange(len(board[0])): cnt += int(board[i][j] == 'X' and (i == 0 or board[i - 1][j] != 'X') and (j == 0 or board[i][j - 1] != 'X')) return cnt ", "class Solution def intersect(self, quadTree1, quadTree2): if quadTree1.isLeaf: return quadTree1 if quadTree1.val else quadTree2 elif quadTree2.isLeaf: return quadTree2 if quadTree2.val else quadTree1 topLeftNode = self.intersect(quadTree1.topLeft, quadTree2.topLeft) topRightNode = self.intersect(quadTree1.topRight, quadTree2.topRight) bottomLeftNode = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft) bottomRightNode = self.intersect(quadTree1.bottomRight, quadTree2.bottomRight) if topLeftNode.isLeaf and topRightNode.isLeaf and bottomLeftNode.isLeaf and bottomRightNode.isLeaf and topLeftNode.val == topRightNode.val == bottomLeftNode.val == bottomRightNode.val: return Node(topLeftNode.val, True, None, None, None, None) return Node(True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode) ", "class Solution def isRationalEqual(self, S, T): def frac(S): if '.' not in S: return Fraction(int(S), 1) i = S.index('.') result = Fraction(int(S[:i]), 1) non_int_part = S[i+1:] if '(' not in non_int_part: if non_int_part: result += Fraction(int(non_int_part), 10**len(non_int_part)) return result i = non_int_part.index('(') if i: result += Fraction(int(non_int_part[:i]), 10**i) repeat_part = non_int_part[i+1:-1] result += Fraction(int(repeat_part), 10**i * (10**len(repeat_part)-1)) return result return frac(S) == frac(T) ", "class Solution def isConsecutive(self, nums): return max(nums)-min(nums)+1 == len(nums) == len(set(nums)) ", "class Solution def isConsecutive(self, nums): nums.sort() return all(nums[i]+1 == nums[i+1] for i in xrange(len(nums)-1)) ", "class Solution def findKthLargest(self, nums, k): def nth_element(nums, n, compare=lambda a, b: a < b): def tri_partition(nums, left, right, target, compare): mid = left while mid <= right: if nums[mid] == target: mid += 1 elif compare(nums[mid], target): nums[left], nums[mid] = nums[mid], nums[left] left += 1 mid += 1 else: nums[mid], nums[right] = nums[right], nums[mid] right -= 1 return left, right left, right = 0, len(nums)-1 while left <= right: pivot_idx = randint(left, right) pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare) if pivot_left <= n <= pivot_right: return elif pivot_left > n: right = pivot_left-1 else: left = pivot_right+1 nth_element(nums, k-1, compare=lambda a, b: a > b) return nums[k-1] ", "class Solution def findKthLargest(self, nums, k): left, right = 0, len(nums) - 1 while left <= right: pivot_idx = randint(left, right) new_pivot_idx = self.PartitionAroundPivot(left, right, pivot_idx, nums) if new_pivot_idx == k - 1: return nums[new_pivot_idx] elif new_pivot_idx > k - 1: right = new_pivot_idx - 1 else: left = new_pivot_idx + 1 def PartitionAroundPivot(self, left, right, pivot_idx, nums): pivot_value = nums[pivot_idx] new_pivot_idx = left nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx] for i in xrange(left, right): if nums[i] > pivot_value: nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i] new_pivot_idx += 1 nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right] return new_pivot_idx ", "class Solution def longestCommonPrefix(self, arr1, arr2): _trie = lambda: collections.defaultdict(_trie) trie = _trie() for x in arr1: reduce(dict.__getitem__, str(x), trie) result = 0 for x in arr2: curr = trie for i, c in enumerate(str(x)): if c not in curr: break curr = curr[c] else: i += 1 result = max(result, i) return result ", "class Solution def longestCommonPrefix(self, arr1, arr2): lookup = {0} for x in arr1: while x not in lookup: lookup.add(x) x //= 10 result = 0 for x in arr2: l = len(str(x)) while x not in lookup: x //= 10 l -= 1 result = max(result, l) return result ", "class Solution def canConvertString(self, s, t, k): if len(s) != len(t): return False cnt = [0]*26 for a, b in itertools.izip(s, t): diff = (ord(b)-ord(a)) % len(cnt) if diff != 0 and cnt[diff]*len(cnt) + diff > k: return False cnt[diff] += 1 return True ", "class Solution def intervalIntersection(self, A, B): result = [] i, j = 0, 0 while i < len(A) and j < len(B): left = max(A[i].start, B[j].start) right = min(A[i].end, B[j].end) if left <= right: result.append(Interval(left, right)) if A[i].end < B[j].end: i += 1 else: j += 1 return result ", "class Solution def countBinarySubstrings(self, s): result, prev, curr = 0, 0, 1 for i in xrange(1, len(s)): if s[i-1] != s[i]: result += min(prev, curr) prev, curr = curr, 1 else: curr += 1 result += min(prev, curr) return result ", "class Solution def deleteGreatestValue(self, grid): for row in grid: row.sort() return sum(max(grid[i][j] for i in xrange(len(grid))) for j in xrange(len(grid[0]))) ", "class Solution def maxNumberOfFamilies(self, n, reservedSeats): lookup = collections.defaultdict(lambda: [False]*3) for r, c in reservedSeats: if 2 <= c <= 5: lookup[r][0] = True if 4 <= c <= 7: lookup[r][1] = True if 6 <= c <= 9: lookup[r][2] = True result = 2*n for a, b, c in lookup.itervalues(): if not a and not c: continue if not a or not b or not c: result -= 1 continue result -= 2 return result ", "class Solution def maxNumberOfFamilies(self, n, reservedSeats): reservedSeats.sort() result, i = 2*n, 0 while i < len(reservedSeats): reserved = [False]*3 curr = reservedSeats[i][0] while i < len(reservedSeats) and reservedSeats[i][0] == curr: _, c = reservedSeats[i] if 2 <= c <= 5: reserved[0] = True if 4 <= c <= 7: reserved[1] = True if 6 <= c <= 9: reserved[2] = True i += 1 if not reserved[0] and not reserved[2]: continue if not all(reserved): result -= 1 continue result -= 2 return result ", "class Solution def addDigits(self, num): return (num - 1) % 9 + 1 if num > 0 else 0 ", "class Solution def xorBeauty(self, nums): return reduce(operator.xor, nums) ", "class Solution def getMaxRepetitions(self, s1, n1, s2, n2): repeat_count = [0] * (len(s2)+1) lookup = {} j, count = 0, 0 for k in xrange(1, n1+1): for i in xrange(len(s1)): if s1[i] == s2[j]: j = (j + 1) % len(s2) count += (j == 0) if j in lookup: i = lookup[j] prefix_count = repeat_count[i] pattern_count = (count - repeat_count[i]) * ((n1 - i) // (k - i)) suffix_count = repeat_count[i + (n1 - i) % (k - i)] - repeat_count[i] return (prefix_count + pattern_count + suffix_count) / n2 lookup[j] = k repeat_count[k] = count return repeat_count[n1] / n2 ", "class Solution def minimumOperations(self, nums): return len({x for x in nums if x}) ", "class Solution def jump(self, A): jump_count = 0 reachable = 0 curr_reachable = 0 for i, length in enumerate(A): if i > reachable: return -1 if i > curr_reachable: curr_reachable = reachable jump_count += 1 reachable = max(reachable, i + length) return jump_count ", "class Solution def countRectangles(self, rectangles, points): max_y = max(y for _, y in rectangles) buckets = [[] for _ in xrange(max_y+1)] for x, y in rectangles: buckets[y].append(x) for bucket in buckets: bucket.sort() return [sum(len(buckets[y])-bisect.bisect_left(buckets[y], x) for y in xrange(y, max_y+1)) for x, y in points] ", "class Solution def duplicateNumbersXOR(self, nums): return reduce(lambda x, y: x^y, nums, 0)^reduce(lambda x, y: x^y, set(nums), 0) import collections ", "class Solution def duplicateNumbersXOR(self, nums): return reduce(lambda x, y: x^y, (x for x, c in collections.Counter(nums).iteritems() if c == 2), 0) ", "class Solution def findDiagonalOrder(self, matrix): if not matrix or not matrix[0]: return [] result = [] row, col, d = 0, 0, 0 dirs = [(-1, 1), (1, -1)] for i in xrange(len(matrix) * len(matrix[0])): result.append(matrix[row][col]) row += dirs[d][0] col += dirs[d][1] if row >= len(matrix): row = len(matrix) - 1 col += 2 d = 1 - d elif col >= len(matrix[0]): col = len(matrix[0]) - 1 row += 2 d = 1 - d elif row < 0: row = 0 d = 1 - d elif col < 0: col = 0 d = 1 - d return result ", "class Solution def alternateDigitSum(self, n): result = 0 sign = 1 while n: sign *= -1 result += sign*(n%10) n //= 10 return sign*result ", "class Solution def countSubarrays(self, nums, k): idx = nums.index(k) lookup = collections.Counter() curr = 0 for i in reversed(xrange(idx+1)): curr += 0 if nums[i] == k else -1 if nums[i] < k else +1 lookup[curr] += 1 result = curr = 0 for i in xrange(idx, len(nums)): curr += 0 if nums[i] == k else -1 if nums[i] < k else +1 result += lookup[-curr]+lookup[-(curr-1)] return result ", "class Solution def findIndices(self, nums, indexDifference, valueDifference): mx_i = mn_i = 0 for i in xrange(len(nums)-indexDifference): if nums[i] > nums[mx_i]: mx_i = i elif nums[i] < nums[mn_i]: mn_i = i if nums[mx_i]-nums[i+indexDifference] >= valueDifference: return [mx_i, i+indexDifference] if nums[i+indexDifference]-nums[mn_i] >= valueDifference: return [mn_i, i+indexDifference] return [-1]*2 ", "class Solution def findPermutation(self, nums): INF = float(\"inf\") n = len(nums) dp = [[(INF, -1) for _ in xrange(n-1)] for _ in xrange(1<<(n-1))] for i in xrange(n-1): dp[1<<i][i] = (abs((i+1)-nums[0]), -1) for mask in xrange(1<<(n-1)): for i in xrange(n-1): if mask&(1<<i) == 0: continue for j in xrange(n-1): if j == i or mask&(1<<j) == 0: continue dp[mask][i] = min(dp[mask][i], (dp[mask^(1<<i)][j][0]+abs((i+1)-nums[j+1]), j)) _, i = min((dp[-1][i][0]+abs(0-nums[i+1]), i) for i in xrange(n-1)) result = [0] mask = (1<<(n-1))-1 while i != -1: result.append(i+1) mask, i = mask^(1<<i), dp[mask][i][1] return result ", "class Solution def canCompleteCircuit(self, gas, cost): start, total_sum, current_sum = 0, 0, 0 for i in xrange(len(gas)): diff = gas[i] - cost[i] current_sum += diff total_sum += diff if current_sum < 0: start = i + 1 current_sum = 0 if total_sum >= 0: return start return -1 ", "class Solution def upsideDownBinaryTree(self, root): p, parent, parent_right = root, None, None while p: left = p.left p.left = parent_right parent_right = p.right p.right = parent parent = p p = left return parent ", "class Solution def upsideDownBinaryTree(self, root): return self.upsideDownBinaryTreeRecu(root, None) def upsideDownBinaryTreeRecu(self, p, parent): if p is None: return parent root = self.upsideDownBinaryTreeRecu(p.left, p) if parent: p.left = parent.right else: p.left = None p.right = parent return root ", "class Solution def findLatestStep(self, arr, m): if m == len(arr): return m length = [0]*(len(arr)+2) result = -1 for i, x in enumerate(arr): left, right = length[x-1], length[x+1] if left == m or right == m: result = i length[x-left] = length[x+right] = left+right+1 return result ", "class Solution def largestNumber(self, cost, target): dp = [0] for t in xrange(1, target+1): dp.append(-1) for i, c in enumerate(cost): if t-c < 0 or dp[t-c] < 0: continue dp[t] = max(dp[t], dp[t-c]+1) if dp[target] < 0: return \"0\" result = [] for i in reversed(xrange(9)): while target >= cost[i] and dp[target] == dp[target-cost[i]]+1: target -= cost[i] result.append(i+1) return \"\".join(map(str, result)) ", "class Solution def largestNumber(self, cost, target): def key(bag): return sum(bag), bag dp = [[0]*9] for t in xrange(1, target+1): dp.append([]) for d, c in enumerate(cost): if t < c or not dp[t-c]: continue curr = dp[t-c][:] curr[~d] += 1 if key(curr) > key(dp[t]): dp[-1] = curr if not dp[-1]: return \"0\" return \"\".join(str(9-i)*c for i, c in enumerate(dp[-1])) ", "class Solution def largestNumber(self, cost, target): dp = [0] for t in xrange(1, target+1): dp.append(-1) for i, c in enumerate(cost): if t-c < 0: continue dp[t] = max(dp[t], dp[t-c]*10 + i+1) return str(max(dp[t], 0)) ", "class Solution def balanceBST(self, root): def inorderTraversal(root): result, stk = [], [(root, False)] while stk: node, is_visited = stk.pop() if node is None: continue if is_visited: result.append(node.val) else: stk.append((node.right, False)) stk.append((node, True)) stk.append((node.left, False)) return result def sortedArrayToBst(arr): ROOT, LEFT, RIGHT = range(3) result = [None] stk = [(0, len(arr), ROOT, result)] while stk: i, j, update, ret = stk.pop() if i >= j: continue mid = i + (j-i)//2 node = TreeNode(arr[mid]) if update == ROOT: ret[0] = node elif update == LEFT: ret[0].left = node else: ret[0].right = node stk.append((mid+1, j, RIGHT, [node])) stk.append((i, mid, LEFT, [node])) return result[0] return sortedArrayToBst(inorderTraversal(root)) ", "class Solution def balanceBST(self, root): def inorderTraversalHelper(node, arr): if not node: return inorderTraversalHelper(node.left, arr) arr.append(node.val) inorderTraversalHelper(node.right, arr) def sortedArrayToBstHelper(arr, i, j): if i >= j: return None mid = i + (j-i)//2 node = TreeNode(arr[mid]) node.left = sortedArrayToBstHelper(arr, i, mid) node.right = sortedArrayToBstHelper(arr, mid+1, j) return node arr = [] inorderTraversalHelper(root, arr) return sortedArrayToBstHelper(arr, 0, len(arr)) ", "class Solution def canBeValid(self, s, locked): if len(s)%2: return False for direction, c in ((lambda x:x, '('), (reversed, ')')): cnt = bal = 0 for i in direction(xrange(len(s))): if locked[i] == '0': cnt += 1 else: bal += 1 if s[i] == c else -1 if cnt+bal < 0: return False return True ", "class Solution def orArray(self, nums): return [nums[i]|nums[i+1] for i in range(len(nums)-1)] ", "class Solution def buildTree(self, inorder, postorder): lookup = {} for i, num in enumerate(inorder): lookup[num] = i return self.buildTreeRecu(lookup, postorder, inorder, len(postorder), 0, len(inorder)) def buildTreeRecu(self, lookup, postorder, inorder, post_end, in_start, in_end): if in_start == in_end: return None node = TreeNode(postorder[post_end - 1]) i = lookup[postorder[post_end - 1]] node.left = self.buildTreeRecu(lookup, postorder, inorder, post_end - 1 - (in_end - i - 1), in_start, i) node.right = self.buildTreeRecu(lookup, postorder, inorder, post_end - 1, i + 1, in_end) return node ", "class Solution def groupThePeople(self, groupSizes): groups, result = collections.defaultdict(list), [] for i, size in enumerate(groupSizes): groups[size].append(i) if len(groups[size]) == size: result.append(groups.pop(size)) return result ", "class Solution def nearestValidPoint(self, x, y, points): smallest, idx = float(\"inf\"), -1 for i, (r, c) in enumerate(points): dx, dy = x-r, y-c if dx*dy == 0 and abs(dx)+abs(dy) < smallest: smallest = abs(dx)+abs(dy) idx = i return idx ", "class Solution def distributeCandies(self, n, limit): def nCr(n, r): if not 0 <= r <= n: return 0 if n-r < r: r = n-r c = 1 for k in xrange(1, r+1): c *= n-k+1 c //= k return c def nHr(n, r): return nCr(n+(r-1), r-1) R = 3 return sum((-1 if r%2 else 1) * nCr(R, r) * nHr(n-r*(limit+1), R) for r in xrange(R+1)) ", "class Solution def checkValid(self, matrix): return all(len(set(row)) == len(matrix) for row in matrix) and all(len(set(matrix[i][j] for i in xrange(len(matrix)))) == len(matrix) for j in xrange(len(matrix[0]))) class Solution_Wrong(object): def checkValid(self, matrix): return all(reduce(lambda x, y: x^y, (matrix[i][j]^(j+1) for j in xrange(len(matrix[0])))) == 0 for i in xrange(len(matrix))) and all(reduce(lambda x, y: x^y, (matrix[i][j]^(i+1) for i in xrange(len(matrix)))) == 0 for j in xrange(len(matrix[0]))) ", "class Solution def longestConsecutive(self, num): result, lengths = 1, {key: 0 for key in num} for i in num: if lengths[i] == 0: lengths[i] = 1 left, right = lengths.get(i - 1, 0), lengths.get(i + 1, 0) length = 1 + left + right result, lengths[i - left], lengths[i + right] = max(result, length), length, length return result ", "class Solution def findGCD(self, nums): return fractions.gcd(min(nums), max(nums)) ", "class Solution def busiestServers(self, k, arrival, load): count = [0]*k min_heap_of_endtimes = [] min_heap_of_nodes_after_curr = [] min_heap_of_nodes_before_curr = range(k) for i, (t, l) in enumerate(itertools.izip(arrival, load)): if i % k == 0: min_heap_of_nodes_before_curr, min_heap_of_nodes_after_curr = [], min_heap_of_nodes_before_curr while min_heap_of_endtimes and min_heap_of_endtimes[0][0] <= t: _, free = heapq.heappop(min_heap_of_endtimes) if free < i % k: heapq.heappush(min_heap_of_nodes_before_curr, free) else: heapq.heappush(min_heap_of_nodes_after_curr, free) min_heap_of_candidates = min_heap_of_nodes_after_curr if min_heap_of_nodes_after_curr else min_heap_of_nodes_before_curr if not min_heap_of_candidates: continue node = heapq.heappop(min_heap_of_candidates) count[node] += 1 heapq.heappush(min_heap_of_endtimes, (t+l, node)) max_count = max(count) return [i for i in xrange(k) if count[i] == max_count] import sortedcontainers import itertools import heapq ", "class Solution def busiestServers(self, k, arrival, load): count = [0]*k min_heap_of_endtimes = [] availables = sortedcontainers.SortedList(xrange(k)) for i, (t, l) in enumerate(itertools.izip(arrival, load)): while min_heap_of_endtimes and min_heap_of_endtimes[0][0] <= t: _, free = heapq.heappop(min_heap_of_endtimes) availables.add(free) if not availables: continue idx = availables.bisect_left(i % k) % len(availables) node = availables.pop(idx) count[node] += 1 heapq.heappush(min_heap_of_endtimes, (t+l, node)) max_count = max(count) return [i for i in xrange(k) if count[i] == max_count] ", "class Solution def findInMountainArray(self, target, mountain_arr): def binarySearch(A, left, right, check): while left <= right: mid = left + (right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left peak = binarySearch(mountain_arr, 0, mountain_arr.length()-1, lambda x: mountain_arr.get(x) >= mountain_arr.get(x+1)) left = binarySearch(mountain_arr, 0, peak, lambda x: mountain_arr.get(x) >= target) if left <= peak and mountain_arr.get(left) == target: return left right = binarySearch(mountain_arr, peak, mountain_arr.length()-1, lambda x: mountain_arr.get(x) <= target) if right <= mountain_arr.length()-1 and mountain_arr.get(right) == target: return right return -1 ", "class Solution def earliestFullBloom(self, plantTime, growTime): order = range(len(growTime)) order.sort(key=lambda x: growTime[x], reverse=True) result = curr = 0 for i in order: curr += plantTime[i] result = max(result, curr+growTime[i]) return result ", "class Solution def carFleet(self, target, position, speed): times = [float(target-p)/s for p, s in sorted(zip(position, speed))] result, curr = 0, 0 for t in reversed(times): if t > curr: result += 1 curr = t return result ", "class Solution def findLUSlength(self, a, b): if a == b: return -1 return max(len(a), len(b)) ", "class Solution def punishmentNumber(self, n): def backtracking(curr, target): if target == 0: return curr == 0 base = 10 while curr >= base//10: q, r = divmod(curr, base) if target-r < 0: break if backtracking(q, target-r): return True base *= 10 return False return sum(i**2 for i in xrange(1, n+1) if backtracking(i**2, i)) ", "class Solution def maximumNumber(self, num, change): mutated = False result = map(int, list(num)) for i, d in enumerate(result): if change[d] < d: if mutated: break elif change[d] > d: result[i] = str(change[d]) mutated = True return \"\".join(map(str, result)) ", "class Solution def frogPosition(self, n, edges, t, target): G = collections.defaultdict(list) for u, v in edges: G[u].append(v) G[v].append(u) stk = [(t, 1, 0, 1)] while stk: new_stk = [] while stk: t, node, parent, choices = stk.pop() if not t or not (len(G[node])-(parent != 0)): if node == target: return 1.0/choices continue for child in G[node]: if child == parent: continue new_stk.append((t-1, child, node, choices*(len(G[node])-(parent != 0)))) stk = new_stk return 0.0 ", "class Solution def frogPosition(self, n, edges, t, target): G = collections.defaultdict(list) for u, v in edges: G[u].append(v) G[v].append(u) stk = [(t, 1, 0, 1)] while stk: t, node, parent, choices = stk.pop() if not t or not (len(G[node])-(parent != 0)): if node == target: return 1.0/choices continue for child in G[node]: if child == parent: continue stk.append((t-1, child, node, choices*(len(G[node])-(parent != 0)))) return 0.0 ", "class Solution def frogPosition(self, n, edges, t, target): def dfs(G, target, t, node, parent): if not t or not (len(G[node])-(parent != 0)): return int(node == target) result = 0 for child in G[node]: if child == parent: continue result = dfs(G, target, t-1, child, node) if result: break return result*(len(G[node])-(parent != 0)) G = collections.defaultdict(list) for u, v in edges: G[u].append(v) G[v].append(u) choices = dfs(G, target, t, 1, 0) return 1.0/choices if choices else 0.0 ", "class Solution def frogPosition(self, n, edges, t, target): def dfs(G, target, t, node, parent): if not t or not (len(G[node])-(parent != 0)): return float(node == target) for child in G[node]: if child == parent: continue result = dfs(G, target, t-1, child, node) if result: break return result/(len(G[node])-(parent != 0)) G = collections.defaultdict(list) for u, v in edges: G[u].append(v) G[v].append(u) return dfs(G, target, t, 1, 0) ", "class Solution def countSubarrays(self, nums, minK, maxK): result = left = 0 right = [-1]*2 for i, x in enumerate(nums): if not (minK <= x <= maxK): left = i+1 continue if x == minK: right[0] = i if x == maxK: right[1] = i result += max(min(right)-left+1, 0) return result ", "class Solution def numTimesAllBlue(self, light): result, right = 0, 0 for i, num in enumerate(light, 1): right = max(right, num) result += (right == i) return result ", "class Solution def findCheapestPrice(self, n, flights, src, dst, K): adj = collections.defaultdict(list) for u, v, w in flights: adj[u].append((v, w)) best = collections.defaultdict(lambda: collections.defaultdict(lambda: float(\"inf\"))) best[src][K+1] = 0 min_heap = [(0, src, K+1)] while min_heap: result, u, k = heapq.heappop(min_heap) if k < 0 or best[u][k] < result: continue if u == dst: return result for v, w in adj[u]: if result+w < best[v][k-1]: best[v][k-1] = result+w heapq.heappush(min_heap, (result+w, v, k-1)) return -1 ", "class Solution def maxScore(self, edges): def iter_dfs(): result = [(0, 0) for _ in xrange(len(adj))] stk = [(1, 0)] while stk: step, u = stk.pop() if step == 1: if not adj[u]: continue stk.append((2, u)) for v, _ in adj[u]: stk.append((1, v)) elif step == 2: without_u = sum(max(result[v]) for v, w in adj[u]) with_u = max(without_u-max(result[v])+(result[v][1]+w) for v, w in adj[u]) result[u] = (with_u, without_u) return max(result[0]) adj = [[] for _ in xrange(len(edges))] for i, (p, w) in enumerate(edges): if i == 0: continue adj[p].append((i, w)) return iter_dfs() ", "class Solution def maxScore(self, edges): def dfs(u): if not adj[u]: return (0, 0) children = [dfs(v) for v, _ in adj[u]] without_u = sum(max(with_v, without_v) for with_v, without_v in children) with_u = max(without_u-max(with_v, without_v)+(without_v+adj[u][i][1]) for i, (with_v, without_v) in enumerate(children)) return (with_u, without_u) adj = [[] for _ in xrange(len(edges))] for i, (p, w) in enumerate(edges): if i == 0: continue adj[p].append((i, w)) return max(dfs(0)) ", "class Solution def minTotalDistance(self, grid): x = [i for i, row in enumerate(grid) for v in row if v == 1] y = [j for row in grid for j, v in enumerate(row) if v == 1] mid_x = self.findKthLargest(x, len(x) / 2 + 1) mid_y = self.findKthLargest(y, len(y) / 2 + 1) return sum([abs(mid_x-i) + abs(mid_y-j) for i, row in enumerate(grid) for j, v in enumerate(row) if v == 1]) def findKthLargest(self, nums, k): left, right = 0, len(nums) - 1 while left <= right: pivot_idx = randint(left, right) new_pivot_idx = self.PartitionAroundPivot(left, right, pivot_idx, nums) if new_pivot_idx == k - 1: return nums[new_pivot_idx] elif new_pivot_idx > k - 1: right = new_pivot_idx - 1 else: left = new_pivot_idx + 1 def PartitionAroundPivot(self, left, right, pivot_idx, nums): pivot_value = nums[pivot_idx] new_pivot_idx = left nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx] for i in xrange(left, right): if nums[i] > pivot_value: nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i] new_pivot_idx += 1 nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right] return new_pivot_idx ", "class Solution def lcaDeepestLeaves(self, root): def lcaDeepestLeavesHelper(root): if not root: return 0, None d1, lca1 = lcaDeepestLeavesHelper(root.left) d2, lca2 = lcaDeepestLeavesHelper(root.right) if d1 > d2: return d1+1, lca1 if d1 < d2: return d2+1, lca2 return d1+1, root return lcaDeepestLeavesHelper(root)[1] ", "class Solution def earliestSecondToMarkIndices(self, nums, changeIndices): def check(t): min_heap = [] cnt = 0 for i in reversed(xrange(t)): if i != lookup[changeIndices[i]-1]: cnt += 1 continue heapq.heappush(min_heap, nums[changeIndices[i]-1]) if cnt: cnt -= 1 else: cnt += 1 heapq.heappop(min_heap) return total-(sum(min_heap)+len(min_heap)) <= cnt lookup = [-1]*len(nums) for i in reversed(xrange(len(changeIndices))): if nums[changeIndices[i]-1]: lookup[changeIndices[i]-1] = i total = sum(nums)+len(nums) left, right = sum((1 if lookup[i] != -1 else nums[i]) for i in xrange(len(nums)))+len(nums), len(changeIndices) while left <= right: mid = left+(right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left if left <= len(changeIndices) else -1 ", "class Solution def getWordsInLongestSubsequence(self, n, words, groups): def check(s1, s2): return len(s1) == len(s2) and sum(a != b for a, b in itertools.izip(s1, s2)) == 1 dp = [[1, -1] for _ in xrange(n)] for i in reversed(xrange(n)): for j in xrange(i+1, n): if groups[i] != groups[j] and check(words[j], words[i]): dp[i] = max(dp[i], [dp[j][0]+1, j]) result = [] i = max(xrange(n), key=lambda x: dp[x]) while i != -1: result.append(words[i]) i = dp[i][1] return result import itertools ", "class Solution def getWordsInLongestSubsequence(self, n, words, groups): def check(s1, s2): return len(s1) == len(s2) and sum(a != b for a, b in itertools.izip(s1, s2)) == 1 dp = [[1, -1] for _ in xrange(n)] for i in xrange(n): for j in xrange(i): if groups[i] != groups[j] and check(words[j], words[i]): dp[i] = max(dp[i], [dp[j][0]+1, j]) result = [] i = max(xrange(n), key=lambda x: dp[x]) while i != -1: result.append(words[i]) i = dp[i][1] result.reverse() return result import itertools ", "class Solution def getWordsInLongestSubsequence(self, n, words, groups): def check(s1, s2): return len(s1) == len(s2) and sum(a != b for a, b in itertools.izip(s1, s2)) == 1 dp = [[] for _ in xrange(n)] for i in xrange(n): for j in xrange(i): if groups[i] != groups[j] and check(words[j], words[i]) and len(dp[j]) > len(dp[i]): dp[i] = dp[j] dp[i] = dp[i]+[i] return map(lambda x: words[x], max(dp, key=lambda x: len(x))) ", "class Solution def findColumnWidth(self, grid): def length(x): l = 1 if x < 0: x = -x l += 1 while x >= 10: x //= 10 l += 1 return l return [max(length(grid[i][j]) for i in xrange(len(grid))) for j in xrange(len(grid[0]))] ", "class Solution def findColumnWidth(self, grid): return [max(len(str(grid[i][j])) for i in xrange(len(grid))) for j in xrange(len(grid[0]))] import itertools ", "class Solution def findColumnWidth(self, grid): return [max(len(str(x)) for x in col) for col in itertools.izip(*grid)] ", "class Solution def isTransformable(self, s, t): idxs = [[] for _ in xrange(10)] for i in reversed(xrange(len(s))): idxs[int(s[i])].append(i) for c in t: d = int(c) if not idxs[d]: return False for k in xrange(d): if idxs[k] and idxs[k][-1] < idxs[d][-1]: return False idxs[d].pop() return True ", "class Solution def searchRange(self, nums, target): def binarySearch(n, check): left, right = 0, n-1 while left <= right: mid = left + (right-left)//2 if check(mid): right = mid-1 else: left = mid+1 return left def binarySearch2(n, check): left, right = 0, n while left < right: mid = left + (right-left)//2 if check(mid): right = mid else: left = mid+1 return left def binarySearch3(n, check): left, right = -1, n-1 while left < right: mid = right - (right-left)//2 if check(mid): right = mid-1 else: left = mid return left+1 def binarySearch4(n, check): left, right = -1, n while right-left >= 2: mid = left + (right-left)//2 if check(mid): right = mid else: left = mid return right left = binarySearch(len(nums), lambda i: nums[i] >= target) if left == len(nums) or nums[left] != target: return [-1, -1] right = binarySearch(len(nums), lambda i: nums[i] > target) return [left, right-1] ", "class Solution def kSmallestPairs(self, nums1, nums2, k): pairs = [] if len(nums1) > len(nums2): tmp = self.kSmallestPairs(nums2, nums1, k) for pair in tmp: pairs.append([pair[1], pair[0]]) return pairs min_heap = [] def push(i, j): if i < len(nums1) and j < len(nums2): heappush(min_heap, [nums1[i] + nums2[j], i, j]) push(0, 0) while min_heap and len(pairs) < k: _, i, j = heappop(min_heap) pairs.append([nums1[i], nums2[j]]) push(i, j + 1) if j == 0: push(i + 1, 0) return pairs from heapq import nsmallest from itertools import product ", "class Solution def kSmallestPairs(self, nums1, nums2, k): return nsmallest(k, product(nums1, nums2), key=sum) ", "class Solution def findDifference(self, nums1, nums2): lookup = [set(nums1), set(nums2)] return [list(lookup[0]-lookup[1]), list(lookup[1]-lookup[0])] ", "class Solution def maxDistance(self, position, m): def check(position, m, x): count, prev = 1, position[0] for i in xrange(1, len(position)): if position[i]-prev >= x: count += 1 prev = position[i] return count >= m position.sort() left, right = 1, position[-1]-position[0] while left <= right: mid = left + (right-left)//2 if not check(position, m, mid): right = mid-1 else: left = mid+1 return right ", "class Solution def amountOfTime(self, root, start): def iter_dfs(root, start): result = -1 stk = [(1, (root, [-1]*2))] while stk: step, args = stk.pop() if step == 1: curr, ret = args if curr is None: continue left, right = [-1]*2, [-1]*2 stk.append((2, (curr, left, right, ret))) stk.append((1, (curr.right, right))) stk.append((1, (curr.left, left))) elif step == 2: curr, left, right, ret = args d = -1 if curr.val == start: d = 0 result = max(left[0], right[0])+1 elif left[1] >= 0: d = left[1]+1 result = max(result, right[0]+1+d) elif right[1] >= 0: d = right[1]+1 result = max(result, left[0]+1+d) ret[:] = [max(left[0], right[0])+1, d] return result return iter_dfs(root, start) ", "class Solution def amountOfTime(self, root, start): def dfs(curr, start, result): if curr is None: return [-1, -1] left = dfs(curr.left, start, result) right = dfs(curr.right, start, result) d = -1 if curr.val == start: d = 0 result[0] = max(left[0], right[0])+1 elif left[1] >= 0: d = left[1]+1 result[0] = max(result[0], right[0]+1+d) elif right[1] >= 0: d = right[1]+1 result[0] = max(result[0], left[0]+1+d) return [max(left[0], right[0])+1, d] result = [-1] dfs(root, start, result) return result[0] ", "class Solution def amountOfTime(self, root, start): def bfs(root): adj = collections.defaultdict(list) q = [root] while q: new_q = [] for u in q: for v in (u.left, u.right): if v is None: continue adj[u.val].append(v.val) adj[v.val].append(u.val) new_q.append(v) q = new_q return adj def bfs2(adj, start): result = -1 q = [start] lookup = {start} while q: new_q = [] for u in q: for v in adj[u]: if v in lookup: continue lookup.add(v) new_q.append(v) q = new_q result += 1 return result adj = bfs(root) return bfs2(adj, start) ", "class Solution def beautifulSubstrings(self, s, k): VOWELS = set(\"aeiou\") prefix = [0]*(len(s)+1) for i in xrange(len(s)): prefix[i+1] = prefix[i]+(+1 if s[i] in VOWELS else -1) new_k = 1 x = k for i in xrange(2, k+1): if i*i > k: break cnt = 0 while x%i == 0: x //= i cnt += 1 if cnt: new_k *= i**((cnt+1)//2+int(i == 2)) if x != 1: new_k *= x**((1+1)//2+int(x == 2)) cnt = collections.Counter() result = 0 for i, p in enumerate(prefix): result += cnt[p, i%new_k] cnt[p, i%new_k] += 1 return result ", "class Solution def beautifulSubstrings(self, s, k): VOWELS = set(\"aeiou\") result = 0 for i in xrange(len(s)): c = v = 0 for j in xrange(i, len(s)): if s[j] in VOWELS: v += 1 else: c += 1 if c == v and (c*v)%k == 0: result += 1 return result ", "class Solution def commonChars(self, A): result = collections.Counter(A[0]) for a in A: result &= collections.Counter(a) return list(result.elements()) ", "class Solution def insertionSortList(self, head): if head is None or self.isSorted(head): return head dummy = ListNode(-2147483648) dummy.next = head cur, sorted_tail = head.next, head while cur: prev = dummy while prev.next.val < cur.val: prev = prev.next if prev == sorted_tail: cur, sorted_tail = cur.next, cur else: cur.next, prev.next, sorted_tail.next = prev.next, cur, cur.next cur = sorted_tail.next return dummy.next def isSorted(self, head): while head and head.next: if head.val > head.next.val: return False head = head.next return True ", "class Solution def dayOfTheWeek(self, day, month, year): DAYS = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"] if month < 3: month += 12 year -= 1 c, y = divmod(year, 100) w = (c//4 - 2*c + y + y//4 + 13*(month+1)//5 + day - 1) % 7 return DAYS[w] ", "class Solution def longestSubarray(self, nums): mx = max(nums) result, l = 1, 0 for x in nums: if x == mx: l += 1 result = max(result, l) else: l = 0 return result ", "class Solution def getConcatenation(self, nums): nums.extend(nums) return nums ", "class Solution def getConcatenation(self, nums): return nums+nums ", "class Solution def getConcatenation(self, nums): return nums*2 ", "class Solution def countGoodTriplets(self, arr, a, b, c): return sum(abs(arr[i]-arr[j]) <= a and abs(arr[j]-arr[k]) <= b and abs(arr[k]-arr[i]) <= c for i in xrange(len(arr)-2) for j in xrange(i+1, len(arr)-1) for k in xrange(j+1, len(arr))) ", "class Solution def createTargetArray(self, nums, index): for i in xrange(len(nums)): for j in xrange(i): if index[j] >= index[i]: index[j] += 1 result = [0]*(len(nums)) for i in xrange(len(nums)): result[index[i]] = nums[i] return result import itertools ", "class Solution def createTargetArray(self, nums, index): result = [] for i, x in itertools.izip(index, nums): result.insert(i, x) return result ", "class Solution def gardenNoAdj(self, N, paths): result = [0]*N G = [[] for i in xrange(N)] for x, y in paths: G[x-1].append(y-1) G[y-1].append(x-1) for i in xrange(N): result[i] = ({1, 2, 3, 4} - {result[j] for j in G[i]}).pop() return result ", "class Solution def findChampion(self, n, edges): lookup = [False]*n for u, v in edges: lookup[v] = True result = -1 for u in xrange(n): if lookup[u]: continue if result != -1: return -1 result = u return result ", "class Solution def findChampion(self, n, edges): lookup = {v for _, v in edges} return next(u for u in xrange(n) if u not in lookup) if len(lookup) == n-1 else -1 ", "class Solution def predictPartyVictory(self, senate): n = len(senate) radiant, dire = collections.deque(), collections.deque() for i, c in enumerate(senate): if c == 'R': radiant.append(i) else: dire.append(i) while radiant and dire: r_idx, d_idx = radiant.popleft(), dire.popleft() if r_idx < d_idx: radiant.append(r_idx+n) else: dire.append(d_idx+n) return \"Radiant\" if len(radiant) > len(dire) else \"Dire\" ", "class Solution def numDistinct(self, S, T): ways = [0 for _ in xrange(len(T) + 1)] ways[0] = 1 for S_char in S: for j, T_char in reversed(list(enumerate(T))): if S_char == T_char: ways[j + 1] += ways[j] return ways[len(T)] ", "class Solution def hIndex(self, citations): n = len(citations) left, right = 0, n - 1 while left <= right: mid = (left + right) / 2 if citations[mid] >= n - mid: right = mid - 1 else: left = mid + 1 return n - left ", "class Solution def componentValue(self, nums, edges): def bfs(target): total = nums[:] lookup = [len(adj[u]) for u in xrange(len(adj))] q = [u for u in xrange(len(adj)) if lookup[u] == 1] while q: new_q = [] for u in q: if total[u] > target: return False if total[u] == target: total[u] = 0 for v in adj[u]: total[v] += total[u] lookup[v] -= 1 if lookup[v] == 1: new_q.append(v) q = new_q return True result = 0 adj = [[] for _ in xrange(len(nums))] for u, v in edges: adj[u].append(v) adj[v].append(u) total = sum(nums) for cnt in reversed(xrange(2, len(nums)+1)): if total%cnt == 0 and bfs(total//cnt): return cnt-1 return 0 ", "class Solution def componentValue(self, nums, edges): def iter_dfs(target): total = nums[:] stk = [(1, (0, -1))] while stk: step, (u, p) = stk.pop() if step == 1: stk.append((2, (u, p))) for v in adj[u]: if v == p: continue stk.append((1, (v, u))) elif step == 2: for v in adj[u]: if v == p: continue total[u] += total[v] if total[u] == target: total[u] = 0 return total[0] result = 0 adj = [[] for _ in xrange(len(nums))] for u, v in edges: adj[u].append(v) adj[v].append(u) total = sum(nums) for cnt in reversed(xrange(2, len(nums)+1)): if total%cnt == 0 and iter_dfs(total//cnt) == 0: return cnt-1 return 0 ", "class Solution def componentValue(self, nums, edges): def dfs(u, p, target): total = nums[u] for v in adj[u]: if v == p: continue total += dfs(v, u, target) return total if total != target else 0 result = 0 adj = [[] for _ in xrange(len(nums))] for u, v in edges: adj[u].append(v) adj[v].append(u) total = sum(nums) for cnt in reversed(xrange(2, len(nums)+1)): if total%cnt == 0 and dfs(0, -1, total//cnt) == 0: return cnt-1 return 0 ", "class Solution def findDifferentBinaryString(self, nums): return \"\".join(\"01\"[nums[i][i] == '0'] for i in xrange(len(nums))) ", "class Solution def findDifferentBinaryString(self, nums): lookup = set(map(lambda x: int(x, 2), nums)) return next(bin(i)[2:].zfill(len(nums[0])) for i in xrange(2**len(nums[0])) if i not in lookup) class Solution_Extra(object): def findAllDifferentBinaryStrings(self, nums): lookup = set(map(lambda x: int(x, 2), nums)) return [bin(i)[2:].zfill(len(nums[0])) for i in xrange(2**len(nums[0])) if i not in lookup] ", "class Solution def countSubarrays(self, nums, k): mx = max(nums) result = left = cnt = 0 for right in xrange(len(nums)): cnt += int(nums[right] == mx) while cnt == k: cnt -= int(nums[left] == mx) left += 1 result += left return result ", "class Solution def countSubarrays(self, nums, k): mx = max(nums) result = (len(nums)+1)*len(nums)//2 left = cnt = 0 for right in xrange(len(nums)): cnt += int(nums[right] == mx) while cnt == k: cnt -= int(nums[left] == mx) left += 1 result -= right-left+1 return result ", "class Solution def duplicateZeros(self, arr): shift, i = 0, 0 while i+shift < len(arr): shift += int(arr[i] == 0) i += 1 i -= 1 while shift: if i+shift < len(arr): arr[i+shift] = arr[i] if arr[i] == 0: shift -= 1 arr[i+shift] = arr[i] i -= 1 ", "class Solution def isFascinating(self, n): lookup = [0] def check(x): while x: x, d = divmod(x, 10) if d == 0 or lookup[0]&(1<<d): return False lookup[0] |= (1<<d) return True return check(n) and check(2*n) and check(3*n) ", "class Solution def isFascinating(self, n): s = str(n)+str(2*n)+str(3*n) return '0' not in s and len(s) == 9 and len(set(s)) == 9 ", "class Solution def countRangeSum(self, nums, lower, upper): def countAndMergeSort(sums, start, end, lower, upper): if end - start <= 1: return 0 mid = start + (end - start) / 2 count = countAndMergeSort(sums, start, mid, lower, upper) + countAndMergeSort(sums, mid, end, lower, upper) j, k, r = mid, mid, mid tmp = [] for i in xrange(start, mid): while k < end and sums[k] - sums[i] < lower: k += 1 while j < end and sums[j] - sums[i] <= upper: j += 1 count += j - k while r < end and sums[r] < sums[i]: tmp.append(sums[r]) r += 1 tmp.append(sums[i]) sums[start:start+len(tmp)] = tmp return count sums = [0] * (len(nums) + 1) for i in xrange(len(nums)): sums[i + 1] = sums[i] + nums[i] return countAndMergeSort(sums, 0, len(sums), lower, upper) ", "class Solution def countRangeSum(self, nums, lower, upper): def countAndMergeSort(sums, start, end, lower, upper): if end - start <= 0: return 0 mid = start + (end - start) / 2 count = countAndMergeSort(sums, start, mid, lower, upper) + countAndMergeSort(sums, mid + 1, end, lower, upper) j, k, r = mid + 1, mid + 1, mid + 1 tmp = [] for i in xrange(start, mid + 1): while k <= end and sums[k] - sums[i] < lower: k += 1 while j <= end and sums[j] - sums[i] <= upper: j += 1 count += j - k while r <= end and sums[r] < sums[i]: tmp.append(sums[r]) r += 1 tmp.append(sums[i]) sums[start:start+len(tmp)] = tmp return count sums = [0] * (len(nums) + 1) for i in xrange(len(nums)): sums[i + 1] = sums[i] + nums[i] return countAndMergeSort(sums, 0, len(sums) - 1, lower, upper) ", "class Solution def rangeBitwiseAnd(self, m, n): while m < n: n &= n - 1 return n ", "class Solution def rangeBitwiseAnd(self, m, n): i, diff = 0, n-m while diff: diff >>= 1 i += 1 return n & m >> i << i ", "class Solution def uniqueLetterString(self, S): M = 10**9 + 7 index = {c: [-1, -1] for c in string.ascii_uppercase} result = 0 for i, c in enumerate(S): k, j = index[c] result = (result + (i-j) * (j-k)) % M index[c] = [j, i] for c in index: k, j = index[c] result = (result + (len(S)-j) * (j-k)) % M return result ", "class Solution def findTheDifference(self, s, t): return chr(reduce(operator.xor, map(ord, s), 0) ^ reduce(operator.xor, map(ord, t), 0)) def findTheDifference2(self, s, t): t = list(t) s = list(s) for i in s: t.remove(i) return t[0] def findTheDifference3(self, s, t): return chr(reduce(operator.xor, map(ord, s + t))) def findTheDifference4(self, s, t): return list((collections.Counter(t) - collections.Counter(s)))[0] def findTheDifference5(self, s, t): s, t = sorted(s), sorted(t) return t[-1] if s == t[:-1] else [x[1] for x in zip(s, t) if x[0] != x[1]][0] ", "class Solution def numTilePossibilities(self, tiles): fact = [0.0]*(len(tiles)+1) fact[0] = 1.0; for i in xrange(1, len(tiles)+1): fact[i] = fact[i-1]*i count = collections.Counter(tiles) coeff = [0.0]*(len(tiles)+1) coeff[0] = 1.0 for i in count.itervalues(): new_coeff = [0.0]*(len(tiles)+1) for j in xrange(len(coeff)): for k in xrange(i+1): if k+j >= len(new_coeff): break new_coeff[j+k] += coeff[j]*1.0/fact[k] coeff = new_coeff result = 0 for i in xrange(1, len(coeff)): result += int(round(coeff[i]*fact[i])) return result ", "class Solution def numTilePossibilities(self, tiles): def backtracking(counter): total = 0 for k, v in counter.iteritems(): if not v: continue counter[k] -= 1 total += 1+backtracking(counter) counter[k] += 1 return total return backtracking(collections.Counter(tiles)) ", "class Solution def numSpecialEquivGroups(self, A): def count(word): result = [0]*52 for i, letter in enumerate(word): result[ord(letter)-ord('a') + 26*(i%2)] += 1 return tuple(result) return len({count(word) for word in A}) ", "class Solution def numberOfStableArrays(self, zero, one, limit): MOD = 10**9+7 dp = [[[0]*2 for _ in xrange(one+1)] for _ in xrange(zero+1)] for i in xrange(zero+1): dp[i][0][0] = 1 if i <= limit else 0 for j in xrange(one+1): dp[0][j][1] = 1 if j <= limit else 0 for i in xrange(1, zero+1): for j in xrange(1, one+1): dp[i][j][0] = (dp[i-1][j][0]+dp[i-1][j][1])%MOD dp[i][j][1] = (dp[i][j-1][0]+dp[i][j-1][1])%MOD if i-limit-1 >= 0: dp[i][j][0] = (dp[i][j][0]-dp[i-limit-1][j][1])%MOD if j-limit-1 >= 0: dp[i][j][1] = (dp[i][j][1]-dp[i][j-limit-1][0])%MOD return (dp[-1][-1][0]+dp[-1][-1][1])%MOD ", "class Solution def numberOfStableArrays(self, zero, one, limit): MOD = 10**9+7 dp = [[[0]*2 for _ in xrange(one+1)] for _ in xrange(zero+1)] dp[0][0][0] = dp[0][0][1] = 1 for i in xrange(zero+1): for j in xrange(one+1): for k in xrange(1, limit+1): if i-k >= 0: dp[i][j][0] = (dp[i][j][0]+dp[i-k][j][1])%MOD if j-k >= 0: dp[i][j][1] = (dp[i][j][1]+dp[i][j-k][0])%MOD return (dp[-1][-1][0]+dp[-1][-1][1])%MOD ", "class Solution def levelOrderBottom(self, root): if root is None: return [] result, current = [], [root] while current: next_level, vals = [], [] for node in current: vals.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current = next_level result.append(vals) return result[::-1] ", "class Solution def maximumLength(self, s): lookup = [[0]*3 for _ in xrange(26)] result = cnt = 0 for i, c in enumerate(s): cnt += 1 if i+1 != len(s) and s[i+1] == s[i]: continue curr = lookup[ord(c)-ord('a')] for j in xrange(len(curr)): if curr[j] < cnt: cnt, curr[j] = curr[j], cnt cnt = 0 result = max(result, max(curr[0]-2, min(curr[0]-1, curr[1]), curr[2])) return result if result else -1 ", "class Solution def maximumLength(self, s): lookup = [[0] for _ in xrange(26)] result = 0 for i, c in enumerate(s): curr = lookup[ord(c)-ord('a')] for j in xrange(i, len(s)): if s[j] != s[i]: break if j-i+1 == len(curr): curr.append(0) curr[j-i+1] += 1 if curr[j-i+1] == 3: result = max(result, j-i+1) return result if result else -1 ", "class Solution def lexicographicallySmallestArray(self, nums, limit): idxs = range(len(nums)) idxs.sort(key=lambda x: nums[x]) groups = [] for i in xrange(len(nums)): if i-1 < 0 or nums[idxs[i]]-nums[idxs[i-1]] > limit: groups.append([]) groups[-1].append(idxs[i]) result = [-1]*len(nums) for g in groups: for i, j in enumerate(sorted(g)): result[j] = nums[g[i]] return result ", "class Solution def ambiguousCoordinates(self, S): def make(S, i, n): for d in xrange(1, n+1): left = S[i:i+d] right = S[i+d:i+n] if ((not left.startswith('0') or left == '0') and (not right.endswith('0'))): yield \"\".join([left, '.' if right else '', right]) return [\"({}, {})\".format(*cand) for i in xrange(1, len(S)-2) for cand in itertools.product(make(S, 1, i), make(S, i+1, len(S)-2-i))] ", "class Solution def isPossible(self, target): total = sum(target) max_heap = [-x for x in target] heapq.heapify(max_heap) while total != len(target): y = -heapq.heappop(max_heap) remain = total-y x = y-remain if x <= 0: return False if x > remain: x = x%remain + remain heapq.heappush(max_heap, -x) total = x+remain return True ", "class Solution def placedCoins(self, edges, cost): def iter_dfs(): result = [0]*len(cost) stk = [(1, (0, -1, [cost[0]]))] while stk: step, args = stk.pop() if step == 1: u, p, ret = args stk.append((4, (u, ret))) stk.append((2, (u, p, 0, ret))) elif step == 2: u, p, i, ret = args if i == len(adj[u]): continue v = adj[u][i] stk.append((2, (u, p, i+1, ret))) if v == p: continue new_ret = [cost[v]] stk.append((3, (new_ret, ret))) stk.append((1, (v, u, new_ret))) elif step == 3: new_ret, ret = args ret.extend(new_ret) ret.sort() if len(ret) > 5: ret = ret[:2]+ret[-3:] elif step == 4: u, ret = args result[u] = 1 if len(ret) < 3 else max(ret[0]*ret[1]*ret[-1], ret[-3]*ret[-2]*ret[-1], 0) return result adj = [[] for _ in xrange(len(cost))] for u, v in edges: adj[u].append(v) adj[v].append(u) return iter_dfs() ", "class Solution def placedCoins(self, edges, cost): def dfs(u, p): arr = [cost[u]] for v in adj[u]: if v == p: continue arr.extend(dfs(v, u)) arr.sort() if len(arr) > 5: arr = arr[:2]+arr[-3:] result[u] = 1 if len(arr) < 3 else max(arr[0]*arr[1]*arr[-1], arr[-3]*arr[-2]*arr[-1], 0) return arr adj = [[] for _ in xrange(len(cost))] for u, v in edges: adj[u].append(v) adj[v].append(u) result = [0]*len(cost) dfs(0, -1) return result ", "class Solution def countPalindromePaths(self, parent, s): def iter_dfs(): result = 0 cnt = collections.defaultdict(int) cnt[0] = 1 stk = [(0, 0)] while stk: u, mask = stk.pop() if u: mask ^= 1<<(ord(s[u])-ord('a')) result += cnt[mask]+sum(cnt[mask^(1<<i)] if mask^(1<<i) in cnt else 0 for i in xrange(26)) cnt[mask] += 1 for v in reversed(adj[u]): stk.append((v, mask)) return result adj = [[] for _ in xrange(len(parent))] for u, p in enumerate(parent): if p != -1: adj[p].append(u) return iter_dfs() import collections ", "class Solution def countPalindromePaths(self, parent, s): def dfs(u, mask): result = 0 if u: mask ^= 1<<(ord(s[u])-ord('a')) result += cnt[mask]+sum(cnt[mask^(1<<i)] if mask^(1<<i) in cnt else 0 for i in xrange(26)) cnt[mask] += 1 return result+sum(dfs(v, mask) for v in adj[u]) adj = [[] for _ in xrange(len(parent))] for u, p in enumerate(parent): if p != -1: adj[p].append(u) cnt = collections.defaultdict(int) cnt[0] = 1 return dfs(0, 0) ", "class Solution def longestAlternatingSubarray(self, nums, threshold): result = l = 0 for x in nums: if x > threshold: l = 0 continue if l%2 == x%2: l += 1 else: l = int(x%2 == 0) result = max(result, l) return result ", "class Solution def countAsterisks(self, s): result = cnt = 0 for c in s: if c == '|': cnt = (cnt+1)%2 continue if c == '*' and cnt == 0: result += 1 return result ", "class Solution def abbreviateProduct(self, left, right): PREFIX_LEN = SUFFIX_LEN = 5 MOD = 10**(PREFIX_LEN+SUFFIX_LEN) curr, zeros = 1, 0 abbr = False for i in xrange(left, right+1): curr *= i while not curr%10: curr //= 10 zeros += 1 q, curr = divmod(curr, MOD) if q: abbr = True if not abbr: return \"%se%s\" % (curr, zeros) decimal = reduce(lambda x, y: (x+y)%1, (math.log10(i) for i in xrange(left, right+1))) prefix = str(int(10**(decimal+(PREFIX_LEN-1)))) suffix = str(curr % 10**SUFFIX_LEN).zfill(SUFFIX_LEN) return \"%s...%se%s\" % (prefix, suffix, zeros) ", "class Solution def leafSimilar(self, root1, root2): def dfs(node): if not node: return if not node.left and not node.right: yield node.val for i in dfs(node.left): yield i for i in dfs(node.right): yield i return all(a == b for a, b in itertools.izip_longest(dfs(root1), dfs(root2))) ", "class Solution def lowestCommonAncestor(self, root, p, q): if root in (None, p, q): return root left, right = [self.lowestCommonAncestor(child, p, q) for child in (root.left, root.right)] return root if left and right else left or right ", "class Solution def occurrencesOfElement(self, nums, queries, x): lookup = [i for i, y in enumerate(nums) if y == x] return [lookup[q-1] if q-1 < len(lookup) else -1 for q in queries] ", "class Solution def largestTimeFromDigits(self, A): result = \"\" for i in xrange(len(A)): A[i] *= -1 A.sort() for h1, h2, m1, m2 in itertools.permutations(A): hours = -(10*h1 + h2) mins = -(10*m1 + m2) if 0 <= hours < 24 and 0 <= mins < 60: result = \"{:02}:{:02}\".format(hours, mins) break return result ", "class Solution def maxSubarrayLength(self, nums, k): cnt = collections.Counter() result = left = 0 for right in xrange(len(nums)): cnt[nums[right]] += 1 while not (cnt[nums[right]] <= k): cnt[nums[left]] -= 1 left += 1 result = max(result, right-left+1) return result ", "class Solution def numTilings(self, N): M = int(1e9+7) def matrix_expo(A, K): result = [[int(i==j) for j in xrange(len(A))] for i in xrange(len(A))] while K: if K % 2: result = matrix_mult(result, A) A = matrix_mult(A, A) K /= 2 return result def matrix_mult(A, B): ZB = zip(*B) return [[sum(a*b for a, b in itertools.izip(row, col)) % M for col in ZB] for row in A] T = [[1, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 0], [1, 1, 1, 0]] return matrix_mult([[1, 0, 0, 0]], matrix_expo(T, N))[0][0] ", "class Solution def numTilings(self, N): M = int(1e9+7) dp = [1, 1, 2] for i in xrange(3, N+1): dp[i%3] = (2*dp[(i-1)%3]%M + dp[(i-3)%3])%M return dp[N%3] ", "class Solution def longestCommomSubsequence(self, arrays): result = min(arrays, key=lambda x: len(x)) for arr in arrays: new_result = [] i, j = 0, 0 while i != len(result) and j != len(arr): if result[i] < arr[j]: i += 1 elif result[i] > arr[j]: j += 1 else: new_result.append(result[i]) i += 1 j += 1 result = new_result return result import collections ", "class Solution def longestCommomSubsequence(self, arrays): return [num for num, cnt in collections.Counter(x for arr in arrays for x in arr).iteritems() if cnt == len(arrays)] ", "class Solution def deepestLeavesSum(self, root): curr = [root] while curr: prev, curr = curr, [child for p in curr for child in [p.left, p.right] if child] return sum(node.val for node in prev) ", "class Solution def knightDialer(self, N): def matrix_expo(A, K): result = [[int(i==j) for j in xrange(len(A))] for i in xrange(len(A))] while K: if K % 2: result = matrix_mult(result, A) A = matrix_mult(A, A) K /= 2 return result def matrix_mult(A, B): ZB = zip(*B) return [[sum(a*b for a, b in itertools.izip(row, col)) % M for col in ZB] for row in A] M = 10**9 + 7 T = [[0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]] return sum(map(sum, matrix_expo(T, N-1))) % M ", "class Solution def knightDialer(self, N): M = 10**9 + 7 moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [], [1, 7, 0], [2, 6], [1, 3], [2, 4]] dp = [[1 for _ in xrange(10)] for _ in xrange(2)] for i in xrange(N-1): dp[(i+1) % 2] = [0] * 10 for j in xrange(10): for nei in moves[j]: dp[(i+1) % 2][nei] += dp[i % 2][j] dp[(i+1) % 2][nei] %= M return sum(dp[(N-1) % 2]) % M ", "class Solution def kSum(self, nums, k): total = sum(x for x in nums if x > 0) sorted_vals = sorted(abs(x) for x in nums) max_heap = [(-total, 0)] for _ in xrange(k): result, i = heapq.heappop(max_heap) result = -result if i == len(sorted_vals): continue heapq.heappush(max_heap, (-(result-sorted_vals[i]), i+1)) if i-1 >= 0: heapq.heappush(max_heap, (-(result+sorted_vals[i-1]-sorted_vals[i]), i+1)) return result ", "class Solution def findKOr(self, nums, k): return sum(1<<i for i in xrange(max(nums).bit_length()) if sum((x&(1<<i)) != 0 for x in nums) >= k) ", "class Solution def prefixesDivBy5(self, A): for i in xrange(1, len(A)): A[i] += A[i-1] * 2 % 5 return [x % 5 == 0 for x in A] ", "class Solution def makeArrayIncreasing(self, arr1, arr2): arr2 = sorted(set(arr2)) dp = {0: -1} for val1 in arr1: next_dp = collections.defaultdict(lambda: float(\"inf\")) for cost, val in dp.iteritems(): if val < val1: next_dp[cost] = min(next_dp[cost], val1) k = bisect.bisect_right(arr2, val) if k == len(arr2): continue next_dp[cost+1] = min(next_dp[cost+1], arr2[k]) dp = next_dp if not dp: return -1 return min(dp.iterkeys()) ", "class Solution def resultArray(self, nums): a, b = [nums[0]], [nums[1]] for i in xrange(2, len(nums)): if a[-1] > b[-1]: a.append(nums[i]) else: b.append(nums[i]) return a+b ", "class Solution def getBiggestThree(self, grid): K = 3 left = [[grid[i][j] for j in xrange(len(grid[i]))] for i in xrange(len(grid))] right = [[grid[i][j] for j in xrange(len(grid[i]))] for i in xrange(len(grid))] for i in xrange(1, len(grid)): for j in xrange(len(grid[0])-1): left[i][j] += left[i-1][j+1] for i in xrange(1, len(grid)): for j in xrange(1, len(grid[0])): right[i][j] += right[i-1][j-1] min_heap = [] lookup = set() for k in xrange((min(len(grid), len(grid[0]))+1)//2): for i in xrange(k, len(grid)-k): for j in xrange(k, len(grid[0])-k): total = (((left[i][j-k]-left[i-k][j])+(right[i][j+k]-right[i-k][j])+grid[i-k][j]) + ((left[i+k][j]-left[i][j+k])+(right[i+k][j]-right[i][j-k])-grid[i+k][j])) if k else grid[i][j] if total in lookup: continue lookup.add(total) heapq.heappush(min_heap, total) if len(min_heap) == K+1: lookup.remove(heapq.heappop(min_heap)) min_heap.sort(reverse=True) return min_heap ", "class Solution def findMaximalUncoveredRanges(self, n, ranges): ranges.sort() covered = [[-1, -1]] for left, right in ranges: if covered[-1][1] < left: covered.append([left, right]) continue covered[-1][1] = max(covered[-1][1], right) covered.append([n, n]) return [[covered[i-1][1]+1, covered[i][0]-1] for i in xrange(1, len(covered)) if covered[i-1][1]+1 <= covered[i][0]-1] ", "class Solution def checkMove(self, board, rMove, cMove, color): def check(board, color, r, c, dr, dc): l = 2 while 0 <= r < len(board) and 0 <= c < len(board[0]) and board[r][c] != '.': if board[r][c] == color: return l >= 3 r += dr c += dc l += 1 return False directions = [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (1, -1), (-1, 1), (1, 1)] for dr, dc in directions: r, c = rMove+dr, cMove+dc if check(board, color, r, c, dr, dc): return True return False ", "class Solution def maximumLength(self, s): lookup = [[0]*3 for _ in xrange(26)] result = cnt = 0 for i, c in enumerate(s): cnt += 1 if i+1 != len(s) and s[i+1] == s[i]: continue curr = lookup[ord(c)-ord('a')] for j in xrange(len(curr)): if curr[j] < cnt: cnt, curr[j] = curr[j], cnt cnt = 0 result = max(result, max(curr[0]-2, min(curr[0]-1, curr[1]), curr[2])) return result if result else -1 ", "class Solution def buddyStrings(self, A, B): if len(A) != len(B): return False diff = [] for a, b in itertools.izip(A, B): if a != b: diff.append((a, b)) if len(diff) > 2: return False return (not diff and len(set(A)) < len(A)) or (len(diff) == 2 and diff[0] == diff[1][::-1]) ", "class Solution def maxFrequencyScore(self, nums, k): nums.sort() result = left = curr = 0 for right in xrange(len(nums)): curr += nums[right]-nums[(left+right)//2] if not curr <= k: curr -= nums[((left+1)+right)//2]-nums[left] left += 1 return right-left+1 ", "class Solution def maxFrequencyScore(self, nums, k): nums.sort() result = left = curr = 0 for right in xrange(len(nums)): curr += nums[right]-nums[(left+right)//2] while not curr <= k: curr -= nums[((left+1)+right)//2]-nums[left] left += 1 result = max(result, right-left+1) return result ", "class Solution def maxFrequencyScore(self, nums, k): def check(l): return any((prefix[i+l]-prefix[i+(l+1)//2])-(prefix[i+l//2]-prefix[i]) <= k for i in xrange(len(nums)-l+1)) nums.sort() prefix = [0]*(len(nums)+1) for i, x in enumerate(nums): prefix[i+1] = prefix[i]+x left, right = 1, len(nums) while left <= right: mid = left+(right-left)//2 if not check(mid): right = mid-1 else: left = mid+1 return right ", "class Solution def findKthNumber(self, m, n, k): def count(target, m, n): return sum(min(target//i, n) for i in xrange(1, m+1)) left, right = 1, m*n while left <= right: mid = left + (right-left)/2 if count(mid, m, n) >= k: right = mid-1 else: left = mid+1 return left ", "class Solution def threeSumSmaller(self, nums, target): nums.sort() n = len(nums) count, k = 0, 2 while k < n: i, j = 0, k - 1 while i < j: if nums[i] + nums[j] + nums[k] >= target: j -= 1 else: count += j - i i += 1 k += 1 return count ", "class Solution def largest1BorderedSquare(self, grid): top, left = [a[:] for a in grid], [a[:] for a in grid] for i in xrange(len(grid)): for j in xrange(len(grid[0])): if not grid[i][j]: continue if i: top[i][j] = top[i-1][j] + 1 if j: left[i][j] = left[i][j-1] + 1 for l in reversed(xrange(1, min(len(grid), len(grid[0]))+1)): for i in xrange(len(grid)-l+1): for j in xrange(len(grid[0])-l+1): if min(top[i+l-1][j], top[i+l-1][j+l-1], left[i][j+l-1], left[i+l-1][j+l-1]) >= l: return l*l return 0 ", "class Solution def basicCalculatorIV(self, expression, evalvars, evalints): ops = {'+':operator.add, '-':operator.sub, '*':operator.mul} def compute(operands, operators): right, left = operands.pop(), operands.pop() operands.append(ops[operators.pop()](left, right)) def parse(s): precedence = {'+':0, '-':0, '*':1} operands, operators, operand = [], [], [] for i in xrange(len(s)): if s[i].isalnum(): operand.append(s[i]) if i == len(s)-1 or not s[i+1].isalnum(): operands.append(Poly(\"\".join(operand))) operand = [] elif s[i] == '(': operators.append(s[i]) elif s[i] == ')': while operators[-1] != '(': compute(operands, operators) operators.pop() elif s[i] in precedence: while operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[s[i]]: compute(operands, operators) operators.append(s[i]) while operators: compute(operands, operators) return operands[-1] lookup = dict(itertools.izip(evalvars, evalints)) return parse(expression).eval(lookup).to_list() ", "class Solution def basicCalculatorIV(self, expression, evalvars, evalints): def compute(operands, operators): left, right = operands.pop(), operands.pop() op = operators.pop() if op == '+': operands.append(left + right) elif op == '-': operands.append(left - right) elif op == '*': operands.append(left * right) def parse(s): if not s: return Poly() operands, operators = [], [] operand = \"\" for i in reversed(xrange(len(s))): if s[i].isalnum(): operand += s[i] if i == 0 or not s[i-1].isalnum(): operands.append(Poly(operand[::-1])) operand = \"\" elif s[i] == ')' or s[i] == '*': operators.append(s[i]) elif s[i] == '+' or s[i] == '-': while operators and operators[-1] == '*': compute(operands, operators) operators.append(s[i]) elif s[i] == '(': while operators[-1] != ')': compute(operands, operators) operators.pop() while operators: compute(operands, operators) return operands[-1] lookup = dict(itertools.izip(evalvars, evalints)) return parse(expression).eval(lookup).to_list() ", "class Solution def countPyramids(self, grid): def count(grid, reverse): def get_grid(i, j): return grid[~i][j] if reverse else grid[i][j] result = 0 dp = [0]*len(grid[0]) for i in xrange(1, len(grid)): new_dp = [0]*len(grid[0]) for j in xrange(1, len(grid[0])-1): if get_grid(i, j) == get_grid(i-1, j-1) == get_grid(i-1, j) == get_grid(i-1, j+1) == 1: new_dp[j] = min(dp[j-1], dp[j+1])+1 dp = new_dp result += sum(dp) return result return count(grid, False) + count(grid, True) ", "class Solution def countPyramids(self, grid): def count(grid): dp = [[0 for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))] for i in xrange(1, len(grid)): for j in xrange(1, len(grid[0])-1): if grid[i][j] == grid[i-1][j-1] == grid[i-1][j] == grid[i-1][j+1] == 1: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1])+1 return sum(sum(row) for row in dp) return count(grid) + count(grid[::-1]) ", "class Solution def maxNumber(self, nums1, nums2, k): def get_max_digits(nums, start, end, max_digits): max_digits[end] = max_digit(nums, end) for i in reversed(xrange(start, end)): max_digits[i] = delete_digit(max_digits[i + 1]) def max_digit(nums, k): drop = len(nums) - k res = [] for num in nums: while drop and res and res[-1] < num: res.pop() drop -= 1 res.append(num) return res[:k] def delete_digit(nums): res = list(nums) for i in xrange(len(res)): if i == len(res) - 1 or res[i] < res[i + 1]: res = res[:i] + res[i+1:] break return res def merge(a, b): return [max(a, b).pop(0) for _ in xrange(len(a)+len(b))] m, n = len(nums1), len(nums2) max_digits1, max_digits2 = [[] for _ in xrange(k + 1)], [[] for _ in xrange(k + 1)] get_max_digits(nums1, max(0, k - n), min(k, m), max_digits1) get_max_digits(nums2, max(0, k - m), min(k, n), max_digits2) return max(merge(max_digits1[i], max_digits2[k-i]) for i in xrange(max(0, k - n), min(k, m) + 1)) ", "class Solution def groupAnagrams(self, strs): anagrams_map, result = collections.defaultdict(list), [] for s in strs: sorted_str = (\"\").join(sorted(s)) anagrams_map[sorted_str].append(s) for anagram in anagrams_map.values(): anagram.sort() result.append(anagram) return result ", "class Solution def longestSubsequence(self, s, k): result, base = 0, 1 for i in reversed(xrange(len(s))): if s[i] == '0': result += 1 elif base <= k: k -= base result += 1 if base <= k: base <<= 1 return result ", "class Solution def minDistance(self, word1, word2): if len(word1) < len(word2): return self.minDistance(word2, word1) distance = [i for i in xrange(len(word2) + 1)] for i in xrange(1, len(word1) + 1): pre_distance_i_j = distance[0] distance[0] = i for j in xrange(1, len(word2) + 1): insert = distance[j - 1] + 1 delete = distance[j] + 1 replace = pre_distance_i_j if word1[i - 1] != word2[j - 1]: replace += 1 pre_distance_i_j = distance[j] distance[j] = min(insert, delete, replace) return distance[-1] ", "class Solution def minDistance(self, word1, word2): distance = [[i] for i in xrange(len(word1) + 1)] distance[0] = [j for j in xrange(len(word2) + 1)] for i in xrange(1, len(word1) + 1): for j in xrange(1, len(word2) + 1): insert = distance[i][j - 1] + 1 delete = distance[i - 1][j] + 1 replace = distance[i - 1][j - 1] if word1[i - 1] != word2[j - 1]: replace += 1 distance[i].append(min(insert, delete, replace)) return distance[-1][-1] ", "class Solution def findNumber(self): return reduce(lambda accu, x: accu|x, (1<<i for i in xrange(30) if commonSetBits(1<<i))) ", "class Solution def hasValidPath(self, grid): if (len(grid)+len(grid[0])-1)%2: return False dp = [0]*(len(grid[0])+1) for i in xrange(len(grid)): dp[0] = int(not i) for j in xrange(len(grid[0])): dp[j+1] = (dp[j]|dp[j+1])<<1 if grid[i][j] == '(' else (dp[j]|dp[j+1])>>1 return dp[-1]&1 class Solution_WA(object): def hasValidPath(self, grid): if (len(grid)+len(grid[0])-1)%2: return False dp = [[float(\"inf\"), float(\"-inf\")] for _ in xrange(len(grid[0])+1)] for i in xrange(len(grid)): dp[0] = [0, 0] if not i else [float(\"inf\"), float(\"-inf\")] for j in xrange(len(grid[0])): d = 1 if grid[i][j] == '(' else -1 dp[j+1] = [min(dp[j+1][0], dp[j][0])+d, max(dp[j+1][1], dp[j][1])+d] if dp[j+1][1] < 0: dp[j+1] = [float(\"inf\"), float(\"-inf\")] else: dp[j+1][0] = max(dp[j+1][0], dp[j+1][1]%2) return dp[-1][0] == 0 ", "class Solution def finalValueAfterOperations(self, operations): return sum(1 if '+' == op[1] else -1 for op in operations) ", "class Solution def asteroidsDestroyed(self, mass, asteroids): asteroids.sort() for x in asteroids: if x > mass: return False mass += min(x, asteroids[-1]-mass) return True ", "class Solution def increasingTriplet(self, nums): min_num, a, b = float(\"inf\"), float(\"inf\"), float(\"inf\") for c in nums: if min_num >= c: min_num = c elif b >= c: a, b = min_num, c else: return True return False class Solution_Generalization(object): def increasingTriplet(self, nums): def increasingKUplet(nums, k): inc = [float('inf')] * (k - 1) for num in nums: i = bisect.bisect_left(inc, num) if i >= k - 1: return True inc[i] = num return k == 0 return increasingKUplet(nums, 3) ", "class Solution def canJump(self, A): reachable = 0 for i, length in enumerate(A): if i > reachable: break reachable = max(reachable, i + length) return reachable >= len(A) - 1 ", "class Solution def countTheNumOfKFreeSubsets(self, nums, k): def count(x): y = x while y-k in cnt: y -= k dp = [1, 0] for i in xrange(y, x+1, k): dp = [dp[0]+dp[1], dp[0]*((1<<cnt[i])-1)] return sum(dp) cnt = collections.Counter(nums) return reduce(operator.mul, (count(i) for i in cnt.iterkeys() if i+k not in cnt)) ", "class Solution def lengthOfLongestSubsequence(self, nums, target): dp = [-1]*(target+1) dp[0] = 0 for x in nums: for i in reversed(xrange(x, len(dp))): if dp[i-x] != -1: dp[i] = max(dp[i], dp[i-x]+1) return dp[-1] ", "class Solution def longestPalindromeSubseq(self, s): if s == s[::-1]: return len(s) dp = [[1] * len(s) for _ in xrange(2)] for i in reversed(xrange(len(s))): for j in xrange(i+1, len(s)): if s[i] == s[j]: dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 <= j-1 else 2 else: dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1]) return dp[0][-1] ", "class Solution def findAllRecipes(self, recipes, ingredients, supplies): indegree = collections.defaultdict(int) adj = collections.defaultdict(list) for r, ingredient in itertools.izip(recipes, ingredients): indegree[r] = len(ingredient) for ing in ingredient: adj[ing].append(r) result = [] recipes = set(recipes) q = supplies while q: new_q = [] for u in q: if u in recipes: result.append(u) for v in adj[u]: indegree[v] -= 1 if not indegree[v]: new_q.append(v) q = new_q return result ", "class Solution def findShortestSubArray(self, nums): counts = collections.Counter(nums) left, right = {}, {} for i, num in enumerate(nums): left.setdefault(num, i) right[num] = i degree = max(counts.values()) return min(right[num]-left[num]+1 for num in counts.keys() if counts[num] == degree) ", "class Solution def countPrimes(self, n): if n <= 2: return 0 is_prime = [True]*(n//2) cnt = len(is_prime) for i in xrange(3, n, 2): if i * i >= n: break if not is_prime[i//2]: continue for j in xrange(i*i, n, 2*i): if not is_prime[j//2]: continue cnt -= 1 is_prime[j//2] = False return cnt class Solution_TLE(object): def countPrimes(self, n): def linear_sieve_of_eratosthenes(n): primes = [] spf = [-1]*(n+1) for i in xrange(2, n+1): if spf[i] == -1: spf[i] = i primes.append(i) for p in primes: if i*p > n or p > spf[i]: break spf[i*p] = p return primes return len(linear_sieve_of_eratosthenes(n-1)) ", "class Solution def countArrangement(self, N): def countArrangementHelper(n, arr): if n <= 0: return 1 count = 0 for i in xrange(n): if arr[i] % n == 0 or n % arr[i] == 0: arr[i], arr[n-1] = arr[n-1], arr[i] count += countArrangementHelper(n - 1, arr) arr[i], arr[n-1] = arr[n-1], arr[i] return count return countArrangementHelper(N, range(1, N+1)) ", "class Solution def colorRed(self, n): result = [[1, 1]] for i in xrange(2, n+1): if i%2 == n%2: result.extend([i, j] for j in xrange((1 if i%4 == n%4 else 3), 2*i, 2)) else: result.append([i, (2 if i%4 == (n-1)%4 else 1)]) return result ", "class Solution def repeatedCharacter(self, s): lookup = set() for c in s: if c in lookup: break lookup.add(c) return c ", "class Solution def countAndSay(self, n): seq = \"1\" for i in xrange(n - 1): seq = self.getNext(seq) return seq def getNext(self, seq): i, next_seq = 0, \"\" while i < len(seq): cnt = 1 while i < len(seq) - 1 and seq[i] == seq[i + 1]: cnt += 1 i += 1 next_seq += str(cnt) + seq[i] i += 1 return next_seq ", "class Solution def largestValues(self, root): def largestValuesHelper(root, depth, result): if not root: return if depth == len(result): result.append(root.val) else: result[depth] = max(result[depth], root.val) largestValuesHelper(root.left, depth+1, result) largestValuesHelper(root.right, depth+1, result) result = [] largestValuesHelper(root, 0, result) return result ", "class Solution def largestValues(self, root): result = [] curr = [root] while any(curr): result.append(max(node.val for node in curr)) curr = [child for node in curr for child in (node.left, node.right) if child] return result ", "class Solution def meetRequirement(self, n, lights, requirement): cnt = collections.defaultdict(int) for p, r in lights: cnt[max(p-r, 0)] += 1 cnt[min(p+r, n-1)+1] -= 1 result = curr = 0 for i, r in enumerate(requirement): curr += cnt.get(i, 0) if curr >= r: result += 1 return result "]